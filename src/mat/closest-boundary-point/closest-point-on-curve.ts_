
import { deflate, allRootsPrecise, allRootsMultiWithErrBounds, toCasStr } from 'flo-poly';

import { getObjClosestTo } from 'flo-vector2d';
import { evaluate, getTangentPolyFromPoint, getTangentPolyFromPointExact } from 'flo-bezier3';
import { estimate } from 'flo-numerical';

import { Curve } from "../../curve";


/** @hidden */
// TODO - remove delta
let DELTA = 1e-11;


/**
 * @hidden
 * @param curve The curve
 * @param p The point from which to check
 * @param tRange The allowed t range
 * @param touchedCurve The bezier on which p is located
 * @param t The t value of the bezier that locates p
 */
function closestPointOnCurve(
        curve: Curve, 
        p: number[], 
        [tS,tE]: number[] = [0,1], 
        touchedCurve?: Curve,
        t?: number) {

    let poly = getTangentPolyFromPointExact(curve.ps, p);

    //if (curve === touchedCurve) {
    //    poly = deflate(poly, t);
    //}

    let roots = allRootsMultiWithErrBounds(
        poly, 
        poly.map(c => 0),  // because all coefficients are exact
        () => [],           // ...
        tS,
        tE
    ).map(t => t.tM);

    // Also test the endpoints
    let push0 = true;
    let push1 = true;
    if ((t === 1 && curve === touchedCurve.next) ||
        (t === 0 && curve === touchedCurve)) {
        push0 = false;
    }
    if ((t === 0 && curve === touchedCurve.prev) ||
        (t === 1 && curve === touchedCurve)) {
        push1 = false;
    }

    if (tS === 0) {
        if (push0) { roots.push(0); }
    } else if (tS === 1) {
        if (push1) { roots.push(1); }
    } else {
        roots.push(tS);
    }

    if (tE === 0) {
        if (push0) { roots.push(0); }
    } else if (tE === 1) {
        if (push1) { roots.push(1); }
    } else {
        roots.push(tE);
    }

    // This is to take care of a numerical issue - see shape p1.svg.
    //let roots_: number[] = [];
    //for (let i=0; i<roots.length; i++) {
    //    let root = roots[i];
    //    if (root !== 0 && root < DELTA) {
    //        root = 0;
    //    } else if (root !== 1 && 1-root < DELTA) {
    //        root = 1;
    //    }
    //    roots_.push(root);
    //}

    let ev = evaluate(curve.ps);
    //let ps = roots_.map(
    let ps = roots.map(
        root => ({ p: ev(root), t: root })
    );

    return getObjClosestTo(p, ps, p => p.p);
}


export { closestPointOnCurve }
