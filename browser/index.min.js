/*! For license information please see index.min.js.LICENSE.txt */
var FloMat;(()=>{"use strict";var __webpack_modules__={"./node_modules/flo-boolean/node_modules/flo-draw/node/debug/debug.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst draw_fs_1 = __webpack_require__(/*! ../draw-fs */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw-fs.js");\r\n/**\r\n * Returns a new debug object by spreading boolean operation debug information\r\n * onto the given (possibly undefined) debug object.\r\n * @param debug a (possibly undefined) debug object\r\n */\r\nfunction enableDebugDrawFs(debugOn) {\r\n    if (!debugOn) {\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = Object.assign(Object.assign({}, debug), { fs: Object.assign(Object.assign({}, debug === null || debug === void 0 ? void 0 : debug.fs), { draw: Object.assign({}, draw_fs_1.drawFs) }) });\r\n    window._debug_ = debug;\r\n}\r\nexports.enableDebugDrawFs = enableDebugDrawFs;\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/debug/debug.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw-fs.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst circle_1 = __webpack_require__(/*! ./draw/circle */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/circle.js");\r\nconst cross_hair_1 = __webpack_require__(/*! ./draw/cross-hair */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cross-hair.js");\r\nconst dot_1 = __webpack_require__(/*! ./draw/dot */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/dot.js");\r\nconst line_1 = __webpack_require__(/*! ./draw/line */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/line.js");\r\nconst rect_1 = __webpack_require__(/*! ./draw/rect */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/rect.js");\r\nconst polygon_1 = __webpack_require__(/*! ./draw/polygon */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polygon.js");\r\nconst loop_1 = __webpack_require__(/*! ./draw/loop */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/loop.js");\r\nconst polyline_1 = __webpack_require__(/*! ./draw/polyline */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polyline.js");\r\nconst beziers_1 = __webpack_require__(/*! ./draw/beziers */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/beziers.js");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./draw/cubic-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cubic-bezier.js");\r\nconst bezier_1 = __webpack_require__(/*! ./draw/bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier.js");\r\nconst bezier_piece_1 = __webpack_require__(/*! ./draw/bezier-piece */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-piece.js");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./draw/quad-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/quad-bezier.js");\r\nconst text_1 = __webpack_require__(/*! ./draw/text */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/text.js");\r\nlet drawFs = {\r\n    circle: circle_1.circle,\r\n    crossHair: cross_hair_1.crossHair,\r\n    dot: dot_1.dot,\r\n    line: line_1.line,\r\n    rect: rect_1.rect,\r\n    beziers: beziers_1.beziers,\r\n    bezier: bezier_1.bezier,\r\n    bezierPiece: bezier_piece_1.bezierPiece,\r\n    quadBezier: quad_bezier_1.quadBezier,\r\n    cubicBezier: cubic_bezier_1.cubicBezier,\r\n    polygon: polygon_1.polygon,\r\n    loop: loop_1.loop,\r\n    polyline: polyline_1.polyline,\r\n    text: text_1.text\r\n};\r\nexports.drawFs = drawFs;\r\n//# sourceMappingURL=draw-fs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw-fs.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/evaluate-bezier.js");\r\nconst split_at_1 = __webpack_require__(/*! ./split-at */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/split-at.js");\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Duplicated here so we don\'t circularly depend on flo-bezier.\r\n *\r\n * Uses de Casteljau\'s algorithm.\r\n *\r\n * @param ps a bezier\r\n * @param tRange a t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return split_at_1.splitAt(ps, tRange[1])[0];\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return split_at_1.splitAt(ps, tRange[0])[1];\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return split_at_1.splitAt(split_at_1.splitAt(ps, tRange[0])[1], (tRange[1] - tRange[0]) / (1 - tRange[0]))[0];\r\n}\r\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\r\n//# sourceMappingURL=bezier-from-bezier-piece.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-piece.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cross-hair.js");\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier.js");\r\nconst evaluate_bezier_1 = __webpack_require__(/*! ./evaluate-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/evaluate-bezier.js");\r\nconst bezier_from_bezier_piece_1 = __webpack_require__(/*! ./bezier-from-bezier-piece */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js");\r\n/**\r\n * Draws a bezier piece, i.e. a bezier within a specified t range.\r\n * @param snap\r\n * @param bezierPiece\r\n * @param class\r\n * @param delay\r\n */\r\nfunction bezierPiece(g, ps_, tRange, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $elems = [];\r\n    // Draw crosshair if t range bounds are equal.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = evaluate_bezier_1.evaluateBezier(ps_, tRange[0]);\r\n        $elems = cross_hair_1.crossHair(g, p, class_, 1.5);\r\n    }\r\n    else {\r\n        let ps = bezier_from_bezier_piece_1.bezierFromBezierPiece(ps_, tRange);\r\n        $elems = bezier_1.bezier(g, ps, class_);\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $elems.forEach(e => e.remove()), delay);\r\n    }\r\n    return $elems;\r\n}\r\nexports.bezierPiece = bezierPiece;\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier-piece.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst line_1 = __webpack_require__(/*! ./line */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/line.js");\r\nconst quad_bezier_1 = __webpack_require__(/*! ./quad-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/quad-bezier.js");\r\nconst cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cubic-bezier.js");\r\nfunction bezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (bezier.length === 2) {\r\n        return line_1.line(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 3) {\r\n        return quad_bezier_1.quadBezier(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 4) {\r\n        return cubic_bezier_1.cubicBezier(g, bezier, class_, delay);\r\n    }\r\n    return [];\r\n}\r\nexports.bezier = bezier;\r\n//# sourceMappingURL=bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/beziers.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst bezier_1 = __webpack_require__(/*! ./bezier */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/bezier.js\");\r\nconst COLORS = ['red', 'green', 'cyan', 'blue'];\r\n/**\r\n * Draws beziers.\r\n * @param snap\r\n * @param beziers\r\n * @param delay\r\n */\r\nfunction beziers(g, beziers, classes, delay) {\r\n    let alternateColors = classes === undefined;\r\n    let $beziers = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        let color = COLORS[i % COLORS.length];\r\n        let class_ = alternateColors\r\n            ? 'thin5 nofill ' + color\r\n            : classes;\r\n        $beziers.push(...bezier_1.bezier(g, ps, class_));\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $beziers.forEach(e => e.remove()), delay);\r\n    }\r\n    return $beziers;\r\n}\r\nexports.beziers = beziers;\r\n//# sourceMappingURL=beziers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/beziers.js?")},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/circle.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\n/**\r\n * Draws a circle\r\n * @param g An SVG group element wherein to draw the circle.\r\n * @param circle\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction circle(g, circle, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let $circle = document.createElementNS(xmlns_1.XMLNS, \'circle\');\r\n    $circle.setAttributeNS(null, "cx", c[0].toString());\r\n    $circle.setAttributeNS(null, "cy", c[1].toString());\r\n    $circle.setAttributeNS(null, "r", r.toString());\r\n    $circle.setAttributeNS(null, "class", classes);\r\n    g.appendChild($circle);\r\n    if (delay) {\r\n        setTimeout(() => $circle.remove(), delay);\r\n    }\r\n    return [$circle];\r\n}\r\nexports.circle = circle;\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/circle.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cross-hair.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst circle_1 = __webpack_require__(/*! ./circle */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/circle.js");\r\nconst line_1 = __webpack_require__(/*! ./line */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/line.js");\r\n/**\r\n * Draws a crosshair.\r\n */\r\nfunction crossHair(g, p, classes = default_class_1.DEFAULT_CLASS, r = 3, delay) {\r\n    let circle_ = { center: p, radius: r };\r\n    let $circle = circle_1.circle(g, circle_, classes);\r\n    let l1 = [[p[0] - r, p[1]], [p[0] + r, p[1]]];\r\n    let l2 = [[p[0], p[1] - r], [p[0], p[1] + r]];\r\n    let $l1 = line_1.line(g, l1, classes);\r\n    let $l2 = line_1.line(g, l2, classes);\r\n    if (delay) {\r\n        setTimeout(() => {\r\n            $circle.forEach(e => e.remove());\r\n            $l1.forEach(e => e.remove());\r\n            $l2.forEach(e => e.remove());\r\n        }, delay);\r\n    }\r\n    return [...$circle, ...$l1, ...$l2];\r\n}\r\nexports.crossHair = crossHair;\r\n//# sourceMappingURL=cross-hair.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cross-hair.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cubic-bezier.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\nconst cross_hair_1 = __webpack_require__(/*! ./cross-hair */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cross-hair.js");\r\nfunction cubicBezier(g, bezier, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = bezier;\r\n    if (x0 === x3 && x1 === x3 && x2 === x3 &&\r\n        y0 === y3 && y1 === y3 && y2 === y3) {\r\n        return cross_hair_1.crossHair(g, [x0, y0], class_, 0.2, delay);\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, \'path\');\r\n    $path.setAttributeNS(null, "d", `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`);\r\n    $path.setAttributeNS(null, "class", class_);\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.cubicBezier = cubicBezier;\r\n//# sourceMappingURL=cubic-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/cubic-bezier.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js":(__unused_webpack_module,exports)=>{eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\nexports.DEFAULT_CLASS = DEFAULT_CLASS;\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js?")},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/dot.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst circle_1 = __webpack_require__(/*! ./circle */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/circle.js\");\r\n/**\r\n * Draws a dot.\r\n */\r\nfunction dot(g, p, r = 3, color = 'red', delay) {\r\n    let [$dot] = circle_1.circle(g, { center: p, radius: r }, 'dot ' + color, delay);\r\n    if (delay) {\r\n        setTimeout(() => $dot.remove(), delay);\r\n    }\r\n    return [$dot];\r\n}\r\nexports.dot = dot;\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/dot.js?")},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/evaluate-bezier.js":(__unused_webpack_module,exports)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\n/**\r\n * Returns an estimate of evaluating the given bezier at the given t value.\r\n * @param ps An order 1, 2 or bezier\r\n * @param t The parameter ∈ [0,1]\r\n */\r\nfunction evaluateBezier(ps, t) {\r\n    let s = 1 - t;\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let x = x0 * Math.pow(s, 3) + 3 * x1 * Math.pow(s, 2) * t + 3 * x2 * s * Math.pow(t, 2) + x3 * Math.pow(t, 3);\r\n        let y = y0 * Math.pow(s, 3) + 3 * y1 * Math.pow(s, 2) * t + 3 * y2 * s * Math.pow(t, 2) + y3 * Math.pow(t, 3);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let x = x0 * Math.pow(s, 2) + 2 * x1 * s * t + x2 * Math.pow(t, 2);\r\n        let y = y0 * Math.pow(s, 2) + 2 * y1 * s * t + y2 * Math.pow(t, 2);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = x0 * s + x1 * t;\r\n        let y = y0 * s + y1 * t;\r\n        return [x, y];\r\n    }\r\n    return [NaN, NaN];\r\n}\r\nexports.evaluateBezier = evaluateBezier;\r\n//# sourceMappingURL=evaluate-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/evaluate-bezier.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/line.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\n/**\r\n *\r\n * @param snap\r\n * @param l\r\n * @param classes\r\n */\r\nfunction line(g, l, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $line = document.createElementNS(xmlns_1.XMLNS, \'line\');\r\n    $line.setAttributeNS(null, "x1", l[0][0].toString());\r\n    $line.setAttributeNS(null, "y1", l[0][1].toString());\r\n    $line.setAttributeNS(null, "x2", l[1][0].toString());\r\n    $line.setAttributeNS(null, "y2", l[1][1].toString());\r\n    $line.setAttributeNS(null, "class", classes);\r\n    g.appendChild($line);\r\n    if (delay) {\r\n        setTimeout(() => $line.remove(), delay);\r\n    }\r\n    return [$line];\r\n}\r\nexports.line = line;\r\n//# sourceMappingURL=line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/line.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/loop.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js\");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js\");\r\nfunction loop(g, curves, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (!curves.length) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, 'path');\r\n    let d = `M${curves[0][0][0]} ${curves[0][0][1]} `;\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        d += `${getType(curve.length)} `;\r\n        for (let j = 1; j < curve.length; j++) {\r\n            d += `${curve[j][0]} ${curve[j][1]} `;\r\n        }\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.loop = loop;\r\nfunction getType(len) {\r\n    if (len === 2) {\r\n        return 'L';\r\n    }\r\n    if (len === 3) {\r\n        return 'Q';\r\n    }\r\n    if (len === 4) {\r\n        return 'C';\r\n    }\r\n}\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/loop.js?")},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polygon.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\n/**\r\n * Draws a polygon\r\n * @param g\r\n * @param poly the polygon specified as an array of points - the last point does\r\n * not have to be specified\r\n * @param class_\r\n * @param delay\r\n */\r\nfunction polygon(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, \'path\');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    d += \' z\';\r\n    $path.setAttributeNS(null, "d", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polygon = polygon;\r\n//# sourceMappingURL=polygon.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polygon.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polyline.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\nfunction polyline(g, poly, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    if (poly.length < 2) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, \'path\');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    $path.setAttributeNS(null, "d", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.polyline = polyline;\r\n//# sourceMappingURL=polyline.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/polyline.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/quad-bezier.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\nfunction quadBezier(g, ps, class_ = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let $path = document.createElementNS(xmlns_1.XMLNS, \'path\');\r\n    $path.setAttributeNS(null, "d", `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nexports.quadBezier = quadBezier;\r\n//# sourceMappingURL=quad-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/quad-bezier.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/rect.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\nfunction rect(g, rect, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1]] = rect;\r\n    let x = x0 < x1 ? x0 : x1;\r\n    let y = y0 < y1 ? y0 : y1;\r\n    let width = Math.abs(x0 - x1);\r\n    let height = Math.abs(y0 - y1);\r\n    let $rect = document.createElementNS(xmlns_1.XMLNS, \'rect\');\r\n    $rect.setAttributeNS(null, "x", x.toString());\r\n    $rect.setAttributeNS(null, "y", y.toString());\r\n    $rect.setAttributeNS(null, "width", width.toString());\r\n    $rect.setAttributeNS(null, "height", height.toString());\r\n    if (classes) {\r\n        $rect.setAttributeNS(null, "class", classes);\r\n    }\r\n    g.appendChild($rect);\r\n    if (delay) {\r\n        setTimeout(() => $rect.remove(), delay);\r\n    }\r\n    return [$rect];\r\n}\r\nexports.rect = rect;\r\n//# sourceMappingURL=rect.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/rect.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/split-at.js":(__unused_webpack_module,exports)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\nexports.splitAt = splitAt;\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau\'s algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    /** The split point */\r\n    let p = [\r\n        t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n        t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0,\r\n            t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0,\r\n            t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1,\r\n            t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2,\r\n            t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * s * x0 + 2 * s * t * x1 + t * t * x2,\r\n        s * s * y0 + 2 * s * t * y1 + t * t * y2\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [s * x0 + t * x1,\r\n            s * y0 + t * y1],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [s * x1 + t * x2,\r\n            s * y1 + t * y2],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/split-at.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/text.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst default_class_1 = __webpack_require__(/*! ./default-class */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/default-class.js");\r\nconst xmlns_1 = __webpack_require__(/*! ./xmlns */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js");\r\n/**\r\n * Draws text\r\n * @param g a SVG group element wherein to draw\r\n * @param p\r\n * @param str\r\n * @param fontSize\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction text(g, p, str, fontSize, classes = default_class_1.DEFAULT_CLASS, delay) {\r\n    let $text = document.createElementNS(xmlns_1.XMLNS, \'text\');\r\n    $text.setAttributeNS(null, "x", p[0].toString());\r\n    $text.setAttributeNS(null, "y", p[1].toString());\r\n    $text.setAttributeNS(null, "font-size", fontSize.toString());\r\n    $text.setAttributeNS(null, "class", classes);\r\n    $text.textContent = str;\r\n    g.appendChild($text);\r\n    if (delay) {\r\n        setTimeout(() => $text.remove(), delay);\r\n    }\r\n    return [$text];\r\n}\r\nexports.text = text;\r\n//# sourceMappingURL=text.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/text.js?')},"./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js":(__unused_webpack_module,exports)=>{eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\nexports.XMLNS = XMLNS;\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/draw/xmlns.js?")},"./node_modules/flo-boolean/node_modules/flo-draw/node/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nconst draw_fs_1 = __webpack_require__(/*! ./draw-fs */ "./node_modules/flo-boolean/node_modules/flo-draw/node/draw-fs.js");\r\nexports.drawFs = draw_fs_1.drawFs;\r\nconst debug_1 = __webpack_require__(/*! ./debug/debug */ "./node_modules/flo-boolean/node_modules/flo-draw/node/debug/debug.js");\r\nexports.enableDebugDrawFs = debug_1.enableDebugDrawFs;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node_modules/flo-draw/node/index.js?')},"./src/circle.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "engulfsCircle": () => (/* binding */ engulfsCircle),\n/* harmony export */   "scaleCircle": () => (/* binding */ scaleCircle)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * Returns a scaled version of the given circle without changing its center.\r\n * @param circle\r\n * @param s multiplier\r\n */\r\nfunction scaleCircle(circle, s) {\r\n    return { center: circle.center, radius: s * circle.radius };\r\n}\r\n/**\r\n * Returns true if the first circle engulfs the second.\r\n * @param c1\r\n * @param c2\r\n */\r\nfunction engulfsCircle(c1, c2) {\r\n    if (c1.radius <= c2.radius) {\r\n        return false;\r\n    }\r\n    let d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(c1.center, c2.center);\r\n    let dr = c1.radius - c2.radius;\r\n    let δ = dr * dr;\r\n    return δ > d;\r\n}\r\n/**\r\n * Returns a human-readable string description of the given circle.\r\n * @param circle\r\n */\r\nfunction toString(circle) {\r\n    return \'c: \' + circle.center + \' r: \' + circle.radius;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/circle.ts?')},"./src/compare-curvatures-at-interface.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compareCurvaturesAtInterface\": () => (/* binding */ compareCurvaturesAtInterface)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n\r\n\r\n/**\r\n * Compare the curvature, κ, between two curves at t === 0.\r\n *\r\n * Returns a positive number if κ for psI > κ for psO, negative if κ for psI < κ\r\n * for psO or zero if the curve extensions are identical (i.e. in same K-family).\r\n *\r\n * Precondition: The point psI evaluated at zero must === the point psO\r\n * evaluated at zero.\r\n *\r\n * // TODO - is this correct?\r\n * Exact: Returns the exact result if the bithlength of all\r\n * coordinates <= 53 - 5 === 48 and are bit-aligned.\r\n *\r\n * @param psI An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * representing the incoming curve\r\n * @param psO Another bezier representing the outgoing curve\r\n */\r\nfunction compareCurvaturesAtInterface(psI, psO) {\r\n    // Get x' and y' for incoming curve evaluated at 0\r\n    let [dxI, dyI] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangentAt0)(psI); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for incoming curve evaluated at 0\r\n    let [ddxI, ddyI] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evaluate2ndDerivativeAt0)(psI); // max bitlength increase / max shift === 5\r\n    // Get x' and y' for outgoing curve evaluated at 0\r\n    let [dxO, dyO] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangentAt0)(psO); // max bitlength increase / max shift === 3\r\n    // Get x'' and y'' for outgoing curve evaluated at 0\r\n    let [ddxO, ddyO] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evaluate2ndDerivativeAt0)(psO); // max bitlength increase / max shift === 5\r\n    //console.log('κI: ', κ(psI, 0));\r\n    //console.log('κO: ', κ(psO, 0));\r\n    // Remember the formula for the signed curvature of a parametric curve:\r\n    // κ = x′y′′ - y′x′′ / sqrt(x′² + y′²)³\r\n    // κ² = (x′y′′ - y′x′′)² / (x′² + y′²)³\r\n    // This allows us to do an exact comparison of curvatures\r\n    // Simplifying the above gives (denoting the incoming curve with a subscript\r\n    // of 1 and the outgoing with a 2):\r\n    //      κIncoming > κOutgoing\r\n    // <=>  (x₁′y₁′′ - y₁′x₁′′)²(x₂′² + y₂′²)³ > (x₂′y₂′′ - y₂′x₂′′)²(x₁′² + y₁′²)³\r\n    // <=>  a²b³ > c²d³\r\n    // Note b³ > 0 and d³ > 0\r\n    // max aggregate bitlength increase (let original bitlength === p):\r\n    // a -> 2 x ((p+3)+(p+5) + 1) === 4p + 18 -> max p in double precision === 8 -> too low\r\n    //let a = (dxI*ddyI - dyI*ddxI)**2;\r\n    // b -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let b = (dxO*dxO  + dyO*dyO )**3;\r\n    // c -> 2 x ((p+3)+(p+5) + 1) === 4p + 18\r\n    //let c = (dxO*ddyO - dyO*ddxO)**2;\r\n    // d -> 3 x ((p+3) + 1) === 3p + 12\r\n    //let d = (dxI*dxI  + dyI*dyI )**3;\r\n    // We need to resort to exact floating point arithmetic at this point\r\n    let a = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxI, ddyI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyI, ddxI));\r\n    let c = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxO, ddyO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyO, ddxO));\r\n    let signA = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a);\r\n    let signC = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(c);\r\n    if (signA !== signC) {\r\n        //console.log('branch 3');\r\n        return signA - signC;\r\n    }\r\n    let b = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxO, dxO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyO, dyO));\r\n    let d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxI, dxI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyI, dyI));\r\n    let b2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(b, b);\r\n    let b3 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(b2, b);\r\n    let d2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(d, d);\r\n    let d3 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(d2, d);\r\n    if (signA !== 0 || signC !== 0) {\r\n        //console.log('branch 4');\r\n        let a2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(a, a);\r\n        let c2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(c, c);\r\n        // max aggregate bitlength increase (let original bitlength === p):\r\n        // κ -> (2 x ((p+3)+(p+5) + 1)) + (3 x ((p+3) + 1)) === 7p + 30\r\n        // e.g. for bit-aligned input bitlength p of 10 we get output bitlength \r\n        // of 100, or for p === 3 (the max exact bitlength allowed to have exact\r\n        // results without resorting to infinite precision) we get 51 bits.\r\n        let κI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(a2, b3);\r\n        let κO = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(c2, d3);\r\n        let δκ = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(κI, κO));\r\n        if (δκ !== 0) {\r\n            //console.log('branch 5');\r\n            // At this point signA === signC, both +tive or -tive\r\n            return signA > 0 ? δκ : -δκ;\r\n        }\r\n    }\r\n    // At this point signA === signC, both +tive or -tive or 0\r\n    // Now we have to look at the change of curvature w.r.t. the parameter t,\r\n    // i.e. \r\n    // κ′ = [(x′²+y′²)(x′y′′′-y′x′′′) - 3(x′y′′-y′x′′)(x′x′′+y′y′′)] / (x′²+y′²)^(5/2)\r\n    // Therefore: (denoting the incoming curve with a subscript of 1 and the outgoing with a 2)\r\n    // κ′Incoming > κ′Outgoing\r\n    // <=> [(x₁′²+y₁′²)(x₁′y₁′′′-y₁′x₁′′′) - 3(x₁′y₁′′-y₁′x₁′′)(x₁′x₁′′+y₁′y₁′′)]²(x₂′²+y₂′²)⁵ >\r\n    //     [(x₂′²+y₂′²)(x₂′y₂′′′-y₂′x₂′′′) - 3(x₂′y₂′′-y₂′x₂′′)(x₂′x₂′′+y₂′y₂′′)]²(x₁′²+y₁′²)⁵\r\n    // <=> (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // <=> i²b⁵ > j²d⁵\r\n    // Get x′′′ and y′′′ for incoming curve evaluated at 1\r\n    let [dddxI, dddyI] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_3rdDerivative)(psI); // max bitlength increase === max shift === 6\r\n    let [dddxO, dddyO] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_3rdDerivative)(psO); // max bitlength increase === max shift === 6\r\n    let e = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxI, dddyI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyI, dddxI));\r\n    let f = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxI, ddxI), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyI, ddyI));\r\n    let g = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxO, dddyO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyO, dddxO));\r\n    let h = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dxO, ddxO), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(dyO, ddyO));\r\n    // (de - 3af)²b⁵ > (bg - 3ch)²d⁵\r\n    // i²b⁵ > j²d⁵\r\n    let i = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(d, e), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(a, f), 3));\r\n    let j = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(b, g), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(c, h), 3));\r\n    let signI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(i);\r\n    let signJ = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(j);\r\n    if (signA !== signC) {\r\n        return signI - signJ;\r\n    }\r\n    if (signI === 0 && signJ === 0) {\r\n        // Both curve extensions are identical, i.e. in the same K-family\r\n        return 0;\r\n    }\r\n    let i2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(i, i);\r\n    let b5 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(b2, b3);\r\n    let j2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(j, j);\r\n    let d5 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(d2, d3);\r\n    let dκI = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(i2, b5);\r\n    let dκO = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(j2, d5);\r\n    let sgn = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(dκI, dκO));\r\n    return signI > 0 ? sgn : -sgn;\r\n    // If the above returned value is still zero then the two curve extensions \r\n    // are identical, i.e. in the same K-family\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/compare-curvatures-at-interface.ts?")},"./src/contact-point.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "compareCps": () => (/* binding */ compareCps)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the two contact points according to their order along the shape\r\n * boundary. Returns > 0 if a > b, < 0 if a < b or 0 if a === b.\r\n * @param a The first contact point.\r\n * @param b The second contact point.\r\n */\r\nfunction compareCps(a, b) {\r\n    //let res = PointOnShape.compare(a.pointOnShape, b.pointOnShape);\r\n    let res = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.comparePoss)(a.pointOnShape, b.pointOnShape);\r\n    if (res === undefined) {\r\n        return undefined;\r\n    }\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.order - b.order;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    return a.order2 - b.order2;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/contact-point.ts?')},"./src/cp-node.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CpNode\": () => (/* binding */ CpNode)\n/* harmony export */ });\n/* harmony import */ var _contact_point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contact-point.js */ \"./src/contact-point.ts\");\n/* harmony import */ var _cp_node_remove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp-node/remove.js */ \"./src/cp-node/remove.ts\");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-curve-to-next.js */ \"./src/get-curve-to-next.ts\");\n\r\n\r\n\r\n/**\r\n * The primary class of the library.\r\n *\r\n * Since the MAT is a full representation of the shape boundary an instance of\r\n * this class contains both the information of a boundary point and a medial\r\n * axis point (and edge to the next point(s)). It also contains edges to other\r\n * [[CpNode]]s which allows for traversal of the MAT and thus implictly\r\n * represents the entire MAT.\r\n *\r\n * To get the maximal disk circle (of which the center is on the medial axis)\r\n * use [[cp]].circle.\r\n *\r\n * To get the boundary point, use [[cp]].pointOnShape.\r\n *\r\n * The edge [[next]] (resp. [[prev]]) allows one to move anti-clockwise (resp.\r\n * clockwise) on the shape boundary to the next [[CpNode]]. This also imposes a\r\n * direction of traversal of the MAT edges and vertices.\r\n *\r\n * The edge [[nextOnCircle]] (resp. [[prevOnCircle]]) allows one to go\r\n * anti-clockwise (resp. clockwise) around the maximal disks implied by\r\n * the CpNode to the next maximal disk contact point. This is equivalent to\r\n * following other branches on the MAT.\r\n *\r\n * Call [[getCurveBetween]](cpNodeFrom, cpNodeTo) or getCurveToNext(cpNode)\r\n * (replacing the older CpNode.[[matCurveToNextVertex]]) to get a bezier curve\r\n * from the maximal disk of this [[CpNode]] to the next [[CpNode]]'s\r\n * maximal disk and thus directly representing a piece of the medial axis.\r\n *\r\n * The function, [[getChildren]], returns the children of this [[CpNode]] when\r\n * seen as a MAT edge. Only children in a 'forward' direction are returned. These\r\n * include all edges except the 'backward' edge given by [[prevOnCircle]]. For\r\n * [[CpNode]]s having a maximal disk with 2 contact points (a 2-prong, the usual\r\n * case) the children will be the single edge [[next]]. For a 3-prong this will\r\n * be the edges [[next]] and [[nextOnCircle]], etc. [[getChildren]] allows one to\r\n * easily traverse the MAT tree - see e.g. the implementation of [[traverseEdges]].\r\n *\r\n * The getter, [[vertexChildren]], is similar to [[getChildren]] but returns the\r\n * child nodes of the tree when [[CpNode]] is seen as a MAT vertex point (as\r\n * opposed to edge). In this way the dual graph of the tree can easily be\r\n * traversed - see e.g. [[traverseVertices]]. Generally, however, traversing the\r\n * edges is preferred as it returns the entire Medial Axis (by utilizing\r\n * [[getCurveToNext]] on each returned edge).\r\n *\r\n * It may be worth mentioning that by traversing from the CpNode by following\r\n * [[next]] repeatedly until one is back at the same CpNode allows one\r\n * to 'go around' the shape boundary and at the same time traverse the MAT twice\r\n * in opposite directions.\r\n */\r\nclass CpNode {\r\n    /**\r\n     * Primarily for internal use.\r\n     * @param cp The shape boundary contact point, i.e. a [[CpNode]] without its\r\n     * edges.\r\n     * @param isHoleClosing If true, this [[CpNode]] belongs to a hole-closing\r\n     * maximal disk.\r\n     * @param isIntersection true if this cpNode is at a shape boundary\r\n     * intersection point, false otherwise\r\n     * @param prev The previous (going clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param next The next (going anti-clockwise around the boundary) contact\r\n     * point ([[CpNode]]).\r\n     * @param prevOnCircle The previous [[CpNode]] (going clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     * @param nextOnCircle The next [[CpNode]] (going anti-clockwise around\r\n     * the inscribed circle defined by the maximal disk).\r\n     */\r\n    constructor(cp, isHoleClosing, isIntersection, prev = undefined, next = undefined, prevOnCircle = undefined, nextOnCircle = undefined) {\r\n        this.cp = cp;\r\n        this.isHoleClosing = isHoleClosing;\r\n        this.isIntersection = isIntersection;\r\n        this.prev = prev;\r\n        this.next = next;\r\n        this.prevOnCircle = prevOnCircle;\r\n        this.nextOnCircle = nextOnCircle;\r\n    }\r\n    /**\r\n     * Returns the bezier curve from the maximal disk of this [[CpNode]] to the\r\n     * next [[CpNode]]'s maximal disk and thus directly represents a piece of the\r\n     * medial axis.\r\n     * @deprecated Use [[getCurveToNext]] instead\r\n     * @param cpNode\r\n     */\r\n    get matCurveToNextVertex() {\r\n        return (0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(this);\r\n    }\r\n    /**\r\n     * Returns the children of this [[CpNode]] when seen as a MAT edge. Only\r\n     * children in a 'forward' direction are returned. These include all edges\r\n     * except the 'backward' edge given by [[prevOnCircle]], even terminating\r\n     * edges.\r\n     */\r\n    getChildren() {\r\n        let children = [];\r\n        let cp = this.next;\r\n        let cp_ = cp;\r\n        do {\r\n            children.push(cp_);\r\n            cp_ = cp_.nextOnCircle;\r\n        } while (cp_.nextOnCircle !== cp);\r\n        return children;\r\n    }\r\n    /**\r\n     * Similar to [[getChildren]] but returns the child nodes of the tree when\r\n     * [[CpNode]] is seen as a MAT vertex point (as opposed to edge). In this\r\n     * way the dual graph of the tree can easily be traversed - see e.g.\r\n     * [[traverseVertices]]. Generally, however, traversing the edges is\r\n     * preferred as it returns the entire Medial Axis (by utilizing\r\n     * [[getCurveToNext]] on each returned edge).\r\n     */\r\n    get vertexChildren() {\r\n        if (this.isTerminating()) {\r\n            return [];\r\n        }\r\n        let cp = this;\r\n        let children = [];\r\n        let cp_ = cp;\r\n        while (cp_ !== cp.prevOnCircle) {\r\n            if (!cp_.isTerminating()) {\r\n                children.push(cp_.next);\r\n            }\r\n            cp_ = cp_.nextOnCircle;\r\n        }\r\n        return children;\r\n    }\r\n    /**\r\n     * Returns all [[CpNode]]s on the MAT that this [[CpNode]] is part of\r\n     * starting from the current one and going anti-clockwise around the shape.\r\n     */\r\n    getAllOnLoop() {\r\n        let cpStart = this;\r\n        let cps = [cpStart];\r\n        let cp = this.next;\r\n        while (cp !== cpStart) {\r\n            cps.push(cp);\r\n            cp = cp.next;\r\n        }\r\n        return cps;\r\n    }\r\n    /**\r\n     * Primarily for internal use.\r\n     *\r\n     * Insert a [[CpNode]] into the MAT tree graph after the specified point\r\n     * and returns the freshly inserted [[CpNode]].\r\n     * @param isHoleClosing True if this is a hole closing contact point.\r\n     * @param isIntersection True if this is a contact point at a shape boundary\r\n     * intersection point.\r\n     * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n     * @param cp [[ContactPoint]] defining the [[CpNode]].\r\n     * @param prev_ Inserts the new [[CpNode]] right after this item if the\r\n     * loop is not empty, else insert the new [[CpNode]] as the only item in the\r\n     * loop.\r\n     */\r\n    static insert(isHoleClosing, isIntersection, cpTree, cp, prev_) {\r\n        let cpNode = new CpNode(cp, isHoleClosing, isIntersection);\r\n        if (typeof _debug_ !== 'undefined') {\r\n            _debug_.generated.elems.cpNode.push({\r\n                generated: _debug_.generated,\r\n                cpNode\r\n            });\r\n        }\r\n        let prev;\r\n        let next;\r\n        if (!prev_) {\r\n            prev = cpNode;\r\n            next = cpNode;\r\n        }\r\n        else {\r\n            prev = prev_;\r\n            next = prev.next;\r\n        }\r\n        next.prev = cpNode;\r\n        prev.next = cpNode;\r\n        cpNode.prev = prev;\r\n        cpNode.next = next;\r\n        cpTree.insert(cpNode);\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Return this (except if exclThis is truthy) and the the other CpNodes\r\n     * around the maximal disk vertex circle in an anti-clockwise order.\r\n     * @param exclThis If true the returned array does not include this\r\n     * [[CpNode]].\r\n     */\r\n    getCpNodesOnCircle(exclThis = false) {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let cps = [];\r\n        do {\r\n            if (exclThis) {\r\n                exclThis = false;\r\n            }\r\n            else {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return cps;\r\n    }\r\n    /**\r\n     * Returns true if the 2 given [[CpNode]]s are on the same maximal disk\r\n     * circle.\r\n     * @param cpNode1 A [[CpNode]].\r\n     * @param cpNode2 Another [[CpNode]]\r\n     */\r\n    static isOnSameCircle(cpNode1, cpNode2) {\r\n        let cpNodes = cpNode1.getCpNodesOnCircle(true);\r\n        return cpNodes.indexOf(cpNode2) >= 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] is terminating, i.e. implies a leaf MAT\r\n     * vertex.\r\n     *\r\n     * This is always the case for sharp corners and maximal disks with\r\n     * a single contact point. Note, however, that even in these cases there are\r\n     * two contact points stored (sitting 'on top' of each other) for the\r\n     * maximal disk. It can be seen as a limiting case of a two-prong where the\r\n     * distance between two of the contact points tend to zero. One point\r\n     * (represented by a [[CpNode]] of course) will be terminating with the\r\n     * other point being its [[next]], whereas the other point will *not* be\r\n     * terminating and 'points' back into the shape.\r\n     */\r\n    isTerminating() {\r\n        return this === this.next.prevOnCircle;\r\n    }\r\n    /**\r\n     * Like isTerminating() but only returns true if all cpNodes on the circle\r\n     * (except this.prevOnCircle) is terminating.\r\n     */\r\n    isFullyTerminating() {\r\n        let otherOnCircle = this.prevOnCircle.getCpNodesOnCircle(true);\r\n        let isFullyTerminating = otherOnCircle.every(cpNode => cpNode.isTerminating());\r\n        return isFullyTerminating;\r\n    }\r\n    /**\r\n     * Returns the first [[CpNode]] (from this one by successively applying\r\n     * .nextOnCircle) that exits the circle.\r\n     */\r\n    getFirstExit() {\r\n        let startNode = this;\r\n        let cpNode = startNode;\r\n        while (cpNode.next === cpNode.prevOnCircle) {\r\n            cpNode = cpNode.next;\r\n            if (cpNode === startNode) {\r\n                // The very special case the MAT is a single point.\r\n                return undefined;\r\n            }\r\n        }\r\n        return cpNode;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]] represents a sharp corner, i.e. the\r\n     * limiting case of a two-prong having zero radius.\r\n     *\r\n     * Note that two [[CpNode]]s are stored for each sharp corner, one being\r\n     * terminating and one not. See [[isTerminating]] for more details.\r\n     */\r\n    isSharp() {\r\n        return this.cp.circle.radius === 0;\r\n    }\r\n    /**\r\n     * Returns true if this [[CpNode]]'s maximal disk has only one contact point\r\n     * on the shape boundary (up to planar coordinates). These includes sharp\r\n     * corners.\r\n     *\r\n     * Note, however, that two [[CpNode]]s are stored for each such point to\r\n     * preserve symmetry - see [[isTerminating]] for more details.\r\n     */\r\n    isOneProng() {\r\n        let cp1 = this;\r\n        if (cp1.cp.circle.radius === 0) {\r\n            return true;\r\n        }\r\n        let cp2 = cp1.nextOnCircle;\r\n        let p1 = cp1.cp.pointOnShape.p;\r\n        let p2 = cp2.cp.pointOnShape.p;\r\n        return (p1[0] === p2[0] && p1[1] === p2[1]);\r\n    }\r\n    /**\r\n     * Returns the number of contact points on the maximal disk circle implied\r\n     * by this [[CpNode]].\r\n     *\r\n     * Note, however, that even one-prongs and sharp corners will return 2 (see\r\n     * [[isTerminating]] for more details); if this is not desired use\r\n     * [[getRealProngCount]] instead which will return 1 in these cases.\r\n     */\r\n    getProngCount() {\r\n        let startCp = this;\r\n        let cp = startCp;\r\n        let i = 0;\r\n        do {\r\n            i++;\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== startCp);\r\n        return i;\r\n    }\r\n    /**\r\n     * Returns the number of contact points (up to planar coordinates) on the\r\n     * maximal disk circle implied by this [[CpNode]].\r\n     *\r\n     * See also [[getProngCount]].\r\n     */\r\n    getRealProngCount() {\r\n        if (this.isOneProng()) {\r\n            return 1;\r\n        }\r\n        return this.getProngCount();\r\n    }\r\n}\r\n/**\r\n * Primarily for internal use.\r\n *\r\n * Compares the order of two [[CpNode]]s. The order is cyclic and depends\r\n * on a [[CpNode]]'s relative position along the shape boundary.\r\n */\r\nCpNode.comparator = (a, b) => (0,_contact_point_js__WEBPACK_IMPORTED_MODULE_0__.compareCps)(a.cp, b.cp);\r\nCpNode.remove = _cp_node_remove_js__WEBPACK_IMPORTED_MODULE_1__.removeCpNode;\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/cp-node.ts?")},"./src/cp-node/clone.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clone\": () => (/* binding */ clone)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node.js */ \"./src/cp-node.ts\");\n\r\n/** @hidden */\r\nconst EDGES = ['prev', 'next', 'prevOnCircle', 'nextOnCircle'];\r\n/**\r\n * Returns a deep clone of this [[CpNode]]. Can be used to copy the MAT\r\n * since cloning a single [[CpNode]] necessarily implies cloning all\r\n * [[CpNode]]s on the same MAT tree.\r\n */\r\nfunction clone(cpNode) {\r\n    // Don't change this function to be recursive, the call stack may \r\n    // overflow if there are too many CpNodes.\r\n    let nodeMap = new Map();\r\n    let newCpNode = new _cp_node_js__WEBPACK_IMPORTED_MODULE_0__.CpNode(cpNode.cp, cpNode.isHoleClosing, cpNode.isIntersection);\r\n    nodeMap.set(cpNode, newCpNode);\r\n    let cpStack = [{ cpNode, newCpNode }];\r\n    while (cpStack.length) {\r\n        let { cpNode, newCpNode } = cpStack.pop();\r\n        for (let edge of EDGES) {\r\n            let node = cpNode[edge];\r\n            let newNode = nodeMap.get(node);\r\n            if (!newNode) {\r\n                newNode = new _cp_node_js__WEBPACK_IMPORTED_MODULE_0__.CpNode(node.cp, node.isHoleClosing, node.isIntersection);\r\n                nodeMap.set(node, newNode);\r\n                cpStack.push({ cpNode: node, newCpNode: newNode });\r\n            }\r\n            newCpNode[edge] = newNode;\r\n        }\r\n    }\r\n    return newCpNode;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/cp-node/clone.ts?")},"./src/cp-node/remove.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "removeCpNode": () => (/* binding */ removeCpNode)\n/* harmony export */ });\n/**\r\n * Removes a cpNode from the MAT.\r\n * @param cpTree The tree graph holding the [[CpNodes]] of the MAT.\r\n * @param cpNode The [[CpNode]] to remove.\r\n */\r\nfunction removeCpNode(cpNode, cpTree) {\r\n    let prev = cpNode.prev;\r\n    let next = cpNode.next;\r\n    prev.next = next;\r\n    next.prev = prev;\r\n    let nextOpposite = next.prevOnCircle;\r\n    let prevOpposite = prev.nextOnCircle;\r\n    nextOpposite.next = prevOpposite;\r\n    prevOpposite.prev = nextOpposite;\r\n    if (cpTree) {\r\n        cpTree.remove(cpNode, false);\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/cp-node/remove.ts?')},"./src/curve.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCorner": () => (/* binding */ getCorner),\n/* harmony export */   "getCornerAtEnd": () => (/* binding */ getCornerAtEnd)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_interface_ccw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interface-ccw.js */ "./src/get-interface-ccw.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Angle in degrees to radians.\r\n */\r\nconst DEGREES = {\r\n    //\'0\'    : 0.0000,\r\n    0.25: 0.0050,\r\n    1: 0.0167,\r\n    4: 0.0698,\r\n    16: 0.2756,\r\n};\r\n/** @hidden */\r\n//const DEGREE_LIMIT = DEGREES[1];\r\nconst DEGREE_LIMIT = DEGREES[4];\r\n//const DEGREE_LIMIT = DEGREES[16]; \r\n/**\r\n * @hidden\r\n * Returns a new corner with properties.\r\n *\r\n * PRECONDITION: The beziers has control points with max bit-length of 26 and\r\n * aligned to a \'grid\' to have the same exponent. This is so the vectors between\r\n * control points can be calculated exactly without resorting to adaptive\r\n * infinite precision floating point operations.\r\n *\r\n * @param psI The incoming bezier that ends in the corner\r\n * @param psO The outgoing bezier that starts at the corner\r\n */\r\nfunction getCorner(psI, psO) {\r\n    // getInterfaceCcw must return a number !== 0 if psI and psO are not the\r\n    // same as seen as a curve extension with t ∈ [-∞,+∞]\r\n    let ccw = (0,_get_interface_ccw_js__WEBPACK_IMPORTED_MODULE_2__.getInterfaceCcw)(psI, psO);\r\n    let isSharp = ccw < 0;\r\n    let isDull = ccw > 0;\r\n    // Find (non-normalized) tangent of curve.ps at t === 1\r\n    let p0E = psI[psI.length - 2];\r\n    let p1E = psI[psI.length - 1];\r\n    let xE = p1E[0] - p0E[0];\r\n    let yE = p1E[1] - p0E[1];\r\n    let tangentAtEnd = [xE, yE];\r\n    // Find (non-normalized) tangent of curve.next.ps at t === 0\r\n    let p0S = psO[0];\r\n    let p1S = psO[1];\r\n    let xS = p1S[0] - p0S[0];\r\n    let yS = p1S[1] - p0S[1];\r\n    let tangentAtStart = [xS, yS];\r\n    // These use square root and are thus not exact\r\n    let tangents_ = [\r\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(tangentAtEnd),\r\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(tangentAtStart),\r\n    ];\r\n    // The cross calculated below should be exact due to beziers having been\r\n    // normalized!\r\n    let crossTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.cross)(tangents_[0], tangents_[1]);\r\n    let isQuiteSharp;\r\n    let isQuiteDull;\r\n    let dotTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.dot)(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction\r\n        isQuiteSharp = crossTangents < -DEGREE_LIMIT;\r\n        isQuiteDull = crossTangents > +DEGREE_LIMIT;\r\n    }\r\n    else {\r\n        isQuiteSharp = isSharp;\r\n        isQuiteDull = isDull;\r\n    }\r\n    return {\r\n        tangents: tangents_,\r\n        crossTangents,\r\n        isSharp,\r\n        isDull,\r\n        isQuiteSharp,\r\n        isQuiteDull\r\n    };\r\n}\r\n/**\r\n * @hidden\r\n * Returns information about the corner created at the end of this curve\r\n * (at t === 1) and the start of the next curve (at t === 0).\r\n */\r\nlet getCornerAtEnd = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (curve) {\r\n    let psE = curve.ps;\r\n    let psS = curve.next.ps;\r\n    return getCorner(psE, psS);\r\n});\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/curve.ts?')},"./src/debug/debug.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enableDebugForMat": () => (/* binding */ enableDebugForMat)\n/* harmony export */ });\n/* harmony import */ var _functions_general_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions/general.js */ "./src/debug/functions/general.ts");\n/* harmony import */ var _functions_two_prong_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions/two-prong.js */ "./src/debug/functions/two-prong.ts");\n/* harmony import */ var _functions_three_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions/three-prong.js */ "./src/debug/functions/three-prong.ts");\n/* harmony import */ var _functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions/draw-elem/draw-elem.js */ "./src/debug/functions/draw-elem/draw-elem.ts");\n\r\n\r\n\r\n\r\nfunction enableDebugForMat(debugOn) {\r\n    if (!debugOn) {\r\n        window._debug_ = undefined;\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = {\r\n        ...debug,\r\n        generated: {\r\n            //...debug?.generated,\r\n            ...(!debug ? {} : !debug.generated ? {} : debug.generated),\r\n            elems: {\r\n                //...debug?.generated?.elems,\r\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.elems ? {} : debug.generated.elems),\r\n                twoProng_regular: [],\r\n                twoProng_failed: [],\r\n                twoProng_notAdded: [],\r\n                twoProng_deleted: [],\r\n                twoProng_holeClosing: [],\r\n                looseBoundingBox: [],\r\n                tightBoundingBox: [],\r\n                oneProng: [],\r\n                oneProngAtDullCorner: [],\r\n                sharpCorner: [],\r\n                dullCorner: [],\r\n                vertex: [],\r\n                threeProng: [],\r\n                boundingHull: [],\r\n                mat: [],\r\n                sat: [],\r\n                cpNode: [],\r\n                maxVertex: [],\r\n                leaves: [],\r\n                culls: [],\r\n            },\r\n            timing: {\r\n                //...debug?.generated?.timing,\r\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.timing ? {} : debug.generated.timing),\r\n                holeClosers: 0,\r\n                oneAnd2Prongs: 0,\r\n                threeProngs: 0,\r\n                sats: 0,\r\n                simplifyMat: 0,\r\n            }\r\n        },\r\n        fs: {\r\n            //...debug?.fs,\r\n            ...(!debug ? {} : !debug.fs ? {} : debug.fs),\r\n            drawElem: {\r\n                //...debug?.fs?.drawElem,\r\n                ...(!debug ? {} : !debug.fs ? {} : !debug.fs.drawElem ? {} : debug.fs.drawElem),\r\n                ..._functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_3__.drawElemFunctions\r\n            },\r\n            ..._functions_general_js__WEBPACK_IMPORTED_MODULE_0__.generalDebugFunctions,\r\n            twoProng: _functions_two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProngDebugFunctions,\r\n            threeProng: _functions_three_prong_js__WEBPACK_IMPORTED_MODULE_2__.threeProngDebugFunctions,\r\n        },\r\n        directives: {\r\n            //...debug?.directives,\r\n            ...(!debug ? {} : !debug.directives ? {} : debug.directives),\r\n            stopAfterHoleClosers: false,\r\n            stopAfterHoleClosersNum: undefined,\r\n            stopAfterTwoProngs: false,\r\n            stopAfterTwoProngsNum: undefined,\r\n            stopAfterThreeProngs: false,\r\n            stopAfterThreeProngsNum: undefined,\r\n        }\r\n    };\r\n    window._debug_ = debug;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/debug.ts?')},"./src/debug/functions/draw-elem/bounding-hull.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "boundingHull": () => (/* binding */ boundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction boundingHull(g, hull, style = \'thin5 black nofill\') {\r\n    let $polygon = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, hull, style);\r\n    return $polygon;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/bounding-hull.ts?')},"./src/debug/functions/draw-elem/branch.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawBranch": () => (/* binding */ drawBranch)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n\r\n\r\n/** @hidden */\r\nfunction drawBranch(g, branch, delay) {\r\n    let classes = \'thin5 purple nofill\';\r\n    let $svgs = [];\r\n    let i = 0;\r\n    for (let cpNode of branch) {\r\n        if (cpNode.isTerminating()) {\r\n            continue;\r\n        }\r\n        //let bezier = cpNode.matCurveToNextVertex;\r\n        let bezier = (0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_1__.getCurveToNext)(cpNode);\r\n        if (!bezier) {\r\n            continue;\r\n        }\r\n        i++;\r\n        $svgs.push(...flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.bezier(g, bezier, classes, delay));\r\n    }\r\n    return $svgs;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/branch.ts?')},"./src/debug/functions/draw-elem/culls.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "culls": () => (/* binding */ culls)\n/* harmony export */ });\n/** @hidden */\r\nfunction culls(g, culls) {\r\n    let $elems = [];\r\n    for (let circle of culls) {\r\n        let p = circle.center;\r\n        $elems.push(drawCircle(g, p, 0.4, \'cyan thin5 nofill\'));\r\n    }\r\n    return $elems;\r\n}\r\n/** @hidden */\r\nfunction drawCircle(g, center, radiusPercent, classes) {\r\n    const XMLNS = \'http://www.w3.org/2000/svg\';\r\n    let $circle = document.createElementNS(XMLNS, \'circle\');\r\n    $circle.setAttributeNS(null, "cx", center[0].toString());\r\n    $circle.setAttributeNS(null, "cy", center[1].toString());\r\n    $circle.setAttributeNS(null, "r", radiusPercent.toString() + \'%\');\r\n    $circle.setAttributeNS(null, "class", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/culls.ts?')},"./src/debug/functions/draw-elem/draw-circle-percent.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawCirclePercent": () => (/* binding */ drawCirclePercent)\n/* harmony export */ });\n/** @hidden */\r\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = \'http://www.w3.org/2000/svg\';\r\n    let $circle = document.createElementNS(XMLNS, \'circle\');\r\n    $circle.setAttributeNS(null, "cx", center[0].toString());\r\n    $circle.setAttributeNS(null, "cy", center[1].toString());\r\n    $circle.setAttributeNS(null, "r", radiusPercent.toString() + \'%\');\r\n    $circle.setAttributeNS(null, "class", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/draw-circle-percent.ts?')},"./src/debug/functions/draw-elem/draw-elem.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawElemFunctions": () => (/* binding */ drawElemFunctions)\n/* harmony export */ });\n/* harmony import */ var _one_prong_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./one-prong.js */ "./src/debug/functions/draw-elem/one-prong.ts");\n/* harmony import */ var _two_prong_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./two-prong.js */ "./src/debug/functions/draw-elem/two-prong.ts");\n/* harmony import */ var _three_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./three-prong.js */ "./src/debug/functions/draw-elem/three-prong.ts");\n/* harmony import */ var _vertex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex.js */ "./src/debug/functions/draw-elem/vertex.ts");\n/* harmony import */ var _bounding_hull_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bounding-hull.js */ "./src/debug/functions/draw-elem/bounding-hull.ts");\n/* harmony import */ var _loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loose-bounding-box.js */ "./src/debug/functions/draw-elem/loose-bounding-box.ts");\n/* harmony import */ var _tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tight-bounding-box.js */ "./src/debug/functions/draw-elem/tight-bounding-box.ts");\n/* harmony import */ var _sharp_corner_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sharp-corner.js */ "./src/debug/functions/draw-elem/sharp-corner.ts");\n/* harmony import */ var _dull_corner_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dull-corner.js */ "./src/debug/functions/draw-elem/dull-corner.ts");\n/* harmony import */ var _mat_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mat.js */ "./src/debug/functions/draw-elem/mat.ts");\n/* harmony import */ var _max_vertex_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./max-vertex.js */ "./src/debug/functions/draw-elem/max-vertex.ts");\n/* harmony import */ var _leaves_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./leaves.js */ "./src/debug/functions/draw-elem/leaves.ts");\n/* harmony import */ var _culls_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./culls.js */ "./src/debug/functions/draw-elem/culls.ts");\n/* harmony import */ var _one_prong_at_dull_corner_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./one-prong-at-dull-corner.js */ "./src/debug/functions/draw-elem/one-prong-at-dull-corner.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @hidden */\r\nfunction notImplementedYet(g, elem) {\r\n    return []; // TODO - implement relevant drawing function\r\n}\r\n/** @hidden */\r\nlet drawElemFunctions = {\r\n    oneProng: _one_prong_js__WEBPACK_IMPORTED_MODULE_0__.drawOneProng,\r\n    oneProngAtDullCorner: _one_prong_at_dull_corner_js__WEBPACK_IMPORTED_MODULE_13__.oneProngAtDullCorner,\r\n    twoProng_regular: _two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProng,\r\n    twoProng_failed: _two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProng,\r\n    twoProng_notAdded: _two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProng,\r\n    twoProng_deleted: _two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProng,\r\n    twoProng_holeClosing: _two_prong_js__WEBPACK_IMPORTED_MODULE_1__.twoProng,\r\n    threeProng: _three_prong_js__WEBPACK_IMPORTED_MODULE_2__.threeProng,\r\n    //minY,\r\n    boundingHull: _bounding_hull_js__WEBPACK_IMPORTED_MODULE_4__.boundingHull,\r\n    looseBoundingBox: _loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_5__.looseBoundingBox,\r\n    tightBoundingBox: _tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__.tightBoundingBox,\r\n    sharpCorner: _sharp_corner_js__WEBPACK_IMPORTED_MODULE_7__.sharpCorner,\r\n    dullCorner: _dull_corner_js__WEBPACK_IMPORTED_MODULE_8__.dullCorner,\r\n    vertex: _vertex_js__WEBPACK_IMPORTED_MODULE_3__.vertex,\r\n    mat: (0,_mat_js__WEBPACK_IMPORTED_MODULE_9__.drawMat)(\'mat\'),\r\n    sat: (0,_mat_js__WEBPACK_IMPORTED_MODULE_9__.drawMat)(\'sat\'),\r\n    //loop,\r\n    //loops,\r\n    maxVertex: _max_vertex_js__WEBPACK_IMPORTED_MODULE_10__.maxVertex,\r\n    leaves: _leaves_js__WEBPACK_IMPORTED_MODULE_11__.leaves,\r\n    culls: _culls_js__WEBPACK_IMPORTED_MODULE_12__.culls,\r\n    cpNode: notImplementedYet\r\n};\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/draw-elem.ts?')},"./src/debug/functions/draw-elem/dull-corner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "dullCorner": () => (/* binding */ dullCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction dullCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let ps = curve.ps;\r\n    let p = curve.ps[ps.length - 1];\r\n    let $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, p, 0.5 * scaleFactor, \'orange\');\r\n    return $pos;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/dull-corner.ts?')},"./src/debug/functions/draw-elem/leaves.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "leaves": () => (/* binding */ leaves)\n/* harmony export */ });\n/* harmony import */ var _draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-circle-percent.js */ "./src/debug/functions/draw-elem/draw-circle-percent.ts");\n\r\n/** @hidden */\r\nfunction leaves(g, leaves) {\r\n    let $elems = [];\r\n    for (let cpNode of leaves) {\r\n        let cp = cpNode.cp;\r\n        let p = cp.circle.center;\r\n        $elems.push((0,_draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__.drawCirclePercent)(g, p, 0.5, \'pinker thin5 nofill\'));\r\n    }\r\n    return $elems;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/leaves.ts?')},"./src/debug/functions/draw-elem/loose-bounding-box.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "looseBoundingBox": () => (/* binding */ looseBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction looseBoundingBox(g, box) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    box = [[x0, y0], [x1, y0], [x1, y1], [x0, y1]];\r\n    let $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, \'thin5 brown nofill\');\r\n    return $box;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/loose-bounding-box.ts?')},"./src/debug/functions/draw-elem/mat.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawMat": () => (/* binding */ drawMat)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n/* harmony import */ var _traverse_edges_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../traverse-edges.js */ "./src/traverse-edges.ts");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n\r\n\r\n\r\n/** @hidden */\r\nfunction drawMat(type) {\r\n    let classes = type === \'mat\'\r\n        ? \'thin5 purple nofill\'\r\n        : \'thin10 red nofill\';\r\n    return (g, mat) => {\r\n        let cpNode = mat.cpNode;\r\n        if (!cpNode) {\r\n            return undefined;\r\n        }\r\n        let $svgs = [];\r\n        let i = 0;\r\n        (0,_traverse_edges_js__WEBPACK_IMPORTED_MODULE_1__.traverseEdges)(cpNode, cpNode => {\r\n            if (cpNode.isTerminating()) {\r\n                return;\r\n            }\r\n            let bezier = (0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(cpNode);\r\n            if (!bezier) {\r\n                return;\r\n            }\r\n            i++;\r\n            $svgs.push(...flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.bezier(g, bezier, classes /*, i*500*/));\r\n        });\r\n        return $svgs;\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/mat.ts?')},"./src/debug/functions/draw-elem/max-vertex.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "maxVertex": () => (/* binding */ maxVertex)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction maxVertex(g, cpNode) {\r\n    let circle = cpNode.cp.circle;\r\n    let $elems = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, \'brown thin10 nofill\');\r\n    return $elems;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/max-vertex.ts?')},"./src/debug/functions/draw-elem/one-prong-at-dull-corner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"oneProngAtDullCorner\": () => (/* binding */ oneProngAtDullCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../point-on-shape.js */ \"./src/point-on-shape.ts\");\n\r\n\r\n/** @hidden */\r\nfunction oneProngAtDullCorner(g, pos) {\r\n    //let oCircle = PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos);\r\n    let oCircle = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.getOsculatingCircle)(Number.POSITIVE_INFINITY, pos);\r\n    let $center = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, pos.p, 0.1, 'orange');\r\n    let $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, oCircle.center, 0.25, 'orange');\r\n    let $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, oCircle, 'orange thin10 nofill');\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/one-prong-at-dull-corner.ts?")},"./src/debug/functions/draw-elem/one-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawOneProng": () => (/* binding */ drawOneProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../circle.js */ "./src/circle.ts");\n\r\n\r\n\r\n/** @hidden */\r\nconst scaleFactor = 0.5;\r\n/** @hidden */\r\nfunction drawOneProng(g, pos, classes, delay = 0) {\r\n    let circle = (0,_circle_js__WEBPACK_IMPORTED_MODULE_2__.scaleCircle)(\r\n    //PointOnShape.getOsculatingCircle(Number.POSITIVE_INFINITY, pos),\r\n    (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.getOsculatingCircle)(Number.POSITIVE_INFINITY, pos), 1);\r\n    let $center = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, pos.p, 0.1 * scaleFactor, \'gray\', delay);\r\n    let $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.25 * scaleFactor, \'gray\', delay);\r\n    let $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, \'gray thin10 nofill\', delay);\r\n    return [...$center, ...$circle, ...$pos];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/one-prong.ts?')},"./src/debug/functions/draw-elem/sharp-corner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sharpCorner": () => (/* binding */ sharpCorner)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction sharpCorner(g, curve) {\r\n    const scaleFactor = 1;\r\n    let p = curve.ps[curve.ps.length - 1];\r\n    let $pos = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, p, 0.6 * scaleFactor, \'green\');\r\n    return $pos;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/sharp-corner.ts?')},"./src/debug/functions/draw-elem/three-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"threeProng\": () => (/* binding */ threeProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../circle.js */ \"./src/circle.ts\");\n\r\n\r\n/** @hidden */\r\nconst scaleFactor = 0.3;\r\n/** @hidden */\r\nfunction threeProng(g, threeProng) {\r\n    let circle = (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.scaleCircle)(threeProng.circle, 1);\r\n    let poss = threeProng.poss;\r\n    let $cp1 = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, poss[0].p, 0.1 * 1 * scaleFactor, 'blue');\r\n    let $cp2 = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, poss[1].p, 0.1 * 2 * scaleFactor, 'blue');\r\n    let $cp3 = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, poss[2].p, 0.1 * 3 * scaleFactor, 'blue');\r\n    let $center = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.3 * scaleFactor, 'blue');\r\n    let $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'blue thin2 nofill');\r\n    return [...$center, ...$cp1, ...$cp2, ...$cp3, ...$circle];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/three-prong.ts?")},"./src/debug/functions/draw-elem/tight-bounding-box.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tightBoundingBox": () => (/* binding */ tightBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction tightBoundingBox(g, box) {\r\n    let $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, \'thin5 pinker nofill\');\r\n    return $box;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/tight-bounding-box.ts?')},"./src/debug/functions/draw-elem/two-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"twoProng\": () => (/* binding */ twoProng)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n/* harmony import */ var _mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../mat/get-two-prong-type.js */ \"./src/mat/get-two-prong-type.ts\");\n\r\n\r\n/** @hidden */\r\nfunction twoProng(g, twoProng) {\r\n    let scaleFactor = 0.3;\r\n    let $failedDot = [];\r\n    let $center = [];\r\n    let $circle = [];\r\n    let $cp1 = [];\r\n    let $cp2 = [];\r\n    let color;\r\n    let thin;\r\n    switch ((0,_mat_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_1__.getTwoProngType)(twoProng)) {\r\n        case 'twoProng_regular': {\r\n            color = 'red ';\r\n            thin = '2';\r\n            break;\r\n        }\r\n        case 'twoProng_holeClosing': {\r\n            color = 'cyan ';\r\n            thin = '10';\r\n            break;\r\n        }\r\n    }\r\n    if (twoProng.failed) {\r\n        $failedDot = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, twoProng.pos.p, 1 * scaleFactor, 'black');\r\n    }\r\n    else if (!twoProng.failed) {\r\n        $center = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, twoProng.circle.center, 1 * scaleFactor, 'yellow');\r\n        $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, twoProng.circle, color + 'thin' + thin + ' nofill');\r\n        $cp1 = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, twoProng.pos.p, 0.035 * scaleFactor, color);\r\n        $cp2 = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, twoProng.z, 0.07 * scaleFactor, color);\r\n    }\r\n    return [...$failedDot, ...$center, ...$circle, ...$cp1, ...$cp2];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/two-prong.ts?")},"./src/debug/functions/draw-elem/vertex.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"vertex\": () => (/* binding */ vertex)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n\r\n/** @hidden */\r\nfunction vertex(g, cpNode, classes, delay, visible = true) {\r\n    let visibleClass = visible ? '' : ' invisible';\r\n    let circle = cpNode.cp.circle;\r\n    const THIN = 'thin20';\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    console.log(cps);\r\n    let $svgs = [];\r\n    let $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'red ' + THIN + ' nofill ' + visibleClass, delay);\r\n    let $crossHair = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, circle.center, 'red ' + THIN + ' nofill ' + visibleClass, 3, delay);\r\n    $svgs = [...$circle, ...$crossHair];\r\n    for (let i = 0; i < cps.length; i++) {\r\n        let cp = cps[i];\r\n        let edgeCircle = cp.next.cp.circle;\r\n        let $circle = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, edgeCircle, 'pink ' + THIN + ' nofill ' + visibleClass, delay);\r\n        let $crossHair = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, edgeCircle.center, 'pink ' + THIN + ' nofill ' + visibleClass, 3, delay);\r\n        $svgs.push(...$circle, ...$crossHair);\r\n        let p1 = circle.center;\r\n        let p2 = edgeCircle.center;\r\n        let thin = i === 0 ? 'thin10' : (i === 1 ? 'thin20' : 'thin35');\r\n        let $line = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [p1, p2], 'yellow ' + thin + ' nofill ' + visibleClass, delay);\r\n        $svgs.push(...$line);\r\n    }\r\n    return $svgs;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/draw-elem/vertex.ts?")},"./src/debug/functions/general.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generalDebugFunctions\": () => (/* binding */ generalDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape.js */ \"./src/point-on-shape.ts\");\n\r\n/** @hidden */\r\nlet i = 0;\r\n/**\r\n * @hidden\r\n * Name the given object - for debugging purposes only\r\n */\r\nfunction nameObj(o, pre = '') {\r\n    o.name = '' + pre + i++;\r\n}\r\n/**\r\n * @hidden\r\n * Transforms a boundary piece (δ) into a human readable string.\r\n * @param cpNodes A boundary piece given by two CpNodes.\r\n */\r\nfunction δToString(cpNodes) {\r\n    return cpNodes.map(cpNode => (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(cpNode.cp.pointOnShape));\r\n}\r\n/**\r\n * @hidden\r\n * Transforms an array of boundary pieces (δs) into a human readable string.\r\n * @param cpNodes An array of boundary pieces.\r\n */\r\nfunction δsToString(cpNodes) {\r\n    return cpNodes.map(δToString);\r\n}\r\n/**\r\n * @hidden\r\n * Convert the given points into a human readable string.\r\n * @param ps\r\n */\r\nfunction pointsToStr(ps, decimalPlaces = 3) {\r\n    return ps.map(p => pointToStr(p, decimalPlaces));\r\n}\r\n/**\r\n * @hidden\r\n * Converts the given point into a human readable string.\r\n * @param p The point\r\n * @param decimalPlaces number of decimal places\r\n */\r\nfunction pointToStr(p, decimalPlaces = 3) {\r\n    return p[0].toFixed(decimalPlaces) + ', ' + p[1].toFixed(decimalPlaces);\r\n}\r\n/** @hidden */\r\nlet generalDebugFunctions /*: IGeneralDebugFunctions*/ = {\r\n    δToString,\r\n    δsToString,\r\n    pointToStr,\r\n    pointsToStr,\r\n    nameObj,\r\n};\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/general.ts?")},"./src/debug/functions/three-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"threeProngDebugFunctions\": () => (/* binding */ threeProngDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n\r\n\r\n/**\r\n * @hidden\r\n * Draws 3 lines from the given 3-prong center to its 3 contact points.\r\n * @param n - The 3-prong's zero-based index.\r\n */\r\nfunction drawSpokes(g, n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    //let g = threeProng.generated.g;\r\n    let cc = threeProng.circle.center;\r\n    let poss = threeProng.poss;\r\n    //_debug_.fs.draw.line(g, [poss[0].p, cc], 'thin5 red');\r\n    //_debug_.fs.draw.line(g, [poss[1].p, cc], 'thin5 red');\r\n    //_debug_.fs.draw.line(g, [poss[2].p, cc], 'thin5 red');\r\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [poss[0].p, cc], 'thin5 red');\r\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [poss[1].p, cc], 'thin5 red');\r\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [poss[2].p, cc], 'thin5 red');\r\n}\r\n/**\r\n * @hidden\r\n * Shows the circle for each boundary iteration.\r\n * @param n_ - The 3-prong's zero-based index. If ommitted, all will be shown.\r\n * @param idx - The specific boundary iteration index to view. If ommitted, all\r\n * will be shown.\r\n */\r\nfunction traceConvergence(g, n_, idx) {\r\n    let sIndx;\r\n    let eIndx;\r\n    if (n_ === undefined) {\r\n        sIndx = 0;\r\n        eIndx = _debug_.generated.elems.threeProng.length;\r\n    }\r\n    else {\r\n        sIndx = n_;\r\n        eIndx = n_ + 1;\r\n    }\r\n    for (let n = sIndx; n < eIndx; n++) {\r\n        let forDebugging = _debug_.generated.elems.threeProng[n];\r\n        //let g = forDebugging.generated.g;\r\n        console.log(forDebugging);\r\n        let candidateThreeProngs = forDebugging.candidateThreeProngs;\r\n        //-----------------------------\r\n        //---- Get start and end index\r\n        //-----------------------------\r\n        let startIndx;\r\n        let endIndx;\r\n        if (n_ === undefined || idx === -1) {\r\n            startIndx = forDebugging.bestIndx;\r\n            endIndx = forDebugging.bestIndx + 1;\r\n        }\r\n        else {\r\n            if (idx === undefined) {\r\n                startIndx = 0;\r\n                endIndx = candidateThreeProngs.length;\r\n            }\r\n            else {\r\n                startIndx = idx;\r\n                endIndx = idx + 1;\r\n            }\r\n        }\r\n        //---------------------------------\r\n        //---- Draw candidate three-prongs\r\n        //---------------------------------\r\n        for (let i = startIndx; i < endIndx; i++) {\r\n            let circle = candidateThreeProngs[i].circle;\r\n            if (forDebugging.bestIndx === i) {\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.2, 'green');\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'black thin10 nofill');\r\n            }\r\n            else {\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, circle.center, 0.2, 'cyan');\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'cyan thin5 nofill');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * Shows the actual boundary for each iteration.\r\n * @param n The 3-prong's zero-based index.\r\n * @param idx The specific boundary iteration index to view. If ommitted will\r\n * show all.\r\n */\r\nfunction showBoundary(g, n, idx) {\r\n    let debugInfo = _debug_.generated.elems.threeProng[n];\r\n    //let g = debugInfo.generated.g;\r\n    let candidateThreeProngs = debugInfo.candidateThreeProngs;\r\n    let startIndx = idx === undefined ? 0 : idx;\r\n    let endIndx = idx === undefined ? candidateThreeProngs.length : idx;\r\n    // Draw relevant δs\r\n    let cpss = debugInfo.cpss;\r\n    let j = 0;\r\n    // For each iteration of δ3s (indexed by j)\r\n    for (let idx = 1; idx < cpss.length - 1; idx++) {\r\n        if (!(j >= startIndx && j <= endIndx)) {\r\n            j++;\r\n            continue;\r\n        }\r\n        let δ3s = [\r\n            cpss[0],\r\n            cpss[idx],\r\n            cpss[cpss.length - 1]\r\n        ];\r\n        // For each of the 3 δs\r\n        for (let i = 0; i < 3; i++) {\r\n            let δ = δ3s[i];\r\n            let δS = δ[0]; // Delta Start\r\n            let δE = δ[1]; // Delta End\r\n            let posS = δS.cp.pointOnShape;\r\n            let posE = δE.cp.pointOnShape;\r\n            let pS = posS.p;\r\n            let pE = posE.p;\r\n            let r = 1 + (i * 0.5);\r\n            if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.equal)(pS, pE)) {\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pS, 'red thin10 nofill', r);\r\n            }\r\n            else {\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pS, 'green thin10 nofill', r);\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, pE, 'blue thin10 nofill', r);\r\n            }\r\n        }\r\n        j++;\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * @param n The 3-prong's zero-based index.\r\n */\r\nfunction logδs(n) {\r\n    let threeProng = _debug_.generated.elems.threeProng[n];\r\n    console.log(threeProng.cpss);\r\n}\r\n/**\r\n * @hidden\r\n * @param p\r\n */\r\nfunction logNearest(showSpokes = true, showTrace = true, showBoundaries = true) {\r\n    return function (g, p, showDelay = 1000) {\r\n        let generated = _debug_.generated;\r\n        let threeProng = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.getObjClosestTo)(p, generated.elems.threeProng, threeProng => threeProng.circle ? threeProng.circle.center : [0, 0]);\r\n        let circle = threeProng.circle;\r\n        //let g = threeProng.generated.g;\r\n        console.log(threeProng);\r\n        let circle2 = {\r\n            center: circle.center,\r\n            radius: circle.radius || 1\r\n        };\r\n        //let draw = _debug_.fs.draw;\r\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle2, 'blue thin10 nofill', showDelay);\r\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, circle.center, 'red thin2 nofill', 2, showDelay);\r\n        if (showSpokes) {\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[0].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[1].p, circle.center], 'blue thin5 nofill', showDelay);\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [threeProng.poss[2].p, circle.center], 'blue thin5 nofill', showDelay);\r\n        }\r\n        if (showBoundaries) {\r\n            let boundaries = threeProng.boundaries;\r\n            let boundaryS = boundaries[0];\r\n            let boundaryE = boundaries[boundaries.length - 1];\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundaryS, 'red thin20 nofill', showDelay);\r\n            for (let i = 1; i < boundaries.length - 1; i++) {\r\n                let boundary = boundaries[i];\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundary, 'green thin20 nofill', showDelay);\r\n            }\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.beziers(g, boundaryE, 'blue thin20 nofill', showDelay);\r\n        }\r\n        if (showTrace) {\r\n            let traces = threeProng.traces;\r\n            for (let trace of traces) {\r\n                flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polyline(g, trace, 'red thin5 nofill', showDelay);\r\n            }\r\n        }\r\n    };\r\n}\r\n/** @hidden */\r\nlet threeProngDebugFunctions = {\r\n    drawSpokes,\r\n    traceConvergence,\r\n    showBoundary,\r\n    logδs,\r\n    logNearest\r\n};\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/three-prong.ts?")},"./src/debug/functions/two-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"twoProngDebugFunctions\": () => (/* binding */ twoProngDebugFunctions)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-draw/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n\r\n\r\n/**\r\n * @hidden\r\n */\r\nfunction logδ(n, type = 'twoProng_regular') {\r\n    let δ = _debug_.generated.elems[type][n].δ;\r\n    console.log(δ);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction log(n, type = 'twoProng_regular') {\r\n    let twoProng = _debug_.generated.elems[type][n];\r\n    console.log(twoProng);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction drawNormal(g, n, showDelay = 1000, type = 'twoProng_regular') {\r\n    let twoProngs = _debug_.generated.elems[type];\r\n    // If not specified which, draw all\r\n    if (n === undefined) {\r\n        for (let i = 0; i < twoProngs.length; i++) {\r\n            drawNormal(g, i);\r\n        }\r\n    }\r\n    let twoProng = twoProngs[n];\r\n    //let g = twoProng.generated.g;\r\n    if (!twoProng) {\r\n        return;\r\n    }\r\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.line(g, [twoProng.pos.p, twoProng.circle.center], 'thin10 blue', showDelay);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction logδBasic(n, type = 'twoProng_regular') {\r\n    let delta = _debug_.generated.elems[type][n].δ;\r\n    function f(x) {\r\n        let pos = x.cp.pointOnShape;\r\n        return {\r\n            bez: pos.curve.ps,\r\n            t: pos.t\r\n        };\r\n    }\r\n    console.log(f(delta[0]));\r\n    console.log(f(delta[1]));\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction logNearest(g, p, showDelay = 1000, type = 'twoProng_regular') {\r\n    let closestPerLoops = [];\r\n    let generated = _debug_.generated;\r\n    let twoProng = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.getObjClosestTo)(p, generated.elems[type], twoProng => twoProng.circle.center);\r\n    closestPerLoops.push(twoProng);\r\n    console.log(twoProng);\r\n    let n;\r\n    for (let i = 0; i < _debug_.generated.elems[type].length; i++) {\r\n        let twoProng_ = _debug_.generated.elems[type][i];\r\n        if (twoProng_ === twoProng) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n !== undefined) {\r\n        traceConvergence(g, n, true, showDelay);\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * @param n - The 2-prong's zero-based index.\r\n * @param range\r\n */\r\nfunction traceConvergence(g, n, finalOnly, showDelay = 1000, range = undefined, type = 'twoProng_regular') {\r\n    if (n === undefined) {\r\n        return;\r\n    }\r\n    let twoProngInfo = _debug_.generated.elems[type][n];\r\n    let xs = twoProngInfo.xs;\r\n    //let g = twoProngInfo.generated.g;\r\n    console.log(twoProngInfo);\r\n    console.log(twoProngInfo.xs.map(x => ({\r\n        x: x.x,\r\n        y: x.y,\r\n        z: x.z,\r\n        d: x.z ? (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(x.y.p, x.z.p) : 0,\r\n        t: x.t,\r\n    })));\r\n    for (let i = 0; i < xs.length; i++) {\r\n        if (range && (i < range[0] || i >= range[1])) {\r\n            continue;\r\n        }\r\n        if (finalOnly && i !== xs.length - 1) {\r\n            continue;\r\n        }\r\n        let x = twoProngInfo.xs[i];\r\n        let circle = { center: x.x, radius: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.distanceBetween)(x.x, x.y.p) };\r\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, x.x, 'red thin10 nofill', undefined, showDelay);\r\n        flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, circle, 'blue thin10 nofill', showDelay);\r\n        if (x.z !== undefined) {\r\n            flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, x.z.p, 'yellow thin10 nofill', 2, showDelay);\r\n        }\r\n    }\r\n    twoProngDebugFunctions.drawNormal(g, n, showDelay);\r\n}\r\n/** @hidden */\r\nlet twoProngDebugFunctions = {\r\n    logδ,\r\n    log,\r\n    drawNormal,\r\n    logδBasic,\r\n    traceConvergence,\r\n    logNearest,\r\n};\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/functions/two-prong.ts?")},"./src/debug/three-prong-for-debugging.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createEmptyThreeProngForDebugging": () => (/* binding */ createEmptyThreeProngForDebugging)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\nfunction createEmptyThreeProngForDebugging() {\r\n    return {\r\n        generated: undefined,\r\n        circle: undefined,\r\n        poss: undefined,\r\n        cp3ss: undefined,\r\n        cpss: undefined,\r\n        bestIndx: undefined,\r\n        candidateThreeProngs: undefined,\r\n        visitedCps: undefined,\r\n        boundaries: undefined,\r\n        traces: undefined,\r\n    };\r\n}\r\nfunction cpsSimple(threeProngForDebugging) {\r\n    return threeProngForDebugging.cpss.map(δ => [(0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(δ[0].cp.pointOnShape),\r\n        (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.posToHumanString)(δ[1].cp.pointOnShape)]);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/debug/three-prong-for-debugging.ts?')},"./src/find-mats.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findMats": () => (/* binding */ findMats)\n/* harmony export */ });\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-boolean */ "./node_modules/flo-boolean/node/index.js");\n/* harmony import */ var _mat_find_mat_find_and_add_3_prongs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat/find-mat/find-and-add-3-prongs.js */ "./src/mat/find-mat/find-and-add-3-prongs.ts");\n/* harmony import */ var _mat_find_mat_create_initial_cp_graph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat/find-mat/create-initial-cp-graph.js */ "./src/mat/find-mat/create-initial-cp-graph.ts");\n/* harmony import */ var _mat_find_mat_add_debug_info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat/find-mat/add-debug-info.js */ "./src/mat/find-mat/add-debug-info.ts");\n/* harmony import */ var _mat_find_mat_get_potential_2_prongs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat/find-mat/get-potential-2-prongs.js */ "./src/mat/find-mat/get-potential-2-prongs.ts");\n/* harmony import */ var _mat_find_mat_get_sharp_corners_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mat/find-mat/get-sharp-corners.js */ "./src/mat/find-mat/get-sharp-corners.ts");\n/* harmony import */ var _mat_find_mat_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mat/find-mat/find-and-add-2-prongs-on-all-paths.js */ "./src/mat/find-mat/find-and-add-2-prongs-on-all-paths.ts");\n/* harmony import */ var _mat_find_mat_create_get_interesting_points_on_loop_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mat/find-mat/create-get-interesting-points-on-loop.js */ "./src/mat/find-mat/create-get-interesting-points-on-loop.ts");\n/* harmony import */ var _mat_find_mat_find_and_add_hole_closing_2_prongs_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mat/find-mat/find-and-add-hole-closing-2-prongs.js */ "./src/mat/find-mat/find-and-add-hole-closing-2-prongs.ts");\n/* harmony import */ var _loop_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loop/get-max-coordinate.js */ "./src/loop/get-max-coordinate.ts");\n\r\n\r\n\r\n;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Finds and returns the Medial Axis Transforms (MATs) from the given array of\r\n * bezier loops representing shape boundaries.\r\n *\r\n * @param bezierLoops An array of (possibly intersecting) loops with each loop\r\n * representing one or more piecewise smooth closed curves (i.e. shapes). Each\r\n * loop consists of an array of beziers represented by an array of control\r\n * points with 2,3 or 4 elements corresponding to linear, quadratic and cubic\r\n * beziers respectively. Each point is a two-element array (ordered pair), the\r\n * first of which is the x-coordinate and the second the y-coordinate.\r\n *\r\n * @param maxCurviness The maximum value the \'curviness\' of a curve can have\r\n * before an additional MAT point is inserted in between. Defaults to 0.4.\r\n * (Curviness is measured as the total angle in radians between the consecutive\r\n * vectors formed by the ordered control points of th bezier curve). The value\r\n * is clipped in the range `[0.05,3]`.\r\n * @param maxLength The maximum length a curve can have before an additional MAT\r\n * point is inserted. This value is scaled to a reference 1024 x 1024\r\n * grid (e.g. if the shape fits in a 512 x 512 axis-aligned box the value will be\r\n * halved, e.g. from 10 to 5). Together with maxCurviness it represents a\r\n * tolerance for the accuracy of the MAT. Defaults to 4. The value is clipped\r\n * in [1,100].\r\n */\r\nfunction findMats(bezierLoops, maxCurviness = 0.4, maxLength = 4) {\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        var timingStart = performance.now();\r\n    }\r\n    let maxCoordinate;\r\n    let minBezLength;\r\n    ({ maxCurviness, maxLength, maxCoordinate, minBezLength } =\r\n        getSizeParams(bezierLoops, maxCurviness, maxLength));\r\n    let loopss = (0,flo_boolean__WEBPACK_IMPORTED_MODULE_0__.simplifyPaths)(bezierLoops, maxCoordinate);\r\n    let mats = [];\r\n    for (let loops of loopss) {\r\n        let mat = findMat(loops, minBezLength, maxCurviness, maxLength, maxCoordinate);\r\n        if (mat) {\r\n            mats.push(mat);\r\n        }\r\n    }\r\n    return mats;\r\n}\r\nfunction getSizeParams(bezierLoops, maxCurviness, maxLength) {\r\n    // Gather some shape metrics\r\n    let { maxCoordinate, maxRadius } = (0,_loop_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_9__.getLoopsMetrics)(bezierLoops);\r\n    let expMax = Math.ceil(Math.log2(maxCoordinate));\r\n    let minBezLengthSigBits = 14;\r\n    /**\r\n     * If a curve is shorter than this value then no points on it will be\r\n     * selected for the purpose of finding the MAT.\r\n     */\r\n    let minBezLength = 2 ** expMax * 2 ** (-minBezLengthSigBits);\r\n    // Limit the tolerance to a reasonable level\r\n    if (maxCurviness < 0.05) {\r\n        maxCurviness = 0.05;\r\n    }\r\n    if (maxCurviness > 3) {\r\n        maxCurviness = 3;\r\n    }\r\n    // Limit the tolerance to a reasonable level\r\n    if (maxLength < 0.1) {\r\n        maxLength = 0.1;\r\n    }\r\n    if (maxLength > 100) {\r\n        maxLength = 100;\r\n    }\r\n    // Adjust length tolerance according to a reference max coordinate\r\n    let expMaxRadius = Math.ceil(Math.log2(maxRadius));\r\n    let maxLengthSigBits = 10; // 1024 x 1024\r\n    maxLength = maxLength * (2 ** expMaxRadius * 2 ** (-maxLengthSigBits));\r\n    return { maxCurviness, maxLength, maxCoordinate, minBezLength };\r\n}\r\n/**\r\n * @hidden\r\n * Find the MAT of the given loops.\r\n * @param loops The loops (that as a precondition must be ordered from highest\r\n * (i.e. smallest y-value) topmost point loops to lowest)\r\n */\r\nfunction findMat(loops, minBezLength, maxCurviness, maxLength, maxCoordinate) {\r\n    (0,_mat_find_mat_add_debug_info_js__WEBPACK_IMPORTED_MODULE_3__.addDebugInfo1)(loops);\r\n    // Gets interesting points on the shape, i.e. those that makes sense to use \r\n    // for the 2-prong procedure.\r\n    let pointsPerLoop = loops.map((0,_mat_find_mat_create_get_interesting_points_on_loop_js__WEBPACK_IMPORTED_MODULE_7__.getInterestingPointsOnLoop)(minBezLength, maxCurviness, maxLength));\r\n    let for2ProngsPerLoop = (0,_mat_find_mat_get_potential_2_prongs_js__WEBPACK_IMPORTED_MODULE_4__.getPotential2Prongs)(pointsPerLoop);\r\n    let sharpCornersPerLoop = (0,_mat_find_mat_get_sharp_corners_js__WEBPACK_IMPORTED_MODULE_5__.getSharpCorners)(pointsPerLoop);\r\n    let cpTrees = new Map();\r\n    let cpNode = (0,_mat_find_mat_create_initial_cp_graph_js__WEBPACK_IMPORTED_MODULE_2__.createInitialCpGraph)(loops, cpTrees, sharpCornersPerLoop);\r\n    (0,_mat_find_mat_find_and_add_hole_closing_2_prongs_js__WEBPACK_IMPORTED_MODULE_8__.findAndAddHoleClosing2Prongs)(loops, cpTrees, maxCoordinate);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        if (_debug_.directives.stopAfterHoleClosers) {\r\n            return undefined;\r\n        }\r\n    }\r\n    (0,_mat_find_mat_add_debug_info_js__WEBPACK_IMPORTED_MODULE_3__.addDebugInfo2)();\r\n    cpNode = (0,_mat_find_mat_find_and_add_2_prongs_on_all_paths_js__WEBPACK_IMPORTED_MODULE_6__.findAndAdd2ProngsOnAllPaths)(loops, cpTrees, for2ProngsPerLoop, maxCoordinate);\r\n    (0,_mat_find_mat_add_debug_info_js__WEBPACK_IMPORTED_MODULE_3__.addDebugInfo3)();\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        if (_debug_.directives.stopAfterTwoProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    if (cpNode === undefined) {\r\n        return undefined;\r\n    }\r\n    (0,_mat_find_mat_find_and_add_3_prongs_js__WEBPACK_IMPORTED_MODULE_1__.findAndAddAll3Prongs)(cpTrees, cpNode, maxCoordinate);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        if (_debug_.directives.stopAfterThreeProngs) {\r\n            return undefined;\r\n        }\r\n    }\r\n    let mat = { cpNode, cpTrees };\r\n    (0,_mat_find_mat_add_debug_info_js__WEBPACK_IMPORTED_MODULE_3__.addDebugInfo4)(mat);\r\n    return mat;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/find-mats.ts?')},"./src/get-boundary-bezier-parts-to-next.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundaryBezierPartsToNext": () => (/* binding */ getBoundaryBezierPartsToNext)\n/* harmony export */ });\n/**\r\n * Returns the ordered bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBezierPartsToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let bezierParts = [];\r\n    if (curveNext === curveThis) {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, posNext.t] });\r\n    }\r\n    else {\r\n        bezierParts.push({ ps: posThis.curve.ps, ts: [posThis.t, 1] });\r\n        addSkippedBeziers(bezierParts, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return bezierParts;\r\n}\r\n/**\r\n * @hidden\r\n * Adds pieces of skipped beziers.\r\n */\r\nfunction addSkippedBeziers(bezierParts, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let bezierPart = curveThis === curveEnd\r\n            ? { ps: curveThis.ps, ts: [0, t1] }\r\n            : { ps: curveThis.ps, ts: [0, 1] };\r\n        bezierParts.push(bezierPart);\r\n    } while (curveThis !== curveEnd);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-boundary-bezier-parts-to-next.ts?')},"./src/get-boundary-beziers-to-next.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundaryBeziersToNext": () => (/* binding */ getBoundaryBeziersToNext)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n// qqq import { fromTo, fromTTo1, from0ToT } from \'flo-bezier3\';\r\n\r\n/**\r\n * Returns the ordered bezier curves from this CpNode to the next CpNode\r\n * on the boundary.\r\n * @param cpNode\r\n */\r\nfunction getBoundaryBeziersToNext(cpNode) {\r\n    let cpThis = cpNode;\r\n    let cpNext = cpNode.next;\r\n    let posThis = cpThis.cp.pointOnShape;\r\n    let posNext = cpNext.cp.pointOnShape;\r\n    let curveThis = posThis.curve;\r\n    let curveNext = posNext.curve;\r\n    if (curveThis.loop !== curveNext.loop) {\r\n        // It is a hole-closer going over to the other loop - a kind of terminal\r\n        // CpNode.\r\n        return undefined;\r\n    }\r\n    let beziers = [];\r\n    if (curveNext === curveThis) {\r\n        beziers.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(posThis.curve.ps, posThis.t, posNext.t));\r\n    }\r\n    else {\r\n        beziers.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(posThis.curve.ps, posThis.t, 1));\r\n        addSkippedBeziers(beziers, posThis.curve, posNext.curve, posNext.t);\r\n    }\r\n    return beziers;\r\n}\r\n/**\r\n * Adds pieces of skipped beziers.\r\n * @hidden\r\n */\r\nfunction addSkippedBeziers(beziers, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        beziers.push(\r\n        // qqq from0ToT(curveThis.ps, tEnd) \r\n        (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(curveThis.ps, 0, tEnd));\r\n    } while (curveThis !== curveEnd);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-boundary-beziers-to-next.ts?')},"./src/get-bounding-box-.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundingBox_": () => (/* binding */ getBoundingBox_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n\r\n\r\nconst getBoundingBox_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingBox);\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-bounding-box-.ts?')},"./src/get-branches.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBranches": () => (/* binding */ getBranches)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n\r\n\r\n\r\n/** @hidden */\r\nconst defaultTolerance = 1; // 1 degree\r\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]). Returns the result as an array of\r\n * smooth branches, where smoothness is total or within a given tolerance.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param tolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required.\r\n */\r\nfunction getBranches(cpNode, tolerance = defaultTolerance) {\r\n    // Start from a leaf\r\n    while (!cpNode.isFullyTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = [];\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = [cpNode.prevOnCircle];\r\n    let branchCpNodes = [];\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        branchCpNodes.push(cp);\r\n        let children = cp.getChildren();\r\n        if (cp.isFullyTerminating()) {\r\n            if (branchCpNodes.length > 1) {\r\n                branches.push(branchCpNodes);\r\n            }\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length === 1) {\r\n            cps.push(children[0]);\r\n            continue;\r\n        }\r\n        children = children.filter(cpNode => !cpNode.isTerminating());\r\n        if (children.length === 0) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            continue;\r\n        }\r\n        if (children.length > 1) {\r\n            // More than one branch comes together\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n            cps.push(...children);\r\n            continue;\r\n        }\r\n        let backPointingTan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.tangent)((0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(cp.next.prevOnCircle), 0));\r\n        let forwardPointingTan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.tangent)((0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(children[0]), 0));\r\n        let cross_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.cross)(backPointingTan, forwardPointingTan);\r\n        let angle = Math.abs(Math.asin(cross_) * (180 / Math.PI));\r\n        if (angle > tolerance) {\r\n            branches.push(branchCpNodes);\r\n            branchCpNodes = [];\r\n        }\r\n        cps.push(children[0]);\r\n    }\r\n    if (branchCpNodes.length) {\r\n        branches.push(branchCpNodes);\r\n    }\r\n    return branches;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-branches.ts?')},"./src/get-curve-to-next.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCurveToNext": () => (/* binding */ getCurveToNext)\n/* harmony export */ });\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-curve/get-curve-between.js */ "./src/get-curve/get-curve-between.ts");\n\r\n/**\r\n * Returns the bezier curve from the maximal disk of the given [[CpNode]] to the\r\n * next [[CpNode]]\'s maximal disk and thus directly represents a piece of the\r\n * medial axis.\r\n * @param cpNode\r\n */\r\nfunction getCurveToNext(cpNode) {\r\n    return (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_0__.getCurveBetween)(cpNode, cpNode.next);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-curve-to-next.ts?')},"./src/get-curve/get-curve-between.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCurveBetween": () => (/* binding */ getCurveBetween)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_edge_direction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-edge-direction.js */ "./src/get-curve/get-edge-direction.ts");\n\r\n\r\n/** @hidden */\r\nconst TOLERANCE_ADD_2PRONG = 0.01;\r\n/** @hidden */\r\nconst TOLERANCE_USE_LINE = 0.0001; // else cubic\r\n/**\r\n * Returns the bezier curve from the maximal disk of one [[CpNode]] to another\r\n * [[CpNode]]\'s maximal disk.\r\n * @param cpNodeFrom\r\n * @param cpNodeTo\r\n */\r\nfunction getCurveBetween(cpNodeFrom, cpNodeTo) {\r\n    let fromCc = cpNodeFrom.cp.circle.center;\r\n    let fromL = (0,_get_edge_direction_js__WEBPACK_IMPORTED_MODULE_1__.getEdgeDirection)(cpNodeFrom);\r\n    let toCc = cpNodeTo.cp.circle.center;\r\n    let toL = (0,_get_edge_direction_js__WEBPACK_IMPORTED_MODULE_1__.getEdgeDirection)(cpNodeTo.prevOnCircle);\r\n    let mid = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.lineLineIntersection)(fromL, toL);\r\n    let c = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(fromCc, toCc);\r\n    let twisted;\r\n    if (!mid) {\r\n        twisted = true;\r\n    }\r\n    else {\r\n        let a = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(fromCc, mid);\r\n        let b = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(toCc, mid);\r\n        twisted = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(a, c) < 0 || (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(b, c) > 0;\r\n    }\r\n    if (!twisted) {\r\n        return [fromCc, mid, toCc];\r\n    }\r\n    let r = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate90Degrees)(c);\r\n    let w1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(fromL[0], fromL[1]); // This is a unit vector\r\n    let w2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(toL[0], toL[1]); // This is a unit vector\r\n    let d1 = Math.abs((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.cross)(c, w1)) / (3 * 3);\r\n    let d2 = Math.abs((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.cross)(c, w2)) / (3 * 3);\r\n    if (d1 > TOLERANCE_ADD_2PRONG || d2 > TOLERANCE_ADD_2PRONG) {\r\n        // TODO - not within tolerance - must add additional 2-prong\r\n        return [fromCc, toCc];\r\n    }\r\n    if (d1 > TOLERANCE_USE_LINE || d2 > TOLERANCE_USE_LINE) {\r\n        // approximate with cubic bezier\r\n        let m1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.interpolate)(fromCc, toCc, 1 / 3);\r\n        let m2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.interpolate)(fromCc, toCc, 2 / 3);\r\n        let v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(r, m1);\r\n        let v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(r, m2);\r\n        let l1 = [m1, v1];\r\n        let l2 = [m2, v2];\r\n        let mid1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.lineLineIntersection)(fromL, l1);\r\n        let mid2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.lineLineIntersection)(toL, l2);\r\n        return [fromCc, mid1, mid2, toCc];\r\n    }\r\n    // Within tolerance - approximate with a straight line.\r\n    return [fromCc, toCc];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-curve/get-curve-between.ts?')},"./src/get-curve/get-edge-direction.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getEdgeDirection": () => (/* binding */ getEdgeDirection)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Returns a line segment of unit length starting in the given Vertex center and\r\n * pointing in the direction of the medial axis (viewed as a rooted tree).\r\n * @param cpNode\r\n */\r\nfunction getEdgeDirection(cpNode) {\r\n    let circleCenter = cpNode.cp.circle.center;\r\n    let cp1 = cpNode;\r\n    let cp2 = cpNode.nextOnCircle;\r\n    let pos1 = cp1.cp.pointOnShape;\r\n    let pos2 = cp2.cp.pointOnShape;\r\n    let p1 = pos1.p;\r\n    let p2 = pos2.p;\r\n    let vDir;\r\n    //if (!PointOnShape.isSharpCorner(pos1)) {\r\n    if (!(0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.isPosSharpCorner)(pos1)) {\r\n        if (p1[0] === p2[0] && p1[1] === p2[1]) {\r\n            vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(p1, circleCenter); // A 1-prong\r\n        }\r\n        else {\r\n            vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate90Degrees)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(p1, p2)); // not a 1-prong.\r\n        }\r\n    }\r\n    else {\r\n        let curve1;\r\n        let curve2;\r\n        // TODO - test if pos1.t can ever be 0 - it is terminating\r\n        if (pos1.t === 0) {\r\n            curve1 = pos1.curve;\r\n            curve2 = pos1.curve.prev;\r\n        }\r\n        else if (pos1.t === 1) {\r\n            curve1 = pos1.curve.next;\r\n            curve2 = pos1.curve;\r\n        }\r\n        let tan1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangent)(curve1.ps, 0));\r\n        let tan2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.reverse)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangent)(curve2.ps, 1)));\r\n        let x = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(tan1, tan2);\r\n        // Recall the identities sin(acos(x)) = sqrt(1-x^2), etc. Also \r\n        // recall the half angle formulas. Then the rotation matrix, R, can \r\n        // be calculated.\r\n        let cosθ = Math.sqrt((1 + x) / 2);\r\n        let sinθ = Math.sqrt((1 - x) / 2);\r\n        vDir = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate)(sinθ, cosθ, tan2);\r\n    }\r\n    let v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)(vDir), circleCenter);\r\n    return [circleCenter, v];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-curve/get-edge-direction.ts?')},"./src/get-interface-ccw.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInterfaceCcw": () => (/* binding */ getInterfaceCcw)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _compare_curvatures_at_interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compare-curvatures-at-interface.js */ "./src/compare-curvatures-at-interface.ts");\n\r\n\r\n\r\n/**\r\n * Returns a positive value if the second bezier (of order 1, 2 or 3) curves\r\n * anti-clockwise with respect to the first at the point where the first bezier\r\n * ends and the second one starts. Returns a negative number if the turn is\r\n * clockwise. Returns 0 otherwise.\r\n *\r\n * The algorithm is a generalization of `ccw`, a.k.a `orient2d`.\r\n *\r\n * The above obviously necessitates that their endpoints coincide as described.\r\n *\r\n * Preconditions (for robustness):\r\n * * The beziers has control points with max bit-length of 25 and bit-aligned.\r\n * * The bezier does not have infinite curvature at either endpoint\r\n *\r\n * This is so the vectors between control points can be\r\n * calculated exactly without resorting to adaptive infinite precision floating\r\n * point operations. Note: aligned to \'grid\' here means if you bitwise-and all\r\n * values together the resulting bitlength === the max bithlength of any value.\r\n *\r\n * @param psI The incoming bezier that ends at the interface\r\n * @param psO The outgoing bezier that starts at the interface\r\n */\r\n// TODO - improve and make at least 46-bitlength precondition\r\nfunction getInterfaceCcw(psI, psO) {\r\n    let lenI = psI.length;\r\n    // second last control point of incoming curve\r\n    let p0 = psI[lenI - 2];\r\n    // last control point of incoming curve / first control point of outgoing\r\n    let p1 = psO[0];\r\n    // second control point of outgoing curve\r\n    let p2 = psO[1];\r\n    /*\r\n    if (typeof _bez_debug_ !== \'undefined\') {\r\n        let maxBitLength = 25;\r\n        let p1_ = psI[lenI-1];\r\n        // ---- precondition: does endpoints coincide\r\n        if (p1_[0] !== p1[0] || p1_[1] !== p1[1]) {\r\n            throw new Error(\'Curve endpoints must coincide.\');\r\n        }\r\n        // ---- precondition: are coordinates grid-aligned\r\n        // Get all coordinate values into an array\r\n        let xs: number[] = [];\r\n        [psI, psO].forEach(ps => ps.forEach(p => p.forEach(x => {\r\n            xs.push(x);\r\n        })));\r\n        \r\n        let msb = xs.reduce((prevX, x) => Math.max(prevX, msbExponent(x)), Number.NEGATIVE_INFINITY);\r\n        let lsb = xs.reduce((prevX, x) => Math.min(prevX, lsbExponent(x)), Number.POSITIVE_INFINITY);\r\n        let bitlengthAll = msb - lsb + 1;\r\n        if (bitlengthAll > maxBitLength) {\r\n            throw new Error(\r\n                `Curve control point coordinates must be bit-aligned and <= ${maxBitLength}. bitlength === ${bitlengthAll}, coordinates: ${xs}`\r\n            );\r\n        }\r\n    }\r\n    */\r\n    // Max one bit can be added in the calculations below due to bit-alignment\r\n    let xE = p1[0] - p0[0]; // tangent x-coordinate\r\n    let yE = p1[1] - p0[1]; // tangent y-coordinate\r\n    let xS = p2[0] - p1[0]; // tangent x-coordinate\r\n    let yS = p2[1] - p1[1]; // tangent y-coordinate\r\n    // If the tangent is to be found at t === 0 or t === 1 then using a basic \r\n    // property of bezier curves we can find the tangents easily as below\r\n    // (non-normalized) tangent of incoming curve at t === 1\r\n    let tangentAtEnd = [xE, yE];\r\n    // (non-normalized) tangent of outgoing curve at t === 0\r\n    let tangentAtStart = [xS, yS];\r\n    // The cross calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    //let crossTangents = cross(tangentAtEnd, tangentAtStart);\r\n    // The cross below is exact by adaptive infinite precision\r\n    let crossTangents = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(p0, p1, p2);\r\n    if (crossTangents !== 0) {\r\n        return crossTangents;\r\n    }\r\n    // The dot calculated below will have a max bitlength of \r\n    // (2*(maxBitLength+1))+1 === e.g. (2*(25+1)) + 1 === 53\r\n    // If the preconditions are met it is exact\r\n    let dotTangents = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.dot)(tangentAtEnd, tangentAtStart);\r\n    if (dotTangents > 0) {\r\n        // Curves go in same direction at interface - neither clock or \r\n        // anti-clockwise.\r\n        // Note: The above comment is not strictly true but as this case is not\r\n        // important for the algorithm we return 0\r\n        return 0;\r\n    }\r\n    // Curves go in opposite directions at interface starting off with the exact\r\n    // same tangent - look now at curvature to see which has the largest \r\n    // curvature so we can base the clock or anti-clockwise result on that\r\n    // Look at curvature\r\n    return (0,_compare_curvatures_at_interface_js__WEBPACK_IMPORTED_MODULE_2__.compareCurvaturesAtInterface)(psI.slice().reverse(), psO);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/get-interface-ccw.ts?')},"./src/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "CpNode": () => (/* reexport safe */ _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode),\n/* harmony export */   "PointOnShape": () => (/* reexport safe */ _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape),\n/* harmony export */   "beziersToSvgPathStr": () => (/* reexport safe */ flo_boolean__WEBPACK_IMPORTED_MODULE_0__.beziersToSvgPathStr),\n/* harmony export */   "drawBranch": () => (/* reexport safe */ _debug_functions_draw_elem_branch_js__WEBPACK_IMPORTED_MODULE_10__.drawBranch),\n/* harmony export */   "drawElemFunctions": () => (/* reexport safe */ _debug_functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_19__.drawElemFunctions),\n/* harmony export */   "drawMat": () => (/* reexport safe */ _debug_functions_draw_elem_mat_js__WEBPACK_IMPORTED_MODULE_11__.drawMat),\n/* harmony export */   "enableDebugForMat": () => (/* reexport safe */ _debug_debug_js__WEBPACK_IMPORTED_MODULE_9__.enableDebugForMat),\n/* harmony export */   "findMats": () => (/* reexport safe */ _find_mats_js__WEBPACK_IMPORTED_MODULE_3__.findMats),\n/* harmony export */   "getBoundaryBezierPartsToNext": () => (/* reexport safe */ _get_boundary_bezier_parts_to_next_js__WEBPACK_IMPORTED_MODULE_15__.getBoundaryBezierPartsToNext),\n/* harmony export */   "getBoundaryBeziersToNext": () => (/* reexport safe */ _get_boundary_beziers_to_next_js__WEBPACK_IMPORTED_MODULE_14__.getBoundaryBeziersToNext),\n/* harmony export */   "getBoundaryPieceBeziers": () => (/* reexport safe */ _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_16__.getBoundaryPieceBeziers),\n/* harmony export */   "getBranches": () => (/* reexport safe */ _get_branches_js__WEBPACK_IMPORTED_MODULE_7__.getBranches),\n/* harmony export */   "getClosestBoundaryPoint": () => (/* reexport safe */ _mat_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_12__.getClosestBoundaryPoint),\n/* harmony export */   "getClosestSquareDistanceToRect": () => (/* reexport safe */ _mat_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_23__.getClosestSquareDistanceToRect),\n/* harmony export */   "getCurveBetween": () => (/* reexport safe */ _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_21__.getCurveBetween),\n/* harmony export */   "getCurveToNext": () => (/* reexport safe */ _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_20__.getCurveToNext),\n/* harmony export */   "getPathsFromStr": () => (/* reexport safe */ flo_boolean__WEBPACK_IMPORTED_MODULE_0__.getPathsFromStr),\n/* harmony export */   "getShapeBounds": () => (/* reexport safe */ _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_13__.getShapeBounds),\n/* harmony export */   "loopFromBeziers": () => (/* reexport safe */ _loop_js__WEBPACK_IMPORTED_MODULE_24__.loopFromBeziers),\n/* harmony export */   "simplifyMat": () => (/* reexport safe */ _simplify_mat_js__WEBPACK_IMPORTED_MODULE_17__.simplifyMat),\n/* harmony export */   "simplifyMatMapOnly": () => (/* reexport safe */ _mat_simplify_mat_map_only_js__WEBPACK_IMPORTED_MODULE_18__.simplifyMatMapOnly),\n/* harmony export */   "sweepLine": () => (/* reexport safe */ _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_22__.sweepLine),\n/* harmony export */   "toScaleAxis": () => (/* reexport safe */ _to_scale_axis_js__WEBPACK_IMPORTED_MODULE_5__.toScaleAxis),\n/* harmony export */   "traverseEdges": () => (/* reexport safe */ _traverse_edges_js__WEBPACK_IMPORTED_MODULE_6__.traverseEdges),\n/* harmony export */   "traverseVertices": () => (/* reexport safe */ _traverse_vertices_js__WEBPACK_IMPORTED_MODULE_8__.traverseVertices),\n/* harmony export */   "trimMat": () => (/* reexport safe */ _mat_trim_mat_js__WEBPACK_IMPORTED_MODULE_4__.trimMat)\n/* harmony export */ });\n/* harmony import */ var flo_boolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-boolean */ "./node_modules/flo-boolean/node/index.js");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp-node.js */ "./src/cp-node.ts");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _find_mats_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./find-mats.js */ "./src/find-mats.ts");\n/* harmony import */ var _mat_trim_mat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat/trim-mat.js */ "./src/mat/trim-mat.ts");\n/* harmony import */ var _to_scale_axis_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./to-scale-axis.js */ "./src/to-scale-axis.ts");\n/* harmony import */ var _traverse_edges_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./traverse-edges.js */ "./src/traverse-edges.ts");\n/* harmony import */ var _get_branches_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-branches.js */ "./src/get-branches.ts");\n/* harmony import */ var _traverse_vertices_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./traverse-vertices.js */ "./src/traverse-vertices.ts");\n/* harmony import */ var _debug_debug_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./debug/debug.js */ "./src/debug/debug.ts");\n/* harmony import */ var _debug_functions_draw_elem_branch_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./debug/functions/draw-elem/branch.js */ "./src/debug/functions/draw-elem/branch.ts");\n/* harmony import */ var _debug_functions_draw_elem_mat_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./debug/functions/draw-elem/mat.js */ "./src/debug/functions/draw-elem/mat.ts");\n/* harmony import */ var _mat_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mat/closest-boundary-point/get-closest-boundary-point.js */ "./src/mat/closest-boundary-point/get-closest-boundary-point.ts");\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./svg/get-shape-bounds.js */ "./src/svg/get-shape-bounds.ts");\n/* harmony import */ var _get_boundary_beziers_to_next_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./get-boundary-beziers-to-next.js */ "./src/get-boundary-beziers-to-next.ts");\n/* harmony import */ var _get_boundary_bezier_parts_to_next_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./get-boundary-bezier-parts-to-next.js */ "./src/get-boundary-bezier-parts-to-next.ts");\n/* harmony import */ var _mat_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./mat/get-boundary-piece-beziers.js */ "./src/mat/get-boundary-piece-beziers.ts");\n/* harmony import */ var _simplify_mat_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./simplify-mat.js */ "./src/simplify-mat.ts");\n/* harmony import */ var _mat_simplify_mat_map_only_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./mat/simplify-mat-map-only.js */ "./src/mat/simplify-mat-map-only.ts");\n/* harmony import */ var _debug_functions_draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./debug/functions/draw-elem/draw-elem.js */ "./src/debug/functions/draw-elem/draw-elem.ts");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./get-curve/get-curve-between.js */ "./src/get-curve/get-curve-between.ts");\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sweep-line/sweep-line.js */ "./src/sweep-line/sweep-line.ts");\n/* harmony import */ var _mat_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mat/geometry/get-closest-square-distance-to-rect.js */ "./src/mat/geometry/get-closest-square-distance-to-rect.ts");\n/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./loop.js */ "./src/loop.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/index.ts?')},"./src/loop.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "loopFromBeziers": () => (/* binding */ loopFromBeziers)\n/* harmony export */ });\n/**\r\n * @param beziers A pre-ordered array of bezier curves to add initially.\r\n */\r\nfunction loopFromBeziers(beziers = []) {\r\n    let curves = [];\r\n    let loop = {\r\n        beziers,\r\n        curves\r\n    };\r\n    if (!beziers.length) {\r\n        return loop;\r\n    }\r\n    let prev;\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let curve = {\r\n            loop,\r\n            ps: beziers[i],\r\n            prev,\r\n            next: undefined,\r\n            idx: i\r\n        };\r\n        if (prev) {\r\n            prev.next = curve;\r\n        }\r\n        prev = curve;\r\n        curves.push(curve);\r\n    }\r\n    // close loop\r\n    let lastCurve = curves[curves.length - 1];\r\n    curves[0].prev = lastCurve;\r\n    lastCurve.next = curves[0];\r\n    return loop;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/loop.ts?')},"./src/loop/get-max-coordinate.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopsMetrics": () => (/* binding */ getLoopsMetrics)\n/* harmony export */ });\nconst max = Math.max;\r\nconst abs = Math.abs;\r\n/**\r\n * @hidden\r\n * Returns the maximum control point coordinate value (x or y) within any loop.\r\n * @param loops The array of loops\r\n */\r\nfunction getLoopsMetrics(loops) {\r\n    let maxCoordinate = 0;\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (let loop of loops) {\r\n        for (let ps of loop) {\r\n            for (let p of ps) {\r\n                let x = p[0];\r\n                let y = p[1];\r\n                let c = max(abs(x), abs(y));\r\n                if (c > maxCoordinate) {\r\n                    maxCoordinate = c;\r\n                }\r\n                if (x < minX) {\r\n                    minX = x;\r\n                }\r\n                if (x > maxX) {\r\n                    maxX = x;\r\n                }\r\n                if (y < minY) {\r\n                    minY = y;\r\n                }\r\n                if (y > maxY) {\r\n                    maxY = y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let width = maxX - minX;\r\n    let height = maxY - minY;\r\n    let maxRadius = max(width, height);\r\n    return { maxCoordinate, maxRadius };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/loop/get-max-coordinate.ts?')},"./src/mat/add-to-cp-graph.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "addToCpGraph": () => (/* binding */ addToCpGraph)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node.js */ "./src/cp-node.ts");\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-neighboring-cps.js */ "./src/mat/get-neighboring-cps.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * @param circle\r\n * @param orders\r\n * @param cpTrees\r\n * @param poss\r\n * @param neighbors\r\n * @hidden\r\n */\r\nfunction addToCpGraph(circle, orders, cpTrees, poss, neighbors) {\r\n    let newCps = poss.map((pos, i) => {\r\n        let cpTree = cpTrees.get(pos.curve.loop);\r\n        let newCp_ = { pointOnShape: pos, circle, order: orders[i], order2: 0 };\r\n        let neighboringCp = neighbors\r\n            ? neighbors[i]\r\n            : (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_1__.getNeighbouringPoints)(cpTree, pos, orders[i], 0);\r\n        let newCp = _cp_node_js__WEBPACK_IMPORTED_MODULE_0__.CpNode.insert(false, false, cpTree, newCp_, neighboringCp[0]);\r\n        return newCp;\r\n    });\r\n    let len = poss.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let indxPrev = i === 0 ? len - 1 : i - 1;\r\n        let indxNext = i === len - 1 ? 0 : i + 1;\r\n        newCps[i].prevOnCircle = newCps[indxPrev];\r\n        newCps[i].nextOnCircle = newCps[indxNext];\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/add-to-cp-graph.ts?')},"./src/mat/closest-boundary-point/closest-points-on-curve.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closestPointsOnCurve\": () => (/* binding */ closestPointsOnCurve)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n// qqq import { deflateQuad, allRootsMultiWithErrBounds, RootInterval } from 'flo-poly';\r\n// qqq import { getTangentPolyFromPointExact, evalDeCasteljau, evaluate, getFootpointPolyExact } from 'flo-bezier3';\r\n\r\n\r\n/**\r\n * @hidden\r\n * @param curve The curve\r\n * @param p The point from which to check\r\n * @param tRange The allowed t range\r\n * @param touchedCurve The bezier on which p is located\r\n * @param t The t value of the bezier that locates p\r\n */\r\nfunction closestPointsOnCurve(curve, p, [tS, tE] = [0, 1], touchedCurve, t) {\r\n    // qqq let poly = getTangentPolyFromPointExact(curve.ps, p);\r\n    const _poly = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getFootpointPolyDd)(curve.ps, p);\r\n    // qqq poly = deflateQuad(poly, t);\r\n    const poly = curve === touchedCurve\r\n        ? (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.ddDeflate)(_poly, t)\r\n        : _poly;\r\n    // let roots: Omit<RootInterval,'multiplicity'>[] = allRootsMultiWithErrBounds(\r\n    let roots;\r\n    roots = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(poly, tS, tE);\r\n    // Also test the endpoints\r\n    let push0 = true;\r\n    let push1 = true;\r\n    if ((t === 1 && curve === touchedCurve.next) ||\r\n        (t === 0 && curve === touchedCurve)) {\r\n        push0 = false;\r\n    }\r\n    if ((t === 0 && curve === touchedCurve.prev) ||\r\n        (t === 1 && curve === touchedCurve)) {\r\n        push1 = false;\r\n    }\r\n    if (tS === 0) {\r\n        if (push0) {\r\n            roots.push({ tS: 0, tE: 0 });\r\n        }\r\n    }\r\n    else if (tS === 1) {\r\n        if (push1) {\r\n            roots.push({ tS: 1, tE: 1 });\r\n        }\r\n    }\r\n    else {\r\n        roots.push({ tS: tS, tE: tS });\r\n    }\r\n    if (tE === 0) {\r\n        if (push0) {\r\n            roots.push({ tS: 0, tE: 0 });\r\n        }\r\n    }\r\n    else if (tE === 1) {\r\n        if (push1) {\r\n            roots.push({ tS: 1, tE: 1 });\r\n        }\r\n    }\r\n    else {\r\n        roots.push({ tS: tE, tE: tE });\r\n    }\r\n    let ps = roots.map(root => {\r\n        let tS = root.tS;\r\n        let tE = root.tE;\r\n        // TODO - tS, tE should always stay within [0,1] - modify findRootsMulti\r\n        let t = tS < 0\r\n            ? 0\r\n            : tE > 1 ? 1 : (tS + tE) / 2;\r\n        // TODO - why does evalDeCasteljau not work here?\r\n        return { p: (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evaluate)(curve.ps, t), t };\r\n        //return { p: evalDeCasteljau(curve.ps,t), t }\r\n    });\r\n    return ps;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/closest-points-on-curve.ts?")},"./src/mat/closest-boundary-point/cull-bezier-pieces.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cullBezierPieces": () => (/* binding */ cullBezierPieces)\n/* harmony export */ });\n/* harmony import */ var _get_best_distance_squared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-best-distance-squared.js */ "./src/mat/closest-boundary-point/get-best-distance-squared.ts");\n/* harmony import */ var _cull_by_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cull-by-loose-bounding-box.js */ "./src/mat/closest-boundary-point/cull-by-loose-bounding-box.ts");\n/* harmony import */ var _cull_by_tight_boundary_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cull-by-tight-boundary-box.js */ "./src/mat/closest-boundary-point/cull-by-tight-boundary-box.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * @param bezierPieces\r\n * @param p\r\n * @param extreme\r\n */\r\nfunction cullBezierPieces(bezierPieces, p) {\r\n    const CULL_THRESHOLD = 0;\r\n    if (bezierPieces.length > CULL_THRESHOLD) {\r\n        let bestSquaredDistance = (0,_get_best_distance_squared_js__WEBPACK_IMPORTED_MODULE_0__.getBestDistanceSquared)(bezierPieces, p);\r\n        bezierPieces = (0,_cull_by_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.cullByLooseBoundingBox)(bezierPieces, p, bestSquaredDistance);\r\n        bezierPieces = (0,_cull_by_tight_boundary_box_js__WEBPACK_IMPORTED_MODULE_2__.cullByTightBoundingBox)(bezierPieces, p, bestSquaredDistance);\r\n    }\r\n    return bezierPieces;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/cull-bezier-pieces.ts?')},"./src/mat/closest-boundary-point/cull-by-loose-bounding-box.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cullByLooseBoundingBox": () => (/* binding */ cullByLooseBoundingBox)\n/* harmony export */ });\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../get-bounding-box-.js */ "./src/get-bounding-box-.ts");\n/* harmony import */ var _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/get-closest-square-distance-to-rect.js */ "./src/mat/geometry/get-closest-square-distance-to-rect.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than \'bestSquaredDistance\', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param dSquared\r\n */\r\nfunction cullByLooseBoundingBox(bezierPieces, p, dSquared) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let boundingBox = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_0__.getBoundingBox_)(ps);\r\n        let d = (0,_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_1__.getClosestSquareDistanceToRect)(boundingBox, p);\r\n        if (d <= dSquared) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/cull-by-loose-bounding-box.ts?')},"./src/mat/closest-boundary-point/cull-by-tight-boundary-box.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cullByTightBoundingBox": () => (/* binding */ cullByTightBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var _geometry_get_closest_squared_distance_to_rotated_rect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/get-closest-squared-distance-to-rotated-rect.js */ "./src/mat/geometry/get-closest-squared-distance-to-rotated-rect.ts");\n\r\n\r\n\r\nconst getBoundingBoxTight_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingBoxTight);\r\n/**\r\n * @hidden\r\n * When checking distances, ignore all those with closest possible distance\r\n * further than \'bestSquaredDistance\', i.e. cull them.\r\n * @param bezierPieces\r\n * @param p\r\n * @param bestSquaredDistance\r\n */\r\nfunction cullByTightBoundingBox(bezierPieces, p, bestSquaredDistance) {\r\n    let candidateBezierPieces = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let tightBoundingBox = getBoundingBoxTight_(ps);\r\n        let d = (0,_geometry_get_closest_squared_distance_to_rotated_rect_js__WEBPACK_IMPORTED_MODULE_2__.getClosestSquaredDistanceToRotatedRect)(tightBoundingBox, p);\r\n        if (d <= bestSquaredDistance) {\r\n            candidateBezierPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return candidateBezierPieces;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/cull-by-tight-boundary-box.ts?')},"./src/mat/closest-boundary-point/get-best-distance-squared.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBestDistanceSquared": () => (/* binding */ getBestDistanceSquared)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n\r\n/**\r\n * @hidden\r\n * Finds an initial distance such that the closest point can not be further than\r\n * this distance away.\r\n */\r\nfunction getBestDistanceSquared(bezierPieces, p) {\r\n    let bestSquaredDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let p1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[0]);\r\n        let p2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, bezierPiece.ts[1]);\r\n        let d = Math.min((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, p1), (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.squaredDistanceBetween)(p, p2));\r\n        if (d < bestSquaredDistance) {\r\n            bestSquaredDistance = d;\r\n        }\r\n    }\r\n    // The extra multiplier is to account for floating point precision.\r\n    // TODO - remove delta (or base it on theory)\r\n    return bestSquaredDistance * 1.01;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/get-best-distance-squared.ts?')},"./src/mat/closest-boundary-point/get-close-boundary-points.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCloseBoundaryPoints": () => (/* binding */ getCloseBoundaryPoints)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ "./src/mat/closest-boundary-point/cull-bezier-pieces.ts");\n/* harmony import */ var _closest_points_on_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closest-points-on-curve.js */ "./src/mat/closest-boundary-point/closest-points-on-curve.ts");\n\r\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getCloseBoundaryPoints(bezierPieces, point, y, distance) {\r\n    let touchedCurve = y.curve;\r\n    let t = y.t;\r\n    let p_ = y.p;\r\n    bezierPieces = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_2__.cullBezierPieces)(bezierPieces, point);\r\n    // TODO - integrate with is-another-cp-closeby - we MUST check angle too!\r\n    let DISTANCE_TOLERANCE = 1e-9;\r\n    let posInfos = [];\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        // TOOD - important - should be able to return multiple points\r\n        let ps = (0,_closest_points_on_curve_js__WEBPACK_IMPORTED_MODULE_3__.closestPointsOnCurve)(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        //if (ps === undefined) { continue; }\r\n        for (let j = 0; j < ps.length; j++) {\r\n            let p = ps[j];\r\n            let d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p.p, point);\r\n            let curve = bezierPiece.curve;\r\n            let t_ = p.t;\r\n            if (Math.abs(d - distance) < DISTANCE_TOLERANCE) {\r\n                if (t_ === 0) {\r\n                    t_ = 1;\r\n                    curve = bezierPiece.curve.prev;\r\n                }\r\n                posInfos.push({ pos: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(curve, t_), d });\r\n            }\r\n        }\r\n    }\r\n    if (posInfos.length > 1) {\r\n        // Remove ones that are too close together.\r\n        // TODO - in future remove all these checks and join n-prongs when they\r\n        // are being added - much simpler and more symmetric. Remeber order when\r\n        // comparing closeness!\r\n        let indexesToCheck = [];\r\n        for (let i = 0; i < posInfos.length; i++) {\r\n            let pi = posInfos[i];\r\n            // Only check if they are close to the edges. Why??\r\n            //if (pi.pos.t < 1e-2 || 1-pi.pos.t < 1e-2) {\r\n            indexesToCheck.push(i);\r\n            //}\r\n        }\r\n        let indexesToRemove = [];\r\n        for (let i = 0; i < indexesToCheck.length; i++) {\r\n            for (let j = i + 1; j < indexesToCheck.length; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n                let p1 = posInfos[indexesToCheck[i]].pos.p;\r\n                let p2 = posInfos[indexesToCheck[j]].pos.p;\r\n                // Below checks for source point too - similar to \r\n                // isAnotherCpCloseBy\r\n                let p3 = p_;\r\n                if ((Math.abs(p1[0] - p2[0]) < 1e-6 &&\r\n                    Math.abs(p1[1] - p2[1]) < 1e-6) ||\r\n                    (Math.abs(p1[0] - p3[0]) < 1e-6 &&\r\n                        Math.abs(p1[1] - p3[1]) < 1e-6)) {\r\n                    indexesToRemove.push(indexesToCheck[i]);\r\n                }\r\n            }\r\n        }\r\n        for (let i = indexesToRemove.length - 1; i >= 0; i--) {\r\n            posInfos.splice(indexesToRemove[i], 1);\r\n        }\r\n    }\r\n    return posInfos;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/get-close-boundary-points.ts?')},"./src/mat/closest-boundary-point/get-closest-boundary-point.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getClosestBoundaryPoint": () => (/* binding */ getClosestBoundaryPoint)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ "./src/mat/closest-boundary-point/cull-bezier-pieces.ts");\n/* harmony import */ var _closest_points_on_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closest-points-on-curve.js */ "./src/mat/closest-boundary-point/closest-points-on-curve.ts");\n\r\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Returns the closest boundary point to the given point, limited to the given\r\n * bezier pieces, including the beziers actually checked after culling.\r\n * @param bezierPieces\r\n * @param point\r\n * @param touchedCurve\r\n * @param t\r\n * @param extreme\r\n */\r\nfunction getClosestBoundaryPoint(bezierPieces, point, touchedCurve, t) {\r\n    bezierPieces = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_2__.cullBezierPieces)(bezierPieces, point);\r\n    let bestDistance = Number.POSITIVE_INFINITY;\r\n    let posInfo;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = (0,_closest_points_on_curve_js__WEBPACK_IMPORTED_MODULE_3__.closestPointsOnCurve)(bezierPiece.curve, point, bezierPiece.ts, touchedCurve, t);\r\n        let p = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.getObjClosestTo)(point, ps, p => p.p);\r\n        if (p === undefined) {\r\n            continue;\r\n        }\r\n        let d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p.p, point);\r\n        let curve = bezierPiece.curve;\r\n        let t_ = p.t;\r\n        if (d < bestDistance) {\r\n            if (t_ === 0) {\r\n                t_ = 1;\r\n                curve = bezierPiece.curve.prev;\r\n            }\r\n            posInfo = { pos: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(curve, t_), d };\r\n            bestDistance = d;\r\n        }\r\n    }\r\n    return posInfo;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/closest-boundary-point/get-closest-boundary-point.ts?')},"./src/mat/create-new-cp-tree.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createNewCpTree": () => (/* binding */ createNewCpTree)\n/* harmony export */ });\n/* harmony import */ var flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-ll-rb-tree */ "./node_modules/flo-ll-rb-tree/node/index.js");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cp-node.js */ "./src/cp-node.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * @param cpNode\r\n */\r\nfunction createNewCpTree(cpNode) {\r\n    let newCpTrees = new Map();\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(f);\r\n    function f(cpNode) {\r\n        let loop = cpNode.cp.pointOnShape.curve.loop;\r\n        let cpTree = newCpTrees.get(loop);\r\n        if (!cpTree) {\r\n            // qqq cpTree = new LlRbTree(CpNode.comparator, [], true); \r\n            cpTree = new flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__.LlRbTree(_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.comparator, false);\r\n            newCpTrees.set(loop, cpTree);\r\n        }\r\n        cpTree.insert(cpNode);\r\n    }\r\n    return newCpTrees;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/create-new-cp-tree.ts?')},"./src/mat/find-mat/add-1-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "add1Prong": () => (/* binding */ add1Prong)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../add-to-cp-graph.js */ "./src/mat/add-to-cp-graph.ts");\n/* harmony import */ var _is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../is-another-cp-closeby.js */ "./src/mat/is-another-cp-closeby.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Add a 1-prong to the MAT.\r\n * @param cpGraphs\r\n * @param pos\r\n */\r\nfunction add1Prong(maxOsculatingCircleRadius, cpGraphs, pos) {\r\n    //if (PointOnShape.isDullCorner(pos)) {\r\n    if ((0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosDullCorner)(pos)) {\r\n        // This is a 1-prong at a dull corner.\r\n        // TODO IMPORTANT \r\n        // Remove this line, uncomment piece below it and implement the \r\n        // following strategy to find the 3-prongs: if deltas are conjoined due \r\n        // to dull corner, split the conjoinment by inserting successively \r\n        // closer (binary division) 2-prongs. If a 2-prong actually fails, \r\n        // simply remove the 1-prong at the dull corner. In this way **all** \r\n        // terminal points are found, e.g. zoom in on top left leg of ant.\r\n        // Afterthought: there is a better way - split points by two prongs.\r\n        //toRemove.push(posNode); // this!\r\n        if (typeof _debug_ !== \'undefined\') {\r\n            _debug_.generated.elems.oneProngAtDullCorner.push(pos);\r\n        }\r\n        return;\r\n    }\r\n    //let circle = PointOnShape.getOsculatingCircle(maxOsculatingCircleRadius, pos);\r\n    let circle = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.getOsculatingCircle)(maxOsculatingCircleRadius, pos);\r\n    //let order = PointOnShape.calcOrder(circle, pos);\r\n    let order = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.calcPosOrder)(circle, pos);\r\n    // Make sure there isn\'t already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    if ((0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_2__.isAnotherCpCloseby)(cpGraphs, pos, circle, order, 0, 1000, \'magenta\')) {\r\n        return;\r\n    }\r\n    (0,_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_1__.addToCpGraph)(circle, [-0.5, +0.5], cpGraphs, [pos, pos]);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        _debug_.generated.elems.oneProng.push(pos);\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/add-1-prong.ts?')},"./src/mat/find-mat/add-2-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add2Prong\": () => (/* binding */ add2Prong)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../cp-node.js */ \"./src/cp-node.ts\");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../point-on-shape.js */ \"./src/point-on-shape.ts\");\n/* harmony import */ var _is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../is-another-cp-closeby.js */ \"./src/mat/is-another-cp-closeby.ts\");\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../get-neighboring-cps.js */ \"./src/mat/get-neighboring-cps.ts\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Adds a 2-prong contact circle to the shape.\r\n * @param cpGraphs\r\n * @param circle Circle containing the 2 contact points\r\n * @param posSource The source point on shape\r\n * @param posAntipode The found antipodal point on shape\r\n * @param holeClosing True if this is a hole-closing 2-prong, false otherwise\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction add2Prong(cpGraphs, circle, posSource, posAntipodes, holeClosing, extreme) {\r\n    //let orderSource   = PointOnShape.calcOrder(circle, posSource);\r\n    let orderSource = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.calcPosOrder)(circle, posSource);\r\n    let orderAntipodes = posAntipodes.map(posAntipode => {\r\n        //console.log(circle.center)\r\n        //return PointOnShape.calcOrder(circle, posAntipode.pos);\r\n        return (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.calcPosOrder)(circle, posAntipode.pos);\r\n    });\r\n    let t_s = posSource.t;\r\n    let curve;\r\n    if (t_s === 0) {\r\n        t_s = 1;\r\n        curve = posSource.curve.prev;\r\n        posSource = new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(curve, t_s);\r\n    }\r\n    // Make sure there isn't already a ContactPoint close by - it can cause\r\n    // floating point stability issues.\r\n    // TODO - possibly combine n-prongs in this case\r\n    let isCloseByAntipodes = false;\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        if ((0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_3__.isAnotherCpCloseby)(cpGraphs, posAntipode.pos, circle, orderAntipode, 0, extreme, 'red')) {\r\n            isCloseByAntipodes = true;\r\n            break;\r\n        }\r\n    }\r\n    if ((0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_3__.isAnotherCpCloseby)(cpGraphs, posSource, circle, orderSource, 0, extreme, 'red') ||\r\n        isCloseByAntipodes) {\r\n        if (typeof _debug_ !== 'undefined') {\r\n            if (holeClosing) {\r\n                _debug_.generated.elems['twoProng_holeClosing'].pop();\r\n            }\r\n            else {\r\n                _debug_.generated.elems['twoProng_regular'].pop();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    // Antipode\r\n    let newCpAntipodes = [];\r\n    let cpAntipodes = [];\r\n    let cpTreeAntipodes = [];\r\n    let deltaAntipodes = [];\r\n    let loopAntipodes = [];\r\n    for (let i = 0; i < posAntipodes.length; i++) {\r\n        let posAntipode = posAntipodes[i];\r\n        let orderAntipode = orderAntipodes[i];\r\n        let cpAntipode = { pointOnShape: posAntipode.pos, circle, order: orderAntipode, order2: 0 };\r\n        cpAntipodes.push(cpAntipode);\r\n        let loopAntipode = posAntipode.pos.curve.loop;\r\n        loopAntipodes.push(loopAntipode);\r\n        let cpTreeAntipode = cpGraphs.get(loopAntipode);\r\n        cpTreeAntipodes.push(cpTreeAntipode);\r\n        let deltaAntipode = (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_4__.getNeighbouringPoints)(cpTreeAntipode, posAntipode.pos, orderAntipode, 0);\r\n        deltaAntipodes.push(deltaAntipode);\r\n        newCpAntipodes.push(_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(holeClosing, false, cpTreeAntipode, cpAntipode, deltaAntipode[0]));\r\n    }\r\n    // Source\r\n    let cpSource = { pointOnShape: posSource, circle, order: orderSource, order2: 0 };\r\n    let loopSource = posSource.curve.loop;\r\n    let cpTreeSource = cpGraphs.get(loopSource);\r\n    let deltaSource = (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_4__.getNeighbouringPoints)(cpTreeSource, posSource, orderSource, 0);\r\n    let newCpSource = _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(holeClosing, false, cpTreeSource, cpSource, deltaSource[0]);\r\n    // Connect graph\r\n    if (newCpAntipodes.length === 1) {\r\n        newCpSource.prevOnCircle = newCpAntipodes[0];\r\n        newCpSource.nextOnCircle = newCpAntipodes[0];\r\n        newCpAntipodes[0].prevOnCircle = newCpSource;\r\n        newCpAntipodes[0].nextOnCircle = newCpSource;\r\n    }\r\n    else {\r\n        let cpNodes = newCpAntipodes.slice();\r\n        cpNodes.push(newCpSource);\r\n        // Order points according to their angle with the x-axis\r\n        cpNodes.sort(byAngle(circle));\r\n        for (let i = 0; i < cpNodes.length; i++) {\r\n            let iNext = (i + 1 === cpNodes.length) ? 0 : i + 1;\r\n            let iPrev = (i === 0) ? cpNodes.length - 1 : i - 1;\r\n            let cpNodeCurr = cpNodes[i];\r\n            let cpNodeNext = cpNodes[iNext];\r\n            let cpNodePrev = cpNodes[iPrev];\r\n            cpNodeCurr.nextOnCircle = cpNodeNext;\r\n            cpNodeCurr.prevOnCircle = cpNodePrev;\r\n        }\r\n    }\r\n    if (holeClosing) {\r\n        // TODO - important - take care of case where there are more than 1 antipode\r\n        // Duplicate ContactPoints\r\n        let cpB2 = { pointOnShape: posAntipodes[0].pos, circle, order: cpAntipodes[0].order, order2: +1 };\r\n        let newCpB2Node = _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(true, false, cpTreeAntipodes[0], cpB2, newCpAntipodes[0]);\r\n        let cpB1 = { pointOnShape: posSource, circle, order: cpSource.order, order2: -1 };\r\n        let newCpB1Node = _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(true, false, cpTreeSource, cpB1, newCpSource.prev);\r\n        // Connect graph\r\n        newCpB1Node.prevOnCircle = newCpB2Node;\r\n        newCpB1Node.nextOnCircle = newCpB2Node;\r\n        newCpB2Node.prevOnCircle = newCpB1Node;\r\n        newCpB2Node.nextOnCircle = newCpB1Node;\r\n        newCpAntipodes[0].next = newCpSource;\r\n        newCpSource.prev = newCpAntipodes[0];\r\n        newCpB1Node.next = newCpB2Node;\r\n        newCpB2Node.prev = newCpB1Node;\r\n    }\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let elems;\r\n        if (holeClosing) {\r\n            elems = _debug_.generated.elems['twoProng_holeClosing'];\r\n        }\r\n        else {\r\n            elems = _debug_.generated.elems['twoProng_regular'];\r\n        }\r\n        let elem = elems[elems.length - 1];\r\n        if (!newCpSource) {\r\n            console.log('asas');\r\n        }\r\n        elem.cpNode = newCpSource;\r\n    }\r\n    return newCpSource;\r\n}\r\n/** @hidden */\r\nfunction scale(n, exp) {\r\n    return n * (2 ** -(exp + 1));\r\n}\r\n/** @hidden */\r\nfunction getSize(x, y) {\r\n    // Get size of a\r\n    if (x > 0) {\r\n        if (x > 0.5) {\r\n            return y; // ~ -0.7 -> 0.7, i.e. -(sqrt(2)/2) -> +(sqrt(2)/2) \r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x - 2; // ~ -2.0 -> -1.3\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 1.3 -> 2.0\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (x < -0.5) {\r\n            return -y + 4; // ~ 3.3 -> 4.7\r\n        }\r\n        else {\r\n            if (y < 0) {\r\n                return x + 6; // ~ 5.3 -> 6.0\r\n            }\r\n            else {\r\n                return -x + 2; // ~ 2 -> 2.7\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @hidden */\r\nfunction byAngle(circle) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let exp = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent)(r);\r\n    return function (_a, _b) {\r\n        let a = _a.cp.pointOnShape.p;\r\n        let b = _b.cp.pointOnShape.p;\r\n        // Move onto origin\r\n        a = [a[0] - c[0], a[1] - c[1]];\r\n        b = [b[0] - c[0], b[1] - c[1]];\r\n        // Scale\r\n        let ax = scale(a[0], exp);\r\n        let ay = scale(a[1], exp);\r\n        let bx = scale(b[0], exp);\r\n        let by = scale(b[1], exp);\r\n        // Get 'size'\r\n        let sa = getSize(ax, ay);\r\n        let sb = getSize(bx, by);\r\n        return sb - sa;\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/add-2-prong.ts?")},"./src/mat/find-mat/add-3-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add3Prong\": () => (/* binding */ add3Prong)\n/* harmony export */ });\n/* harmony import */ var _add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../add-to-cp-graph.js */ \"./src/mat/add-to-cp-graph.ts\");\n/* harmony import */ var _is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../is-another-cp-closeby.js */ \"./src/mat/is-another-cp-closeby.ts\");\n\r\n\r\n/**\r\n * @hidden\r\n * Adds a 3-prong MAT circle according to the 3 given (previously calculated)\r\n * points on the shape.\r\n * @param cpTrees\r\n * @param orders\r\n * @param threeProng\r\n */\r\nfunction add3Prong(cpTrees, orders, threeProng) {\r\n    let { circle, ps: poss, δ3s } = threeProng;\r\n    // Keep for possible future debugging.\t\r\n    /*\r\n    if (typeof _debug_ !== 'undefined') {\r\n        for (let i=0; i<3; i++) {\r\n            let cpBef = threeProng.δ3s[i][0].cp;\r\n            let cpAft = threeProng.δ3s[i][1].cp;\r\n            //let cmpBef = PointOnShape.compareInclOrder(cpBef.pointOnShape, ps[i], cpBef.order, orders[i]);\r\n            //let cmpAft = PointOnShape.compareInclOrder(cpAft.pointOnShape, ps[i], cpAft.order, orders[i]);\r\n\r\n            let cmpBef = PointOnShape.compare(cpBef.pointOnShape, ps[i]);\r\n            let cmpAft = PointOnShape.compare(cpAft.pointOnShape, ps[i]);\r\n\r\n            // len is used by debug functions to reference a particular\r\n            // three-prong.\r\n            let len = _debug_.generated.elems.threeProng.length-1;\r\n            if (cmpBef > 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (bef) : i: ${i} - cmp: ${cmpBef} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n            if (cmpAft < 0) {\r\n                console.log('----------------------------------------');\r\n                console.log(`3-prong order is wrong (aft) : i: ${i} - cmp: ${cmpAft} - n: ${len}`);\r\n                console.log(threeProng);\r\n                console.log(cpBef);\r\n                console.log(cpAft);\r\n                console.log(ps[i]);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    // TODO - replace 1000 below with correct value\r\n    (0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_1__.isAnotherCpCloseby)(cpTrees, poss[0], circle, orders[0], 0, 1000, 'blue');\r\n    (0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_1__.isAnotherCpCloseby)(cpTrees, poss[1], circle, orders[1], 0, 1000, 'blue');\r\n    (0,_is_another_cp_closeby_js__WEBPACK_IMPORTED_MODULE_1__.isAnotherCpCloseby)(cpTrees, poss[2], circle, orders[2], 0, 1000, 'blue');\r\n    (0,_add_to_cp_graph_js__WEBPACK_IMPORTED_MODULE_0__.addToCpGraph)(circle, orders, cpTrees, poss, δ3s);\r\n    return circle;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/add-3-prong.ts?")},"./src/mat/find-mat/add-debug-info.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "addDebugInfo1": () => (/* binding */ addDebugInfo1),\n/* harmony export */   "addDebugInfo2": () => (/* binding */ addDebugInfo2),\n/* harmony export */   "addDebugInfo3": () => (/* binding */ addDebugInfo3),\n/* harmony export */   "addDebugInfo4": () => (/* binding */ addDebugInfo4)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../curve.js */ "./src/curve.ts");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../get-bounding-box-.js */ "./src/get-bounding-box-.ts");\n\r\n\r\n\r\nif (typeof _debug_ !== \'undefined\') {\r\n    var timingStart;\r\n}\r\n/** @hidden */\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    timingStart = performance.now();\r\n    for (let loop of loops) {\r\n        _debug_.fs.nameObj(loop, \'l|\');\r\n    }\r\n    let generated = _debug_.generated;\r\n    //generated.elems.loop.push(...loops);\r\n    //generated.elems.loops.push(loops);\r\n    for (let loop of loops) {\r\n        let i = 0;\r\n        loop.curves.forEach(function (curve) {\r\n            let ps = curve.ps;\r\n            let hull = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingHull)(ps);\r\n            generated.elems.boundingHull.push(hull);\r\n            let looseBoundingBox = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.getBoundingBox_)(ps);\r\n            generated.elems.looseBoundingBox.push(looseBoundingBox);\r\n            let tightBoundingBox = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingBoxTight)(ps);\r\n            generated.elems.tightBoundingBox.push(tightBoundingBox);\r\n            let corner = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.getCornerAtEnd)(curve);\r\n            if (corner.isSharp) {\r\n                generated.elems.sharpCorner.push(curve);\r\n            }\r\n            else if (corner.isDull) {\r\n                generated.elems.dullCorner.push(curve);\r\n            }\r\n            i++;\r\n        });\r\n    }\r\n}\r\n/** @hidden */\r\nfunction addDebugInfo2() {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    let timing = _debug_.generated.timing;\r\n    let now = performance.now();\r\n    timing.holeClosers += now - timingStart;\r\n    timingStart = now;\r\n}\r\nfunction addDebugInfo3() {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    let now = performance.now();\r\n    timing.oneAnd2Prongs += now - timingStart;\r\n    timingStart = now;\r\n}\r\nfunction addDebugInfo4(mat) {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    let generated = _debug_.generated;\r\n    let timing = generated.timing;\r\n    generated.elems.mat.push(mat);\r\n    timing.threeProngs += performance.now() - timingStart;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/add-debug-info.ts?')},"./src/mat/find-mat/create-get-interesting-points-on-loop.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInterestingPointsOnLoop": () => (/* binding */ getInterestingPointsOnLoop)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _get_contact_circles_at_interface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../get-contact-circles-at-interface.js */ "./src/mat/get-contact-circles-at-interface.ts");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Get useful points on the shape - these incude points of maximum curvature and\r\n * points at the bezier-bezier interfaces.\r\n * @param loop\r\n * @param additionalPointCount\r\n */\r\nfunction getInterestingPointsOnLoop(minBezLength, maxCurviness, maxLength) {\r\n    return function (loop) {\r\n        let allPoints = [];\r\n        for (let i = 0; i < loop.curves.length; i++) {\r\n            let curve = loop.curves[i];\r\n            // qqq if (lengthSquaredUpperBound(curve.ps) < minBezLength) {\r\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(curve.ps) < minBezLength) {\r\n                continue;\r\n            }\r\n            /*\r\n            let { maxCurvatureTs, maxNegativeCurvatureTs } =\r\n                getCurvatureExtrema(curve.ps);\r\n            let maxCurvatures = maxCurvatureTs.map(t => new PointOnShape(curve, t));\r\n            let maxNegativeCurvatures = maxNegativeCurvatureTs.map(t => new PointOnShape(curve, t));\r\n\r\n            allPoints.push(\r\n                ...getContactCirclesAtInterface(curve),\r\n                ...maxCurvatures,\r\n                ...maxNegativeCurvatures\r\n            );\r\n            */\r\n            // let { maxima } = getCurvatureExtrema(curve.ps);\r\n            // qqq let { maxCurvatureTs, maxNegativeCurvatureTs } = getCurvatureExtrema(curve.ps);\r\n            let { maxima } = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getCurvatureExtrema)(curve.ps);\r\n            // let maxAbsCurvatures = maxima.map(t => new PointOnShape(curve, t));\r\n            // qqq let maxAbsCurvatures = [...maxCurvatureTs, ...maxNegativeCurvatureTs].map(t => new PointOnShape(curve, t));\r\n            let maxAbsCurvatures = [...maxima].map(t => new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(curve, t));\r\n            allPoints.push(...(0,_get_contact_circles_at_interface_js__WEBPACK_IMPORTED_MODULE_1__.getContactCirclesAtInterface)(curve), ...maxAbsCurvatures);\r\n            let ts = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.splitByCurvatureAndLength)(curve.ps, maxCurviness, maxLength);\r\n            if (ts.length === 2) {\r\n                ts = [0, 0.5, 1];\r\n            }\r\n            for (let i = 1; i < ts.length - 1; i++) {\r\n                allPoints.push(new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(curve, ts[i]));\r\n            }\r\n        }\r\n        allPoints.sort(_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.comparePoss);\r\n        return allPoints;\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/create-get-interesting-points-on-loop.ts?')},"./src/mat/find-mat/create-initial-cp-graph.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createInitialCpGraph": () => (/* binding */ createInitialCpGraph)\n/* harmony export */ });\n/* harmony import */ var flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-ll-rb-tree */ "./node_modules/flo-ll-rb-tree/node/index.js");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../cp-node.js */ "./src/cp-node.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Creates the initial ContactPoint loops from the given sharp corners.\r\n * @param shape\r\n * @param sharpCornerss\r\n */\r\nfunction createInitialCpGraph(loops, cpTrees, sharpCornerss /*,\r\nxMap: Map<number[][],{ ps: number[][] }>*/) {\r\n    let cpNode;\r\n    for (let k = 0; k < sharpCornerss.length; k++) {\r\n        let sharpCorners = sharpCornerss[k];\r\n        // qqq let cpTree = new LlRbTree(CpNode.comparator, [], true);\r\n        let cpTree = new flo_ll_rb_tree__WEBPACK_IMPORTED_MODULE_0__.LlRbTree(_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.comparator, false);\r\n        let cpNode1 = undefined;\r\n        let cpNode2 = undefined;\r\n        for (let pos of sharpCorners) {\r\n            let ps = pos.curve.next.ps;\r\n            //let x = xMap.get(ps);\r\n            //let isIntersection = !!x;\r\n            let circle = { center: pos.p, radius: 0 };\r\n            let cp1 = { pointOnShape: pos, circle, order: -1, order2: 0 };\r\n            let cp2 = { pointOnShape: pos, circle, order: +1, order2: 0 };\r\n            cpNode1 = _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(false, /*isIntersection*/ false, cpTree, cp1, cpNode2);\r\n            cpNode2 = _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.insert(false, /*isIntersection*/ false, cpTree, cp2, cpNode1);\r\n            cpNode1.prevOnCircle = cpNode2;\r\n            cpNode2.prevOnCircle = cpNode1;\r\n            cpNode1.nextOnCircle = cpNode2;\r\n            cpNode2.nextOnCircle = cpNode1;\r\n        }\r\n        if (!cpNode) {\r\n            cpNode = cpNode1;\r\n        }\r\n        let loop = loops[k];\r\n        cpTrees.set(loop, cpTree);\r\n    }\r\n    return cpNode;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/create-initial-cp-graph.ts?')},"./src/mat/find-mat/find-2-prong/add-debug-info.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "addDebugInfo": () => (/* binding */ addDebugInfo)\n/* harmony export */ });\n/* harmony import */ var _get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../get-two-prong-type.js */ "./src/mat/get-two-prong-type.ts");\n\r\n/** @hidden */\r\nfunction addDebugInfo(bezierPieces, failed, pos, circle, z, δ, xs, holeClosing) {\r\n    let twoProng = {\r\n        generated: _debug_.generated,\r\n        bezierPieces,\r\n        pos,\r\n        δ,\r\n        z: z ? z.p : undefined,\r\n        circle,\r\n        xs,\r\n        failed,\r\n        holeClosing,\r\n        notAdded: false,\r\n        deleted: false,\r\n        cpNode: undefined\r\n    };\r\n    let twoProngType = (0,_get_two_prong_type_js__WEBPACK_IMPORTED_MODULE_0__.getTwoProngType)(twoProng);\r\n    _debug_.generated.elems[twoProngType].push(twoProng);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-2-prong/add-debug-info.ts?')},"./src/mat/find-mat/find-2-prong/cull-bezier-pieces.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cullBezierPieces": () => (/* binding */ cullBezierPieces)\n/* harmony export */ });\n/* harmony import */ var _geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/get-closest-square-distance-to-rect.js */ "./src/mat/geometry/get-closest-square-distance-to-rect.ts");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../get-bounding-box-.js */ "./src/get-bounding-box-.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Cull all bezierPieces not within given radius of a given point.\r\n * @param extreme\r\n * @param bezierPieces\r\n * @param p\r\n * @param rSquared\r\n */\r\nfunction cullBezierPieces(bezierPieces, p, rSquared) {\r\n    const CULL_THRESHOLD = 5;\r\n    // TODO - base delta on theory\r\n    const TOLERANCE = 1 + 1e-3;\r\n    if (bezierPieces.length <= CULL_THRESHOLD) {\r\n        return bezierPieces;\r\n    }\r\n    let newPieces = [];\r\n    for (let bezierPiece of bezierPieces) {\r\n        let ps = bezierPiece.curve.ps;\r\n        let rect = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox_)(ps);\r\n        let bd = (0,_geometry_get_closest_square_distance_to_rect_js__WEBPACK_IMPORTED_MODULE_0__.getClosestSquareDistanceToRect)(rect, p);\r\n        if (bd <= rSquared * TOLERANCE) {\r\n            newPieces.push(bezierPiece);\r\n        }\r\n    }\r\n    return newPieces;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-2-prong/cull-bezier-pieces.ts?')},"./src/mat/find-mat/find-2-prong/find-2-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"find2Prong\": () => (/* binding */ find2Prong)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/* harmony import */ var _closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point.js */ \"./src/mat/closest-boundary-point/get-closest-boundary-point.ts\");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../point-on-shape.js */ \"./src/point-on-shape.ts\");\n/* harmony import */ var _add_1_prong_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../add-1-prong.js */ \"./src/mat/find-mat/add-1-prong.ts\");\n/* harmony import */ var _add_debug_info_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./add-debug-info.js */ \"./src/mat/find-mat/find-2-prong/add-debug-info.ts\");\n/* harmony import */ var _cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cull-bezier-pieces.js */ \"./src/mat/find-mat/find-2-prong/cull-bezier-pieces.ts\");\n/* harmony import */ var _find_equidistant_point_on_line_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./find-equidistant-point-on-line.js */ \"./src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.ts\");\n/* harmony import */ var _get_initial_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-initial-bezier-pieces.js */ \"./src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.ts\");\n/* harmony import */ var _closest_boundary_point_get_close_boundary_points_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../closest-boundary-point/get-close-boundary-points.js */ \"./src/mat/closest-boundary-point/get-close-boundary-points.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst evalDeCasteljau = flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau;\r\n/**\r\n * @hidden\r\n * Adds a 2-prong to the MAT. The first point on the shape boundary is given and\r\n * the second one is found by the algorithm.\r\n *\r\n * A 2-prong is defined as a MAT circle that touches the shape at exactly 2\r\n * points.\r\n *\r\n * Before any 2-prongs are added the entire shape is our δΩ (1-prongs do not\r\n * reduce the boundary).\r\n *\r\n * As per the paper by Choi, Choi, Moon and Wee:\r\n *   \"The starting point of this algorithm is a choice of a circle Br(x)\r\n *    centered at an interior point x which contains two boundary portions c and\r\n *    d of dΩ as in Fig. 19.\"\r\n * In fact, we (and they) start by fixing one point on the boundary beforehand.\r\n * @param loops A shape represented by path loops\r\n * @param extreme The extreme coordinate value of the shape\r\n * @param squaredDiagonalLength The squared diagonal length of the shape\r\n * bounding box.\r\n * @param y The source point of the 2-prong to be found\r\n * @param isHoleClosing True if this is a hole-closing two-prong, false otherwise\r\n * @param k The loop array index\r\n */\r\nfunction find2Prong(loops, extreme, squaredDiagonalLength, cpTrees, y, isHoleClosing, k) {\r\n    const MAX_ITERATIONS = 25;\r\n    const squaredSeperationTolerance = (1e-6 * extreme) ** 2;\r\n    // TODO - base deltas on theory or remove\r\n    const oneProngTolerance = (1e-4) ** 2;\r\n    const squaredErrorTolerance = 1e-2 * squaredSeperationTolerance;\r\n    const maxOsculatingCircleRadiusSquared = squaredDiagonalLength;\r\n    // The boundary piece that should contain the other point of \r\n    // the 2-prong circle. (Defined by start and end points).\r\n    let { bezierPieces, δ } = (0,_get_initial_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_8__.getInitialBezierPieces)(isHoleClosing, k, loops, cpTrees, y);\r\n    //console.log(bezierPieces.length)\r\n    /** The center of the two-prong (successively refined) */\r\n    let x;\r\n    let p;\r\n    let r;\r\n    if (isHoleClosing) {\r\n        p = [y.p[0], y.p[1]];\r\n        x = [p[0], p[1] - Math.sqrt(maxOsculatingCircleRadiusSquared)];\r\n        r = maxOsculatingCircleRadiusSquared;\r\n    }\r\n    else {\r\n        p = y.p;\r\n        //x = PointOnShape.getOsculatingCircle(maxOsculatingCircleRadiusSquared, y).center;\r\n        x = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_3__.getOsculatingCircle)(maxOsculatingCircleRadiusSquared, y).center;\r\n        r = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p, x);\r\n    }\r\n    // The lines below is an optimization.\r\n    let r_ = reduceRadius(extreme, bezierPieces, p, x);\r\n    if (r > r_) {\r\n        x = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.interpolate)(p, x, Math.sqrt(r_ / r));\r\n    }\r\n    /** Trace the convergence (for debugging). */\r\n    let xs = [];\r\n    /** The antipode of the two-prong (successively refined) */\r\n    let z;\r\n    let i = 0;\r\n    let done = 0;\r\n    let failed = false; // The failed flag is set if a 2-prong cannot be found.\r\n    let bezierPieces_ = bezierPieces;\r\n    // ---\x3e for (let b of bezierPieces) { d.fs.draw.bezierPiece(document.getElementsByTagName('g')[0], b.curve.ps, b.ts, 'nofill thin10 red', 100); }\r\n    do {\r\n        i++;\r\n        /** squared distance between source boundary point and circle center */\r\n        let r = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(x, y.p);\r\n        bezierPieces_ = (0,_cull_bezier_pieces_js__WEBPACK_IMPORTED_MODULE_6__.cullBezierPieces)(bezierPieces_, x, r);\r\n        z = (0,_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_2__.getClosestBoundaryPoint)(bezierPieces_, x, y.curve, y.t);\r\n        if (z === undefined) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular;\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log('failed: no closest point - ' + elemStr);\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        if (typeof _debug_ !== 'undefined') {\r\n            xs.push({ x, y, z: z.pos, t: y.t });\r\n        }\r\n        /** squared distance between anti-pode boundary point and circle center */\r\n        let d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(x, z.pos.p);\r\n        //if (i === 1 && d*oneProngTolerance >= r) {\r\n        if (i === 1 && r < d + oneProngTolerance) {\r\n            // It is a 1-prong.\r\n            (0,_add_1_prong_js__WEBPACK_IMPORTED_MODULE_4__.add1Prong)(Math.sqrt(maxOsculatingCircleRadiusSquared), cpTrees, y);\r\n            return undefined;\r\n        }\r\n        // TODO - squaredSeperationTolerance should in future be replaced with\r\n        // a relative error, i.e. distance between y (or z) / length(y (or z)).\r\n        if (!isHoleClosing && (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(y.p, z.pos.p) <= squaredSeperationTolerance) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                /*\r\n                let elems = _debug_.generated.elems;\r\n                let elem = isHoleClosing\r\n                    ? elems.twoProng_holeClosing\r\n                    : elems.twoProng_regular\r\n                let elemStr = isHoleClosing\r\n                    ? 'hole-closing: ' + elem.length\r\n                    : 'regular: ' + elem.length;\r\n                console.log(\r\n                    'failed: two-prong radius too small - ' + elemStr\r\n                );\r\n                */\r\n            }\r\n            failed = true;\r\n            break;\r\n        }\r\n        // TODO - Accuracy optimization: tolerance should not be between x and \r\n        // nextX, but rather (distance from x to y) - (distance from x to z)\r\n        // Find the point on the line connecting y with x that is  \r\n        // equidistant from y and z. This will be our next x.\r\n        let nextX = (0,_find_equidistant_point_on_line_js__WEBPACK_IMPORTED_MODULE_7__.findEquidistantPointOnLine)(x, y.p, z.pos.p);\r\n        let squaredError = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(x, nextX);\r\n        x = nextX;\r\n        if (squaredError < squaredErrorTolerance) {\r\n            done++; // Do one more iteration\r\n        }\r\n        else if (i === MAX_ITERATIONS) {\r\n            // Convergence was too slow.\r\n            failed = true;\r\n            break; // We're done\r\n        }\r\n    } while (done < 1);\r\n    // TODO - Optimization: only do this if second closest point is within the\r\n    // tolerance which can be checked in getClosestBoundaryPoint algorithm\r\n    let zs = [];\r\n    if (!failed) {\r\n        zs = (0,_closest_boundary_point_get_close_boundary_points_js__WEBPACK_IMPORTED_MODULE_9__.getCloseBoundaryPoints)(bezierPieces_, x, y, (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(x, z.pos.p));\r\n        if (!zs.length) {\r\n            // TODO - Numerical issue - fix\r\n            zs.push(z);\r\n        }\r\n    }\r\n    let circle;\r\n    if (z !== undefined) {\r\n        circle = { center: x, radius: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(x, z.pos.p) };\r\n    }\r\n    if (typeof _debug_ !== 'undefined' && !failed) {\r\n        xs.push({ x, y, z: z.pos, t: y.t });\r\n        (0,_add_debug_info_js__WEBPACK_IMPORTED_MODULE_5__.addDebugInfo)(bezierPieces, failed, y, circle, z.pos, δ, xs, isHoleClosing);\r\n    }\r\n    return failed ? undefined : { circle, zs };\r\n}\r\n/**\r\n * @hidden\r\n * Reduces the circle radius initially as an optimization step.\r\n */\r\nfunction reduceRadius(extreme, bezierPieces, p, x) {\r\n    const TOLERANCE = extreme * 1e-3;\r\n    let prevP = undefined;\r\n    let minRadius = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < bezierPieces.length; i++) {\r\n        let bezierPiece = bezierPieces[i];\r\n        let ps = bezierPiece.curve.ps;\r\n        let p1 = evalDeCasteljau(ps, bezierPiece.ts[0]);\r\n        let r1 = Number.POSITIVE_INFINITY;\r\n        // Prevent evaluating the same points twice\r\n        if (!prevP || prevP[0] !== p1[0] || prevP[1] !== p1[1]) {\r\n            let cc1 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1);\r\n            if (cc1) {\r\n                r1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p, cc1);\r\n            }\r\n        }\r\n        let r2 = Number.POSITIVE_INFINITY;\r\n        let p2 = evalDeCasteljau(ps, bezierPiece.ts[1]);\r\n        let cc2 = getCircleCenterFrom2PointsAndNormal(extreme, p, x, p2);\r\n        if (cc2) {\r\n            r2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p, cc2);\r\n        }\r\n        prevP = p2;\r\n        let d = Math.min(r1, r2);\r\n        if (d < minRadius) {\r\n            minRadius = d;\r\n        }\r\n    }\r\n    // The extra bit is to account for floating point precision.\r\n    // TODO - base delta on theory\r\n    return minRadius + TOLERANCE;\r\n}\r\n/**\r\n * @hidden\r\n * @param p A point on the circle with normal pointing to x towards the center\r\n * of the circle.\r\n * @param x\r\n * @param p1 Another point on the circle.\r\n */\r\nfunction getCircleCenterFrom2PointsAndNormal(extreme, p, x, p1) {\r\n    // TODO - remove delta\r\n    let TOLERANCE = (1e-4 * extreme) ** 2;\r\n    // Ignore if p and p1 are too close together\r\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p, p1) < TOLERANCE) {\r\n        return undefined;\r\n    }\r\n    /** The perpindicular bisector between the two given points on the circle */\r\n    let pb = [\r\n        (p[0] + p1[0]) / 2,\r\n        (p[1] + p1[1]) / 2,\r\n    ];\r\n    let tan = [p1[0] - p[0], p1[1] - p[1]];\r\n    let norm = [-tan[1], tan[0]]; // Rotate by 90 degrees\r\n    let pb2 = [pb[0] + norm[0], pb[1] + norm[1]];\r\n    let res = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.lineLineIntersection)([p, x], [pb, pb2]);\r\n    if (!res) {\r\n        return undefined;\r\n    }\r\n    let resO = [res[0] - p[0], res[1] - p[1]];\r\n    let xO = [x[0] - p[0], x[1] - p[1]];\r\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(resO, xO) < 0) {\r\n        return undefined;\r\n    }\r\n    return res;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-2-prong/find-2-prong.ts?")},"./src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findEquidistantPointOnLine": () => (/* binding */ findEquidistantPointOnLine)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * @param x\r\n * @param y\r\n * @param z\r\n * @returns The point on the line from y to x that is equidistant from y and z.\r\n */\r\nfunction findEquidistantPointOnLine(x, y, z) {\r\n    // Some basic algebra (not shown) finds the required point.\r\n    // Swap axes if x and y are more aligned to y-axis than to x-axis.\r\n    let swapAxes = Math.abs((x[1] - y[1]) / (x[0] - y[0])) > 1;\r\n    // Cache\r\n    let x1, x2, y1, y2, z1, z2;\r\n    if (swapAxes) {\r\n        x1 = x[1];\r\n        x2 = x[0];\r\n        y1 = y[1];\r\n        y2 = y[0];\r\n        z1 = z[1];\r\n        z2 = z[0];\r\n    }\r\n    else {\r\n        x1 = x[0];\r\n        x2 = x[1];\r\n        y1 = y[0];\r\n        y2 = y[1];\r\n        z1 = z[0];\r\n        z2 = z[1];\r\n    }\r\n    // a <= 1 (due to swapped axes)\r\n    let a = (x2 - y2) / (x1 - y1);\r\n    let b = y2 - a * y1;\r\n    let c = (y1 * y1 + y2 * y2 - z1 * z1 - z2 * z2) + 2 * b * (z2 - y2);\r\n    let d = y1 - z1 + a * (y2 - z2);\r\n    let t1 = c / (2 * d);\r\n    let t2 = a * t1 + b;\r\n    return swapAxes ? [t2, t1] : [t1, t2];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-2-prong/find-equidistant-point-on-line.ts?')},"./src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInitialBezierPieces": () => (/* binding */ getInitialBezierPieces)\n/* harmony export */ });\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../get-neighboring-cps.js */ "./src/mat/get-neighboring-cps.ts");\n/* harmony import */ var _get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../get-boundary-piece-beziers.js */ "./src/mat/get-boundary-piece-beziers.ts");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n\r\n\r\n/** @hidden */\r\nfunction getInitialBezierPieces(isHoleClosing, k, loops, cpTrees, y) {\r\n    let bezierPieces;\r\n    let δ;\r\n    if (isHoleClosing) {\r\n        bezierPieces = [];\r\n        for (let k2 = 0; k2 < k; k2++) {\r\n            let pieces = loops[k2].curves\r\n                .map(curve => ({ curve, ts: [0, 1] }));\r\n            bezierPieces.push(...pieces);\r\n        }\r\n    }\r\n    else {\r\n        //let order = PointOnShape.isDullCorner(y)\r\n        let order = (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.isPosDullCorner)(y)\r\n            ? y.t === 1 ? -1 : +1\r\n            : 0;\r\n        let loop = loops[k];\r\n        let cpNode = (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_0__.getNeighbouringPoints)(cpTrees.get(loop), y, order, 0)[0];\r\n        δ = [cpNode, cpNode];\r\n        if (!cpNode ||\r\n            // The special case if there is only a single sharp corner or \r\n            // terminating 2-prong currently in the MAT. Don\'t remove!\r\n            (cpNode === cpNode.next.next)) {\r\n            bezierPieces = loop.curves\r\n                .map(curve => ({ curve, ts: [0, 1] }));\r\n        }\r\n        else {\r\n            bezierPieces = (0,_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_1__.getBoundaryPieceBeziers)(δ);\r\n        }\r\n    }\r\n    return { bezierPieces, δ };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-2-prong/get-initial-bezier-pieces.ts?')},"./src/mat/find-mat/find-3-prong/calc-better-x.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calcBetterX": () => (/* binding */ calcBetterX)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_closest_points_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-closest-points.js */ "./src/mat/find-mat/find-3-prong/get-closest-points.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Find new x and ps that are a better estimate of the 3-prong circle.\r\n * The potential function, V, is defined as the distance to the actual 3 prong\r\n * circle center.\r\n * @param bezierPiece3s The three boundary pieces, each of which should contain\r\n * a point of the 3-prong to be found.\r\n * @param x The currently best guess at the center of the 3-prong circle.\r\n * @param vectorToZeroV\r\n * @param extreme\r\n */\r\nfunction calcBetterX(bezierPiece3s, x, vectorToZeroV) {\r\n    let V = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(vectorToZeroV);\r\n    let nu = 1;\r\n    let better;\r\n    let newX;\r\n    let newPs;\r\n    let newV;\r\n    let i = 0; // Safeguard\r\n    do {\r\n        let shift = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.scale)(vectorToZeroV, nu);\r\n        newX = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(shift, x);\r\n        newPs = (0,_get_closest_points_js__WEBPACK_IMPORTED_MODULE_1__.getClosestPoints)(newX, bezierPiece3s);\r\n        // Point of zero V\r\n        let newCircleCenter = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.circumCenter)(newPs.map(pos => pos.p));\r\n        let newVectorToZeroV = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(newX, newCircleCenter);\r\n        newV = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(newVectorToZeroV);\r\n        better = newV < V;\r\n        nu = nu / 2;\r\n        i++;\r\n    } while (!better && i < 3);\r\n    return { newX, newV, newPs };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-3-prong/calc-better-x.ts?')},"./src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calcInitial3ProngCenter": () => (/* binding */ calcInitial3ProngCenter)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point.js */ "./src/mat/closest-boundary-point/get-closest-boundary-point.ts");\n/** @hidden */\r\n\r\n\r\n/**\r\n * @hidden\r\n * Finds an initial 3-prong circle center point from which to iterate. The point\r\n * must be within the shape.\r\n * @param δ3s - The three boundary pieces of which we need to find the three\r\n * 3-prong points.\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction calcInitial3ProngCenter(δ3s, bezierPiece3s) {\r\n    let twoProngCircleCenter = δ3s[0][0].cp.circle.center;\r\n    let posInfo = (0,_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_1__.getClosestBoundaryPoint)(bezierPiece3s[1], twoProngCircleCenter, undefined, // curve\r\n    undefined // t\r\n    );\r\n    let meanPoints = [\r\n        δ3s[0][0].cp.pointOnShape.p,\r\n        posInfo.pos.p,\r\n        δ3s[2][1].cp.pointOnShape.p,\r\n    ];\r\n    return (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.circumCenter)(meanPoints);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.ts?')},"./src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "find3ProngForDelta3s": () => (/* binding */ find3ProngForDelta3s)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point.js */ "./src/mat/closest-boundary-point/get-closest-boundary-point.ts");\n/* harmony import */ var _calc_initial_3_prong_center_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calc-initial-3-prong-center.js */ "./src/mat/find-mat/find-3-prong/calc-initial-3-prong-center.ts");\n/* harmony import */ var _get_closest_points_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-closest-points.js */ "./src/mat/find-mat/find-3-prong/get-closest-points.ts");\n/* harmony import */ var _calc_better_x_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./calc-better-x.js */ "./src/mat/find-mat/find-3-prong/calc-better-x.ts");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../curve.js */ "./src/curve.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @hidden */\r\nconst calcVectorToZeroV_StraightToIt = flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo;\r\n/**\r\n * @hidden\r\n * Finds a 3-prong using only the 3 given δs.\r\n * @param δs The boundary pieces\r\n * @param idx δ identifier\r\n * @param bezierPiecess\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3ProngForDelta3s(δs, idx, k, bezierPiecess, extreme) {\r\n    const TOLERANCE = extreme * 1e-10;\r\n    const MAX_ITERATIONS = 10;\r\n    let δs_ = [\r\n        δs[0],\r\n        δs[idx],\r\n        δs[δs.length - 1]\r\n    ];\r\n    let bezierPieces_ = [\r\n        bezierPiecess[0],\r\n        bezierPiecess[idx],\r\n        bezierPiecess[δs.length - 1]\r\n    ];\r\n    let δ3ss = [\r\n        [δs_[0], δs_[1], δs_[2]],\r\n        [δs_[1], δs_[2], δs_[0]],\r\n        [δs_[2], δs_[0], δs_[1]],\r\n    ];\r\n    let bezierPiecess_ = [\r\n        [bezierPieces_[0], bezierPieces_[1], bezierPieces_[2]],\r\n        [bezierPieces_[1], bezierPieces_[2], bezierPieces_[0]],\r\n        [bezierPieces_[2], bezierPieces_[0], bezierPieces_[1]],\r\n    ];\r\n    let δ3s = δ3ss[k];\r\n    let bezierPiece3s = bezierPiecess_[k];\r\n    if (δ3s[0][0].isSharp()) {\r\n        return undefined;\r\n    }\r\n    let ps;\r\n    let circumCenter_;\r\n    let j = 0; // Safeguard for slow convergence\r\n    let x = (0,_calc_initial_3_prong_center_js__WEBPACK_IMPORTED_MODULE_4__.calcInitial3ProngCenter)(δ3s, bezierPiece3s);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        let trace = d.traces[d.traces.length - 1];\r\n        trace.push(x);\r\n    }\r\n    let tolerance = Number.POSITIVE_INFINITY;\r\n    while (tolerance > TOLERANCE && j < MAX_ITERATIONS) {\r\n        j++;\r\n        ps = (0,_get_closest_points_js__WEBPACK_IMPORTED_MODULE_5__.getClosestPoints)(x, bezierPiece3s);\r\n        if (!Number.isFinite(x[0]) || !Number.isFinite(x[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don\'t\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        circumCenter_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.circumCenter)(ps.map(x => x.p));\r\n        let vectorToZeroV = calcVectorToZeroV_StraightToIt(x, circumCenter_);\r\n        if (!Number.isFinite(vectorToZeroV[0]) || !Number.isFinite(vectorToZeroV[1])) {\r\n            // TODO - the code can be cleaned up and sped up a lot if we don\'t\r\n            // use this function as is but instead use δs[0] and δs[2] as is\r\n            // and make δs[1] include all the rest of the beziers around the \r\n            // loop. This check, for instance, would be eliminated completely.\r\n            return undefined;\r\n        }\r\n        let upds = (0,_calc_better_x_js__WEBPACK_IMPORTED_MODULE_6__.calcBetterX)(bezierPiece3s, x, vectorToZeroV);\r\n        x = upds.newX;\r\n        ps = upds.newPs;\r\n        if (typeof _debug_ !== \'undefined\') {\r\n            let threeProngs = _debug_.generated.elems.threeProng;\r\n            let d = threeProngs[threeProngs.length - 1];\r\n            let trace = d.traces[d.traces.length - 1];\r\n            trace.push(x);\r\n        }\r\n        let V = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.len)(vectorToZeroV); // The \'potential\'\r\n        tolerance = Math.abs(V - upds.newV);\r\n    }\r\n    let radius = ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(x, ps[0].p) +\r\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(x, ps[1].p) +\r\n        (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(x, ps[2].p)) / 3;\r\n    let circle = { center: x, radius };\r\n    //-------------------------------------------------------------------------\r\n    // Calculate the unit tangent vector at 3-prong circle points - they should \r\n    // be very close to tangent to the boundary piece tangents at those points \r\n    // (up to sign). Sharp corners are a common special case.\r\n    //-------------------------------------------------------------------------\r\n    let totalAngleError = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n        let p = ps[i];\r\n        //----------------------------\r\n        // Tangent of circle at point\r\n        //----------------------------\r\n        let v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(p.p, x));\r\n        let v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate90Degrees)(v);\r\n        //-----------------------------------\r\n        // Check if point is on dull crorner\r\n        //-----------------------------------\r\n        //if (PointOnShape.isDullCorner(p)) {\r\n        if ((0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.isPosDullCorner)(p)) {\r\n            //let corner = Curve.getCornerAtEnd(p.curve);\r\n            let corner = (0,_curve_js__WEBPACK_IMPORTED_MODULE_7__.getCornerAtEnd)(p.curve);\r\n            let tans = corner.tangents;\r\n            let perps = tans.map(flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate90Degrees);\r\n            let angleError1 = Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.cross)(perps[0], v));\r\n            let angleError2 = Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.cross)(v, perps[1]));\r\n            let angleError = 0;\r\n            if (angleError1 > 0) {\r\n                angleError += angleError1;\r\n            }\r\n            if (angleError2 > 0) {\r\n                angleError += angleError2;\r\n            }\r\n            totalAngleError += angleError;\r\n        }\r\n        else {\r\n            //---------------------------\r\n            // Tangent of curve at point\r\n            //---------------------------\r\n            let v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangent)(p.curve.ps, p.t));\r\n            // Cross is more numerically stable than Vector.dot at angles a\r\n            // multiple of Math.PI **and** is close to the actual angle value\r\n            // and can thus just be added to cone method of looking at \r\n            // tolerance.\r\n            // Should be close to zero and is close to the actual angle.\r\n            let cross_ = Math.abs(Math.asin((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.cross)(v1, v2)));\r\n            totalAngleError += cross_;\r\n        }\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    // Calculate radiusDelta, the difference between the radius and the closest\r\n    // point to the 3-prong. It should be around 0. If not, this is not a good \r\n    // candidate for the 3-prong.\r\n    //-------------------------------------------------------------------------\r\n    let closestDs = [];\r\n    for (let i = 0; i < bezierPiecess.length; i++) {\r\n        let p = (0,_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_3__.getClosestBoundaryPoint)(bezierPiecess[i], x, undefined, undefined);\r\n        closestDs.push((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p.pos.p, x));\r\n    }\r\n    let closestD = Math.min(...closestDs);\r\n    let radiusDelta = Math.abs(radius - closestD);\r\n    // Weights below still need to be optimized.\r\n    let W1 = 1;\r\n    let W2 = 1;\r\n    let error = W1 * radiusDelta + W2 * totalAngleError;\r\n    return { ps, circle, error, δ3s };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.ts?')},"./src/mat/find-mat/find-3-prong/find-3-prong.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"find3Prong\": () => (/* binding */ find3Prong)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/* harmony import */ var _debug_three_prong_for_debugging_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../debug/three-prong-for-debugging.js */ \"./src/debug/three-prong-for-debugging.ts\");\n/* harmony import */ var _find_3_prong_for_delta3s_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./find-3-prong-for-delta3s.js */ \"./src/mat/find-mat/find-3-prong/find-3-prong-for-delta3s.ts\");\n/* harmony import */ var _get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../get-boundary-piece-beziers.js */ \"./src/mat/get-boundary-piece-beziers.ts\");\n\r\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Find and return a 3-prong from the given boundary piece.\r\n * @param δs A boundary piece\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction find3Prong(δs, extreme) {\r\n    let bezierPiecess = δs.map(_get_boundary_piece_beziers_js__WEBPACK_IMPORTED_MODULE_3__.getBoundaryPieceBeziers);\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        threeProngs.push((0,_debug_three_prong_for_debugging_js__WEBPACK_IMPORTED_MODULE_1__.createEmptyThreeProngForDebugging)());\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.boundaries = [];\r\n        for (let bezierPieces of bezierPiecess) {\r\n            let boundary = [];\r\n            d.boundaries.push(boundary);\r\n            for (let bezierPiece of bezierPieces) {\r\n                /* qqq\r\n                let bezier = fromTo(bezierPiece.curve.ps)(\r\n                    bezierPiece.ts[0], bezierPiece.ts[1]\r\n                );\r\n                */\r\n                const bezier = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(bezierPiece.curve.ps, bezierPiece.ts[0], bezierPiece.ts[1]);\r\n                boundary.push(bezier);\r\n            }\r\n        }\r\n        d.traces = [];\r\n    }\r\n    let candidateThreeProngs = [];\r\n    // The best candidate amongst the different 'permutations' of the given δs.\r\n    let threeProng;\r\n    let bestIndx = undefined;\r\n    let smallestError = Number.POSITIVE_INFINITY;\r\n    for (let i = 1; i < δs.length - 1; i++) {\r\n        for (let k = 0; k < 3; k++) {\r\n            if (typeof _debug_ !== 'undefined') {\r\n                let threeProngs = _debug_.generated.elems.threeProng;\r\n                let d = threeProngs[threeProngs.length - 1];\r\n                let trace = [];\r\n                d.traces.push(trace);\r\n            }\r\n            let threeProngInfo = (0,_find_3_prong_for_delta3s_js__WEBPACK_IMPORTED_MODULE_2__.find3ProngForDelta3s)(δs, i, k, bezierPiecess, extreme);\r\n            if (!threeProngInfo) {\r\n                continue;\r\n            }\r\n            let { circle, ps, error, δ3s } = threeProngInfo;\r\n            if (typeof _debug_ !== 'undefined') {\r\n                candidateThreeProngs.push({ circle, ps });\r\n            }\r\n            if (error < smallestError) {\r\n                smallestError = error;\r\n                bestIndx = i - 1;\r\n                threeProng = { circle, ps, δ3s };\r\n            }\r\n        }\r\n    }\r\n    //threeProng.δ3s = [δs[0], δs[bestIndx+1], δs[δs.length-1]];\r\n    if (typeof _debug_ !== 'undefined') {\r\n        let threeProngs = _debug_.generated.elems.threeProng;\r\n        let d = threeProngs[threeProngs.length - 1];\r\n        d.generated = _debug_.generated;\r\n        d.circle = threeProng.circle;\r\n        d.poss = threeProng.ps;\r\n        d.cp3ss = threeProng.δ3s;\r\n        d.cpss = δs;\r\n        d.bestIndx = bestIndx;\r\n        d.candidateThreeProngs = candidateThreeProngs;\r\n    }\r\n    return threeProng;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-3-prong/find-3-prong.ts?")},"./src/mat/find-mat/find-3-prong/get-closest-points.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getClosestPoints": () => (/* binding */ getClosestPoints)\n/* harmony export */ });\n/* harmony import */ var _closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../closest-boundary-point/get-closest-boundary-point.js */ "./src/mat/closest-boundary-point/get-closest-boundary-point.ts");\n\r\n/**\r\n * @hidden\r\n * @param x\r\n * @param bezierPiece3s\r\n * @param extreme\r\n */\r\nfunction getClosestPoints(x, bezierPiece3s) {\r\n    return bezierPiece3s.map(bezierPieces => {\r\n        let posInfo = (0,_closest_boundary_point_get_closest_boundary_point_js__WEBPACK_IMPORTED_MODULE_0__.getClosestBoundaryPoint)(bezierPieces, x, undefined, // curve\r\n        undefined // t\r\n        );\r\n        return posInfo ? posInfo.pos : undefined;\r\n    });\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-3-prong/get-closest-points.ts?')},"./src/mat/find-mat/find-and-add-2-prongs-on-all-paths.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findAndAdd2ProngsOnAllPaths": () => (/* binding */ findAndAdd2ProngsOnAllPaths)\n/* harmony export */ });\n/* harmony import */ var _find_and_add_2_prongs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find-and-add-2-prongs.js */ "./src/mat/find-mat/find-and-add-2-prongs.ts");\n\r\n/**\r\n * @hidden\r\n * Add 2 prongs. See comments on the add2Prong function.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param for2Prongss\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2ProngsOnAllPaths(loops, cpGraphs, for2Prongss, extreme) {\r\n    let cpNode;\r\n    for (let k = 0; k < for2Prongss.length; k++) {\r\n        let for2Prongs = for2Prongss[k];\r\n        let _cpNode = (0,_find_and_add_2_prongs_js__WEBPACK_IMPORTED_MODULE_0__.findAndAdd2Prongs)(loops, cpGraphs, k, for2Prongs, extreme);\r\n        cpNode = cpNode || _cpNode;\r\n    }\r\n    return cpNode;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-and-add-2-prongs-on-all-paths.ts?')},"./src/mat/find-mat/find-and-add-2-prongs.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findAndAdd2Prongs": () => (/* binding */ findAndAdd2Prongs)\n/* harmony export */ });\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../svg/get-shape-bounds.js */ "./src/svg/get-shape-bounds.ts");\n/* harmony import */ var _find_2_prong_find_2_prong_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-2-prong/find-2-prong.js */ "./src/mat/find-mat/find-2-prong/find-2-prong.ts");\n/* harmony import */ var _add_2_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add-2-prong.js */ "./src/mat/find-mat/add-2-prong.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Find and add two-prongs.\r\n * @param loops\r\n * @param cpGraphs\r\n * @param k\r\n * @param for2Prongs\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd2Prongs(loops, cpGraphs, k, for2Prongs, extreme) {\r\n    let len = for2Prongs.length;\r\n    let index = indexLinear(len);\r\n    //let index = indexInterlaced(len); // Keep for possible future use.\r\n    let cpNode_;\r\n    let bounds = (0,_svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getShapeBounds)(loops);\r\n    let squaredDiagonalLength = (bounds.maxX.p[0] - bounds.minX.p[0]) ** 2 +\r\n        (bounds.maxY.p[1] - bounds.minY.p[1]) ** 2;\r\n    for (let i = 0; i < len; i++) {\r\n        let pos = for2Prongs[index[i]];\r\n        let twoProngInfo;\r\n        twoProngInfo = (0,_find_2_prong_find_2_prong_js__WEBPACK_IMPORTED_MODULE_1__.find2Prong)(loops, extreme, squaredDiagonalLength, cpGraphs, pos, false, k);\r\n        if (twoProngInfo) {\r\n            let { circle, zs } = twoProngInfo;\r\n            let cpNode = (0,_add_2_prong_js__WEBPACK_IMPORTED_MODULE_2__.add2Prong)(cpGraphs, circle, pos, zs, false, extreme);\r\n            cpNode_ = cpNode_ || cpNode;\r\n        }\r\n        if (typeof _debug_ !== \'undefined\') {\r\n            if (i + 1 === _debug_.directives.stopAfterTwoProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    }\r\n    return cpNode_;\r\n}\r\n/**\r\n * @hidden\r\n * Simple linear array indexing.\r\n * @param n\r\n */\r\nfunction indexLinear(n) {\r\n    let arr = [];\r\n    for (let i = 0; i < n; i++) {\r\n        arr.push(i);\r\n    }\r\n    return arr;\r\n}\r\n/**\r\n * @hidden\r\n * Creates a kind of interlaced index vector.\r\n * @param n\r\n*/\r\nfunction indexInterlaced(n) {\r\n    let source = {};\r\n    let arr = [];\r\n    // l is the lowest power of 2 so that 2^l > n\r\n    let l = Math.pow(2, Math.floor(Math.log2(n)));\r\n    while (l >= 1) {\r\n        let k = 0;\r\n        while (k < n) {\r\n            if (!source[k]) {\r\n                arr.push(k);\r\n                source[k] = true;\r\n            }\r\n            k = k + l;\r\n        }\r\n        l = l / 2;\r\n    }\r\n    return arr;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-and-add-2-prongs.ts?')},"./src/mat/find-mat/find-and-add-3-prongs.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findAndAddAll3Prongs": () => (/* binding */ findAndAddAll3Prongs)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _find_3_prong_find_3_prong_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./find-3-prong/find-3-prong.js */ "./src/mat/find-mat/find-3-prong/find-3-prong.ts");\n/* harmony import */ var _find_mat_add_3_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../find-mat/add-3-prong.js */ "./src/mat/find-mat/add-3-prong.ts");\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Finds and adds all 3-prongs.\r\n * @param cpGraphs\r\n * @param cpStart The CpNode to start traversing from.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddAll3Prongs(cpGraphs, cpStart, extreme) {\r\n    // Don\'t change this function to be recursive, the call stack may overflow \r\n    // if there are too many two-prongs.\r\n    let visitedEdges = new Map();\r\n    let edgesToCheck = [{ fromCpNode: undefined, cpStart }];\r\n    while (edgesToCheck.length) {\r\n        let { fromCpNode, cpStart } = edgesToCheck.shift();\r\n        markEdgeAsTaken(visitedEdges, fromCpNode, cpStart);\r\n        for (let cpNode of cpStart.getCpNodesOnCircle()) {\r\n            //if (!PointOnShape.isSharpCorner(cpNode.cp.pointOnShape)) {\r\n            if (!(0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosSharpCorner)(cpNode.cp.pointOnShape)) {\r\n                if (findAndAdd3Prongs(cpGraphs, cpNode, extreme) === undefined) {\r\n                    return; // only for debugging purposes\r\n                }\r\n                ;\r\n            }\r\n            if (hasEdgeBeenTaken(visitedEdges, cpNode, cpNode.next)) {\r\n                continue; // We already visited this edge\r\n            }\r\n            edgesToCheck.push({ fromCpNode: cpStart, cpStart: cpNode.next });\r\n        }\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n * Marks the given edge as already taken.\r\n */\r\nfunction markEdgeAsTaken(visitedEdges, cp1, cp2) {\r\n    if (cp1 === undefined) {\r\n        return;\r\n    }\r\n    f(cp1, cp2);\r\n    f(cp2, cp1);\r\n    function f(cp1, cp2) {\r\n        let visited = visitedEdges.get(cp1);\r\n        if (!visited) {\r\n            visited = new Set();\r\n            visitedEdges.set(cp1, visited);\r\n        }\r\n        visited.add(cp2);\r\n    }\r\n}\r\n/** @hidden */\r\nfunction hasEdgeBeenTaken(visitedEdges, cp1, cp2) {\r\n    let cps;\r\n    cps = visitedEdges.get(cp1);\r\n    let takenForward = cps && cps.has(cp2);\r\n    cps = visitedEdges.get(cp2);\r\n    let takenBackwards = cps && cps.has(cp1);\r\n    return takenForward || takenBackwards;\r\n}\r\n/**\r\n * @hidden\r\n * Traverses the shape from the given ContactPoint going around contact circles\r\n * so that only a piece of the shape is traversed and returns the visited\r\n * CpNodes (starting from the given CpNode).\r\n * @param cpStart The ContactPoint from where to start the traversal.\r\n */\r\nfunction traverseShape(cpStart) {\r\n    let cpNode = cpStart;\r\n    if (cpNode === cpNode.next.prevOnCircle) {\r\n        return [cpNode];\r\n    }\r\n    let visitedCps = [];\r\n    do {\r\n        visitedCps.push(cpNode);\r\n        let next = cpNode.next.prevOnCircle;\r\n        cpNode = cpNode === next\r\n            ? cpNode = cpNode.next.next // Terminal vertex\r\n            : cpNode = next; // Take last exit\r\n    } while (cpNode !== cpStart);\r\n    return visitedCps;\r\n}\r\n/**\r\n * @hidden\r\n * Starting from some ContactPoint, traverses the shape going around Vertices\r\n * and if more than two Vertices have been visited in total then recursively\r\n * adds 3-prongs until only one or two Vertices have been visited.\r\n *\r\n * This process further subdivides the shape.\r\n * @param cpGraphs\r\n * @param cpStart The ContactPoint from where to start the process.\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nlet ii = 0;\r\nfunction findAndAdd3Prongs(cpGraphs, cpStart, extreme) {\r\n    let visitedCps;\r\n    do {\r\n        visitedCps = traverseShape(cpStart);\r\n        if (visitedCps.length > 2) {\r\n            findAndAdd3Prong(cpGraphs, visitedCps, extreme);\r\n            ii++;\r\n        }\r\n        if (typeof _debug_ !== \'undefined\') {\r\n            if (ii === _debug_.directives.stopAfterThreeProngsNum) {\r\n                return undefined;\r\n            }\r\n        }\r\n    } while (visitedCps.length > 2);\r\n    return visitedCps;\r\n}\r\n/**\r\n * @hidden\r\n * Finds and add a 3-prong MAT circle to the given shape.\r\n * @param cpGraphs\r\n * @param visitedCps\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAdd3Prong(cpGraphs, visitedCps, extreme) {\r\n    let δs = [];\r\n    for (let visitedCp of visitedCps) {\r\n        δs.push([visitedCp, visitedCp.next]);\r\n    }\r\n    let threeProng = (0,_find_3_prong_find_3_prong_js__WEBPACK_IMPORTED_MODULE_1__.find3Prong)(δs, extreme);\r\n    let orders = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        orders.push(\r\n        //PointOnShape.calcOrder(threeProng.circle, threeProng.ps[i])\r\n        (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.calcPosOrder)(threeProng.circle, threeProng.ps[i]));\r\n    }\r\n    let circle = (0,_find_mat_add_3_prong_js__WEBPACK_IMPORTED_MODULE_2__.add3Prong)(cpGraphs, orders, threeProng);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        add3ProngDebugInfo(circle, visitedCps);\r\n    }\r\n}\r\n/** @hidden */\r\nfunction add3ProngDebugInfo(circle, visitedCps) {\r\n    let threeProngs = _debug_.generated.elems.threeProng;\r\n    let len = threeProngs.length;\r\n    let data = threeProngs[len - 1];\r\n    data.visitedCps = visitedCps;\r\n    data.circle = circle;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-and-add-3-prongs.ts?')},"./src/mat/find-mat/find-and-add-hole-closing-2-prongs.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "findAndAddHoleClosing2Prongs": () => (/* binding */ findAndAddHoleClosing2Prongs)\n/* harmony export */ });\n/* harmony import */ var _svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../svg/get-shape-bounds.js */ "./src/svg/get-shape-bounds.ts");\n/* harmony import */ var _svg_get_min_y_pos_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../svg/get-min-y-pos.js */ "./src/svg/get-min-y-pos.ts");\n/* harmony import */ var _find_2_prong_find_2_prong_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./find-2-prong/find-2-prong.js */ "./src/mat/find-mat/find-2-prong/find-2-prong.ts");\n/* harmony import */ var _add_2_prong_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-2-prong.js */ "./src/mat/find-mat/add-2-prong.ts");\n\r\n\r\n\r\n\r\n/**\r\n * @hidden\r\n * Find and add two-prongs that remove any holes in the shape.\r\n * @param loops The loops (that as a precondition must be ordered from\r\n * highest (i.e. smallest y-value) topmost point loops to lowest)\r\n * @param cpTrees\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n */\r\nfunction findAndAddHoleClosing2Prongs(loops, cpTrees, extreme) {\r\n    let bounds = (0,_svg_get_shape_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getShapeBounds)(loops);\r\n    let squaredDiagonalLength = (bounds.maxX.p[0] - bounds.minX.p[0]) ** 2 +\r\n        (bounds.maxY.p[1] - bounds.minY.p[1]) ** 2;\r\n    // Find the topmost points on each loop.\r\n    let minYs = loops.map(_svg_get_min_y_pos_js__WEBPACK_IMPORTED_MODULE_1__.getMinYPos);\r\n    // We start at 1 since 0 is the outer (root) loop\r\n    for (let k = 1; k < minYs.length; k++) {\r\n        let posSource = minYs[k];\r\n        let holeClosingTwoProng = (0,_find_2_prong_find_2_prong_js__WEBPACK_IMPORTED_MODULE_2__.find2Prong)(loops, extreme, squaredDiagonalLength, cpTrees, posSource, true, k);\r\n        if (!holeClosingTwoProng) {\r\n            throw new Error(`Unable to find hole-closing 2-prong`);\r\n        }\r\n        // TODO important - handle case of n-prong, i.e. more than one antipode\r\n        // - currently we only handle case of single antipode (the general case)\r\n        let { circle, zs: posAntipodes } = holeClosingTwoProng;\r\n        (0,_add_2_prong_js__WEBPACK_IMPORTED_MODULE_3__.add2Prong)(cpTrees, circle, posSource, [posAntipodes[0]], true, extreme);\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/find-and-add-hole-closing-2-prongs.ts?')},"./src/mat/find-mat/get-potential-2-prongs.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getPotential2Prongs": () => (/* binding */ getPotential2Prongs)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n/** @hidden */\r\nfunction getPotential2Prongs(possPerLoop) {\r\n    let for2ProngsArray = [];\r\n    for (let poss of possPerLoop) {\r\n        let for2Prongs = [];\r\n        for (let pos of poss) {\r\n            if (!(0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(pos)) {\r\n                for2Prongs.push(pos);\r\n            }\r\n        }\r\n        for2ProngsArray.push(for2Prongs);\r\n    }\r\n    return for2ProngsArray;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/get-potential-2-prongs.ts?')},"./src/mat/find-mat/get-sharp-corners.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getSharpCorners": () => (/* binding */ getSharpCorners)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n/** @hidden */\r\nfunction getSharpCorners(possPerLoop) {\r\n    let sharpCornersPerLoop = [];\r\n    for (let poss of possPerLoop) {\r\n        let sharpCorners = [];\r\n        for (let pos of poss) {\r\n            //if (PointOnShape.isQuiteSharpCorner(pos)) {\r\n            if ((0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(pos)) {\r\n                sharpCorners.push(pos);\r\n            }\r\n        }\r\n        sharpCornersPerLoop.push(sharpCorners);\r\n    }\r\n    return sharpCornersPerLoop;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/find-mat/get-sharp-corners.ts?')},"./src/mat/geometry/get-closest-square-distance-to-rect.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getClosestSquareDistanceToRect": () => (/* binding */ getClosestSquareDistanceToRect)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\nconst squaredDistanceBetween = flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween;\r\n/**\r\n * @hidden\r\n */\r\nfunction getClosestSquareDistanceToRect(box, p) {\r\n    const p0 = box[0];\r\n    const p1 = box[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const xp = p[0];\r\n    const yp = p[1];\r\n    //let [[x0,y0],[x1,y1]] = box;\r\n    //let [xp,yp] = p;\r\n    if (xp < x0) {\r\n        if (yp < y0) {\r\n            return squaredDistanceBetween(box[0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return squaredDistanceBetween([x0, y1], p);\r\n        }\r\n        else {\r\n            return (x0 - xp) ** 2;\r\n        }\r\n    }\r\n    else if (xp > x1) {\r\n        if (yp < y0) {\r\n            return squaredDistanceBetween([x1, y0], p);\r\n        }\r\n        else if (yp > y1) {\r\n            return squaredDistanceBetween(box[1], p);\r\n        }\r\n        else {\r\n            return (xp - x1) ** 2;\r\n        }\r\n    }\r\n    else {\r\n        if (yp < y0) {\r\n            return (y0 - yp) ** 2;\r\n        }\r\n        else if (yp > y1) {\r\n            return (yp - y1) ** 2;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/geometry/get-closest-square-distance-to-rect.ts?')},"./src/mat/geometry/get-closest-squared-distance-to-rotated-rect.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getClosestSquaredDistanceToRotatedRect": () => (/* binding */ getClosestSquaredDistanceToRotatedRect)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * @hidden\r\n */\r\nfunction getClosestSquaredDistanceToRotatedRect(ps, p) {\r\n    let ds = [0, 1, 2, 3].map(i => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetweenPointAndLineSegment)(p, [ps[i], ps[(i + 1) % 4]]));\r\n    let width = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(ps[0], ps[1]);\r\n    let height = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(ps[0], ps[3]);\r\n    if (ds[0] <= height && ds[2] <= height &&\r\n        ds[1] <= width && ds[3] <= width) {\r\n        return 0; // Inside rotated rect\r\n    }\r\n    return Math.min(...ds);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/geometry/get-closest-squared-distance-to-rotated-rect.ts?')},"./src/mat/get-boundary-piece-beziers.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundaryPieceBeziers": () => (/* binding */ getBoundaryPieceBeziers)\n/* harmony export */ });\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point-on-shape.js */ "./src/point-on-shape.ts");\n/* harmony import */ var _contact_point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contact-point.js */ "./src/contact-point.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Returns the ordered cubic bezier pieces (i.e a bezier with a t range)\r\n * from the given boundary piece.\r\n * @param cpNodes - An ordered pair that represents the start and end points of\r\n * the boundary piece\r\n */\r\nfunction getBoundaryPieceBeziers(cpNodes) {\r\n    let cpThis = cpNodes[0];\r\n    let cpEnd = cpNodes[1];\r\n    let bezierPieces = [];\r\n    // As opposed to going around the circle and taking the last exit\r\n    let goStraight = true;\r\n    do {\r\n        if (!goStraight) {\r\n            goStraight = true;\r\n            cpThis = cpThis.prevOnCircle; // take last exit\r\n            continue;\r\n        }\r\n        goStraight = false;\r\n        let posThis = cpThis.cp.pointOnShape;\r\n        let posNext = cpThis.next.cp.pointOnShape;\r\n        if (posNext.curve === posThis.curve &&\r\n            //PointOnShape.isQuiteSharpCorner(posThis) && \r\n            //PointOnShape.isQuiteSharpCorner(posNext)) {\r\n            (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(posThis) &&\r\n            (0,_point_on_shape_js__WEBPACK_IMPORTED_MODULE_0__.isPosQuiteSharpCorner)(posNext)) {\r\n            // Do nothing\r\n        }\r\n        else if (posNext.curve === posThis.curve &&\r\n            (0,_contact_point_js__WEBPACK_IMPORTED_MODULE_1__.compareCps)(cpThis.next.cp, cpThis.cp) > 0) {\r\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, posNext.t] });\r\n        }\r\n        else {\r\n            bezierPieces.push({ curve: posThis.curve, ts: [posThis.t, 1] });\r\n            if (cpThis.cp.pointOnShape.curve.loop === cpThis.next.cp.pointOnShape.curve.loop) {\r\n                addSkippedBeziers(bezierPieces, posThis.curve, posNext.curve, posNext.t);\r\n            }\r\n        }\r\n        cpThis = cpThis.next;\r\n    } while (cpThis !== cpEnd);\r\n    return bezierPieces;\r\n}\r\n/**\r\n * @hidden\r\n * Adds pieces of skipped beziers\r\n */\r\nfunction addSkippedBeziers(bezierPieces, curveStart, curveEnd, t1) {\r\n    let curveThis = curveStart;\r\n    do {\r\n        curveThis = curveThis.next;\r\n        let tEnd = curveThis === curveEnd ? t1 : 1;\r\n        bezierPieces.push({ curve: curveThis, ts: [0, tEnd] });\r\n    } while (curveThis !== curveEnd);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-boundary-piece-beziers.ts?')},"./src/mat/get-contact-circles-at-interface.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getContactCirclesAtInterface": () => (/* binding */ getContactCirclesAtInterface)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curve.js */ "./src/curve.ts");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * @param curve\r\n */\r\nfunction getContactCirclesAtInterface(curve) {\r\n    let { isQuiteSharp, isQuiteDull } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.getCornerAtEnd)(curve);\r\n    if (isQuiteSharp) {\r\n        return [new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(curve, 1)];\r\n    }\r\n    else if (isQuiteDull) {\r\n        return [\r\n            new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(curve, 1),\r\n            new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(curve.next, 0)\r\n        ];\r\n    }\r\n    return [];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-contact-circles-at-interface.ts?')},"./src/mat/get-largest-vertex.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLargestVertex": () => (/* binding */ getLargestVertex)\n/* harmony export */ });\n/** @hidden */\r\nfunction getLargestVertex(cpNodes) {\r\n    return cpNodes.reduce(function (maxCpNode, cpNode) {\r\n        return maxCpNode.cp.circle.radius >= cpNode.cp.circle.radius\r\n            ? maxCpNode\r\n            : cpNode;\r\n    }, cpNodes[0]);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-largest-vertex.ts?')},"./src/mat/get-leaves.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLeaves": () => (/* binding */ getLeaves)\n/* harmony export */ });\n/** @hidden */\r\nfunction getLeaves(cpNode) {\r\n    let leaves = [];\r\n    let cps = cpNode.getAllOnLoop();\r\n    cps.forEach(function (cp) {\r\n        if (cp.isTerminating()) {\r\n            leaves.push(cp);\r\n        }\r\n    });\r\n    return leaves;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-leaves.ts?')},"./src/mat/get-neighboring-cps.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getNeighbouringPoints": () => (/* binding */ getNeighbouringPoints)\n/* harmony export */ });\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cp-node.js */ "./src/cp-node.ts");\n\r\n/**\r\n * @hidden\r\n * Returns the boundary piece that starts at the immediate previous point on the\r\n * shape and ends at the immediate next point.\r\n * @param cpTree\r\n * @param pos\r\n * @param order\r\n * @param order2\r\n */\r\nfunction getNeighbouringPoints(cpTree, pos, order, order2) {\r\n    let cps = cpTree.findBounds(new _cp_node_js__WEBPACK_IMPORTED_MODULE_0__.CpNode({ pointOnShape: pos, circle: undefined, order, order2 }, false, false));\r\n    if (!cps[0] && !cps[1]) {\r\n        // The tree is still empty\r\n        return [undefined, undefined];\r\n    }\r\n    if (!cps[0] || !cps[1]) {\r\n        // Smaller than all -> cptree.min() === cps[1].data OR\r\n        // Larger  than all -> cptree.max() === cps[0].data\r\n        return [\r\n            cpTree.max(cpTree.root),\r\n            cpTree.min(cpTree.root)\r\n        ];\r\n    }\r\n    return [\r\n        cps[0].datum,\r\n        cps[1].datum\r\n    ];\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-neighboring-cps.ts?')},"./src/mat/get-two-prong-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getTwoProngType\": () => (/* binding */ getTwoProngType)\n/* harmony export */ });\n/** @hidden */\r\nfunction getTwoProngType(e) {\r\n    if (e.holeClosing) {\r\n        return 'twoProng_holeClosing';\r\n    }\r\n    return 'twoProng_regular';\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/get-two-prong-type.ts?")},"./src/mat/is-another-cp-closeby.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isAnotherCpCloseby": () => (/* binding */ isAnotherCpCloseby)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-neighboring-cps.js */ "./src/mat/get-neighboring-cps.ts");\n\r\n\r\n/** @hidden */\r\n//const ANGLE_THRESHOLD = Math.cos(3 * (Math.PI / 180)); // 3 degrees\r\nconst ANGLE_THRESHOLD = 0.9986295347545738; // === Math.cos(3  degrees)\r\n//const ANGLE_THRESHOLD = 0.9848077530122080; // === Math.cos(10 degrees)\r\n//const ANGLE_THRESHOLD = 0.9998476951563913; // === Math.cos(1 degrees)\r\n//const ANGLE_THRESHOLD = 0.9999984769132877; // === Math.cos(0.1 degrees)   \r\n//const ANGLE_THRESHOLD = 0.9999999847691291  // === Math.cos(0.01 degrees)   \r\n/**\r\n * @hidden\r\n * Returns true if another CpNode is close to the given implied (via pos, order\r\n * and order2) CpNode.\r\n * @param cpTrees\r\n * @param pos\r\n * @param circle\r\n * @param order\r\n * @param order2\r\n * @param extreme The maximum coordinate value used to calculate floating point\r\n * tolerances.\r\n * @param color Used for debugging only\r\n */\r\nfunction isAnotherCpCloseby(cpTrees, pos, circle, order, order2, extreme, color) {\r\n    //console.log(extreme)\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1; \r\n    //const DISTANCE_THRESHOLD = extreme * 1e-1;\r\n    const DISTANCE_THRESHOLD = extreme * 1e-4;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-4; - was this\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-6;\r\n    //const DISTANCE_THRESHOLD = extreme * 1e-12;\r\n    // It seems this can be zero else the ordering should be correct\r\n    //const DISTANCE_THRESHOLD = 0;\r\n    let cpTree = cpTrees.get(pos.curve.loop);\r\n    let cpNodes = (0,_get_neighboring_cps_js__WEBPACK_IMPORTED_MODULE_1__.getNeighbouringPoints)(cpTree, pos, order, order2);\r\n    if (!cpNodes[0]) {\r\n        return false;\r\n    }\r\n    for (let cpNode of cpNodes) {\r\n        let pos2 = cpNode.cp.pointOnShape;\r\n        let p1 = pos.p;\r\n        let p2 = pos2.p;\r\n        if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p1, p2) > DISTANCE_THRESHOLD) {\r\n            continue;\r\n        }\r\n        let v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(cpNode.cp.pointOnShape.p, cpNode.cp.circle.center));\r\n        let v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(p1, circle.center));\r\n        let cosTheta = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(v1, v2);\r\n        if (cosTheta > ANGLE_THRESHOLD) {\r\n            //console.log(`%c${cosTheta} - ${distanceBetween(p1,p2)}`, `color: ${color}`);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/is-another-cp-closeby.ts?')},"./src/mat/simplify-mat-map-only.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "simplifyMatMapOnly": () => (/* binding */ simplifyMatMapOnly)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _get_branches_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../get-branches.js */ "./src/get-branches.ts");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-curve/get-curve-between.js */ "./src/get-curve/get-curve-between.ts");\n\r\n\r\n\r\n\r\n/**\r\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\r\n * the MAT with fewer ones to within a given tolerance. Returns the map of\r\n * to be deleted nodes only - does not actually delete them. Use simplifyMat\r\n * instead if you want to delete the nodes.\r\n * @param cpNode A representation of the MAT\r\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required - defaults to 15.\r\n * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\r\n * defaults to 0.1\r\n * @param hausdorffSpacing The spacing on the curves used to calculate the Hausdorff\r\n * Distance - defaults to 1\r\n */\r\nfunction simplifyMatMapOnly(cpNode, anlgeTolerance = 15, hausdorffTolerance = 1e-1, hausdorffSpacing = 1e0) {\r\n    let simpleMap = new Map();\r\n    // Start from a leaf\r\n    while (!cpNode.isTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = (0,_get_branches_js__WEBPACK_IMPORTED_MODULE_1__.getBranches)(cpNode, anlgeTolerance);\r\n    let canDeletes = [];\r\n    for (let k = 0; k < branches.length; k++) {\r\n        let branch = branches[k];\r\n        // Try to remove some\r\n        let j = 0;\r\n        while (j < branch.length) {\r\n            let i = j;\r\n            while (true) {\r\n                j++;\r\n                if (j === branch.length) {\r\n                    break;\r\n                }\r\n                let hd = getTotalHausdorffDistance(i, j, branch, hausdorffSpacing);\r\n                if (hd > hausdorffTolerance) {\r\n                    break;\r\n                }\r\n                else {\r\n                    canDeletes.push(branch[j]);\r\n                }\r\n            }\r\n            if (i + 1 === j) {\r\n                // no simplification occured\r\n            }\r\n            else {\r\n                let branStart = branch[i];\r\n                let branEnd = branch[j - 1];\r\n                let medial = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toCubic)((0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__.getCurveBetween)(branStart, branEnd.next));\r\n                let rev = medial.slice().reverse();\r\n                let curCpNode = branStart;\r\n                let prevT = 0;\r\n                while (curCpNode !== branEnd) {\r\n                    let t = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezier)(medial, curCpNode.next.cp.circle.center).t;\r\n                    simpleMap.set(curCpNode, { ps: medial, ts: [prevT, t] });\r\n                    let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                    simpleMap.set(oppositeCpNode, { ps: rev, ts: [1 - t, 1 - prevT] });\r\n                    prevT = t;\r\n                    curCpNode = curCpNode.next;\r\n                }\r\n                simpleMap.set(curCpNode, { ps: medial, ts: [prevT, 1] });\r\n                let oppositeCpNode = curCpNode.nextOnCircle.prev;\r\n                simpleMap.set(oppositeCpNode, { ps: rev, ts: [0, 1 - prevT] });\r\n            }\r\n        }\r\n    }\r\n    return { simpleMap, cpNode };\r\n}\r\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\r\n    let hds = [];\r\n    let longCurve = (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_3__.getCurveBetween)(branch[i], branch[j].next);\r\n    for (let m = i; m < j + 1; m++) {\r\n        hds.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistance)((0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_2__.getCurveToNext)(branch[m]), longCurve, hausdorffSpacing));\r\n    }\r\n    return Math.max(...hds);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/simplify-mat-map-only.ts?')},"./src/mat/to-scale-axis/add-debug-info.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addDebugInfo\": () => (/* binding */ addDebugInfo)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * @param sat\r\n */\r\nfunction addDebugInfo(sat, timingStart) {\r\n    if (typeof _debug_ === 'undefined') {\r\n        return;\r\n    }\r\n    _debug_.generated.elems.sat.push(sat);\r\n    let timing = _debug_.generated.timing;\r\n    timing.sats = performance.now() - timingStart;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/to-scale-axis/add-debug-info.ts?")},"./src/mat/to-scale-axis/cull-non-cycles.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cullNonCycles": () => (/* binding */ cullNonCycles)\n/* harmony export */ });\n/* harmony import */ var _get_leaves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-leaves.js */ "./src/mat/get-leaves.ts");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../cp-node.js */ "./src/cp-node.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Cull all edges not part of a cycle in the MAT planar graph.\r\n * @param cpStart The start CpNode which must reprsesent the maximal 3-prong\r\n * vertex.\r\n */\r\nfunction cullNonCycles(cpStart) {\r\n    let cpNodeKept = cpStart;\r\n    let leaves = (0,_get_leaves_js__WEBPACK_IMPORTED_MODULE_0__.getLeaves)(cpStart);\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology - keep cycles.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (cpNode.getProngCount() > 2) {\r\n                //let cp2 = cp1.prevOnCircle;\r\n                let cp2 = cpNode.nextOnCircle;\r\n                //if (cpStart === cpNode || cpStart === cp1 || cpStart === cp2) {\r\n                if (_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.isOnSameCircle(cpNode, cpStart)) {\r\n                    cut = true; // We are at the max disk - cut whole edge\r\n                }\r\n                else if (cpNode.next === cp2) {\r\n                    cpNode = cp2;\r\n                }\r\n                else if (cp2.next !== cp1) {\r\n                    cut = true; // Cut whole edge\r\n                }\r\n            }\r\n            else if (cpNode.isTerminating() && !cpNode.isIntersection) {\r\n                cpNodeKept = cpNode;\r\n                return undefined;\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                cpNodeKept = cpNode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return cpNodeKept;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/to-scale-axis/cull-non-cycles.ts?')},"./src/mat/to-scale-axis/cull.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cull": () => (/* binding */ cull)\n/* harmony export */ });\n/* harmony import */ var _get_leaves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-leaves.js */ "./src/mat/get-leaves.ts");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../cp-node.js */ "./src/cp-node.ts");\n\r\n\r\n/**\r\n * @hidden\r\n * Returns the set of Vertices passing the following test: walk the MAT tree and\r\n * keep all Vertices not in the current cull set and any Vertices that have a\r\n * non-culled node further down the line toward the tree leaves.\r\n * @param culls The CpNodes (referred to by circles) that should be culled.\r\n * @param maxCpNode The start CpNode which must reprsesent the maximal vertex.\r\n */\r\nfunction cull(culls, maxCpNode) {\r\n    let leaves = (0,_get_leaves_js__WEBPACK_IMPORTED_MODULE_0__.getLeaves)(maxCpNode);\r\n    function getNonTrivialEdges(cpStart) {\r\n        let cp = cpStart;\r\n        let cps = [];\r\n        do {\r\n            if (cp.next !== cp.nextOnCircle) {\r\n                cps.push(cp);\r\n            }\r\n            cp = cp.nextOnCircle;\r\n        } while (cp !== cpStart.prevOnCircle);\r\n        return cps;\r\n    }\r\n    while (leaves.length) {\r\n        let leaf = leaves.pop();\r\n        // Preserve topology.\r\n        if (leaf.isHoleClosing || leaf.isIntersection) {\r\n            continue;\r\n        }\r\n        if (!culls.has(leaf.cp.circle)) {\r\n            continue;\r\n        }\r\n        let cpNode = leaf.next; // Turn around\r\n        while (true) {\r\n            cpNode = cpNode.next;\r\n            let cut = false;\r\n            let cp1 = cpNode.prevOnCircle;\r\n            if (!culls.has(cpNode.cp.circle)) {\r\n                // Cut off the edge once a non-cull has been reached.\r\n                cut = true;\r\n            }\r\n            else if (_cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.isOnSameCircle(cpNode, maxCpNode)) {\r\n                cut = true; // We are at the max disk - cut whole edge\r\n            }\r\n            else {\r\n                let cps = getNonTrivialEdges(cpNode);\r\n                if (cps.length === 1) {\r\n                    cpNode = cps[0];\r\n                }\r\n                else {\r\n                    cut = true;\r\n                }\r\n            }\r\n            if (cut) {\r\n                cp1.next = cpNode;\r\n                cpNode.prev = cp1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/*\r\nfunction cull(\r\n    culls: Set<Circle>,\r\n    maxCpNode: CpNode) {\r\n\r\nlet leaves = getLeaves(maxCpNode);\r\n\r\nfunction getNonTrivialBranches(cpStart: CpNode) {\r\n    let cp = cpStart.next;\r\n    \r\n    let cps: CpNode[] = [];\r\n    do {\r\n        if (cp.next !== cp.nextOnCircle) {\r\n            cps.push(cp);\r\n        }\r\n        cp = cp.nextOnCircle;\r\n    } while (cp !== cpStart)\r\n\r\n    return cps;\r\n}\r\n\r\nwhile (leaves.length) {\r\n    let leaf = leaves.pop();\r\n\r\n    // Preserve topology.\r\n    if (leaf.isHoleClosing || leaf.isIntersection) { continue; }\r\n\r\n    if (!culls.has(leaf.cp.circle)) {\r\n        continue;\r\n    }\r\n\r\n    let cpNode = leaf.next; // Turn around\r\n\r\n    while (true) {\r\n        cpNode = cpNode.next;\r\n        let cut = false;\r\n        let cp1 = cpNode.prevOnCircle;\r\n\r\n        if (!culls.has(cpNode.cp.circle)) {\r\n            // Cut the branch once a non-cull has been reached.\r\n            cut = true;\r\n        } else {\r\n            //let cp2 = cp1.prevOnCircle;\r\n            let cp2 = cpNode.nextOnCircle;\r\n\r\n            //if (maxCpNode === cpNode || maxCpNode === cp1 || maxCpNode === cp2) {\r\n            if (CpNode.isOnSameCircle(cpNode, maxCpNode)) {\r\n                cut = true; // We are at the max disk - cut whole edge\r\n            } else if (cpNode.next === cp2) {\r\n                // Continue but starting from cp2\r\n                cpNode = cp2;\r\n            } else if (cp2.next === cp1) {\r\n                // Do nothing - ignore the branch starting from cp2 since it\r\n                // is terminating.\r\n            } else if (cp2.next !== cp1) {\r\n                // At this stage (cpNode.next !== cp2 && cp2.next !== cp1)\r\n                // so it is a bifurcation point - cut the edge.\r\n                cut = true;\r\n            }\r\n        }\r\n\r\n        if (cut) {\r\n            cp1.next = cpNode;\r\n            cpNode.prev = cp1;\r\n            break;\r\n        }\r\n    }\r\n}\r\n}\r\n*/\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/to-scale-axis/cull.ts?')},"./src/mat/trim-mat.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "trimMat": () => (/* binding */ trimMat)\n/* harmony export */ });\n/* harmony import */ var _create_new_cp_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-new-cp-tree.js */ "./src/mat/create-new-cp-tree.ts");\n/* harmony import */ var _to_scale_axis_cull_non_cycles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./to-scale-axis/cull-non-cycles.js */ "./src/mat/to-scale-axis/cull-non-cycles.ts");\n/* harmony import */ var _cp_node_clone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cp-node/clone.js */ "./src/cp-node/clone.ts");\n\r\n\r\n\r\n/**\r\n * Trims the given Medial Axis Transform so that only cycles remain. Similar to\r\n * toScaleAxis(mat, Number.POSITIVE_INFINITY).\r\n * @param mat The MAT to trim.\r\n */\r\nfunction trimMat(mat) {\r\n    let cpNode = (0,_to_scale_axis_cull_non_cycles_js__WEBPACK_IMPORTED_MODULE_1__.cullNonCycles)((0,_cp_node_clone_js__WEBPACK_IMPORTED_MODULE_2__.clone)(mat.cpNode));\r\n    if (!cpNode) {\r\n        return undefined;\r\n    }\r\n    return { cpNode, cpTrees: (0,_create_new_cp_tree_js__WEBPACK_IMPORTED_MODULE_0__.createNewCpTree)(cpNode) };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/mat/trim-mat.ts?')},"./src/point-on-shape.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "PointOnShape": () => (/* binding */ PointOnShape),\n/* harmony export */   "calcPosOrder": () => (/* binding */ calcPosOrder),\n/* harmony export */   "comparePoss": () => (/* binding */ comparePoss),\n/* harmony export */   "getOsculatingCircle": () => (/* binding */ getOsculatingCircle),\n/* harmony export */   "isPosDullCorner": () => (/* binding */ isPosDullCorner),\n/* harmony export */   "isPosQuiteDullCorner": () => (/* binding */ isPosQuiteDullCorner),\n/* harmony export */   "isPosQuiteSharpCorner": () => (/* binding */ isPosQuiteSharpCorner),\n/* harmony export */   "isPosSharpCorner": () => (/* binding */ isPosSharpCorner),\n/* harmony export */   "posToHumanString": () => (/* binding */ posToHumanString)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curve.js */ "./src/curve.ts");\n\r\n\r\n\r\n\r\n/**\r\n * Represents a point on the shape boundary for which MAT vertex information\r\n * has not *necessarily* been calculated.\r\n */\r\nclass PointOnShape {\r\n    /**\r\n     * @param curve\tThe [[ICurve]] on the shape boundary this points belong to.\r\n     * @param t The bezier parameter value on the curve to identify the point\r\n     * coordinates.\r\n     */\r\n    constructor(curve, t) {\r\n        this.curve = curve;\r\n        this.t = t;\r\n        // Cache\r\n        this.p_ = undefined;\r\n    }\r\n    /**\r\n     * The planar point coordinates of this [[PointOnShape]].\r\n     */\r\n    get p() {\r\n        return this.p_ === undefined\r\n            ? this.p_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(this.curve.ps, this.t)\r\n            : this.p_;\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction isPosCorner(pos) {\r\n    return (pos.t === 0 || pos.t === 1);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nfunction getPosCorner(pos) {\r\n    return (0,_curve_js__WEBPACK_IMPORTED_MODULE_3__.getCornerAtEnd)(pos.t === 1 ? pos.curve : pos.curve.prev);\r\n}\r\n/**\r\n * @hidden\r\n */\r\nlet isPosSharpCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isSharp;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nlet isPosDullCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isDull;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nlet isPosQuiteSharpCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isQuiteSharp;\r\n});\r\n/**\r\n * @hidden\r\n */\r\nlet isPosQuiteDullCorner = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)((pos) => {\r\n    if (!isPosCorner(pos)) {\r\n        return false;\r\n    }\r\n    return getPosCorner(pos).isQuiteDull;\r\n});\r\n/**\r\n * Returns a human-readable string of the given [[PointOnShape]].\r\n * For debugging only.\r\n * @hidden\r\n */\r\nfunction posToHumanString(pos) {\r\n    return \'\' + pos.p[0] + \', \' + pos.p[1] +\r\n        \' | bz: \' + pos.curve.idx +\r\n        \' | t: \' + pos.t;\r\n}\r\n/**\r\n * @hidden\r\n * Calculates the order (to distinguish between points lying on top of each\r\n * other) of the contact point if it is a dull corner.\r\n * @param pos\r\n */\r\nfunction calcPosOrder(circle, pos) {\r\n    if (!isPosCorner(pos)) {\r\n        return 0;\r\n    }\r\n    if (!isPosDullCorner(pos)) {\r\n        return 0;\r\n    }\r\n    //if (!isPosDullCorner(pos)) { return 0; }\r\n    let corner = getPosCorner(pos);\r\n    let n = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotateNeg90Degrees)(corner.tangents[0]);\r\n    let v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(pos.p, circle.center));\r\n    return -(0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(n, v);\r\n}\r\n/**\r\n * Compares two [[PointOnShape]]s according to their cyclic ordering imposed\r\n * by their relative positions on the shape boundary.\r\n * @param a The first [[PointOnShape]].\r\n * @param b The second [[PointOnShape]].\r\n * @hidden\r\n */\r\nfunction comparePoss(a, b) {\r\n    if (a === undefined || b === undefined) {\r\n        return undefined;\r\n    }\r\n    let res;\r\n    res = a.curve.idx - b.curve.idx;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    res = a.t - b.t;\r\n    return res;\r\n}\r\n/**\r\n * Calculates and returns the osculating circle radius of the bezier at a\r\n * specific t. If it is found to have negative or nearly zero radius\r\n * it is clipped to have positive radius so it can point into the shape.\r\n * @param ps\r\n * @param t\r\n * @hidden\r\n */\r\nlet calcOsculatingCircleRadius = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)((pos) => {\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    let c = -(0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.curvature)(ps, t);\r\n    // c > 0 => bending inwards\r\n    return 1 / c;\r\n});\r\n/**\r\n * Returns the osculating circle at this point of the curve.\r\n * @param maxOsculatingCircleRadius If not Number.POSITIVE_INFINITY then the\r\n * circle radius will be limited to this value.\r\n * @param pos The [[PointOnShape]] identifying the point.\r\n */\r\nfunction getOsculatingCircle(maxOsculatingCircleRadius, pos) {\r\n    if (isPosSharpCorner(pos)) {\r\n        return { center: pos.p, radius: 0 };\r\n    }\r\n    let radius = calcOsculatingCircleRadius(pos);\r\n    if (radius < 0) {\r\n        radius = Number.POSITIVE_INFINITY;\r\n    }\r\n    radius = Math.min(radius, maxOsculatingCircleRadius);\r\n    let ps = pos.curve.ps;\r\n    let t = pos.t;\r\n    const tangent_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.tangent)(ps, t);\r\n    let normal_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toUnitVector)([-tangent_[1], tangent_[0]]);\r\n    let p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\r\n    let circleCenter = [\r\n        p[0] - normal_[0] * radius,\r\n        p[1] - normal_[1] * radius\r\n    ];\r\n    return { center: circleCenter, radius };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/point-on-shape.ts?')},"./src/simplify-mat.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "simplifyMat": () => (/* binding */ simplifyMat)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _cp_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cp-node.js */ "./src/cp-node.ts");\n/* harmony import */ var _get_branches_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-branches.js */ "./src/get-branches.ts");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n/* harmony import */ var _get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-curve/get-curve-between.js */ "./src/get-curve/get-curve-between.ts");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Simplifies the given MAT by replacing the piecewise quad beziers composing\r\n * the MAT with fewer ones to within a given tolerance.\r\n * @param cpNode A representation of the MAT\r\n * @param anlgeTolerance Tolerance given as the degrees difference of the unit\r\n * direction vectors at the interface between curves. A tolerance of zero means\r\n * perfect smoothness is required - defaults to 15.\r\n * TODO - the next two params are wrong??\r\n * @param hausdorffTolerance The approximate maximum Hausdorff Distance tolerance -\r\n * defaults to 0.1\r\n * @param maxIterations The spacing on the curves used to calculate the Hausdorff\r\n * Distance - defaults to 1\r\n */\r\nfunction simplifyMat(mat, anlgeTolerance = 15, hausdorffTolerance = 2 ** -3, maxIterations = 50) {\r\n    let cpNode = mat.cpNode;\r\n    // Start from a leaf\r\n    while (!cpNode.isTerminating()) {\r\n        cpNode = cpNode.next;\r\n    }\r\n    let branches = (0,_get_branches_js__WEBPACK_IMPORTED_MODULE_2__.getBranches)(cpNode, anlgeTolerance);\r\n    let canDeletes = [];\r\n    for (let k = 0; k < branches.length; k++) {\r\n        let branch = branches[k];\r\n        // Try to remove some\r\n        let j = 0;\r\n        while (j < branch.length) {\r\n            let i = j;\r\n            while (true) {\r\n                j++;\r\n                if (j === branch.length) {\r\n                    break;\r\n                }\r\n                let hd = getTotalHausdorffDistance(i, j, branch, maxIterations);\r\n                if (hd > hausdorffTolerance) {\r\n                    break;\r\n                }\r\n                else {\r\n                    canDeletes.push(branch[j]);\r\n                }\r\n            }\r\n            if (i + 1 === j) {\r\n                // no simplification occured\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (let cpNode of canDeletes) {\r\n        let isTerminating = cpNode.isTerminating();\r\n        let onCircleCount = cpNode.getCpNodesOnCircle().length;\r\n        if (isTerminating || onCircleCount !== 2) {\r\n            continue;\r\n        }\r\n        _cp_node_js__WEBPACK_IMPORTED_MODULE_1__.CpNode.remove(cpNode);\r\n    }\r\n    //return { cpNode, cpTrees: createNewCpTree(cpNode) }; \r\n    return { cpNode, cpTrees: undefined };\r\n}\r\nfunction getTotalHausdorffDistance(i, j, branch, hausdorffSpacing) {\r\n    let hds = [];\r\n    let longCurve = (0,_get_curve_get_curve_between_js__WEBPACK_IMPORTED_MODULE_4__.getCurveBetween)(branch[i], branch[j].next);\r\n    for (; i < j + 1; i++) {\r\n        hds.push((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistance)((0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_3__.getCurveToNext)(branch[i]), longCurve, hausdorffSpacing));\r\n    }\r\n    return Math.max(...hds);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/simplify-mat.ts?')},"./src/svg/get-loop-bounds.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopBounds": () => (/* binding */ getLoopBounds)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point-on-shape.js */ "./src/point-on-shape.ts");\n\r\n\r\n\r\n/** @hidden */\r\nconst INF = Number.POSITIVE_INFINITY;\r\n/**\r\n * @hidden\r\n */\r\nlet getLoopBounds = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(function (loop) {\r\n    let extremes = [\r\n        [\r\n            { bezier: undefined, t: undefined, val: INF },\r\n            { bezier: undefined, t: undefined, val: INF }\r\n        ],\r\n        [\r\n            { bezier: undefined, t: undefined, val: -INF },\r\n            { bezier: undefined, t: undefined, val: -INF }\r\n        ]\r\n    ];\r\n    loop.curves.forEach(function (curve) {\r\n        let ps = curve.ps;\r\n        // let bounds = getBounds_(ps);\r\n        let bounds = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBounds)(ps);\r\n        {\r\n            {\r\n                let v = bounds.box[0][0];\r\n                let x = extremes[0][0].val;\r\n                if (v < x || (v === x && bounds.ts[0][0] > extremes[0][0].t)) {\r\n                    extremes[0][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[0][1];\r\n                let x = extremes[0][1].val;\r\n                if (v < x || (v === x && bounds.ts[0][1] > extremes[0][1].t)) {\r\n                    extremes[0][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        {\r\n            {\r\n                let v = bounds.box[1][0];\r\n                let x = extremes[1][0].val;\r\n                if (v > x || (v === x && bounds.ts[1][0] > extremes[1][0].t)) {\r\n                    extremes[1][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[1][1];\r\n                let x = extremes[1][1].val;\r\n                if (v > x || (v === x && bounds.ts[1][1] > extremes[1][1].t)) {\r\n                    extremes[1][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        minX: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\r\n        minY: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\r\n        maxX: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\r\n        maxY: new _point_on_shape_js__WEBPACK_IMPORTED_MODULE_2__.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\r\n    };\r\n});\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/svg/get-loop-bounds.ts?')},"./src/svg/get-min-y-pos.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getMinYPos": () => (/* binding */ getMinYPos)\n/* harmony export */ });\n/* harmony import */ var _get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-loop-bounds.js */ "./src/svg/get-loop-bounds.ts");\n\r\n/**\r\n * @hidden\r\n * Get topmost PointOnShape of the given loop.\r\n */\r\nfunction getMinYPos(loop) {\r\n    return (0,_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getLoopBounds)(loop).minY;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/svg/get-min-y-pos.ts?')},"./src/svg/get-shape-bounds.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getShapeBounds": () => (/* binding */ getShapeBounds)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var _get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-loop-bounds.js */ "./src/svg/get-loop-bounds.ts");\n\r\n\r\n// TODO - move to another library\r\n/** @hidden */\r\nlet getShapeBounds = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (loops) {\r\n    let minX_ = Number.POSITIVE_INFINITY;\r\n    let maxX_ = Number.NEGATIVE_INFINITY;\r\n    let minY_ = Number.POSITIVE_INFINITY;\r\n    let maxY_ = Number.NEGATIVE_INFINITY;\r\n    let minX;\r\n    let maxX;\r\n    let minY;\r\n    let maxY;\r\n    for (let loop of loops) {\r\n        let bounds = (0,_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_1__.getLoopBounds)(loop);\r\n        if (bounds.minX.p[0] < minX_) {\r\n            minX = bounds.minX;\r\n            minX_ = bounds.minX.p[0];\r\n        }\r\n        if (bounds.maxX.p[0] > maxX_) {\r\n            maxX = bounds.maxX;\r\n            maxX_ = bounds.maxX.p[0];\r\n        }\r\n        if (bounds.minY.p[1] < minY_) {\r\n            minY = bounds.minY;\r\n            minY_ = bounds.minY.p[1];\r\n        }\r\n        if (bounds.maxY.p[1] > maxY_) {\r\n            maxY = bounds.maxY;\r\n            maxY_ = bounds.maxY.p[1];\r\n        }\r\n    }\r\n    return { minX, minY, maxX, maxY };\r\n});\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/svg/get-shape-bounds.ts?')},"./src/sweep-line/sweep-line.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sweepLine": () => (/* binding */ sweepLine)\n/* harmony export */ });\n/** @hidden */\r\nconst EVENT_LEFT = 0;\r\n/** @hidden */\r\nconst EVENT_RIGHT = 1;\r\n/**\r\n * @hidden\r\n * Generalized sweepline algorithm.\r\n *\r\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\r\n *\r\n * @param items An array of items that are to be compared. Items should\r\n * typically be geometric objects in 2d space with well-defined left and right\r\n * endpoints.\r\n * @param getLeftmostPoint A function that returns the leftmost point of the\r\n * geometric object of interest.\r\n * @param getRightmostPoint A function that returns the rightmost point of the\r\n * geometric object of interest.\r\n * @param predicate A predicate that takes two geometric objects and returns\r\n * true if they are of interest or false otherwise.\r\n */\r\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\r\n    // Initialize event queue to contain all endpoints.\r\n    let events = [];\r\n    for (let item of items) {\r\n        events.push({\r\n            type: EVENT_LEFT,\r\n            item,\r\n            x: getLeftmost(item)\r\n        });\r\n        events.push({\r\n            type: EVENT_RIGHT,\r\n            item,\r\n            x: getRightmost(item)\r\n        });\r\n    }\r\n    events.sort(compare);\r\n    let activeItems = new Set();\r\n    /** A list of pairs of items that passed the predicate */\r\n    let pairedItems = [];\r\n    for (let event of events) {\r\n        let { item } = event;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeItem of activeItems.values()) {\r\n                if (predicate(item, activeItem)) {\r\n                    pairedItems.push([item, activeItem]);\r\n                }\r\n            }\r\n            activeItems.add(item);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeItems.delete(event.item);\r\n        }\r\n    }\r\n    return pairedItems;\r\n}\r\n/**\r\n * @hidden\r\n * Compare two Events by their x-axis and then by their type. Since it is\r\n * open boxes that are compared we must let the right endpoint type come\r\n * before the left.\r\n * @param a An event\r\n * @param b Another event\r\n */\r\nfunction compare(a, b) {\r\n    let res = a.x - b.x;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Alwys put left events before right ones.\r\n    return a.type === EVENT_LEFT ? -1 : +1;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/sweep-line/sweep-line.ts?')},"./src/to-scale-axis.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toScaleAxis": () => (/* binding */ toScaleAxis)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _traverse_edges_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./traverse-edges.js */ "./src/traverse-edges.ts");\n/* harmony import */ var _traverse_vertices_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./traverse-vertices.js */ "./src/traverse-vertices.ts");\n/* harmony import */ var _mat_get_largest_vertex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat/get-largest-vertex.js */ "./src/mat/get-largest-vertex.ts");\n/* harmony import */ var _mat_get_leaves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat/get-leaves.js */ "./src/mat/get-leaves.ts");\n/* harmony import */ var _mat_to_scale_axis_cull_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mat/to-scale-axis/cull.js */ "./src/mat/to-scale-axis/cull.ts");\n/* harmony import */ var _mat_to_scale_axis_add_debug_info_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mat/to-scale-axis/add-debug-info.js */ "./src/mat/to-scale-axis/add-debug-info.ts");\n/* harmony import */ var _cp_node_clone_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cp-node/clone.js */ "./src/cp-node/clone.ts");\n/* harmony import */ var _get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./get-curve-to-next.js */ "./src/get-curve-to-next.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction linearScale(s) {\r\n    return function (r) {\r\n        return s * r;\r\n    };\r\n}\r\n/** @hidden */\r\n//let len = length([0,1]);\r\n/**\r\n * Apply and returns an enhanced version of the Scale Axis Transform (SAT) to\r\n * the given MAT. The returned SAT is guaranteed to be a subset of the MAT and\r\n * preserves topology at any scale.\r\n *\r\n * Typically the MAT contains too many branches caused by minute details on the\r\n * boundary of the shape. The SAT is a simplification of the MAT that preserves\r\n * less detail the higher the applied scale factor. The severity at which noise\r\n * are removed depends on the local scale of the shape.\r\n * @param mat The Medial Axis Transform ([[Mat]]) on which to apply the SAT.\r\n * @param s The scale factor >= 1 (e.g. 1.3)\r\n */\r\nfunction toScaleAxis(mat, s, f = linearScale) {\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        var timingStart = performance.now();\r\n        let leaves = (0,_mat_get_leaves_js__WEBPACK_IMPORTED_MODULE_4__.getLeaves)(mat.cpNode);\r\n        _debug_.generated.elems.leaves.push(leaves);\r\n    }\r\n    /** The largest vertex (as measured by its inscribed disk) */\r\n    let cpNodes = [];\r\n    (0,_traverse_vertices_js__WEBPACK_IMPORTED_MODULE_2__.traverseVertices)((0,_cp_node_clone_js__WEBPACK_IMPORTED_MODULE_7__.clone)(mat.cpNode), cpNode => { cpNodes.push(cpNode); });\r\n    let cpNode = (0,_mat_get_largest_vertex_js__WEBPACK_IMPORTED_MODULE_3__.getLargestVertex)(cpNodes);\r\n    let f_ = f(s);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        _debug_.generated.elems.maxVertex.push(cpNode);\r\n    }\r\n    /**\r\n     * All vertices that are set to be culled initially. This may change later\r\n     * in order to preserve topology.\r\n     */\r\n    let culls = new Set();\r\n    let rMap = new Map();\r\n    (0,_traverse_edges_js__WEBPACK_IMPORTED_MODULE_1__.traverseEdges)(cpNode, function (cpNode) {\r\n        /** The occulating radius stored with this vertex. */\r\n        let R = rMap.get(cpNode) || f_(cpNode.cp.circle.radius);\r\n        let cpNode_ = cpNode.next;\r\n        let l = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.length)([0, 1], (0,_get_curve_to_next_js__WEBPACK_IMPORTED_MODULE_8__.getCurveToNext)(cpNode));\r\n        let r = cpNode_.cp.circle.radius;\r\n        let r_ = f_(r);\r\n        if (R - l > r_) {\r\n            for (let cpNode of cpNode_.getCpNodesOnCircle()) {\r\n                rMap.set(cpNode, R - l); // Update osculating radii\r\n            }\r\n            culls.add(cpNode_.cp.circle);\r\n        }\r\n    });\r\n    (0,_mat_to_scale_axis_cull_js__WEBPACK_IMPORTED_MODULE_5__.cull)(culls, cpNode);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        _debug_.generated.elems.culls.push(Array.from(culls));\r\n    }\r\n    // TODO - put line below back - goes into infinite loop\r\n    //let sat: Mat = { cpNode, cpTrees: createNewCpTree(cpNode) };\r\n    let sat = { cpNode, cpTrees: undefined };\r\n    (0,_mat_to_scale_axis_add_debug_info_js__WEBPACK_IMPORTED_MODULE_6__.addDebugInfo)(sat, timingStart);\r\n    return sat;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/to-scale-axis.ts?')},"./src/traverse-edges.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "traverseEdges": () => (/* binding */ traverseEdges)\n/* harmony export */ });\n/**\r\n * Traverses all edges (depth first) of the given MAT tree starting at the given\r\n * vertex (represented by a [[CpNode]]).\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function for each CpNode representing the vertex at the\r\n * start of an edge.\r\n  */\r\nfunction traverseEdges(cpNode, f) {\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given vertex.\r\n    let cps = cpNode.getCpNodesOnCircle();\r\n    while (cps.length) {\r\n        let cp = cps.pop();\r\n        f(cp);\r\n        if (cp.isTerminating()) {\r\n            continue;\r\n        }\r\n        cps.push(...cp.getChildren());\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/traverse-edges.ts?')},"./src/traverse-vertices.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "traverseVertices": () => (/* binding */ traverseVertices)\n/* harmony export */ });\n/**\r\n * Traverses the MAT tree and calls the given callback function for each vertex\r\n * (represented by a [[CpNode]]) on the MAT.\r\n *\r\n * It is usually preferable to use [[traverseEdges]] as it allows for the\r\n * traversal of all the smooth curves representing the MAT.\r\n * @param cpNode Any [[CpNode]] representing the start vertex.\r\n * @param f A callback function taking a single [[CpNode]] as parameter.\r\n */\r\nfunction traverseVertices(cpNode, f) {\r\n    f(cpNode);\r\n    // Since the tree is unrooted we must iterate in all directions from the\r\n    // given cpNode.\t\r\n    cpNode.getCpNodesOnCircle()\r\n        .filter(cpNode => !cpNode.isTerminating())\r\n        .map(cpNode => cpNode.next)\r\n        .forEach(f_);\r\n    function f_(cpNode) {\r\n        let cps = [cpNode];\r\n        while (cps.length) {\r\n            let cp = cps.pop();\r\n            f(cp);\r\n            cps.push(...cp.vertexChildren);\r\n        }\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://FloMat/./src/traverse-vertices.ts?')},"./node_modules/big-float-ts/node/basic/fast-two-diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fastTwoDiff": () => (/* binding */ fastTwoDiff)\n/* harmony export */ });\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. a-b === x+y exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    const x = a - b;\r\n    const y = (a - x) - b;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/fast-two-diff.js?')},"./node_modules/big-float-ts/node/basic/fast-two-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fastTwoSum": () => (/* binding */ fastTwoSum)\n/* harmony export */ });\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    const x = a + b;\r\n    return [b - (x - a), x];\r\n}\r\n// inlined\r\n//const R = a + b; const r = b - (R - a); return [r, R];\r\n\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/fast-two-sum.js?')},"./node_modules/big-float-ts/node/basic/reduce-significand.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reduceSignificand": () => (/* binding */ reduceSignificand)\n/* harmony export */ });\n/**\r\n * Truncates a floating point value\'s significand and returns the result.\r\n * Similar to split, but with the ability to specify the number of bits to keep.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param a a double\r\n * @param bits the number of significand bits to leave intact\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    const s = 53 - bits;\r\n    const f = 2 ** s + 1;\r\n    const c = f * a;\r\n    const r = c - (c - a);\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/reduce-significand.js?')},"./node_modules/big-float-ts/node/basic/split.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "split": () => (/* binding */ split)\n/* harmony export */ });\n/**\r\n * === Math.ceil(p/2) where p is the # of significand bits in a double === 53.\r\n */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    const c = f * a;\r\n    const a_h = c - (c - a);\r\n    const a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\n// inlined - input a, output a_h, a_l\r\n// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];\r\n\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/split.js?')},"./node_modules/big-float-ts/node/basic/two-diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoDiff": () => (/* binding */ twoDiff)\n/* harmony export */ });\n/**\r\n * Returns the exact result of subtracting b from a (as a floating point\r\n * expansion).\r\n * @param a\r\n * @param b\r\n */\r\nfunction twoDiff(a, b) {\r\n    const x = a - b;\r\n    const bvirt = a - x;\r\n    const y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/two-diff.js?')},"./node_modules/big-float-ts/node/basic/two-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoProduct": () => (/* binding */ twoProduct)\n/* harmony export */ });\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    const x = a * b;\r\n    //const [ah, al] = split(a);\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    //const [bh, bl] = split(b);\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //const err1 = x - (ah * bh);\r\n    //const err2 = err1 - (al * bh);\r\n    //const err3 = err2 - (ah * bl);\r\n    //const y = (al * bl) - err3;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/two-product.js?')},"./node_modules/big-float-ts/node/basic/two-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoSum": () => (/* binding */ twoSum)\n/* harmony export */ });\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    const x = a + b;\r\n    const bv = x - a;\r\n    return [(a - (x - bv)) + (b - bv), x];\r\n}\r\n// inlined\r\n//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]\r\n\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/basic/two-sum.js?')},"./node_modules/big-float-ts/node/double-expansion/e-abs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eAbs": () => (/* binding */ eAbs)\n/* harmony export */ });\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-sign.js */ "./node_modules/big-float-ts/node/double-expansion/e-sign.js");\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-negative-of.js */ "./node_modules/big-float-ts/node/double-expansion/e-negative-of.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst sign = _e_sign_js__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst negativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\n/**\r\n * Returns the absolute value of the given floating point expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eAbs(e) {\r\n    if (e[e.length - 1] < 0) {\r\n        return negativeOf(e);\r\n    }\r\n    return e;\r\n}\r\n\r\n//# sourceMappingURL=e-abs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-abs.js?')},"./node_modules/big-float-ts/node/double-expansion/e-calculate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eCalculate": () => (/* binding */ eCalculate)\n/* harmony export */ });\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-product.js */ "./node_modules/big-float-ts/node/basic/two-product.js");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scale-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/two-sum.js */ "./node_modules/big-float-ts/node/basic/two-sum.js");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grow-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/grow-expansion.js");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion;\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_3__.twoSum;\r\nconst addDouble = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_4__.growExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_6__.eCompress;\r\n/**\r\n * Return the result of summing an array of terms, each term being an array of\r\n * floating point expansions to be multiplied together.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms An array of terms to be summed; A term consists of an\r\n * array of floating point expansions to be multiplied together.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it\'s really worth it I am not sure.\r\nfunction eCalculate(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        const term = terms[i];\r\n        let product = term[0];\r\n        for (let j = 1; j < term.length; j++) {\r\n            const multiplicant = term[j];\r\n            if (multiplicant.length == 1) {\r\n                if (product.length === 1) {\r\n                    product = tp(product[0], multiplicant[0]);\r\n                }\r\n                else {\r\n                    product = multByDouble(product, multiplicant[0]);\r\n                }\r\n            }\r\n            else if (product.length === 1) {\r\n                product = multByDouble(multiplicant, product[0]);\r\n            }\r\n            else {\r\n                product = mult(multiplicant, product);\r\n            }\r\n        }\r\n        // add\r\n        if (product.length === 1) {\r\n            if (total.length === 1) {\r\n                total = ts(total[0], product[0]);\r\n            }\r\n            else {\r\n                total = addDouble(total, product[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = addDouble(product, total[0]);\r\n            }\r\n            else {\r\n                total = add(total, product);\r\n            }\r\n        }\r\n    }\r\n    //return compress(total);\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=e-calculate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-calculate.js?')},"./node_modules/big-float-ts/node/double-expansion/e-compare.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eCompare": () => (/* binding */ eCompare)\n/* harmony export */ });\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-diff.js */ "./node_modules/big-float-ts/node/double-expansion/e-diff.js");\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-sign.js */ "./node_modules/big-float-ts/node/double-expansion/e-sign.js");\n\r\n\r\n/**\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * "The easiest way to compare two expansions is to subtract one from the other,\r\n * and test the sign of the result. An expansion’s sign can be easily tested\r\n * because of the nonoverlapping property; simply check the sign of the\r\n * expansion\'s most significant nonzero component..."\r\n *\r\n * @param a a floating point expansion\r\n * @param b another floating point expansion\r\n */\r\nfunction eCompare(a, b) {\r\n    return (0,_e_sign_js__WEBPACK_IMPORTED_MODULE_1__.eSign)((0,_e_diff_js__WEBPACK_IMPORTED_MODULE_0__.eDiff)(a, b));\r\n}\r\n\r\n//# sourceMappingURL=e-compare.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-compare.js?')},"./node_modules/big-float-ts/node/double-expansion/e-compress.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eCompress": () => (/* binding */ eCompress)\n/* harmony export */ });\n/**\r\n * Returns the result of compressing the given floating point expansion.\r\n *\r\n * * primarily for internal library use\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 23 (Shewchuck): Let e = sum_(i=1)^m(e_i) be a nonoverlapping\r\n * expansion of m p-bit components, where m >= 3. Suppose that the components of\r\n * e are sorted in order of increasing magnitude, except that any of the e_i may\r\n * be zero. Then the following algorithm will produce a nonoverlapping expansion\r\n * (nonadjacent if round-to even tiebreaking is used) such that\r\n * h = sum_(i=1)^n(h_i) = e, where the components h_i are in order of increasing\r\n * magnitude. If h != 0, none of the h_i will be zero. Furthermore, the largest\r\n * component h_n approximates h with an error smaller than ulp(h_n).\r\n */\r\nfunction eCompress(e) {\r\n    //return e;\r\n    const e_ = e.slice();\r\n    const m = e_.length;\r\n    if (m === 1) {\r\n        return e_;\r\n    }\r\n    let Q = e_[m - 1];\r\n    let bottom = m;\r\n    for (let i = m - 2; i >= 0; --i) {\r\n        const a = Q;\r\n        const b = e_[i];\r\n        Q = a + b;\r\n        const bv = Q - a;\r\n        const q = b - bv;\r\n        if (q) {\r\n            e_[--bottom] = Q;\r\n            Q = q;\r\n        }\r\n    }\r\n    let top = 0;\r\n    for (let i = bottom; i < m; ++i) {\r\n        const a = e_[i];\r\n        const b = Q;\r\n        Q = a + b;\r\n        const bv = Q - a;\r\n        const q = b - bv;\r\n        if (q) {\r\n            e_[top++] = q;\r\n        }\r\n    }\r\n    e_[top++] = Q;\r\n    e_.length = top;\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-compress.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-compress.js?')},"./node_modules/big-float-ts/node/double-expansion/e-diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eDiff": () => (/* binding */ eDiff)\n/* harmony export */ });\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-negative-of.js */ "./node_modules/big-float-ts/node/double-expansion/e-negative-of.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst negativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\n/**\r\n * Returns the difference between two floating point expansions, i.e. e - f.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n * @param f another floating point expansion\r\n */\r\nfunction eDiff(e, f) {\r\n    const g = negativeOf(f);\r\n    return add(e, g);\r\n}\r\n\r\n//# sourceMappingURL=e-diff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-diff.js?')},"./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eDivBy2": () => (/* binding */ eDivBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of dividing a floating point expansion by 2.\r\n * * **error free**\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eDivBy2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(0.5 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-div-by-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js?')},"./node_modules/big-float-ts/node/double-expansion/e-div.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eDiv": () => (/* binding */ eDiv)\n/* harmony export */ });\n/* harmony import */ var _e_estimate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-estimate.js */ "./node_modules/big-float-ts/node/double-expansion/e-estimate.js");\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expansion-product.js */ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js");\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-diff.js */ "./node_modules/big-float-ts/node/double-expansion/e-diff.js");\n/* harmony import */ var _e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-to-bitlength.js */ "./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../double-representation/bit-length.js */ "./node_modules/big-float-ts/node/double-representation/bit-length.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst toBitlength = _e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_3__.eToBitlength;\r\nconst bitLength = _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_4__.expBitLength;\r\nconst diff = _e_diff_js__WEBPACK_IMPORTED_MODULE_2__.eDiff;\r\nconst estimate = _e_estimate_js__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\n/**\r\n * Returns the result of a/b using Goldschmidt division.\r\n *\r\n * The result will only be exact if b|a, i.e. if b divides a exactly, else the\r\n * result will be rounded to the longest bitlength between a and b.\r\n *\r\n * @param a the numerator\r\n * @param b the denominator\r\n *\r\n * @param expansionLength the bitlength/53 of the final result, e.g. 1 means\r\n * standard double precision, 2 means double-double, etc up to a max of about 20 at\r\n * which point underflow cease precision improvement. If the division is known\r\n * to be exact beforehand (such as in the pseudo remainder sequence algorithm)\r\n * then set expansionLength === 0 and an exact division will be done.\r\n */\r\n// TODO - test this function properly or replace with a better one\r\nfunction eDiv(N, D, expansionLength) {\r\n    let D_ = D;\r\n    let N_ = N;\r\n    let exact = false;\r\n    let resultBitlengthUpperBound = 0;\r\n    if (!expansionLength) {\r\n        let bitlengthN = bitLength(N_);\r\n        let bitlengthD = bitLength(D_);\r\n        // resultBitlengthUpperBound is only valid if the division is known\r\n        // to be exact\r\n        resultBitlengthUpperBound = bitlengthN - bitlengthD + 1;\r\n        expansionLength = (resultBitlengthUpperBound / 53) + 1;\r\n        exact = true;\r\n    }\r\n    let F = [1 / estimate(D_)]; // Initial guess - out by 1/2 upls\r\n    let i = 1;\r\n    while (true) {\r\n        N_ = mult(N_, F);\r\n        // The precision bitlength doubles on each iteration\r\n        if (i > expansionLength) {\r\n            // we now have roughly double the needed precision - we actually \r\n            // only require about the precision and then round properly - this\r\n            // could be implemented in the future.\r\n            if (exact) {\r\n                // We must throw away bits known to be zero. \r\n                // Any bits > expansionLength * 53 must be thrown away as they\r\n                // are wrong - all other bits are exact.\r\n                N_ = toBitlength(N_, resultBitlengthUpperBound);\r\n                // TODO - below is just for testing - remove later\r\n                //if (compare(mult(D, N_), N) !== 0) {\r\n                //    console.log(mult(D, N_))\r\n                //    throw new Error(`division in-exact - probably due to underflow, N: ${N}, D: ${D}, Result: ${N_}, product: ${mult(D, N_)}`); \r\n                //} \r\n                return N_;\r\n            }\r\n            // Returning only significant bits helps with sign determination later on.\r\n            return N_.slice(N_.length - expansionLength, N_.length);\r\n        }\r\n        D_ = mult(D_, F);\r\n        F = diff([2], D_);\r\n        i *= 2;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=e-div.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-div.js?')},"./node_modules/big-float-ts/node/double-expansion/e-estimate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eEstimate": () => (/* binding */ eEstimate)\n/* harmony export */ });\n/**\r\n * Returns the result of the given floating point expansion rounded to a double\r\n * floating point number.\r\n *\r\n * The result is within 1 ulps of the actual value, e.g. imagine the worst case\r\n * situation where we add (in 4dot4) 1111.1000 + 0.000011111111... The result\r\n * will be 1111.1000 whereas as the correct result should be 1111.1001 and we\r\n * thus lost 1 ulp of accuracy. It does not matter that the expansion contain\r\n * several floats since none is overlapping.\r\n *\r\n * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eEstimate(e) {\r\n    let Q = e[0];\r\n    for (let i = 1; i < e.length; i++) {\r\n        Q += e[i];\r\n    }\r\n    return Q;\r\n}\r\n\r\n//# sourceMappingURL=e-estimate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-estimate.js?')},"./node_modules/big-float-ts/node/double-expansion/e-int-div.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIntDiv": () => (/* binding */ eIntDiv)\n/* harmony export */ });\n/* harmony import */ var _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-long-divide.js */ "./node_modules/big-float-ts/node/double-expansion/e-long-divide.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eLongDivide = _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__.eLongDivide;\r\n/**\r\n * Returns the result of the integer division a/b.\r\n *\r\n * * **precondition:** a and b must be integers, b !== 0\r\n */\r\nfunction eIntDiv(a, b) {\r\n    return eLongDivide(a, b).div;\r\n}\r\n\r\n//# sourceMappingURL=e-int-div.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-int-div.js?')},"./node_modules/big-float-ts/node/double-expansion/e-int-pow.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIntPow": () => (/* binding */ eIntPow)\n/* harmony export */ });\n/* harmony import */ var _e_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-product.js */ "./node_modules/big-float-ts/node/double-expansion/e-product.js");\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expansion-product.js */ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst prod = _e_product_js__WEBPACK_IMPORTED_MODULE_0__.eProduct;\r\n/**\r\n * Returns a**i, where i is a non-negative integer.\r\n * @param a a floating point expansion\r\n */\r\n// TODO - this algorithm\'s speed can easily be improved significantly using \'repeated squaring\'\r\nfunction eIntPow(a, p) {\r\n    // a^0 === 1\r\n    if (p === 0) {\r\n        return [1];\r\n    }\r\n    // a^1 === a\r\n    if (p === 1) {\r\n        return a;\r\n    }\r\n    if (p === 2) {\r\n        return mult(a, a);\r\n    }\r\n    const as = [];\r\n    for (let i = 0; i < p; i++) {\r\n        as.push(a);\r\n    }\r\n    return prod(as);\r\n}\r\n\r\n//# sourceMappingURL=e-int-pow.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-int-pow.js?')},"./node_modules/big-float-ts/node/double-expansion/e-is-integer.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIsInteger": () => (/* binding */ eIsInteger)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\nfunction eIsInteger(a) {\r\n    a = (0,_e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress)(a);\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (a[i] % 1 !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=e-is-integer.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-is-integer.js?')},"./node_modules/big-float-ts/node/double-expansion/e-long-divide.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eLongDivide": () => (/* binding */ eLongDivide)\n/* harmony export */ });\n/* harmony import */ var _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-negative-of.js */ "./node_modules/big-float-ts/node/double-expansion/e-negative-of.js");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grow-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/grow-expansion.js");\n/* harmony import */ var _e_sum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./e-sum.js */ "./node_modules/big-float-ts/node/double-expansion/e-sum.js");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scale-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js");\n/* harmony import */ var _e_diff_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./e-diff.js */ "./node_modules/big-float-ts/node/double-expansion/e-diff.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eNegativeOf = _e_negative_of_js__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\nconst fastExpansionSum = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst eCompress = _e_compress_js__WEBPACK_IMPORTED_MODULE_2__.eCompress;\r\nconst growExpansion = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_3__.growExpansion;\r\nconst eSum = _e_sum_js__WEBPACK_IMPORTED_MODULE_4__.eSum;\r\nconst scaleExpansion = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_5__.scaleExpansion;\r\nconst eDiff = _e_diff_js__WEBPACK_IMPORTED_MODULE_6__.eDiff;\r\nconst sign = Math.sign;\r\nfunction eLongDivide(N, D) {\r\n    N = eCompress(N);\r\n    D = eCompress(D);\r\n    // get the most significant double\r\n    // out by at most 1 ulp, exact if d < MAX_SAFE_INT\r\n    let d = D[D.length - 1];\r\n    // trivial cases\r\n    if (D.length === 1) {\r\n        if (d === 0) {\r\n            throw new Error(\'division by zero\');\r\n        }\r\n        if (d === 1) {\r\n            return { div: N, rem: [0] };\r\n        }\r\n        if (d === -1) {\r\n            return { div: eNegativeOf(N), rem: [0] };\r\n        }\r\n    }\r\n    const signN = sign(N[N.length - 1]);\r\n    if (signN === 0) {\r\n        return { div: [0], rem: [0] };\r\n    }\r\n    let signD = sign(d);\r\n    let divs = [];\r\n    let oldLen = 0;\r\n    while (true) {\r\n        let rems = [];\r\n        // loop from big `n[i]` to small `n[i]`\r\n        for (let i = N.length - 1; i >= 0; i--) {\r\n            const n = N[i];\r\n            // `n % d` is the exact rem (for rem < MAX_SAFE_INTEGER) but is preliminary \r\n            // as it is subject to round-off for rem > MAX_SAFE_INTEGER; thus out by at \r\n            // most 1/2 ulp\r\n            // Due to roundoff (and the fact we\'e using `d` and not `D`!), `_div` does \r\n            // not necessarily represent the exact quotient.\r\n            let div = Math.round((n - (n % d)) / d);\r\n            // get the remainder by calculating `rem = n - d*div`\r\n            rems.push(scaleExpansion(D, div)); // exact\r\n            if (div === 0) {\r\n                break;\r\n            }\r\n            divs.push(div);\r\n        }\r\n        N = eCompress(eDiff(N, eSum(rems)));\r\n        if (oldLen === divs.length) {\r\n            break;\r\n        }\r\n        oldLen = divs.length;\r\n    }\r\n    let rem = N;\r\n    let div = [0];\r\n    for (let i = 0; i < divs.length; i++) {\r\n        div = growExpansion(div, divs[i]);\r\n    }\r\n    div = eCompress(div);\r\n    //----------------------\r\n    // fix signs (possibly)\r\n    //----------------------\r\n    //const signDiv = sign(div[div.length-1]);\r\n    const signRem = sign(rem[rem.length - 1]);\r\n    //const signND = signN * signD;\r\n    // We must have:\r\n    // sign(div) === sign(n) * sign(d)\r\n    // sign(rem) === sign(n)\r\n    // At this point: `signN !== 0` and `signD !== 0`\r\n    if (signRem !== 0 && signRem !== signN) {\r\n        if (signN > 0) {\r\n            if (signD > 0) {\r\n                // div = div - 1  (div is positive)\r\n                // rem = rem + D\r\n                div = growExpansion(div, -1);\r\n                rem = fastExpansionSum(rem, D);\r\n            }\r\n            else {\r\n                // div = div + 1  (div is positive)\r\n                // rem = rem - D\r\n                div = growExpansion(div, +1);\r\n                rem = fastExpansionSum(rem, eNegativeOf(D));\r\n            }\r\n        }\r\n        else if (signN < 0) {\r\n            if (signD > 0) {\r\n                // div = div + 1 (div is negative)\r\n                // rem = rem - D\r\n                div = growExpansion(div, +1);\r\n                rem = fastExpansionSum(rem, eNegativeOf(D));\r\n            }\r\n            else {\r\n                // div = div - 1  (div is positive)\r\n                // rem = rem + D\r\n                div = growExpansion(div, -1);\r\n                rem = fastExpansionSum(rem, D);\r\n            }\r\n        }\r\n    }\r\n    return { div, rem };\r\n}\r\n\r\n//# sourceMappingURL=e-long-divide.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-long-divide.js?')},"./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eMultBy2": () => (/* binding */ eMultBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying a floating point expansion by 2.\r\n * * **error free**\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eMultBy2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-mult-by-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js?')},"./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eMultByNeg2": () => (/* binding */ eMultByNeg2)\n/* harmony export */ });\n/**\r\n * Multiply a floating point expansion by -2.\r\n * * **error free**\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eMultByNeg2(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(-2 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n\r\n//# sourceMappingURL=e-mult-by-neg-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js?')},"./node_modules/big-float-ts/node/double-expansion/e-negative-of.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eNegativeOf": () => (/* binding */ eNegativeOf)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given floating point expansion.\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n */\r\nfunction eNegativeOf(e) {\r\n    const m = e.length;\r\n    const h = new Array(m);\r\n    for (let i = 0; i < m; i++) {\r\n        h[i] = -e[i];\r\n    }\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=e-negative-of.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-negative-of.js?')},"./node_modules/big-float-ts/node/double-expansion/e-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eProduct": () => (/* binding */ eProduct)\n/* harmony export */ });\n/* harmony import */ var _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expansion-product.js */ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-product.js */ "./node_modules/big-float-ts/node/basic/two-product.js");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scale-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst mult = _expansion_product_js__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_3__.eCompress;\r\n/**\r\n * Return the result of multiplying together an array of floating point\r\n * expansions.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms an array of multiplicands\r\n */\r\nfunction eProduct(term) {\r\n    let product = term[0];\r\n    for (let j = 1; j < term.length; j++) {\r\n        const multiplicant = term[j];\r\n        if (multiplicant.length == 1) {\r\n            if (product.length === 1) {\r\n                product = tp(product[0], multiplicant[0]);\r\n            }\r\n            else {\r\n                product = multByDouble(product, multiplicant[0]);\r\n            }\r\n        }\r\n        else if (product.length === 1) {\r\n            product = multByDouble(multiplicant, product[0]);\r\n        }\r\n        else {\r\n            product = mult(multiplicant, product);\r\n        }\r\n    }\r\n    return compress(product);\r\n    //return product;\r\n}\r\n\r\n//# sourceMappingURL=e-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-product.js?')},"./node_modules/big-float-ts/node/double-expansion/e-rem.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eRem": () => (/* binding */ eRem)\n/* harmony export */ });\n/* harmony import */ var _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-long-divide.js */ "./node_modules/big-float-ts/node/double-expansion/e-long-divide.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst eLongDivide = _e_long_divide_js__WEBPACK_IMPORTED_MODULE_0__.eLongDivide;\r\n/**\r\n * Returns a % b\r\n *\r\n * * **precondition:** a and b must be integers, b !== 0\r\n */\r\nfunction eRem(a, b) {\r\n    return eLongDivide(a, b).rem;\r\n}\r\n\r\n//# sourceMappingURL=e-rem.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-rem.js?')},"./node_modules/big-float-ts/node/double-expansion/e-sign.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eSign": () => (/* binding */ eSign)\n/* harmony export */ });\n/**\r\n * Returns the sign of the given expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * From Shewchuk: "A nonoverlapping expansion is desirable because it is easy to\r\n * determine its sign (take the sign of the largest component) ... "\r\n *\r\n * @param e A floating point expansion with zeroes eliminated.\r\n */\r\nfunction eSign(e) {\r\n    return e[e.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=e-sign.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-sign.js?')},"./node_modules/big-float-ts/node/double-expansion/e-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eSum": () => (/* binding */ eSum)\n/* harmony export */ });\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/two-sum.js */ "./node_modules/big-float-ts/node/basic/two-sum.js");\n/* harmony import */ var _grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grow-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/grow-expansion.js");\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst addDouble = _grow_expansion_js__WEBPACK_IMPORTED_MODULE_1__.growExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\n/**\r\n * Returns the result of summing an array of floating point expansions.\r\n *\r\n * * The result is exact in the form of a non-overlapping floating point\r\n * expansion.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param terms An array of numbers to be summed; A term is represented by a\r\n * floating point expansion.\r\n */\r\n// The terms parameter were chosen to always be expansions in order to keep the \r\n// function monomorhic, but whether it\'s really worth it I am not sure.\r\nfunction eSum(terms) {\r\n    let total = [0];\r\n    for (let i = 0; i < terms.length; i++) {\r\n        const term = terms[i];\r\n        // add\r\n        if (term.length === 1) {\r\n            if (total.length === 1) {\r\n                total = ts(total[0], term[0]);\r\n            }\r\n            else {\r\n                total = addDouble(total, term[0]);\r\n            }\r\n        }\r\n        else {\r\n            if (total.length === 1) {\r\n                total = addDouble(term, total[0]);\r\n            }\r\n            else {\r\n                total = add(total, term);\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=e-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-sum.js?')},"./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eToBitlength": () => (/* binding */ eToBitlength)\n/* harmony export */ });\n/* harmony import */ var _e_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-sign.js */ "./node_modules/big-float-ts/node/double-expansion/e-sign.js");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-representation/msb-exponent.js */ "./node_modules/big-float-ts/node/double-representation/msb-exponent.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/reduce-significand.js */ "./node_modules/big-float-ts/node/basic/reduce-significand.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst sign = _e_sign_js__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_2__.eCompress;\r\n/**\r\n * Returns a floating point expansion accurate to the given number of bits.\r\n * Extraneous bits are discarded.\r\n * @param a a floating point expansion\r\n * @param l the number of accurate bits to keep\r\n */\r\n// TODO - make faster\r\nfunction eToBitlength(a, l) {\r\n    a = compress(a);\r\n    if (sign(a) === 0) {\r\n        return [0];\r\n    }\r\n    let maxMsb = (0,_double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_1__.msbExponent)(a[a.length - 1]);\r\n    let msb = maxMsb;\r\n    let i = a.length - 1; // start at most significant byte\r\n    while (i > 0) {\r\n        let msb_ = (0,_double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_1__.msbExponent)(a[i - 1]);\r\n        if (maxMsb - msb_ > l) {\r\n            break;\r\n        }\r\n        msb = msb_;\r\n        i--;\r\n    }\r\n    let keepBits = Math.min(l - (maxMsb - msb), 53);\r\n    let b = a[i];\r\n    b = (0,_basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_3__.reduceSignificand)(b, keepBits);\r\n    let result = a.slice(i);\r\n    result[0] = b;\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-to-bitlength.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js?')},"./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eToDd": () => (/* binding */ eToDd)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of converting a floating point expansion to a\r\n * double-double precision floating point number.\r\n */\r\nfunction eToDd(e) {\r\n    e = compress(e);\r\n    const len = e.length;\r\n    if (len === 2) {\r\n        return e; // already a double-double\r\n    }\r\n    else if (len === 1) {\r\n        return [0, e[0]]; // double-doubles have a fixed length of 2\r\n    }\r\n    return [e[len - 2], e[len - 1]]; // return only most significant parts\r\n}\r\n\r\n//# sourceMappingURL=e-to-double-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js?')},"./node_modules/big-float-ts/node/double-expansion/expansion-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "expansionProduct": () => (/* binding */ expansionProduct)\n/* harmony export */ });\n/* harmony import */ var _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _scale_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scale-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst multByDouble = _scale_expansion_js__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion;\r\nconst add = _fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_2__.eCompress;\r\n/**\r\n * Returns the product of two double floating point expansions.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * As per Shewchuk in the above paper: "To find the product of two expansions\r\n * e and f, use SCALE-EXPANSION (with zero elimination) to form the expansions\r\n * ef_1, ef_2, ..., then sum these using a distillation tree."\r\n *\r\n * A distillation tree used with fastExpansionSum will give O(k*log k) vs O(k^2)\r\n * operations.\r\n *\r\n * Implemented naively and not as described by Shewchuk (i.e. the algorithm\r\n * takes O(k^2) operations).\r\n * @param e a double floating point expansion\r\n * @param f another double floating point expansion\r\n */\r\nfunction expansionProduct(e, f) {\r\n    let sum = [0];\r\n    for (let i = 0; i < e.length; i++) {\r\n        sum = add(sum, multByDouble(f, e[i]));\r\n    }\r\n    //return compress(sum);\r\n    return sum;\r\n}\r\n\r\n//# sourceMappingURL=expansion-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/expansion-product.js?')},"./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fastExpansionSum": () => (/* binding */ fastExpansionSum)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of adding two expansions.\r\n *\r\n * Theorem 13: Let e = sum_(i=1)^m(e_i) and f = sum_(i=1)^n(f_i) be strongly\r\n * nonoverlapping expansions of m and n p-bit components, respectively, where\r\n * p >= 4. Suppose that the components of both e and f are sorted in order of\r\n * increasing magnitude, except that any of the e_i or f_i may be zero. On a\r\n * machine whose arithmetic uses the round-to-even rule, the following algorithm\r\n * will produce a strongly nonoverlapping expansion h such that\r\n * sum_(i=1)^(m+n)(e_i + f_i) = e + f, where the components of h are also in\r\n * order of increasing magnitude, except that any of the h_i may be zero.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastExpansionSum(e, f) {\r\n    //const g = merge(e,f);\r\n    // inlined (above line)\r\n    const lenE = e.length;\r\n    const lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    const g = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            g.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            g.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        g.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        g.push(f[j]);\r\n        j++;\r\n    }\r\n    if (g.length === 0) {\r\n        return [0];\r\n    }\r\n    // end inlined\r\n    const len = g.length;\r\n    if (len === 1) {\r\n        return g;\r\n    }\r\n    //const h: number[] = new Array(len);\r\n    const h = [];\r\n    //const q: number;\r\n    //[h[0], q] = fastTwoSum(g[1], g[0]);\r\n    // inlined (above line)\r\n    const a = g[1];\r\n    const b = g[0];\r\n    let q = a + b;\r\n    //h[0] = b - (q - a);\r\n    const hh = b - (q - a);\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    ;\r\n    //let j = 0;\r\n    j = 0;\r\n    for (let i = 2; i < len; i++) {\r\n        //[h[i-1], q] = twoSum(q, g[i]);\r\n        // inlined (above line)\r\n        const b = g[i];\r\n        const R = q + b;\r\n        const _ = R - q;\r\n        //h[i-1] = (q - (R - _)) + (b - _);\r\n        const hh = (q - (R - _)) + (b - _);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q = R;\r\n    }\r\n    //h[len-1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return compress(h);\r\n    return h;\r\n}\r\n/**\r\n * Returns the result of merging an expansion e and f into a single expansion,\r\n * in order of nondecreasing magnitude (possibly with interspersed zeros).\r\n * (This function is zero-eliminating)\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n * @param f another floating point expansion\r\n */\r\nfunction merge(e, f) {\r\n    const lenE = e.length;\r\n    const lenF = f.length;\r\n    let i = 0;\r\n    let j = 0;\r\n    const merged = [];\r\n    while (i < lenE && j < lenF) {\r\n        if (e[i] === 0) {\r\n            i++;\r\n            continue;\r\n        }\r\n        if (f[j] === 0) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (Math.abs(e[i]) <= Math.abs(f[j])) {\r\n            merged.push(e[i]);\r\n            i++;\r\n        }\r\n        else {\r\n            merged.push(f[j]);\r\n            j++;\r\n        }\r\n    }\r\n    while (i < lenE) {\r\n        merged.push(e[i]);\r\n        i++;\r\n    }\r\n    while (j < lenF) {\r\n        merged.push(f[j]);\r\n        j++;\r\n    }\r\n    if (merged.length === 0) {\r\n        return [0];\r\n    }\r\n    return merged;\r\n}\r\n\r\n//# sourceMappingURL=fast-expansion-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js?')},"./node_modules/big-float-ts/node/double-expansion/grow-expansion.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "growExpansion": () => (/* binding */ growExpansion)\n/* harmony export */ });\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_0__.eCompress;\r\n/**\r\n * Returns the result of adding a double to an expansion.\r\n *\r\n * Let e be a nonoverlapping expansion of m p-bit components, and let b be a\r\n * p-bit value where p >= 3. Suppose that the components e_1, ..., e_m are\r\n * sorted in order of *increasing* magnitude, except that any of the ei may be\r\n * zero.\r\n * Then the following algorithm will produce a nonoverlapping expansion such\r\n * that h = sum_i(h_i) = e + b, where the components h_1, ..., h_(m+1) are also\r\n * in order of increasing magnitude, except that any of the h_i may be zero.\r\n * Furthermore, if e is nonadjacent and round-to-even tiebreaking is used, then\r\n * h is nonadjacent.\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param e A floating point expansion\r\n * @param b Another floating point expansion\r\n */\r\nfunction growExpansion(e, b) {\r\n    const m = e.length;\r\n    let q = b;\r\n    //const h: number[] = new Array(m+1);\r\n    const h = [];\r\n    //let j = 0;\r\n    for (let i = 0; i < m; i++) {\r\n        // Note the use of twoSum and not fastTwoSum.\r\n        //[h[i], q] = ts(q, e[i]);\r\n        const ee = e[i];\r\n        const x = q + ee;\r\n        const bv = x - q;\r\n        let hh = (q - (x - bv)) + (ee - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q = x;\r\n    }\r\n    //h[j] = q;\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return compress(h);\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=grow-expansion.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/grow-expansion.js?')},"./node_modules/big-float-ts/node/double-expansion/is-adjacent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isAdjacent": () => (/* binding */ isAdjacent)\n/* harmony export */ });\n/* harmony import */ var _is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-overlapping.js */ "./node_modules/big-float-ts/node/double-expansion/is-overlapping.js");\n\r\n/**\r\n * Returns true if x and y are adjacent, false otherwise.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * for details\r\n *\r\n * @param x a double floating point number\r\n * @param y another double floating point number\r\n */\r\nfunction isAdjacent(x, y) {\r\n    return (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(x, y) ||\r\n        (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(x, 2 * y) ||\r\n        (0,_is_overlapping_js__WEBPACK_IMPORTED_MODULE_0__.isOverlapping)(2 * x, y);\r\n}\r\n\r\n//# sourceMappingURL=is-adjacent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/is-adjacent.js?')},"./node_modules/big-float-ts/node/double-expansion/is-overlapping.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isNonOverlapping": () => (/* binding */ isNonOverlapping),\n/* harmony export */   "isNonOverlappingAll": () => (/* binding */ isNonOverlappingAll),\n/* harmony export */   "isOverlapping": () => (/* binding */ isOverlapping)\n/* harmony export */ });\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double-representation/get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-representation/exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns true if a and b overlaps, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Implemented for testing purposes.\r\n * @param a a double\r\n * @param b another double\r\n */\r\nfunction isOverlapping(a, b) {\r\n    return !isNonOverlapping(a, b);\r\n}\r\n/**\r\n * Returns true if a and b does not overlap, false otherwise.\r\n *\r\n * Two floating-point values x and y are nonoverlapping if the least significant\r\n * nonzero bit of x is more significant than the most significant nonzero bit of\r\n * y.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Implemented for testing purposes.\r\n *\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction isNonOverlapping(a, b) {\r\n    if (a === 0 || b === 0) {\r\n        return true;\r\n    }\r\n    if (Math.abs(b) > Math.abs(a)) {\r\n        [a, b] = [b, a];\r\n    }\r\n    // At this point abs(a) > abs(b)\r\n    let l = (0,_double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a);\r\n    let h = (0,_double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(b);\r\n    let shift = (0,_double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a) - (0,_double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(b);\r\n    return (l + shift) > h;\r\n}\r\n/**\r\n * Returns true if all components of the given floating point expansion is\r\n * non-overlapping, false otherwise.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a double floating point expansion\r\n */\r\nfunction isNonOverlappingAll(e) {\r\n    for (let i = 1; i < e.length; i++) {\r\n        if (isOverlapping(e[i - 1], e[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-overlapping.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/is-overlapping.js?')},"./node_modules/big-float-ts/node/double-expansion/scale-expansion.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleExpansion": () => (/* binding */ scaleExpansion),\n/* harmony export */   "scaleExpansion2": () => (/* binding */ scaleExpansion2)\n/* harmony export */ });\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/two-product.js */ "./node_modules/big-float-ts/node/basic/two-product.js");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/two-sum.js */ "./node_modules/big-float-ts/node/basic/two-sum.js");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../basic/fast-two-sum.js */ "./node_modules/big-float-ts/node/basic/fast-two-sum.js");\n/* harmony import */ var _e_compress_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n\r\n\r\n\r\nconst f = 134217729; // 2**27 + 1;\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst ts = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_1__.twoSum;\r\nconst fts = _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_2__.fastTwoSum;\r\nconst compress = _e_compress_js__WEBPACK_IMPORTED_MODULE_3__.eCompress;\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * @param e a double floating point expansion\r\n * @param b a double\r\n */\r\nfunction scaleExpansion(e, b) {\r\n    const m = e.length;\r\n    //const h: number[] = new Array(2*m);\r\n    let q_;\r\n    //[h[0], q] = tp(e[0], b);\r\n    // inlined (above line)\r\n    const a = e[0];\r\n    let q = a * b;\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const h = [];\r\n    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));\r\n    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    ;\r\n    for (let i = 1; i < m; i++) {\r\n        //const [t, T] = tp(e[i], b);\r\n        // inlined (above line)\r\n        const a = e[i];\r\n        const T = a * b;\r\n        const c = f * a;\r\n        const ah = c - (c - a);\r\n        const al = a - ah;\r\n        const d = f * b;\r\n        const bh = d - (d - b);\r\n        const bl = b - bh;\r\n        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));\r\n        //[h[2*i-1], q_] = ts(q, t);\r\n        // inlined (above line)\r\n        const x = q + t;\r\n        const bv = x - q;\r\n        //h[2*i-1] = (q - (x - bv)) + (t - bv);\r\n        //h.push((q - (x - bv)) + (t - bv));\r\n        const hh = (q - (x - bv)) + (t - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q_ = x;\r\n        //[h[2*i], q] = fts(T, q_);\r\n        // inlined (above line)\r\n        const xx = T + q_;\r\n        //h[2*i] = q_ - (xx - T);\r\n        //h.push(q_ - (xx - T));\r\n        const hhh = q_ - (xx - T);\r\n        if (hhh !== 0) {\r\n            h.push(hhh);\r\n        }\r\n        q = xx;\r\n    }\r\n    //h[2*m - 1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return eCompress(h);\r\n    return h;\r\n}\r\n/**\r\n * Returns the result of multiplying an expansion by a double.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion\r\n * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that\r\n * the components of e are sorted in order of increasing magnitude, except that\r\n * any of the e_i may be zero. Then the following algorithm will produce a\r\n * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the\r\n * components of h are also in order of increasing magnitude, except that any of\r\n * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even\r\n * tiebreaking is used, then h is non-adjacent.\r\n *\r\n * @param e a double floating point expansion\r\n * @param b a double\r\n */\r\nfunction scaleExpansion2(b, e) {\r\n    const m = e.length;\r\n    //const h: number[] = new Array(2*m);\r\n    let q_;\r\n    //[h[0], q] = tp(e[0], b);\r\n    // inlined (above line)\r\n    const a = e[0];\r\n    let q = a * b;\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const h = [];\r\n    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));\r\n    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));\r\n    if (hh !== 0) {\r\n        h.push(hh);\r\n    }\r\n    ;\r\n    for (let i = 1; i < m; i++) {\r\n        //const [t, T] = tp(e[i], b);\r\n        // inlined (above line)\r\n        const a = e[i];\r\n        const T = a * b;\r\n        const c = f * a;\r\n        const ah = c - (c - a);\r\n        const al = a - ah;\r\n        const d = f * b;\r\n        const bh = d - (d - b);\r\n        const bl = b - bh;\r\n        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));\r\n        //[h[2*i-1], q_] = ts(q, t);\r\n        // inlined (above line)\r\n        const x = q + t;\r\n        const bv = x - q;\r\n        //h[2*i-1] = (q - (x - bv)) + (t - bv);\r\n        //h.push((q - (x - bv)) + (t - bv));\r\n        const hh = (q - (x - bv)) + (t - bv);\r\n        if (hh !== 0) {\r\n            h.push(hh);\r\n        }\r\n        q_ = x;\r\n        //[h[2*i], q] = fts(T, q_);\r\n        // inlined (above line)\r\n        const xx = T + q_;\r\n        //h[2*i] = q_ - (xx - T);\r\n        //h.push(q_ - (xx - T));\r\n        const hhh = q_ - (xx - T);\r\n        if (hhh !== 0) {\r\n            h.push(hhh);\r\n        }\r\n        q = xx;\r\n    }\r\n    //h[2*m - 1] = q;\r\n    //h.push(q);\r\n    if (q !== 0 || h.length === 0) {\r\n        h.push(q);\r\n    }\r\n    //return eCompress(h);\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=scale-expansion.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-expansion/scale-expansion.js?')},"./node_modules/big-float-ts/node/double-representation/bit-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bitLength": () => (/* binding */ bitLength),\n/* harmony export */   "expBitLength": () => (/* binding */ expBitLength)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-expansion/e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n/* harmony import */ var _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../double-expansion/e-sign.js */ "./node_modules/big-float-ts/node/double-expansion/e-sign.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a A double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) + 1;\r\n}\r\n/**\r\n * Returns the bit-length of the significand of the given floating point\r\n * expansion in such a way that trailing zeros are not counted.\r\n * * precondition: subnormals not currently supported\r\n * @param a A double precision floating point expansion\r\n */\r\nfunction expBitLength(a) {\r\n    let a_ = (0,_double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_1__.eCompress)(a);\r\n    if ((0,_double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_3__.eSign)(a_) === 0) {\r\n        return 0;\r\n    }\r\n    let msbyte = a_[a_.length - 1];\r\n    let lsbyte = a_[0];\r\n    return (0,_exponent_js__WEBPACK_IMPORTED_MODULE_2__.exponent)(msbyte) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_2__.exponent)(lsbyte) + (53 - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(lsbyte));\r\n}\r\n\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/bit-length.js?')},"./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleToBinaryString": () => (/* binding */ doubleToBinaryString)\n/* harmony export */ });\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ "./node_modules/big-float-ts/node/double-representation/double-to-octets.js");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString((0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(number));\r\n}\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join(\'\');\r\n}\r\n/**\r\n * intToBinaryString(8) -> "00001000"\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = "0" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js?')},"./node_modules/big-float-ts/node/double-representation/double-to-octets.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleToOctets": () => (/* binding */ doubleToOctets)\n/* harmony export */ });\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n */\r\nfunction doubleToOctets(number) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\n\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/double-to-octets.js?')},"./node_modules/big-float-ts/node/double-representation/exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "exponent": () => (/* binding */ exponent)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ "./node_modules/big-float-ts/node/double-representation/parse-double.js");\n\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).exponent;\r\n}\r\n\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/exponent.js?')},"./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getHighestSetBit": () => (/* binding */ getHighestSetBit),\n/* harmony export */   "getLowestSetBit": () => (/* binding */ getLowestSetBit)\n/* harmony export */ });\n/* harmony import */ var _significand_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./significand.js */ "./node_modules/big-float-ts/node/double-representation/significand.js");\n\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number\'s significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    let s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    let len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        let l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    let s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    let len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js?')},"./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isBitAligned": () => (/* binding */ isBitAligned)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are bit aligned with e === 3 and max\r\n * bitlength === 6:\r\n *    a -> 00|101100|000\r\n *    b -> 00|000100|000\r\n *    c -> 00|110111|000\r\n * These are not\r\n *    a -> 01|101100|000\r\n *    b -> 00|000100|000\r\n * These are not\r\n *    a -> 00|101100|000\r\n *    b -> 00|000100|100\r\n * These are not\r\n *    a -> 00|101100|100\r\n *    b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    let maxSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - 52 + e;\r\n    let minSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) - 52 + e;\r\n    let minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\n\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js?')},"./node_modules/big-float-ts/node/double-representation/lsb-exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lsbExponent": () => (/* binding */ lsbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/lsb-exponent.js?')},"./node_modules/big-float-ts/node/double-representation/msb-exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "msbExponent": () => (/* binding */ msbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    // Will return e for all but subnormal numbers\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/msb-exponent.js?')},"./node_modules/big-float-ts/node/double-representation/parse-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "parseDouble": () => (/* binding */ parseDouble),\n/* harmony export */   "parseDoubleDetailed": () => (/* binding */ parseDoubleDetailed)\n/* harmony export */ });\n/* harmony import */ var _double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-binary-string.js */ "./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js");\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-to-octets.js */ "./node_modules/big-float-ts/node/double-representation/double-to-octets.js");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    let parts = (0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_1__.doubleToOctets)(x);\r\n    let p0 = parts[0];\r\n    let p1 = parts[1];\r\n    let sign = p0 >> 7;\r\n    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    let hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    let exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    let significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    let str = (0,_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_0__.doubleToBinaryString)(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    let exponent_ = parseInt(exponent, 2);\r\n    let hidden = exponent_ === 0 ? "0" : "1";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/parse-double.js?')},"./node_modules/big-float-ts/node/double-representation/significand.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "significand": () => (/* binding */ significand)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ "./node_modules/big-float-ts/node/double-representation/parse-double.js");\n\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).significand;\r\n}\r\n\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/double-representation/significand.js?')},"./node_modules/big-float-ts/node/geometric-primitives/orient2d.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "orient2d": () => (/* binding */ orient2d)\n/* harmony export */ });\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/two-product.js */ "./node_modules/big-float-ts/node/basic/two-product.js");\n/* harmony import */ var _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double-expansion/e-diff.js */ "./node_modules/big-float-ts/node/double-expansion/e-diff.js");\n/* harmony import */ var _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double-expansion/e-estimate.js */ "./node_modules/big-float-ts/node/double-expansion/e-estimate.js");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../basic/two-diff.js */ "./node_modules/big-float-ts/node/basic/two-diff.js");\n/* harmony import */ var _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../double-expansion/fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../double-expansion/e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n\r\n\r\n\r\n\r\n\r\n\r\nlet ccwerrboundA = 3.330669073875472e-16;\r\nlet ccwerrboundB = 2.220446049250315e-16;\r\nlet ccwerrboundC = 1.109335647967049e-31;\r\nlet resulterrbound = 3.330669073875471e-16;\r\n/**\r\n * * Ported from [Shewchuk](http://docs.ros.org/kinetic/api/asr_approx_mvbb/html/Predicates_8cpp_source.html)\r\n * * see also https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n *\r\n * * Adaptive exact 2d orientation test.\r\n *\r\n * * Robust.\r\n *\r\n * Return a positive value if the points pa, pb, and pc occur in\r\n * counterclockwise order; a negative value if they occur in clockwise order;\r\n * and zero if they are collinear.  The result is also a rough approximation of\r\n * twice the signed area of the triangle defined by the three points.\r\n *\r\n * The result returned is the determinant of a matrix. This determinant is\r\n * computed adaptively, in the sense that exact arithmetic is used only to the\r\n * degree it is needed to ensure that the returned value has the correct sign.\r\n * Hence, orient2d() is usually quite fast, but will run more slowly when the\r\n * input points are collinear or nearly so.\r\n */\r\nfunction orient2d(A, B, C) {\r\n    let detleft = (A[0] - C[0]) * (B[1] - C[1]);\r\n    let detright = (A[1] - C[1]) * (B[0] - C[0]);\r\n    let det = detleft - detright;\r\n    let detsum;\r\n    if (detleft > 0) {\r\n        if (detright <= 0) {\r\n            // Anti-clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = detleft + detright;\r\n        }\r\n    }\r\n    else if (detleft < 0) {\r\n        if (detright >= 0) {\r\n            // Clockwise\r\n            return det;\r\n        }\r\n        else {\r\n            detsum = -detleft - detright;\r\n        }\r\n    }\r\n    else {\r\n        // Anti-clockwise, clockwise or straight\r\n        return det;\r\n    }\r\n    if (Math.abs(det) >= ccwerrboundA * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    return orient2dAdapt(A, B, C, detsum);\r\n}\r\nfunction orient2dAdapt(A, B, C, detsum) {\r\n    let acx = A[0] - C[0];\r\n    let bcx = B[0] - C[0];\r\n    let acy = A[1] - C[1];\r\n    let bcy = B[1] - C[1];\r\n    let b = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_1__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acx, bcy), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acy, bcx));\r\n    let det = (0,_double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_2__.eEstimate)(b);\r\n    if (Math.abs(det) >= ccwerrboundB * detsum) {\r\n        // Anti-clockwise or clockwise\r\n        return det;\r\n    }\r\n    let acxtail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(A[0], C[0])[0];\r\n    let bcxtail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(B[0], C[0])[0];\r\n    let acytail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(A[1], C[1])[0];\r\n    let bcytail = (0,_basic_two_diff_js__WEBPACK_IMPORTED_MODULE_3__.twoDiff)(B[1], C[1])[0];\r\n    if (acxtail === 0 && acytail === 0 &&\r\n        bcxtail === 0 && bcytail === 0) {\r\n        // Straight\r\n        return det;\r\n    }\r\n    let errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\r\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\r\n    if (Math.abs(det) >= errbound) {\r\n        return det;\r\n    }\r\n    let a = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_1__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acxtail, bcy), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acytail, bcx));\r\n    let c = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(b, a);\r\n    let d = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_1__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acx, bcytail), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acy, bcxtail));\r\n    let e = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(c, d);\r\n    let f = (0,_double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_1__.eDiff)((0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acxtail, bcytail), (0,_basic_two_product_js__WEBPACK_IMPORTED_MODULE_0__.twoProduct)(acytail, bcxtail));\r\n    let D = (0,_double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_4__.fastExpansionSum)(e, f);\r\n    D = (0,_double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__.eCompress)(D);\r\n    return D[D.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=orient2d.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/geometric-primitives/orient2d.js?')},"./node_modules/big-float-ts/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bitLength": () => (/* reexport safe */ _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_30__.bitLength),\n/* harmony export */   "doubleToBinaryString": () => (/* reexport safe */ _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__.doubleToBinaryString),\n/* harmony export */   "doubleToOctets": () => (/* reexport safe */ _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__.doubleToOctets),\n/* harmony export */   "eAbs": () => (/* reexport safe */ _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_7__.eAbs),\n/* harmony export */   "eAdd": () => (/* binding */ eAdd),\n/* harmony export */   "eAddDouble": () => (/* binding */ eAddDouble),\n/* harmony export */   "eCalculate": () => (/* reexport safe */ _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_31__.eCalculate),\n/* harmony export */   "eCompare": () => (/* reexport safe */ _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_6__.eCompare),\n/* harmony export */   "eCompress": () => (/* reexport safe */ _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__.eCompress),\n/* harmony export */   "eDiff": () => (/* reexport safe */ _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_9__.eDiff),\n/* harmony export */   "eDiv": () => (/* reexport safe */ _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_1__.eDiv),\n/* harmony export */   "eDivBy2": () => (/* reexport safe */ _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_18__.eDivBy2),\n/* harmony export */   "eEstimate": () => (/* reexport safe */ _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_8__.eEstimate),\n/* harmony export */   "eIntDiv": () => (/* reexport safe */ _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_3__.eIntDiv),\n/* harmony export */   "eIntPow": () => (/* reexport safe */ _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_39__.eIntPow),\n/* harmony export */   "eIsInteger": () => (/* reexport safe */ _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__.eIsInteger),\n/* harmony export */   "eLongDivide": () => (/* reexport safe */ _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_2__.eLongDivide),\n/* harmony export */   "eMult": () => (/* binding */ eMult),\n/* harmony export */   "eMultBy2": () => (/* reexport safe */ _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_16__.eMultBy2),\n/* harmony export */   "eMultByNeg2": () => (/* reexport safe */ _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_17__.eMultByNeg2),\n/* harmony export */   "eMultDouble1": () => (/* binding */ eMultDouble1),\n/* harmony export */   "eMultDouble2": () => (/* binding */ eMultDouble2),\n/* harmony export */   "eNegativeOf": () => (/* reexport safe */ _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_14__.eNegativeOf),\n/* harmony export */   "eProduct": () => (/* reexport safe */ _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_33__.eProduct),\n/* harmony export */   "eRem": () => (/* reexport safe */ _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_4__.eRem),\n/* harmony export */   "eSign": () => (/* reexport safe */ _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_29__.eSign),\n/* harmony export */   "eSum": () => (/* reexport safe */ _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_32__.eSum),\n/* harmony export */   "eToBitlength": () => (/* reexport safe */ _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_0__.eToBitlength),\n/* harmony export */   "eToDd": () => (/* reexport safe */ _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_40__.eToDd),\n/* harmony export */   "expBitLength": () => (/* reexport safe */ _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_30__.expBitLength),\n/* harmony export */   "expansionProduct": () => (/* reexport safe */ _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_24__.expansionProduct),\n/* harmony export */   "exponent": () => (/* reexport safe */ _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_34__.exponent),\n/* harmony export */   "fastExpansionSum": () => (/* reexport safe */ _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_10__.fastExpansionSum),\n/* harmony export */   "fastTwoDiff": () => (/* reexport safe */ _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_11__.fastTwoDiff),\n/* harmony export */   "fastTwoSum": () => (/* reexport safe */ _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_12__.fastTwoSum),\n/* harmony export */   "getHighestSetBit": () => (/* reexport safe */ _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getHighestSetBit),\n/* harmony export */   "getLowestSetBit": () => (/* reexport safe */ _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getLowestSetBit),\n/* harmony export */   "growExpansion": () => (/* reexport safe */ _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_13__.growExpansion),\n/* harmony export */   "isAdjacent": () => (/* reexport safe */ _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__.isAdjacent),\n/* harmony export */   "isBitAligned": () => (/* reexport safe */ _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_26__.isBitAligned),\n/* harmony export */   "isNonOverlappingAll": () => (/* reexport safe */ _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__.isNonOverlappingAll),\n/* harmony export */   "lsbExponent": () => (/* reexport safe */ _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_28__.lsbExponent),\n/* harmony export */   "msbExponent": () => (/* reexport safe */ _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_27__.msbExponent),\n/* harmony export */   "operators": () => (/* binding */ operators),\n/* harmony export */   "orient2d": () => (/* reexport safe */ _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__.orient2d),\n/* harmony export */   "parseDouble": () => (/* reexport safe */ _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_25__.parseDouble),\n/* harmony export */   "parseDoubleDetailed": () => (/* reexport safe */ _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_25__.parseDoubleDetailed),\n/* harmony export */   "reduceSignificand": () => (/* reexport safe */ _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_23__.reduceSignificand),\n/* harmony export */   "scaleExpansion": () => (/* reexport safe */ _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion),\n/* harmony export */   "scaleExpansion2": () => (/* reexport safe */ _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion2),\n/* harmony export */   "significand": () => (/* reexport safe */ _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_35__.significand),\n/* harmony export */   "split": () => (/* reexport safe */ _basic_split_js__WEBPACK_IMPORTED_MODULE_19__.split),\n/* harmony export */   "twoDiff": () => (/* reexport safe */ _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_20__.twoDiff),\n/* harmony export */   "twoProduct": () => (/* reexport safe */ _basic_two_product_js__WEBPACK_IMPORTED_MODULE_21__.twoProduct),\n/* harmony export */   "twoSum": () => (/* reexport safe */ _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_22__.twoSum)\n/* harmony export */ });\n/* harmony import */ var _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-expansion/e-to-bitlength.js */ "./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js");\n/* harmony import */ var _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-expansion/e-div.js */ "./node_modules/big-float-ts/node/double-expansion/e-div.js");\n/* harmony import */ var _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-expansion/e-long-divide.js */ "./node_modules/big-float-ts/node/double-expansion/e-long-divide.js");\n/* harmony import */ var _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-expansion/e-int-div.js */ "./node_modules/big-float-ts/node/double-expansion/e-int-div.js");\n/* harmony import */ var _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-expansion/e-rem.js */ "./node_modules/big-float-ts/node/double-expansion/e-rem.js");\n/* harmony import */ var _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-expansion/e-compress.js */ "./node_modules/big-float-ts/node/double-expansion/e-compress.js");\n/* harmony import */ var _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-expansion/e-compare.js */ "./node_modules/big-float-ts/node/double-expansion/e-compare.js");\n/* harmony import */ var _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-expansion/e-abs.js */ "./node_modules/big-float-ts/node/double-expansion/e-abs.js");\n/* harmony import */ var _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-expansion/e-estimate.js */ "./node_modules/big-float-ts/node/double-expansion/e-estimate.js");\n/* harmony import */ var _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./double-expansion/e-diff.js */ "./node_modules/big-float-ts/node/double-expansion/e-diff.js");\n/* harmony import */ var _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./double-expansion/fast-expansion-sum.js */ "./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js");\n/* harmony import */ var _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./basic/fast-two-diff.js */ "./node_modules/big-float-ts/node/basic/fast-two-diff.js");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./basic/fast-two-sum.js */ "./node_modules/big-float-ts/node/basic/fast-two-sum.js");\n/* harmony import */ var _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./double-expansion/grow-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/grow-expansion.js");\n/* harmony import */ var _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./double-expansion/e-negative-of.js */ "./node_modules/big-float-ts/node/double-expansion/e-negative-of.js");\n/* harmony import */ var _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./double-expansion/scale-expansion.js */ "./node_modules/big-float-ts/node/double-expansion/scale-expansion.js");\n/* harmony import */ var _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./double-expansion/e-mult-by-2.js */ "./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js");\n/* harmony import */ var _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./double-expansion/e-mult-by-neg-2.js */ "./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js");\n/* harmony import */ var _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./double-expansion/e-div-by-2.js */ "./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js");\n/* harmony import */ var _basic_split_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./basic/split.js */ "./node_modules/big-float-ts/node/basic/split.js");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./basic/two-diff.js */ "./node_modules/big-float-ts/node/basic/two-diff.js");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./basic/two-product.js */ "./node_modules/big-float-ts/node/basic/two-product.js");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./basic/two-sum.js */ "./node_modules/big-float-ts/node/basic/two-sum.js");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./basic/reduce-significand.js */ "./node_modules/big-float-ts/node/basic/reduce-significand.js");\n/* harmony import */ var _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./double-expansion/expansion-product.js */ "./node_modules/big-float-ts/node/double-expansion/expansion-product.js");\n/* harmony import */ var _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./double-representation/parse-double.js */ "./node_modules/big-float-ts/node/double-representation/parse-double.js");\n/* harmony import */ var _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./double-representation/is-bit-aligned.js */ "./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./double-representation/msb-exponent.js */ "./node_modules/big-float-ts/node/double-representation/msb-exponent.js");\n/* harmony import */ var _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./double-representation/lsb-exponent.js */ "./node_modules/big-float-ts/node/double-representation/lsb-exponent.js");\n/* harmony import */ var _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./double-expansion/e-sign.js */ "./node_modules/big-float-ts/node/double-expansion/e-sign.js");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./double-representation/bit-length.js */ "./node_modules/big-float-ts/node/double-representation/bit-length.js");\n/* harmony import */ var _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./double-expansion/e-calculate.js */ "./node_modules/big-float-ts/node/double-expansion/e-calculate.js");\n/* harmony import */ var _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./double-expansion/e-sum.js */ "./node_modules/big-float-ts/node/double-expansion/e-sum.js");\n/* harmony import */ var _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./double-expansion/e-product.js */ "./node_modules/big-float-ts/node/double-expansion/e-product.js");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./double-representation/exponent.js */ "./node_modules/big-float-ts/node/double-representation/exponent.js");\n/* harmony import */ var _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./double-representation/significand.js */ "./node_modules/big-float-ts/node/double-representation/significand.js");\n/* harmony import */ var _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./double-representation/double-to-binary-string.js */ "./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js");\n/* harmony import */ var _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./double-representation/double-to-octets.js */ "./node_modules/big-float-ts/node/double-representation/double-to-octets.js");\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./double-representation/get-max-set-bit.js */ "./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./double-expansion/e-int-pow.js */ "./node_modules/big-float-ts/node/double-expansion/e-int-pow.js");\n/* harmony import */ var _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./double-expansion/e-to-double-double.js */ "./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js");\n/* harmony import */ var _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./geometric-primitives/orient2d.js */ "./node_modules/big-float-ts/node/geometric-primitives/orient2d.js");\n/* harmony import */ var _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./double-expansion/is-adjacent.js */ "./node_modules/big-float-ts/node/double-expansion/is-adjacent.js");\n/* harmony import */ var _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./double-expansion/is-overlapping.js */ "./node_modules/big-float-ts/node/double-expansion/is-overlapping.js");\n/* harmony import */ var _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./double-expansion/e-is-integer.js */ "./node_modules/big-float-ts/node/double-expansion/e-is-integer.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Aliases for some functions which names were not changed due to them being\r\n// used extensively in the literature with a particular recognizable name\r\nconst eAdd = _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_10__.fastExpansionSum;\r\nconst eAddDouble = _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_13__.growExpansion;\r\nconst eMult = _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_24__.expansionProduct;\r\nconst eMultDouble1 = _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion;\r\nconst eMultDouble2 = _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion2;\r\nconst operators = {\r\n    //---- basic ----//\r\n    fastTwoDiff: _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_11__.fastTwoDiff,\r\n    fastTwoSum: _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_12__.fastTwoSum,\r\n    split: _basic_split_js__WEBPACK_IMPORTED_MODULE_19__.split,\r\n    twoDiff: _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_20__.twoDiff,\r\n    twoProduct: _basic_two_product_js__WEBPACK_IMPORTED_MODULE_21__.twoProduct,\r\n    twoSum: _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_22__.twoSum,\r\n    reduceSignificand: _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_23__.reduceSignificand,\r\n    //---- double floating point expansions ----//\r\n    fastExpansionSum: _double_expansion_fast_expansion_sum_js__WEBPACK_IMPORTED_MODULE_10__.fastExpansionSum, eAdd,\r\n    growExpansion: _double_expansion_grow_expansion_js__WEBPACK_IMPORTED_MODULE_13__.growExpansion, eAddDouble,\r\n    expansionProduct: _double_expansion_expansion_product_js__WEBPACK_IMPORTED_MODULE_24__.expansionProduct, eMult,\r\n    scaleExpansion: _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion, eMultDouble1,\r\n    scaleExpansion2: _double_expansion_scale_expansion_js__WEBPACK_IMPORTED_MODULE_15__.scaleExpansion2, eMultDouble2,\r\n    eDiv: _double_expansion_e_div_js__WEBPACK_IMPORTED_MODULE_1__.eDiv,\r\n    eLongDivide: _double_expansion_e_long_divide_js__WEBPACK_IMPORTED_MODULE_2__.eLongDivide,\r\n    eIntDiv: _double_expansion_e_int_div_js__WEBPACK_IMPORTED_MODULE_3__.eIntDiv,\r\n    eRem: _double_expansion_e_rem_js__WEBPACK_IMPORTED_MODULE_4__.eRem,\r\n    eCompress: _double_expansion_e_compress_js__WEBPACK_IMPORTED_MODULE_5__.eCompress,\r\n    eEstimate: _double_expansion_e_estimate_js__WEBPACK_IMPORTED_MODULE_8__.eEstimate,\r\n    eDiff: _double_expansion_e_diff_js__WEBPACK_IMPORTED_MODULE_9__.eDiff,\r\n    eNegativeOf: _double_expansion_e_negative_of_js__WEBPACK_IMPORTED_MODULE_14__.eNegativeOf,\r\n    eMultBy2: _double_expansion_e_mult_by_2_js__WEBPACK_IMPORTED_MODULE_16__.eMultBy2,\r\n    eMultByNeg2: _double_expansion_e_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_17__.eMultByNeg2,\r\n    eDivBy2: _double_expansion_e_div_by_2_js__WEBPACK_IMPORTED_MODULE_18__.eDivBy2,\r\n    eSign: _double_expansion_e_sign_js__WEBPACK_IMPORTED_MODULE_29__.eSign,\r\n    eCompare: _double_expansion_e_compare_js__WEBPACK_IMPORTED_MODULE_6__.eCompare,\r\n    eAbs: _double_expansion_e_abs_js__WEBPACK_IMPORTED_MODULE_7__.eAbs,\r\n    eToBitlength: _double_expansion_e_to_bitlength_js__WEBPACK_IMPORTED_MODULE_0__.eToBitlength,\r\n    eIntPow: _double_expansion_e_int_pow_js__WEBPACK_IMPORTED_MODULE_39__.eIntPow,\r\n    eCalculate: _double_expansion_e_calculate_js__WEBPACK_IMPORTED_MODULE_31__.eCalculate,\r\n    eSum: _double_expansion_e_sum_js__WEBPACK_IMPORTED_MODULE_32__.eSum,\r\n    eProduct: _double_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_33__.eProduct,\r\n    eToDd: _double_expansion_e_to_double_double_js__WEBPACK_IMPORTED_MODULE_40__.eToDd,\r\n    //---- double floating point representation ----//\r\n    parseDouble: _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_25__.parseDouble,\r\n    parseDoubleDetailed: _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_25__.parseDoubleDetailed,\r\n    isBitAligned: _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_26__.isBitAligned,\r\n    msbExponent: _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_27__.msbExponent,\r\n    lsbExponent: _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_28__.lsbExponent,\r\n    bitLength: _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_30__.bitLength,\r\n    expBitLength: _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_30__.expBitLength,\r\n    doubleToBinaryString: _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_36__.doubleToBinaryString,\r\n    doubleToOctets: _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_37__.doubleToOctets,\r\n    getHighestSetBit: _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getHighestSetBit,\r\n    getLowestSetBit: _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_38__.getLowestSetBit,\r\n    exponent: _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_34__.exponent,\r\n    significand: _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_35__.significand,\r\n    //---- geometric primitives\r\n    orient2d: _geometric_primitives_orient2d_js__WEBPACK_IMPORTED_MODULE_41__.orient2d,\r\n    //---- others\r\n    isAdjacent: _double_expansion_is_adjacent_js__WEBPACK_IMPORTED_MODULE_42__.isAdjacent,\r\n    isNonOverlappingAll: _double_expansion_is_overlapping_js__WEBPACK_IMPORTED_MODULE_43__.isNonOverlappingAll,\r\n    eIsInteger: _double_expansion_e_is_integer_js__WEBPACK_IMPORTED_MODULE_44__.eIsInteger\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/big-float-ts/node/index.js?')},"./node_modules/double-double/node/basic/fast-two-diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fastTwoDiff": () => (/* binding */ fastTwoDiff)\n/* harmony export */ });\n/**\r\n * Returns the difference and exact error of subtracting two floating point\r\n * numbers.\r\n * Uses an EFT (error-free transformation), i.e. `a-b === x+y` exactly.\r\n * The returned result is a non-overlapping expansion (smallest value first!).\r\n *\r\n * * **precondition:** `abs(a) >= abs(b)` - A fast test that can be used is\r\n * `(a > b) === (a > -b)`\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoDiff(a, b) {\r\n    const x = a - b;\r\n    const y = (a - x) - b;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=fast-two-diff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/fast-two-diff.js?')},"./node_modules/double-double/node/basic/fast-two-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fastTwoSum": () => (/* binding */ fastTwoSum)\n/* harmony export */ });\n/**\r\n * Returns the sum and exact error of adding two floating point numbers.\r\n * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.\r\n * The returned sum is a non-overlapping expansion (smallest value first!).\r\n *\r\n * Precondition: abs(a) >= abs(b) - A fast test that can be used is\r\n * (a > b) === (a > -b)\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction fastTwoSum(a, b) {\r\n    const x = a + b;\r\n    return [b - (x - a), x];\r\n}\r\n// inlined\r\n//const R = a + b; const r = b - (R - a); return [r, R];\r\n\r\n//# sourceMappingURL=fast-two-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/fast-two-sum.js?')},"./node_modules/double-double/node/basic/reduce-significand.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reduceSignificand": () => (/* binding */ reduceSignificand)\n/* harmony export */ });\n/**\r\n * Truncates a floating point value\'s significand and returns the result.\r\n * Similar to split, but with the ability to specify the number of bits to keep.\r\n *\r\n * **Theorem 17 (Veltkamp-Dekker)**: Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param a a double\r\n * @param bits the number of significand bits to leave intact\r\n */\r\nfunction reduceSignificand(a, bits) {\r\n    const s = 53 - bits;\r\n    const f = 2 ** s + 1;\r\n    const c = f * a;\r\n    const r = c - (c - a);\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=reduce-significand.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/reduce-significand.js?')},"./node_modules/double-double/node/basic/split.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "split": () => (/* binding */ split)\n/* harmony export */ });\n/**\r\n * === 2^Math.ceil(p/2) + 1 where p is the # of significand bits in a double === 53.\r\n * @internal\r\n */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of splitting a double into 2 26-bit doubles.\r\n *\r\n * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where\r\n * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the\r\n * following algorithm will produce a (p-s)-bit value a_hi and a\r\n * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and\r\n * a = a_hi + a_lo.\r\n *\r\n * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * @param a A double floating point number\r\n */\r\nfunction split(a) {\r\n    const c = f * a;\r\n    const a_h = c - (c - a);\r\n    const a_l = a - a_h;\r\n    return [a_h, a_l];\r\n}\r\n// inlined - input a, output a_h, a_l\r\n// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];\r\n\r\n//# sourceMappingURL=split.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/split.js?')},"./node_modules/double-double/node/basic/two-diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoDiff": () => (/* binding */ twoDiff)\n/* harmony export */ });\n/**\r\n * Returns the exact result of subtracting b from a.\r\n *\r\n * @param a minuend - a double-double precision floating point number\r\n * @param b subtrahend - a double-double precision floating point number\r\n */\r\nfunction twoDiff(a, b) {\r\n    const x = a - b;\r\n    const bvirt = a - x;\r\n    const y = (a - (x + bvirt)) + (bvirt - b);\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-diff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/two-diff.js?')},"./node_modules/double-double/node/basic/two-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoProduct": () => (/* binding */ twoProduct)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the exact result of multiplying two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where\r\n * p >= 6. Then the following algorithm will produce a nonoverlapping expansion\r\n * x + y such that ab = x + y, where x is an approximation to ab and y\r\n * represents the roundoff error in the calculation of x. Furthermore, if\r\n * round-to-even tiebreaking is used, x and y are non-adjacent.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n * @param a A double\r\n * @param b Another double\r\n */\r\nfunction twoProduct(a, b) {\r\n    const x = a * b;\r\n    //const [ah, al] = split(a);\r\n    const c = f * a;\r\n    const ah = c - (c - a);\r\n    const al = a - ah;\r\n    //const [bh, bl] = split(b);\r\n    const d = f * b;\r\n    const bh = d - (d - b);\r\n    const bl = b - bh;\r\n    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //const err1 = x - (ah * bh);\r\n    //const err2 = err1 - (al * bh);\r\n    //const err3 = err2 - (ah * bl);\r\n    //const y = (al * bl) - err3;\r\n    return [y, x];\r\n}\r\n\r\n//# sourceMappingURL=two-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/two-product.js?')},"./node_modules/double-double/node/basic/two-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "twoSum": () => (/* binding */ twoSum)\n/* harmony export */ });\n/**\r\n * Returns the exact result of adding two doubles.\r\n *\r\n * * the resulting array is the reverse of the standard twoSum in the literature.\r\n *\r\n * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the\r\n * following algorithm will produce a nonoverlapping expansion x + y such that\r\n * a + b = x + y, where x is an approximation to a + b and y is the roundoff\r\n * error in the calculation of x.\r\n *\r\n * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf\r\n */\r\nfunction twoSum(a, b) {\r\n    const x = a + b;\r\n    const bv = x - a;\r\n    return [(a - (x - bv)) + (b - bv), x];\r\n}\r\n// inlined\r\n//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]\r\n\r\n//# sourceMappingURL=two-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/basic/two-sum.js?')},"./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDivDdWithError": () => (/* binding */ ddDivDdWithError)\n/* harmony export */ });\n/* harmony import */ var _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double-double/binary/dd-div-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-div-dd.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst div = _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDivDd;\r\n/** @internal */\r\nconst eps = Number.EPSILON;\r\n/** @internal */\r\nconst u = eps / 2;\r\n/** @internal */\r\nconst uu = u * u;\r\n/**\r\n * Returns the result of dividing two double-double-precision floating point\r\n * numbers together with an absolute error bound where nE and dE are absolute\r\n * error bounds on the *input* values.\r\n *\r\n * @param numer numerator - a double-double-precision float\r\n * @param denom denominator - a double-double-precision float\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction ddDivDdWithError(numer, denom, nE, dE) {\r\n    const n = numer[0];\r\n    const N = numer[1];\r\n    const d = denom[0];\r\n    const D = denom[1];\r\n    // estimate the result of the division\r\n    const est = div(numer, denom);\r\n    const _n = Math.abs(n + N); // absolute value of estimate of n accurate to within 1/2 ulp\r\n    const _d = Math.abs(d + D); // absolute value of estimate of d accurate to within 1/2 ulp\r\n    const δd = u * _d; // the max error in the rounding to _d\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    const minD = _d - δd - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    const err = ((_d * nE + _n * dE) / minD ** 2) + 9 * uu * Math.abs(_n / _d);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=dd-div-dd-with-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js?')},"./node_modules/double-double/node/double-double/binary/dd-add-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddAddDd": () => (/* binding */ ddAddDd)\n/* harmony export */ });\n/**\r\n * Returns the result of adding two double-double-precision floating point\r\n * numbers.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddAddDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh + yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl + yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    const zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-add-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-add-dd.js?')},"./node_modules/double-double/node/double-double/binary/dd-compare.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddCompare": () => (/* binding */ ddCompare)\n/* harmony export */ });\n/**\r\n * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.\r\n *\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddCompare(x, y) {\r\n    //return ddDiffDd(x,y)[1];\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh - yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (-yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl - yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (-yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    return zh;\r\n}\r\n\r\n//# sourceMappingURL=dd-compare.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-compare.js?')},"./node_modules/double-double/node/double-double/binary/dd-diff-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDiffDd": () => (/* binding */ ddDiffDd)\n/* harmony export */ });\n/**\r\n * Returns the result of subtracting the second given double-double-precision\r\n * floating point number from the first.\r\n *\r\n * * relative error bound: 3u^2 + 13u^3, i.e. fl(a-b) = (a-b)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n * * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 2.25u^2\r\n *\r\n * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddDiffDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    //const [sl,sh] = twoSum(xh,yh);\r\n    const sh = xh - yh;\r\n    const _1 = sh - xh;\r\n    const sl = (xh - (sh - _1)) + (-yh - _1);\r\n    //const [tl,th] = twoSum(xl,yl);\r\n    const th = xl - yl;\r\n    const _2 = th - xl;\r\n    const tl = (xl - (th - _2)) + (-yl - _2);\r\n    const c = sl + th;\r\n    //const [vl,vh] = fastTwoSum(sh,c)\r\n    const vh = sh + c;\r\n    const vl = c - (vh - sh);\r\n    const w = tl + vl;\r\n    //const [zl,zh] = fastTwoSum(vh,w)\r\n    const zh = vh + w;\r\n    const zl = w - (zh - vh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-diff-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-diff-dd.js?')},"./node_modules/double-double/node/double-double/binary/dd-div-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDivDd": () => (/* binding */ ddDivDd)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing two double-double-precision floating point\r\n * numbers, i.e. returns x/y.\r\n *\r\n * * relative error bound: 15u^2 + 56u^3, i.e. fl(a/b) = (a/b)(1+ϵ),\r\n * where ϵ <= 15u^2 + 56u^3, u = 0.5 * Number.EPSILON\r\n * * the largest error found was 8.465u^2\r\n *\r\n * * ALGORITHM 17 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddDivDd(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const yl = y[0];\r\n    const yh = y[1];\r\n    const th = xh / yh;\r\n    // approximation to th*(yh + yl) using Algorithm 7\r\n    //const [rl,rh] = ddMultDouble1(th,[yl,yh]);  \r\n    const ch = yh * th;\r\n    const c = f * yh;\r\n    const ah = c - (c - yh);\r\n    const al = yh - ah;\r\n    const d = f * th;\r\n    const bh = d - (d - th);\r\n    const bl = th - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = yl * th;\r\n    const th_ = ch + cl2;\r\n    const tl1 = cl2 - (th_ - ch);\r\n    const tl2 = tl1 + cl1;\r\n    const rh = th_ + tl2;\r\n    const rl = tl2 - (rh - th_);\r\n    const πh = xh - rh; // exact operation\r\n    const δl = xl - rl;\r\n    const δ = πh + δl;\r\n    const tl = δ / yh;\r\n    //return fastTwoSum(th,tl);\r\n    const xx = th + tl;\r\n    return [tl - (xx - th), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-div-dd.js?')},"./node_modules/double-double/node/double-double/binary/dd-max.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMax": () => (/* binding */ ddMax)\n/* harmony export */ });\n/* harmony import */ var _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-diff-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-diff-dd.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst diff = _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the maximum of a and b.\r\n * @param a a double-double precision floating point number\r\n * @param b another double-double precision floating point number\r\n */\r\nfunction ddMax(a, b) {\r\n    const res = diff(a, b)[1];\r\n    return res > 0 ? a : b;\r\n}\r\n\r\n//# sourceMappingURL=dd-max.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-max.js?')},"./node_modules/double-double/node/double-double/binary/dd-min.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMin": () => (/* binding */ ddMin)\n/* harmony export */ });\n/* harmony import */ var _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-diff-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-diff-dd.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\n/** @internal */\r\nconst diff = _dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the minimum of a and b.\r\n * @param a a double-double precision floating point number\r\n * @param b another double-double precision floating point number\r\n */\r\nfunction ddMin(a, b) {\r\n    const res = diff(a, b)[1];\r\n    return res > 0 ? b : a;\r\n}\r\n\r\n//# sourceMappingURL=dd-min.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-min.js?')},"./node_modules/double-double/node/double-double/binary/dd-mult-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultDd": () => (/* binding */ ddMultDd)\n/* harmony export */ });\n/** @internal */\r\nconst f = 2 ** 27 + 1;\r\n/**\r\n * Returns the product of two double-double-precision floating point numbers.\r\n *\r\n * * relative error bound: 7u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n * the error bound is not sharp - the worst case that could be found by the\r\n * authors were 5u^2\r\n *\r\n * * ALGORITHM 10 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y another double-double precision floating point number\r\n */\r\nfunction ddMultDd(x, y) {\r\n    //const xl = x[0];\r\n    const xh = x[1];\r\n    //const yl = y[0];\r\n    const yh = y[1];\r\n    //const [cl1,ch] = twoProduct(xh,yh);\r\n    const ch = xh * yh;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * yh;\r\n    const bh = d - (d - yh);\r\n    const bl = yh - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    //return fastTwoSum(ch,cl1 + (xh*yl + xl*yh));\r\n    const b = cl1 + (xh * y[0] + x[0] * yh);\r\n    const xx = ch + b;\r\n    return [b - (xx - ch), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/binary/dd-mult-dd.js?')},"./node_modules/double-double/node/double-double/multi/dd-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddProduct": () => (/* binding */ ddProduct)\n/* harmony export */ });\n/* harmony import */ var _binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary/dd-mult-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-mult-dd.js");\n\r\n/**\r\n * Returns the result of multiplying together an array of double-double-precision\r\n * floating point numbers naively (i.e. not using pairwise addition to reduce\r\n * error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON\r\n */\r\nfunction ddProduct(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = (0,_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddMultDd)(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=dd-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/multi/dd-product.js?')},"./node_modules/double-double/node/double-double/multi/dd-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddSum": () => (/* binding */ ddSum)\n/* harmony export */ });\n/* harmony import */ var _binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary/dd-add-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-add-dd.js");\n\r\n/**\r\n * Returns the result of summing an array of double-double-precision floating\r\n * point numbers naively (i.e. not using pairwise addition to reduce error a bit).\r\n *\r\n * * an error bound is given by: (n-1)(1+ϵ),\r\n * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON\r\n */\r\nfunction ddSum(qs) {\r\n    let q = qs[0];\r\n    for (let i = 1; i < qs.length; i++) {\r\n        q = (0,_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_0__.ddAddDd)(q, qs[i]);\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=dd-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/multi/dd-sum.js?')},"./node_modules/double-double/node/double-double/unary/dd-abs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddAbs": () => (/* binding */ ddAbs)\n/* harmony export */ });\n/**\r\n * Returns the absolute value of the given double-double precision floating\r\n * point number.\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddAbs(f) {\r\n    const Q = f[1];\r\n    return (Q < 0) ? [-f[0], -Q] : f;\r\n}\r\n\r\n//# sourceMappingURL=dd-abs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-abs.js?')},"./node_modules/double-double/node/double-double/unary/dd-div-by-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDivBy2": () => (/* binding */ ddDivBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of dividing the given double-double by 2.\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddDivBy2(f) {\r\n    return [f[0] / 2, f[1] / 2];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-by-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-div-by-2.js?')},"./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultBy2": () => (/* binding */ ddMultBy2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by 2.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultBy2(f) {\r\n    return [2 * f[0], 2 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js?')},"./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultBy4": () => (/* binding */ ddMultBy4)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by 4.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultBy4(f) {\r\n    return [4 * f[0], 4 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-4.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js?')},"./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultByNeg2": () => (/* binding */ ddMultByNeg2)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by -2.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultByNeg2(f) {\r\n    return [-2 * f[0], -2 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-neg-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js?')},"./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultByNeg4": () => (/* binding */ ddMultByNeg4)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying the given double-double by -4.\r\n * * The result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddMultByNeg4(f) {\r\n    return [-4 * f[0], -4 * f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-by-neg-4.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js?')},"./node_modules/double-double/node/double-double/unary/dd-negative-of.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddNegativeOf": () => (/* binding */ ddNegativeOf)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given double-double precision floating point\r\n * number.\r\n * * the result is exact\r\n * @param f a double-double precision floating point number\r\n */\r\nfunction ddNegativeOf(f) {\r\n    return [-f[0], -f[1]];\r\n}\r\n\r\n//# sourceMappingURL=dd-negative-of.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-negative-of.js?')},"./node_modules/double-double/node/double-double/unary/dd-sign.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddSign": () => (/* binding */ ddSign)\n/* harmony export */ });\n/**\r\n * Returns the sign of the given double-double-precision floating point number.\r\n * * a positive or negative double or zero is returned - not necessarily +1, 0\r\n * or -1\r\n * * prefer inlining this - it is really only here for reference\r\n */\r\nfunction ddSign(f) {\r\n    return f[1];\r\n}\r\n\r\n//# sourceMappingURL=dd-sign.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-sign.js?')},"./node_modules/double-double/node/double-double/unary/dd-sqrt.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddSqrt": () => (/* binding */ ddSqrt)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts\r\n// Unfortunately no error bound given\r\n/**\r\n * Returns the square root of a double-double as a double-double.\r\n * * no error bound is returned\r\n *\r\n * @param x a double-double precision floating point number\r\n */\r\n// TODO - calculate an error bound and add to function description\r\nfunction ddSqrt(x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    if (xh === 0) {\r\n        return [0, 0];\r\n    }\r\n    const s = Math.sqrt(xh);\r\n    //const [tl,th] = twoSquare(s);\r\n    const th = s * s;\r\n    const c = f * s;\r\n    const ah = c - (c - s);\r\n    const al = s - ah;\r\n    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));\r\n    const e = (xh - th - tl + xl) * 0.5 / s;\r\n    return [e - ((s + e) - s), s + e];\r\n}\r\n\r\n//# sourceMappingURL=dd-sqrt.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-double/unary/dd-sqrt.js?')},"./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddAddDouble": () => (/* binding */ ddAddDouble)\n/* harmony export */ });\n/**\r\n * Returns the result of adding a double to a double-double precision floating\r\n * point number.\r\n *\r\n * * relative error bound: 2u^2, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 2u^2, u = 0.5 * Number.EPSILON\r\n * * the error bound is sharp\r\n *\r\n * ALGORITHM 4 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y a double precision floating point number\r\n */\r\nfunction ddAddDouble(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [sl,sh] = twoSum(xh, y);\r\n    const sh = xh + y;\r\n    const c = sh - xh;\r\n    const sl = (xh - (sh - c)) + (y - c);\r\n    const v = xl + sl;\r\n    //const [zl,zh] = fastTwoSum(sh,v);\r\n    const zh = sh + v;\r\n    const zl = v - (zh - sh);\r\n    return [zl, zh];\r\n}\r\n\r\n//# sourceMappingURL=dd-add-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js?')},"./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDivDouble": () => (/* binding */ ddDivDouble)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing a double-double-precision floating point\r\n * number by a double.\r\n *\r\n * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,\r\n * u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n *\r\n * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param x a double-double precision floating point number\r\n * @param y the double-precision divisor\r\n */\r\nfunction ddDivDouble(x, y) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    const th = xh / y;\r\n    //const [πl,πh] = twoProduct(th,y);\r\n    const πh = th * y;\r\n    const c = f * th;\r\n    const ah = c - (c - th);\r\n    const al = th - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const δh = xh - πh; // exact operation\r\n    const δt = δh - πl; // exact operation\r\n    const δ = δt + xl;\r\n    const tl = δ / y;\r\n    //return fastTwoSum(th,tl);\r\n    const rl = th + tl;\r\n    return [tl - (rl - th), rl];\r\n}\r\n\r\n//# sourceMappingURL=dd-div-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js?')},"./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddMultDouble1": () => (/* binding */ ddMultDouble1),\n/* harmony export */   "ddMultDouble2": () => (/* binding */ ddMultDouble2)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the product of a double-double-precision floating point number and a\r\n * double.\r\n *\r\n * * slower than ALGORITHM 8 (one call to fastTwoSum more) but about 2x more\r\n * accurate\r\n * * relative error bound: 1.5u^2 + 4u^3, i.e. fl(a+b) = (a+b)(1+ϵ),\r\n * where ϵ <= 1.5u^2 + 4u^3, u = 0.5 * Number.EPSILON\r\n * * the bound is very sharp\r\n * * probably prefer `ddMultDouble2` due to extra speed\r\n *\r\n * * ALGORITHM 7 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param x a double-double precision floating point number\r\n */\r\nfunction ddMultDouble1(y, x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [cl1,ch] = twoProduct(xh,y);\r\n    const ch = xh * y;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = xl * y;\r\n    //const [tl1,th] = fastTwoSum(ch,cl2);\r\n    const th = ch + cl2;\r\n    const tl1 = cl2 - (th - ch);\r\n    const tl2 = tl1 + cl1;\r\n    //const [zl,zh] = fastTwoSum(th,tl2);\r\n    const zh = th + tl2;\r\n    const zl = tl2 - (zh - th);\r\n    return [zl, zh];\r\n}\r\n/**\r\n * Returns the product of a double-double-precision floating point number and a double.\r\n *\r\n * * faster than ALGORITHM 7 (one call to fastTwoSum less) but about 2x less\r\n * accurate\r\n * * relative error bound: 3u^2, i.e. fl(a*b) = (a*b)(1+ϵ),\r\n * where ϵ <= 3u^2, u = 0.5 * Number.EPSILON\r\n * * the bound is sharp\r\n * * probably prefer this algorithm due to extra speed\r\n *\r\n * * ALGORITHM 8 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * @param y a double\r\n * @param x a double-double precision floating point number\r\n */\r\nfunction ddMultDouble2(y, x) {\r\n    const xl = x[0];\r\n    const xh = x[1];\r\n    //const [cl1,ch] = twoProduct(xh,y);\r\n    const ch = xh * y;\r\n    const c = f * xh;\r\n    const ah = c - (c - xh);\r\n    const al = xh - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const cl2 = xl * y;\r\n    const cl3 = cl1 + cl2;\r\n    //return fastTwoSum(ch,cl3);\r\n    const xx = ch + cl3;\r\n    return [cl3 - (xx - ch), xx];\r\n}\r\n\r\n//# sourceMappingURL=dd-mult-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js?')},"./node_modules/double-double/node/double-mixed-double-double/double-div-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleDivDouble": () => (/* binding */ doubleDivDouble)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n/**\r\n * Returns the result of dividing a double-precision floating point\r\n * number by a double with the result given as a double-double.\r\n * This is a slight modification of ddDivDd.\r\n *\r\n * * **!! NOT an error-free transformation !!**\r\n * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,\r\n * u = 0.5 * Number.EPSILON\r\n *\r\n * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document\r\n * (slightly modified)\r\n * @param x dividend\r\n * @param y divisor\r\n */\r\nfunction doubleDivDouble(x, y) {\r\n    const th = x / y;\r\n    //const [πl,πh] = twoProduct(th,y);\r\n    const πh = th * y;\r\n    const c = f * th;\r\n    const ah = c - (c - th);\r\n    const al = th - ah;\r\n    const d = f * y;\r\n    const bh = d - (d - y);\r\n    const bl = y - bh;\r\n    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));\r\n    const δh = x - πh; // exact operation\r\n    const δt = δh - πl; // exact operation\r\n    const tl = δt / y;\r\n    //return fastTwoSum(th,tl);\r\n    const xx = th + tl;\r\n    return [tl - (xx - th), xx];\r\n}\r\n\r\n//# sourceMappingURL=double-div-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-mixed-double-double/double-div-double.js?')},"./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleSqrt": () => (/* binding */ doubleSqrt)\n/* harmony export */ });\n/** @internal */\r\nconst f = 134217729; // 2**27 + 1;\r\n// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts\r\n// Unfortunately no error bound given\r\n/**\r\n * Returns the square root of a double as a double-double.\r\n * * no error bound is returned\r\n */\r\n// TODO - calculate an error bound and add to function description\r\nfunction doubleSqrt(x) {\r\n    if (x === 0) {\r\n        return [0, 0];\r\n    }\r\n    const s = Math.sqrt(x);\r\n    //const [tl,th] = twoSquare(s);\r\n    const th = s * s;\r\n    const c = f * s;\r\n    const ah = c - (c - s);\r\n    const al = s - ah;\r\n    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));\r\n    const e = (x - th - tl) * 0.5 / s;\r\n    x = s + e;\r\n    const xl = e - (x - s);\r\n    return [xl, x];\r\n}\r\n\r\n//# sourceMappingURL=double-sqrt.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js?')},"./node_modules/double-double/node/double-representation/bit-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bitLength": () => (/* binding */ bitLength)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/double-double/node/double-representation/get-max-set-bit.js");\n\r\n/**\r\n * Returns the bit-length of the significand of the given number in such a way\r\n * that trailing zeros are not counted.\r\n * @param a a double precision floating point number\r\n */\r\nfunction bitLength(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) + 1;\r\n}\r\n\r\n//# sourceMappingURL=bit-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/bit-length.js?')},"./node_modules/double-double/node/double-representation/double-to-binary-string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleToBinaryString": () => (/* binding */ doubleToBinaryString)\n/* harmony export */ });\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-octets.js */ "./node_modules/double-double/node/double-representation/double-to-octets.js");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n/** @internal */\r\nfunction doubleToBinaryString(number) {\r\n    return octetsToBinaryString((0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_0__.doubleToOctets)(number));\r\n}\r\n/**\r\n * @param octets The 8 bytes composing a double (msb first)\r\n * @internal\r\n */\r\nfunction octetsToBinaryString(octets) {\r\n    return octets\r\n        .map(int8ToBinaryString)\r\n        .join(\'\');\r\n}\r\n/**\r\n * intToBinaryString(8) -> "00001000"\r\n * @internal\r\n */\r\nfunction int8ToBinaryString(i) {\r\n    let iStr = i.toString(2);\r\n    for (; iStr.length < 8; iStr = "0" + iStr)\r\n        ;\r\n    return iStr;\r\n}\r\n\r\n//# sourceMappingURL=double-to-binary-string.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/double-to-binary-string.js?')},"./node_modules/double-double/node/double-representation/double-to-octets.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doubleToOctets": () => (/* binding */ doubleToOctets)\n/* harmony export */ });\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n/**\r\n * Returns the ieee-574 8 bytes composing the given double, starting from the\r\n * sign bit and ending in the lsb of the significand.\r\n * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]\r\n * @internal\r\n */\r\nfunction doubleToOctets(number) {\r\n    var buffer = new ArrayBuffer(8);\r\n    new DataView(buffer).setFloat64(0, number, false);\r\n    return Array.from(new Uint8Array(buffer));\r\n}\r\n\r\n//# sourceMappingURL=double-to-octets.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/double-to-octets.js?')},"./node_modules/double-double/node/double-representation/exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "exponent": () => (/* binding */ exponent)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ "./node_modules/double-double/node/double-representation/parse-double.js");\n\r\n/**\r\n * Returns the normalized exponent of the given number.\r\n * @param a A double\r\n */\r\nfunction exponent(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).exponent;\r\n}\r\n\r\n//# sourceMappingURL=exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/exponent.js?')},"./node_modules/double-double/node/double-representation/get-max-set-bit.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getHighestSetBit": () => (/* binding */ getHighestSetBit),\n/* harmony export */   "getLowestSetBit": () => (/* binding */ getLowestSetBit)\n/* harmony export */ });\n/* harmony import */ var _significand_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./significand.js */ "./node_modules/double-double/node/double-representation/significand.js");\n\r\n/**\r\n * Returns the lowest set bit of the given value in [1, (2**31)-1],\r\n * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns\r\n * NaN, otherwise if the number is out of range returns a non-finite\r\n * number.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n * @internal\r\n */\r\nfunction getLowestSetBit_(a) {\r\n    return Math.log2(a & -a);\r\n}\r\n/**\r\n * Returns the lowest set bit of the given number\'s significand (where the lsb\r\n * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or\r\n * NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getLowestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // Note: the significand includes the hidden bit!\r\n    let s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    let len = s.length;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === 0) {\r\n            continue;\r\n        }\r\n        let l = getLowestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up\r\n * to 255. If the input number === 0 returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n * @internal\r\n */\r\nfunction getHighestSetBit_(a) {\r\n    return a >= 128 ? 7\r\n        : a >= 64 ? 6\r\n            : a >= 32 ? 5\r\n                : a >= 16 ? 4\r\n                    : a >= 8 ? 3\r\n                        : a >= 4 ? 2\r\n                            : a >= 2 ? 1\r\n                                : a >= 1 ? 0\r\n                                    : NaN;\r\n}\r\n/**\r\n * Returns the highest set bit of the given double. If no bit is set (input\r\n * === 0 or +/-inf or NaN) returns NaN.\r\n * See https://stackoverflow.com/a/35190288/2010061\r\n */\r\nfunction getHighestSetBit(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        // There is no lowest set bit\r\n        return NaN;\r\n    }\r\n    // At this point there must be a highest set bit (always === 52 if the \r\n    // number is not a subnormal.\r\n    let s = (0,_significand_js__WEBPACK_IMPORTED_MODULE_0__.significand)(a);\r\n    let len = s.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let l = getHighestSetBit_(s[i]);\r\n        if (Number.isFinite(l)) {\r\n            return (8 * (len - i - 1)) + l;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n//# sourceMappingURL=get-max-set-bit.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/get-max-set-bit.js?')},"./node_modules/double-double/node/double-representation/is-bit-aligned.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isBitAligned": () => (/* binding */ isBitAligned)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/double-double/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/double-double/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns true if the given number is bit-aligned in the sense that its a\r\n * multiple of a given power of 2, say e, and such that the number, say a,\r\n * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.\r\n * This essentially means the numbers act somewhat like fixed-point numbers\r\n * which can drastically speed up some geometric algorithms and also reduce\r\n * their complexity.\r\n *\r\n * Visually:\r\n * These numbers (a,b and c) are grid aligned with e === 3 and max\r\n * bitlength === 6:\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|000\r\n *   c -> 00|110111|000\r\n * These are not\r\n *   a -> 01|101100|000\r\n *   b -> 00|000100|000\r\n * These are not\r\n *   a -> 00|101100|000\r\n *   b -> 00|000100|100\r\n * These are not\r\n *   a -> 00|101100|100\r\n *   b -> 00|000100|100\r\n * @param as An array of numbers to check\r\n * @param maxBitLength The max allowed bitlength\r\n * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent\r\n */\r\nfunction isBitAligned(a, maxBitLength, gridSpacingExponent) {\r\n    if (a === 0) {\r\n        return true;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    let maxSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - 52 + e;\r\n    let minSetBit = (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) - 52 + e;\r\n    let minBitBigEnough = minSetBit >= gridSpacingExponent;\r\n    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;\r\n    return minBitBigEnough && maxBitSmallEnough;\r\n}\r\n\r\n//# sourceMappingURL=is-bit-aligned.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/is-bit-aligned.js?')},"./node_modules/double-double/node/double-representation/lsb-exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lsbExponent": () => (/* binding */ lsbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/double-double/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/double-double/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns the true exponent of the lsb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction lsbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getLowestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=lsb-exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/lsb-exponent.js?')},"./node_modules/double-double/node/double-representation/msb-exponent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "msbExponent": () => (/* binding */ msbExponent)\n/* harmony export */ });\n/* harmony import */ var _get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-set-bit.js */ "./node_modules/double-double/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/double-double/node/double-representation/exponent.js");\n\r\n\r\n/**\r\n * Returns the true exponent of the msb that is set of the given number or\r\n * NaN if a === 0 or +-inf or NaN.\r\n * @param a An array of numbers to check\r\n */\r\nfunction msbExponent(a) {\r\n    if (a === 0 || !Number.isFinite(a)) {\r\n        return NaN;\r\n    }\r\n    let e = (0,_exponent_js__WEBPACK_IMPORTED_MODULE_1__.exponent)(a);\r\n    // Will return e for all but subnormal numbers\r\n    return (0,_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_0__.getHighestSetBit)(a) - 52 + e;\r\n}\r\n\r\n//# sourceMappingURL=msb-exponent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/msb-exponent.js?')},"./node_modules/double-double/node/double-representation/parse-double.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "parseDouble": () => (/* binding */ parseDouble),\n/* harmony export */   "parseDoubleDetailed": () => (/* binding */ parseDoubleDetailed)\n/* harmony export */ });\n/* harmony import */ var _double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-to-binary-string.js */ "./node_modules/double-double/node/double-representation/double-to-binary-string.js");\n/* harmony import */ var _double_to_octets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-to-octets.js */ "./node_modules/double-double/node/double-representation/double-to-octets.js");\n// Modified from https://github.com/bartaz/ieee754-visualization/\r\n// under the MIT license\r\n// Copyright 2013 Bartek Szopka (original author)\r\n\r\n\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double. The returned\r\n * exponent has been normalized (i.e. 1023 ha been subtracted) and the\r\n * significand has the hidden bit added if appropriate.\r\n * See https://github.com/bartaz/ieee754-visualization\r\n */\r\nfunction parseDouble(x) {\r\n    let parts = (0,_double_to_octets_js__WEBPACK_IMPORTED_MODULE_1__.doubleToOctets)(x);\r\n    let p0 = parts[0];\r\n    let p1 = parts[1];\r\n    let sign = p0 >> 7;\r\n    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);\r\n    //---- Check for negative / positive zero / denormalized numbers.\r\n    let hiddenMsb = exponent_ === 0 ? 0 : 16;\r\n    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).\r\n    let exponent = exponent_ === 0\r\n        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)\r\n        : exponent_ - 1023;\r\n    //---- Break up the significand into bytes\r\n    let significand = parts.slice(1);\r\n    significand[0] = (p1 & 15) + hiddenMsb;\r\n    return {\r\n        sign,\r\n        exponent,\r\n        significand\r\n    };\r\n}\r\n/**\r\n * Returns the relevant parts of the given IEEE-754 double.\r\n * See https://github.com/bartaz/ieee754-visualization.\r\n * This is a slower version of parseDouble that gives binary string\r\n * representations of the components.\r\n */\r\nfunction parseDoubleDetailed(x) {\r\n    let str = (0,_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_0__.doubleToBinaryString)(x);\r\n    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)\r\n    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);\r\n    let exponent_ = parseInt(exponent, 2);\r\n    let hidden = exponent_ === 0 ? "0" : "1";\r\n    return {\r\n        full: sign + exponent + hidden + significand,\r\n        sign,\r\n        exponent,\r\n        hidden,\r\n        significand\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=parse-double.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/parse-double.js?')},"./node_modules/double-double/node/double-representation/significand.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "significand": () => (/* binding */ significand)\n/* harmony export */ });\n/* harmony import */ var _parse_double_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-double.js */ "./node_modules/double-double/node/double-representation/parse-double.js");\n\r\n/**\r\n * Return the significand of the given double with the hidden bit added (in case\r\n * a is not subnormal or 0, etc.)\r\n *\r\n * @param a A double\r\n */\r\nfunction significand(a) {\r\n    return (0,_parse_double_js__WEBPACK_IMPORTED_MODULE_0__.parseDouble)(a).significand;\r\n}\r\n\r\n//# sourceMappingURL=significand.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-representation/significand.js?')},"./node_modules/double-double/node/double-with-err/div-with-err.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "divWithErr": () => (/* binding */ divWithErr)\n/* harmony export */ });\n/** @internal */\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of dividing two double floating point numbers\r\n * together with an absolute error bound where nE and dE are absolute error\r\n * bounds on the input values.\r\n * @param n numerator\r\n * @param d denominator\r\n * @param nE absolute value error bound in numerator\r\n * @param dE absolute value error bound in denominator\r\n */\r\nfunction divWithErr(n, d, nE, dE) {\r\n    // estimate the result of the division\r\n    const est = n / d;\r\n    const _n = Math.abs(n);\r\n    const _d = Math.abs(d);\r\n    // if the error in the denominator is too high the error can be \r\n    // arbitrarily high\r\n    const minD = _d - dE;\r\n    // maxErr is only valid if minD > 0\r\n    if (minD <= 0) {\r\n        // the error can be arbitrarily high; est is mostly irrelevant\r\n        return { est, err: Number.POSITIVE_INFINITY };\r\n    }\r\n    const err = ((_d * nE + _n * dE) / minD ** 2) + u * Math.abs(_n / _d);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=div-with-err.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-with-err/div-with-err.js?')},"./node_modules/double-double/node/double-with-err/sqrt-with-err.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sqrtWithErr": () => (/* binding */ sqrtWithErr)\n/* harmony export */ });\n/** @internal */\r\nconst eps = Number.EPSILON;\r\n/**\r\n * Returns the result of the square root of a double floating point number\r\n * together with an absolute error bound where x_ is an absolute error\r\n * bound on the input value.\r\n * * see also "A Reduced Product of Absolute and Relative Error Bounds for Floating-point Analysis"\r\n * by Maxime Jacquemin, Sylvie Putot, and Franck Vedrine\r\n * @param x numerator\r\n * @param x_ absolute value error bound in numerator\r\n */\r\nfunction sqrtWithErr(x, x_) {\r\n    // Note: it is assumed x + x_ >= 0, else the error in x_ was wrong in the\r\n    // first place (since we can\'t have a negative input to the square root)\r\n    // estimate the result of the square root\r\n    if (x - x_ <= 0) {\r\n        const est = x > 0 ? Math.sqrt(x) : 0;\r\n        return {\r\n            est,\r\n            err: Math.max(Math.sqrt(x + x_) - est, est)\r\n        };\r\n    }\r\n    const est = Math.sqrt(x);\r\n    const minSqrt = Math.sqrt(x - x_);\r\n    const maxSqrt = Math.sqrt(x + x_);\r\n    const err = Math.max(Math.abs(minSqrt - est), Math.abs(maxSqrt - est));\r\n    //err += eps*abs(est + err);\r\n    //err = eps*abs(est + err);\r\n    // approx relative input error\r\n    //const rel = x_/abs(x);\r\n    // propogated error bound\r\n    //const err = est*(Math.sqrt(1 + rel) - 1) + u*abs(est);\r\n    return { est, err };\r\n}\r\n\r\n//# sourceMappingURL=sqrt-with-err.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/double-with-err/sqrt-with-err.js?')},"./node_modules/double-double/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bitLength": () => (/* binding */ bitLength),\n/* harmony export */   "ddAbs": () => (/* binding */ ddAbs),\n/* harmony export */   "ddAddDd": () => (/* binding */ ddAddDd),\n/* harmony export */   "ddAddDouble": () => (/* binding */ ddAddDouble),\n/* harmony export */   "ddCompare": () => (/* binding */ ddCompare),\n/* harmony export */   "ddDiffDd": () => (/* binding */ ddDiffDd),\n/* harmony export */   "ddDivBy2": () => (/* binding */ ddDivBy2),\n/* harmony export */   "ddDivDd": () => (/* binding */ ddDivDd),\n/* harmony export */   "ddDivDdWithError": () => (/* binding */ ddDivDdWithError),\n/* harmony export */   "ddDivDouble": () => (/* binding */ ddDivDouble),\n/* harmony export */   "ddMax": () => (/* binding */ ddMax),\n/* harmony export */   "ddMin": () => (/* binding */ ddMin),\n/* harmony export */   "ddMultBy2": () => (/* binding */ ddMultBy2),\n/* harmony export */   "ddMultBy4": () => (/* binding */ ddMultBy4),\n/* harmony export */   "ddMultByNeg2": () => (/* binding */ ddMultByNeg2),\n/* harmony export */   "ddMultByNeg4": () => (/* binding */ ddMultByNeg4),\n/* harmony export */   "ddMultDd": () => (/* binding */ ddMultDd),\n/* harmony export */   "ddMultDouble1": () => (/* binding */ ddMultDouble1),\n/* harmony export */   "ddMultDouble2": () => (/* binding */ ddMultDouble2),\n/* harmony export */   "ddNegativeOf": () => (/* binding */ ddNegativeOf),\n/* harmony export */   "ddProduct": () => (/* binding */ ddProduct),\n/* harmony export */   "ddSign": () => (/* binding */ ddSign),\n/* harmony export */   "ddSqrt": () => (/* binding */ ddSqrt),\n/* harmony export */   "ddSum": () => (/* binding */ ddSum),\n/* harmony export */   "divWithErr": () => (/* binding */ divWithErr),\n/* harmony export */   "doubleDivDouble": () => (/* binding */ doubleDivDouble),\n/* harmony export */   "doubleSqrt": () => (/* binding */ doubleSqrt),\n/* harmony export */   "doubleToBinaryString": () => (/* binding */ doubleToBinaryString),\n/* harmony export */   "doubleToOctets": () => (/* binding */ doubleToOctets),\n/* harmony export */   "exponent": () => (/* binding */ exponent),\n/* harmony export */   "fastTwoDiff": () => (/* binding */ fastTwoDiff),\n/* harmony export */   "fastTwoSum": () => (/* binding */ fastTwoSum),\n/* harmony export */   "getHighestSetBit": () => (/* binding */ getHighestSetBit),\n/* harmony export */   "getLowestSetBit": () => (/* binding */ getLowestSetBit),\n/* harmony export */   "isBitAligned": () => (/* binding */ isBitAligned),\n/* harmony export */   "lsbExponent": () => (/* binding */ lsbExponent),\n/* harmony export */   "msbExponent": () => (/* binding */ msbExponent),\n/* harmony export */   "operators": () => (/* binding */ operators),\n/* harmony export */   "parseDouble": () => (/* binding */ parseDouble),\n/* harmony export */   "parseDoubleDetailed": () => (/* binding */ parseDoubleDetailed),\n/* harmony export */   "reduceSignificand": () => (/* binding */ reduceSignificand),\n/* harmony export */   "significand": () => (/* binding */ significand),\n/* harmony export */   "split": () => (/* binding */ split),\n/* harmony export */   "sqrtWithErr": () => (/* binding */ sqrtWithErr),\n/* harmony export */   "twoDiff": () => (/* binding */ twoDiff),\n/* harmony export */   "twoProduct": () => (/* binding */ twoProduct),\n/* harmony export */   "twoSum": () => (/* binding */ twoSum)\n/* harmony export */ });\n/* harmony import */ var _double_double_binary_dd_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-double/binary/dd-min.js */ "./node_modules/double-double/node/double-double/binary/dd-min.js");\n/* harmony import */ var _double_double_binary_dd_max_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-double/binary/dd-max.js */ "./node_modules/double-double/node/double-double/binary/dd-max.js");\n/* harmony import */ var _double_double_unary_dd_sqrt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-double/unary/dd-sqrt.js */ "./node_modules/double-double/node/double-double/unary/dd-sqrt.js");\n/* harmony import */ var _double_mixed_double_double_double_sqrt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-mixed-double-double/double-sqrt.js */ "./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js");\n/* harmony import */ var _double_with_err_sqrt_with_err_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-with-err/sqrt-with-err.js */ "./node_modules/double-double/node/double-with-err/sqrt-with-err.js");\n/* harmony import */ var _double_double_unary_dd_abs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-double/unary/dd-abs.js */ "./node_modules/double-double/node/double-double/unary/dd-abs.js");\n/* harmony import */ var _double_mixed_double_double_dd_add_double_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-mixed-double-double/dd-add-double.js */ "./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js");\n/* harmony import */ var _double_double_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-double/binary/dd-add-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-add-dd.js");\n/* harmony import */ var _double_double_multi_dd_product_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-double/multi/dd-product.js */ "./node_modules/double-double/node/double-double/multi/dd-product.js");\n/* harmony import */ var _double_double_multi_dd_sum_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./double-double/multi/dd-sum.js */ "./node_modules/double-double/node/double-double/multi/dd-sum.js");\n/* harmony import */ var _double_double_binary_dd_compare_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./double-double/binary/dd-compare.js */ "./node_modules/double-double/node/double-double/binary/dd-compare.js");\n/* harmony import */ var _double_double_binary_dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./double-double/binary/dd-diff-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-diff-dd.js");\n/* harmony import */ var _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./double-mixed-double-double/dd-mult-double.js */ "./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js");\n/* harmony import */ var _double_double_unary_dd_mult_by_2_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-2.js */ "./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js");\n/* harmony import */ var _double_double_unary_dd_mult_by_4_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-4.js */ "./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js");\n/* harmony import */ var _double_double_unary_dd_div_by_2_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./double-double/unary/dd-div-by-2.js */ "./node_modules/double-double/node/double-double/unary/dd-div-by-2.js");\n/* harmony import */ var _double_double_unary_dd_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-neg-2.js */ "./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js");\n/* harmony import */ var _double_double_unary_dd_mult_by_neg_4_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./double-double/unary/dd-mult-by-neg-4.js */ "./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js");\n/* harmony import */ var _double_double_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./double-double/binary/dd-mult-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-mult-dd.js");\n/* harmony import */ var _double_mixed_double_double_dd_div_double_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./double-mixed-double-double/dd-div-double.js */ "./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js");\n/* harmony import */ var _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./double-double/binary/dd-div-dd.js */ "./node_modules/double-double/node/double-double/binary/dd-div-dd.js");\n/* harmony import */ var _double_double_unary_dd_negative_of_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./double-double/unary/dd-negative-of.js */ "./node_modules/double-double/node/double-double/unary/dd-negative-of.js");\n/* harmony import */ var _double_double_unary_dd_sign_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./double-double/unary/dd-sign.js */ "./node_modules/double-double/node/double-double/unary/dd-sign.js");\n/* harmony import */ var _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./basic/fast-two-diff.js */ "./node_modules/double-double/node/basic/fast-two-diff.js");\n/* harmony import */ var _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./basic/fast-two-sum.js */ "./node_modules/double-double/node/basic/fast-two-sum.js");\n/* harmony import */ var _basic_split_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./basic/split.js */ "./node_modules/double-double/node/basic/split.js");\n/* harmony import */ var _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./basic/two-diff.js */ "./node_modules/double-double/node/basic/two-diff.js");\n/* harmony import */ var _basic_two_product_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./basic/two-product.js */ "./node_modules/double-double/node/basic/two-product.js");\n/* harmony import */ var _double_mixed_double_double_double_div_double_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./double-mixed-double-double/double-div-double.js */ "./node_modules/double-double/node/double-mixed-double-double/double-div-double.js");\n/* harmony import */ var _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./basic/two-sum.js */ "./node_modules/double-double/node/basic/two-sum.js");\n/* harmony import */ var _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./basic/reduce-significand.js */ "./node_modules/double-double/node/basic/reduce-significand.js");\n/* harmony import */ var _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./double-representation/parse-double.js */ "./node_modules/double-double/node/double-representation/parse-double.js");\n/* harmony import */ var _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./double-representation/is-bit-aligned.js */ "./node_modules/double-double/node/double-representation/is-bit-aligned.js");\n/* harmony import */ var _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./double-representation/msb-exponent.js */ "./node_modules/double-double/node/double-representation/msb-exponent.js");\n/* harmony import */ var _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./double-representation/lsb-exponent.js */ "./node_modules/double-double/node/double-representation/lsb-exponent.js");\n/* harmony import */ var _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./double-representation/bit-length.js */ "./node_modules/double-double/node/double-representation/bit-length.js");\n/* harmony import */ var _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./double-representation/exponent.js */ "./node_modules/double-double/node/double-representation/exponent.js");\n/* harmony import */ var _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./double-representation/significand.js */ "./node_modules/double-double/node/double-representation/significand.js");\n/* harmony import */ var _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./double-representation/double-to-binary-string.js */ "./node_modules/double-double/node/double-representation/double-to-binary-string.js");\n/* harmony import */ var _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./double-representation/double-to-octets.js */ "./node_modules/double-double/node/double-representation/double-to-octets.js");\n/* harmony import */ var _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./double-representation/get-max-set-bit.js */ "./node_modules/double-double/node/double-representation/get-max-set-bit.js");\n/* harmony import */ var _double_double_with_error_dd_div_dd_with_error_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./double-double-with-error/dd-div-dd-with-error.js */ "./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js");\n/* harmony import */ var _double_with_err_div_with_err_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./double-with-err/div-with-err.js */ "./node_modules/double-double/node/double-with-err/div-with-err.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ddMultDouble2 = _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_12__.ddMultDouble2;\r\nconst parseDoubleDetailed = _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDoubleDetailed;\r\nconst getLowestSetBit = _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_40__.getLowestSetBit;\r\nconst ddMin = _double_double_binary_dd_min_js__WEBPACK_IMPORTED_MODULE_0__.ddMin;\r\nconst ddMax = _double_double_binary_dd_max_js__WEBPACK_IMPORTED_MODULE_1__.ddMax;\r\nconst ddSqrt = _double_double_unary_dd_sqrt_js__WEBPACK_IMPORTED_MODULE_2__.ddSqrt;\r\nconst doubleSqrt = _double_mixed_double_double_double_sqrt_js__WEBPACK_IMPORTED_MODULE_3__.doubleSqrt;\r\nconst sqrtWithErr = _double_with_err_sqrt_with_err_js__WEBPACK_IMPORTED_MODULE_4__.sqrtWithErr;\r\nconst ddAbs = _double_double_unary_dd_abs_js__WEBPACK_IMPORTED_MODULE_5__.ddAbs;\r\nconst ddAddDouble = _double_mixed_double_double_dd_add_double_js__WEBPACK_IMPORTED_MODULE_6__.ddAddDouble;\r\nconst ddAddDd = _double_double_binary_dd_add_dd_js__WEBPACK_IMPORTED_MODULE_7__.ddAddDd;\r\nconst ddProduct = _double_double_multi_dd_product_js__WEBPACK_IMPORTED_MODULE_8__.ddProduct;\r\nconst ddSum = _double_double_multi_dd_sum_js__WEBPACK_IMPORTED_MODULE_9__.ddSum;\r\nconst ddCompare = _double_double_binary_dd_compare_js__WEBPACK_IMPORTED_MODULE_10__.ddCompare;\r\nconst ddDiffDd = _double_double_binary_dd_diff_dd_js__WEBPACK_IMPORTED_MODULE_11__.ddDiffDd;\r\nconst ddMultDouble1 = _double_mixed_double_double_dd_mult_double_js__WEBPACK_IMPORTED_MODULE_12__.ddMultDouble1;\r\nconst ddMultBy2 = _double_double_unary_dd_mult_by_2_js__WEBPACK_IMPORTED_MODULE_13__.ddMultBy2;\r\nconst ddMultBy4 = _double_double_unary_dd_mult_by_4_js__WEBPACK_IMPORTED_MODULE_14__.ddMultBy4;\r\nconst ddDivBy2 = _double_double_unary_dd_div_by_2_js__WEBPACK_IMPORTED_MODULE_15__.ddDivBy2;\r\nconst ddMultByNeg2 = _double_double_unary_dd_mult_by_neg_2_js__WEBPACK_IMPORTED_MODULE_16__.ddMultByNeg2;\r\nconst ddMultByNeg4 = _double_double_unary_dd_mult_by_neg_4_js__WEBPACK_IMPORTED_MODULE_17__.ddMultByNeg4;\r\nconst ddMultDd = _double_double_binary_dd_mult_dd_js__WEBPACK_IMPORTED_MODULE_18__.ddMultDd;\r\nconst ddDivDouble = _double_mixed_double_double_dd_div_double_js__WEBPACK_IMPORTED_MODULE_19__.ddDivDouble;\r\nconst ddDivDd = _double_double_binary_dd_div_dd_js__WEBPACK_IMPORTED_MODULE_20__.ddDivDd;\r\nconst ddNegativeOf = _double_double_unary_dd_negative_of_js__WEBPACK_IMPORTED_MODULE_21__.ddNegativeOf;\r\nconst ddSign = _double_double_unary_dd_sign_js__WEBPACK_IMPORTED_MODULE_22__.ddSign;\r\nconst fastTwoDiff = _basic_fast_two_diff_js__WEBPACK_IMPORTED_MODULE_23__.fastTwoDiff;\r\nconst fastTwoSum = _basic_fast_two_sum_js__WEBPACK_IMPORTED_MODULE_24__.fastTwoSum;\r\nconst split = _basic_split_js__WEBPACK_IMPORTED_MODULE_25__.split;\r\nconst twoDiff = _basic_two_diff_js__WEBPACK_IMPORTED_MODULE_26__.twoDiff;\r\nconst twoProduct = _basic_two_product_js__WEBPACK_IMPORTED_MODULE_27__.twoProduct;\r\nconst doubleDivDouble = _double_mixed_double_double_double_div_double_js__WEBPACK_IMPORTED_MODULE_28__.doubleDivDouble;\r\nconst twoSum = _basic_two_sum_js__WEBPACK_IMPORTED_MODULE_29__.twoSum;\r\nconst reduceSignificand = _basic_reduce_significand_js__WEBPACK_IMPORTED_MODULE_30__.reduceSignificand;\r\nconst parseDouble = _double_representation_parse_double_js__WEBPACK_IMPORTED_MODULE_31__.parseDouble;\r\nconst isBitAligned = _double_representation_is_bit_aligned_js__WEBPACK_IMPORTED_MODULE_32__.isBitAligned;\r\nconst msbExponent = _double_representation_msb_exponent_js__WEBPACK_IMPORTED_MODULE_33__.msbExponent;\r\nconst lsbExponent = _double_representation_lsb_exponent_js__WEBPACK_IMPORTED_MODULE_34__.lsbExponent;\r\nconst bitLength = _double_representation_bit_length_js__WEBPACK_IMPORTED_MODULE_35__.bitLength;\r\nconst exponent = _double_representation_exponent_js__WEBPACK_IMPORTED_MODULE_36__.exponent;\r\nconst significand = _double_representation_significand_js__WEBPACK_IMPORTED_MODULE_37__.significand;\r\nconst doubleToBinaryString = _double_representation_double_to_binary_string_js__WEBPACK_IMPORTED_MODULE_38__.doubleToBinaryString;\r\nconst doubleToOctets = _double_representation_double_to_octets_js__WEBPACK_IMPORTED_MODULE_39__.doubleToOctets;\r\nconst getHighestSetBit = _double_representation_get_max_set_bit_js__WEBPACK_IMPORTED_MODULE_40__.getHighestSetBit;\r\nconst ddDivDdWithError = _double_double_with_error_dd_div_dd_with_error_js__WEBPACK_IMPORTED_MODULE_41__.ddDivDdWithError;\r\nconst divWithErr = _double_with_err_div_with_err_js__WEBPACK_IMPORTED_MODULE_42__.divWithErr;\r\nconst operators = {\r\n    //---- basic ----//\r\n    fastTwoDiff,\r\n    fastTwoSum,\r\n    split,\r\n    twoDiff,\r\n    twoProduct,\r\n    doubleDivDouble,\r\n    twoSum,\r\n    reduceSignificand,\r\n    //---- double-double precision ----//\r\n    doubleSqrt,\r\n    ddSqrt,\r\n    ddAbs,\r\n    ddAddDouble,\r\n    ddAddDd,\r\n    ddProduct,\r\n    ddSum,\r\n    ddCompare,\r\n    ddDiffDd,\r\n    ddMultDouble1,\r\n    ddMultDouble2,\r\n    ddMultDd,\r\n    ddDivDouble,\r\n    ddDivDd,\r\n    ddNegativeOf,\r\n    ddSign,\r\n    ddMultBy2,\r\n    ddMultBy4,\r\n    ddDivBy2,\r\n    ddMultByNeg2,\r\n    ddMultByNeg4,\r\n    ddMin,\r\n    ddMax,\r\n    //---- double-double precision error propagation - with error bound on input parameters\r\n    ddDivDdWithError,\r\n    //---- double precision error propagation - with error bound on input parameters\r\n    divWithErr,\r\n    sqrtWithErr,\r\n    //---- double floating point representation ----//\r\n    parseDouble,\r\n    parseDoubleDetailed,\r\n    isBitAligned,\r\n    msbExponent,\r\n    lsbExponent,\r\n    bitLength,\r\n    doubleToBinaryString,\r\n    doubleToOctets,\r\n    getHighestSetBit,\r\n    getLowestSetBit,\r\n    exponent,\r\n    significand\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/double-double/node/index.js?')},"./node_modules/flo-bezier3/node/add-1-ulp.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "add1Ulp": () => (/* binding */ add1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\r\nconst u = eps / 2;\r\nconst es = (eps ** 2) / 2;\r\nconst ups = u + es;\r\n/**\r\n * Add one unit in the last place (ulp) to the given number\r\n *\r\n * * subnormal numbers (and 0) are returned unaltered\r\n * @internal\r\n */\r\nfunction add1Ulp(n) {\r\n    return n > 0 ? n + n * ups : n - n * ups;\r\n}\r\n\r\n//# sourceMappingURL=add-1-ulp.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/add-1-ulp.js?')},"./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "areBoxesIntersecting": () => (/* binding */ areBoxesIntersecting)\n/* harmony export */ });\n/**\r\n * Returns `true` if the 2 given axis-aligned rectangular boxes intersect.\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param closed if `true`, interpret boxes as being closed (i.e. they contain\r\n * their border), otherwise open.\r\n * @param a an axis-aligned rectangular box (given by an array of two points,\r\n * e.g. `[[1,2], [3,4]]`)\r\n * @param b another axis-aligned rectangular box\r\n *\r\n * @doc mdx\r\n */\r\nfunction areBoxesIntersecting(closed, a, b) {\r\n    let [[ax0, ay0], [ax1, ay1]] = a;\r\n    let [[bx0, by0], [bx1, by1]] = b;\r\n    // Swap so smaller coordinate comes first\r\n    if (ay0 > ay1) {\r\n        [ay0, ay1] = [ay1, ay0];\r\n    }\r\n    ;\r\n    if (by0 > by1) {\r\n        [by0, by1] = [by1, by0];\r\n    }\r\n    ;\r\n    if (ax0 > ax1) {\r\n        [ax0, ax1] = [ax1, ax0];\r\n    }\r\n    ;\r\n    if (bx0 > bx1) {\r\n        [bx0, bx1] = [bx1, bx0];\r\n    }\r\n    ;\r\n    return closed\r\n        ? ax0 <= bx1 && ax1 >= bx0 &&\r\n            by0 <= ay1 && by1 >= ay0\r\n        : ax0 < bx1 && ax1 > bx0 &&\r\n            by0 < ay1 && by1 > ay0;\r\n}\r\n\r\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js?')},"./node_modules/flo-bezier3/node/boxes/intersect-boxes.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"intersectBoxes\": () => (/* binding */ intersectBoxes)\n/* harmony export */ });\nconst min = Math.min;\r\nconst max = Math.max;\r\n/**\r\n * Returns the intersection of 2 given axis-aligned rectangular boxes (or\r\n * `undefined` if they don't intersect).\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n * * **closed**: interpret boxes as being closed (i.e. they contain their border).\r\n *\r\n * @param a an axis-aligned rectangular box (given by an array of two points,\r\n * e.g. `[[1,2], [3,4]]`)\r\n * @param b another box\r\n *\r\n * @doc mdx\r\n */\r\nfunction intersectBoxes(a, b) {\r\n    let [[ax0, ay0], [ax1, ay1]] = a;\r\n    let [[bx0, by0], [bx1, by1]] = b;\r\n    // Swap so smaller coordinate comes first\r\n    if (ax0 > ax1) {\r\n        [ax0, ax1] = [ax1, ax0];\r\n    }\r\n    ;\r\n    if (bx0 > bx1) {\r\n        [bx0, bx1] = [bx1, bx0];\r\n    }\r\n    ;\r\n    if (ay0 > ay1) {\r\n        [ay0, ay1] = [ay1, ay0];\r\n    }\r\n    ;\r\n    if (by0 > by1) {\r\n        [by0, by1] = [by1, by0];\r\n    }\r\n    ;\r\n    if (!(ax0 <= bx1 && ax1 >= bx0 &&\r\n        by0 <= ay1 && by1 >= ay0)) {\r\n        // they don't intersect\r\n        return undefined;\r\n    }\r\n    return [\r\n        [max(ax0, bx0), max(ay0, by0)],\r\n        [min(ax1, bx1), min(ay1, by1)]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=intersect-boxes.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/boxes/intersect-boxes.js?")},"./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cubicThroughPointGiven013": () => (/* binding */ cubicThroughPointGiven013)\n/* harmony export */ });\n/**\r\n * Generates and returns a cubic bezier curve going through a specific point\r\n * given control points 0,1 and 3.\r\n *\r\n * * **non-exact:** the returned bezier does not necessarily go through the\r\n * point *exactly* (due to floating-point round-off).\r\n *\r\n * @param ps a cubic bezier curve\'s 1st, 2nd and 4th control point coordinates,\r\n * i.e. `[[x0,y0], [x1,y1], [x3,y3]]`, e.g. `[[1,2], [3,4], [5,6]]`\r\n * @param p a point through which the bezier should go, e.g. `[4.5,6.1]`\r\n * @param t a `t` parameter value at which the bezier should go through the\r\n * point - this is necessary due to a degree of freedom still left\r\n *\r\n * @doc mdx\r\n */\r\nfunction cubicThroughPointGiven013(ps, p, t) {\r\n    const [[x0, y0], [x1, y1], [x3, y3]] = ps;\r\n    const [x, y] = p;\r\n    const x2 = (t ** 3 * (-x0 + 3 * x1 + x3) + 3 * t ** 2 * (x0 - 2 * x1) - 3 * t * (x0 - x1) - x + x0) / (3 * t ** 2 * (t - 1));\r\n    const y2 = (t ** 3 * (-y0 + 3 * y1 + y3) + 3 * t ** 2 * (y0 - 2 * y1) - 3 * t * (y0 - y1) - y + y0) / (3 * t ** 2 * (t - 1));\r\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n}\r\n\r\n//# sourceMappingURL=cubic-through-point-given013.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js?')},"./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateCuspAtHalf3\": () => (/* binding */ generateCuspAtHalf3)\n/* harmony export */ });\n/**\r\n * Returns the cubic bezier curve control points with a zero tangent vector\r\n * (i.e. `[0,0]`) at `t = 0.5` (i.e. a 'cusp') at the given point with\r\n * given starting and ending control points.\r\n * * **non-exact**: due to floating-point round-off the cusp is not\r\n * necessarily *exactly* at the given point, nor does the tangent vector\r\n * necessarily vanish *exactly*.\r\n *\r\n * @param p0 the bezier start point\r\n * @param pz the point at which the vanishing tangent should occur\r\n * @param pE the bezier end point\r\n *\r\n * @doc mdx\r\n */\r\nfunction generateCuspAtHalf3(p0, pz, pE) {\r\n    // x3 - 3x2 + 3x1 - x0, // := a = coefficent of t^3\r\n    // 3x2 - 6x1 + 3x0,     // := b = coefficent of t^2\r\n    // 3x1 - 3x0,           // := c = coefficent of t^1\r\n    // x0,                  // := d = coefficent of t^0\r\n    // y3 - 3y2 + 3y1 - y0, // := e = coefficent of t^3\r\n    // 3y2 - 6y1 + 3y0,     // := f = coefficent of t^2\r\n    // 3y1 - 3y0,           // := g = coefficent of t^1\r\n    // y0,                  // := h = coefficent of t^0\r\n    // const x = at^3 + bt^2 + ct + d\r\n    // const y = et^3 + ft^2 + gt + h\r\n    // x` = 3at^2 + 2bt + c\r\n    // y` = 3et^2 + 2ft + g\r\n    // d = x0 and h = y0\r\n    const [x0, y0] = p0;\r\n    const [xz, yz] = pz;\r\n    const [xE, yE] = pE;\r\n    // We must have x` = y` = 0 at t = 1/2:\r\n    // 3a/4 + b + c = 0            =>  3a  + 4b  + 4c  =  0       (1)\r\n    // 3e/4 + f + g = 0            =>  3e  + 4f  + 4g  =  0       (2)\r\n    // Also, x(1/2) === pz[0]:\r\n    // a/8 + b/4 + c/2 + d = pz[0] => a + 2b + 4c + 8d = 8xz      (3)\r\n    // and y(1/2) === pz[1]:\r\n    // e/8 + f/4 + g/2 + h = pz[1] => e + 2f + 4g + 8h = 8yz      (4)\r\n    // and by definitition:\r\n    // a = x3 - 3x2 + 3x1 - x0     => -3x2 + 3x1 - a   =  x0 - x3 (5)\r\n    // b = 3x2 - 6x1 + 3x0         =>  3x2 - 6x1 - b   = -3x0     (6)\r\n    // c = 3x1 - 3x0               =>  3x1       - c   =  3x0     (7)\r\n    // e = y3 - 3y2 + 3y1 - y0     => -3y2 + 3y1 - e   =  y0 - y3 (8)\r\n    // f = 3y2 - 6y1 + 3y0         =>  3y2 - 6y1 - f   = -3y0     (9) \r\n    // g = 3y1 - 3y0               =>  3y1       - g   =  3y0     (10)\r\n    // Solving the above linear system gives:\r\n    //const a = 4*xE-4*x0;\r\n    //const b = 4*x0-4*xz-4*xE+4*x0;\r\n    //const c = -4*x0+4*xz+xE-x0;\r\n    //const e = 4*yE-4*y0;\r\n    //const f = 4*y0-4*yz-4*yE+4*y0;\r\n    //const g = -4*y0+4*yz+yE-y0;\r\n    const x1 = -(4 * x0 - 4 * xz - xE - 2 * x0) / 3;\r\n    const y1 = -(4 * y0 - 4 * yz - yE - 2 * y0) / 3;\r\n    const x2 = -(4 * x0 - 4 * xz + 2 * xE - 5 * x0) / 3;\r\n    const y2 = -(4 * y0 - 4 * yz + 2 * yE - 5 * y0) / 3;\r\n    return [p0, [x1, y1], [x2, y2], pE];\r\n}\r\n\r\n/*\r\n3*a  + 4*b  + 4*c   = 0\r\n3*e  + 4*f  + 4*g   = 0\r\na + 2*b + 4*c + 8*d = 8*xz\r\ne + 2*f + 4*g + 8*h = 8*yz\r\n-3*x2 + 3*x1 - a =  x0 - x3\r\n3*x2 - 6*x1 - b = -3*x0\r\n3*x1 - c = 3*x0\r\n-3*y2 + 3*y1 - e = y0 - y3\r\n3*y2 - 6*y1  - f = -3*y0\r\n3*y1 - g = 3*y0\r\n*/\r\n//# sourceMappingURL=generate-cusp-at-half-t.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js?")},"./node_modules/flo-bezier3/node/create/generate-quarter-circle.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "generateQuarterCircle": () => (/* binding */ generateQuarterCircle)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * Returns a cubic bezier curve that is an approximation of the unit quarter\r\n * circle in the first quadrant scaled and then translated.\r\n *\r\n * * see: [Approximate a circle with cubic Bézier curves](https://spencermortensen.com/articles/bezier-circle/)\r\n *\r\n * @doc mdx\r\n */\r\nfunction generateQuarterCircle(scale, translation) {\r\n    // `c` can be made slightly more accurate by calculating a more accurate\r\n    // value of \r\n    const c = 0.551915024494;\r\n    const s = scale;\r\n    return [[0, s], [s * c, s], [s, s * c], [s, 0]].map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(translation));\r\n}\r\n\r\n//# sourceMappingURL=generate-quarter-circle.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/create/generate-quarter-circle.js?')},"./node_modules/flo-bezier3/node/create/generate-self-intersecting.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateSelfIntersecting\": () => (/* binding */ generateSelfIntersecting)\n/* harmony export */ });\n/**\r\n * Returns the cubic bezier curve with given starting, 2nd and 3rd control\r\n * points such that there is a self-intersection.\r\n *\r\n * * **in-exact:** the result may not be exact due to floating point round-off\r\n *\r\n * @param ts the two `t` values where the self-intersection should occur\r\n * @param p0 the bezier's initial control point, e.g. `[1,2]`\r\n * @param p1 the bezier's 2nd control point\r\n * @param p2 the bezier's 3rd control point\r\n *\r\n * @doc mdx\r\n */\r\nfunction generateSelfIntersecting(p0, p1, p2, ts) {\r\n    const [x0, y0] = p0;\r\n    const [x1, y1] = p1;\r\n    const [x2, y2] = p2;\r\n    const [t1, t2] = ts;\r\n    // power basis representation:\r\n    //const a3 = (x3 - x0) + 3*(x1 - x2)\r\n    const a2 = 3 * ((x2 + x0) - 2 * x1);\r\n    const a1 = 3 * (x1 - x0);\r\n    //const b3 = (y3 - y0) + 3*(y1 - y2)\r\n    const b2 = 3 * ((y2 + y0) - 2 * y1);\r\n    const b1 = 3 * (y1 - y0);\r\n    // f4 = a2*b3 - a3*b2;\r\n    // f5 = a1*b3 - a3*b1;\r\n    // f6 = a2*b1 - a1*b2;\r\n    // a = f4*f4;\r\n    // b = f4*f5;\r\n    // c = f4*f6 + f5*f5;\r\n    // The self-intersection is given by the roots of `at^2 + bt + c`\r\n    const vₓ = b2 * (a1 * b2 - a2 * b1);\r\n    const vᵧ = -a2 * (a1 * b2 - a2 * b1);\r\n    // a3**2* (b1**2 + b1*b2*t1 + b2**2*t1**2) +\r\n    // b3**2* (a1**2 + a1*a2*t1 + a2**2*t1**2) + \r\n    // a3*b3* (-2*a1*b1 + -a1*b2*t1 + -a2*b1*t1 + -2*a2*b2*t1**2) +\r\n    // a3* (a1*b2**2 + -a2*b1*b2) +\r\n    // b3* (a2**2*b1 + -a1*a2*b2) === 0\r\n    const vₓₓ = b1 ** 2 + b1 * b2 * t1 + b2 ** 2 * t1 ** 2;\r\n    const vₓᵧ = -2 * a1 * b1 + -a1 * b2 * t1 + -a2 * b1 * t1 + -2 * a2 * b2 * t1 ** 2;\r\n    const vᵧᵧ = a1 ** 2 + a1 * a2 * t1 + a2 ** 2 * t1 ** 2;\r\n    // implicit form 1 === {vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v: 0};\r\n    // a3**2* (b1**2 + b1*b2*t2 + b2**2*t2**2) +\r\n    // a3*b3* (-2*a1*b1 + -a1*b2*t2 + -a2*b1*t2 + -2*a2*b2*t2**2) +\r\n    // b3**2* (a1**2 + a1*a2*t2 + a2**2*t2**2) + \r\n    // a3* (a1*b2**2 + -a2*b1*b2) + \r\n    // b3* (a2**2*b1 + -a1*a2*b2) === 0\r\n    const wₓₓ = b1 ** 2 + b1 * b2 * t2 + b2 ** 2 * t2 ** 2;\r\n    const wₓᵧ = -2 * a1 * b1 + -a1 * b2 * t2 + -a2 * b1 * t2 + -2 * a2 * b2 * t2 ** 2;\r\n    const wᵧᵧ = a1 ** 2 + a1 * a2 * t2 + a2 ** 2 * t2 ** 2;\r\n    // implicit form 2 === {wₓₓ, wₓᵧ, wᵧᵧ, vₓ, vᵧ, v: 0};\r\n    // The below are the coefficients as if we've called \r\n    // getImplicitCoeffsBez2Bez2, except there are now more constraints (e.g.\r\n    // `vₓ === wₓ`, etc.) so we reproduce them here.\r\n    const xx4 = vₓₓ * (wᵧᵧ * (vₓₓ * wᵧᵧ - vₓᵧ * wₓᵧ - 2 * vᵧᵧ * wₓₓ) + vᵧᵧ * wₓᵧ * wₓᵧ) +\r\n        wₓₓ * (vₓᵧ * (vₓᵧ * wᵧᵧ - vᵧᵧ * wₓᵧ) + vᵧᵧ * vᵧᵧ * wₓₓ);\r\n    const xx3 = vₓ * (wᵧᵧ * (2 * (vₓₓ * (wᵧᵧ - vᵧᵧ) - vᵧᵧ * wₓₓ) - vₓᵧ * (wₓᵧ - vₓᵧ)) +\r\n        vᵧᵧ * (2 * vᵧᵧ * wₓₓ - wₓᵧ * (vₓᵧ - wₓᵧ))) +\r\n        vᵧ * (vₓₓ * (2 * vᵧᵧ * wₓᵧ - wᵧᵧ * (vₓᵧ + wₓᵧ)) +\r\n            wₓₓ * (2 * vₓᵧ * wᵧᵧ - vᵧᵧ * (vₓᵧ + wₓᵧ)));\r\n    // Due to constraints, `x2`, `x1` and `x0` all vanish.\r\n    // Solve for: xx4*x + xx3 = 0\r\n    const a3 = -xx3 / xx4;\r\n    const yy3 = vₓ * (vₓₓ * (wₓᵧ * (2 * vᵧᵧ - wᵧᵧ) - vₓᵧ * wᵧᵧ) +\r\n        wₓₓ * (vₓᵧ * (2 * wᵧᵧ - vᵧᵧ) - vᵧᵧ * wₓᵧ)) +\r\n        vᵧ * (vₓₓ * (2 * (wᵧᵧ * (vₓₓ - wₓₓ) - vᵧᵧ * wₓₓ) - wₓᵧ * (vₓᵧ - wₓᵧ)) +\r\n            wₓₓ * (2 * vᵧᵧ * wₓₓ + vₓᵧ * (vₓᵧ - wₓᵧ)));\r\n    // Due to constraints, `y2`, `y1` and `y0` all vanish.\r\n    // Solve for: yy4*y + yy3 = 0\r\n    const b3 = -yy3 / xx4; // note: yy4 === xx4\r\n    const x3 = a3 + x0 - 3 * (x1 - x2); //note: a3 === (x3 - x0) + 3*(x1 - x2)\r\n    const y3 = b3 + y0 - 3 * (y1 - y2); //note: b3 === (y3 - y0) + 3*(y1 - y2)\r\n    // Note: A self-intersection occurs when:\r\n    // `3*(a1*b3 - a3*b1)**2 + 4*(a2*b1 - a1*b2)*(a2*b3 - a3*b2) <= 0`\r\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\r\n}\r\n\r\n//# sourceMappingURL=generate-self-intersecting.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/create/generate-self-intersecting.js?")},"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "γ": () => (/* binding */ γ),\n/* harmony export */   "γγ": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\r\nconst uu = u * u;\r\n/** @internal */\r\nfunction γ(n) {\r\n    const nu = n * u;\r\n    return nu / (1 - nu);\r\n}\r\n/** @internal */\r\nfunction γγ(n) {\r\n    const nuu = n * uu;\r\n    return nuu / (1 - nuu);\r\n}\r\n\r\nγ(1); //=> 1.1102230246251568e-16\r\nγγ(3); //=> 3.697785493223493e-32\r\n//# sourceMappingURL=error-analysis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/error-analysis/error-analysis.js?')},"./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "maxAbsCoordinate": () => (/* binding */ maxAbsCoordinate)\n/* harmony export */ });\n/**\r\n * Returns the maximum absolute value of the coordinates of the control points\r\n * of the given bezier curve.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction maxAbsCoordinate(ps) {\r\n    let m = Number.NEGATIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const p = ps[i];\r\n        const absX = Math.abs(p[0]);\r\n        const absY = Math.abs(p[1]);\r\n        if (absX > m) {\r\n            m = absX;\r\n        }\r\n        if (absY > m) {\r\n            m = absY;\r\n        }\r\n    }\r\n    return m;\r\n}\r\n\r\n//# sourceMappingURL=max-abs-coordinate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js?')},"./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fitQuadsToCubic": () => (/* binding */ fitQuadsToCubic)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/classify.js */ "./node_modules/flo-bezier3/node/global-properties/classification/classify.js");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-3-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-abs-area-between.js */ "./node_modules/flo-bezier3/node/fit/get-abs-area-between.js");\n/* harmony import */ var _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../intersection/self-intersection/bezier-self-intersection.js */ "./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Approximate the given cubic bezier curve (up to the given tolerance) by\r\n * fitting an array of ordered (by `t` value) piecewise bezier curves\r\n * (of quadratic order or less).\r\n *\r\n * * the start and end point of each approximating curve lies on the cubic\r\n * curve and the the tangents of each approximating curve coincide with that of\r\n * the cubic at each such point\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tolerance tolerance given as the maximum total absolute area difference\r\n * between the two curves\r\n *\r\n * @doc mdx\r\n */\r\nfunction fitQuadsToCubic(ps, tolerance) {\r\n    if (ps.length < 4) {\r\n        throw new Error(\'Only cubic bezier curves are supported by this function.\');\r\n    }\r\n    const { collinear, realOrder, nodeType } = (0,_global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_0__.classify)(ps);\r\n    // if all points collinear or a line (or point)\r\n    if (collinear || realOrder <= 1) {\r\n        // return a quad that\'s a line between the first and last points\r\n        // return [ps[0], [(ps[0][0] + ps[3][0])/2, (ps[0][1] + ps[3][1])/2], ps[3]];\r\n        return [[ps[0], ps[3]]];\r\n    }\r\n    if (realOrder === 2) {\r\n        // already a quadratic in disguise\r\n        // It is not possible that `toQuadraticFromCubic(ps)` be undefined here\r\n        // since the `real order` is exactly 2 and the control points are *not*\r\n        // collinear.\r\n        return [(0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps)];\r\n    }\r\n    const stack = [];\r\n    // if endpoints coincide\r\n    if (ps[0][0] === ps[3][0] && ps[0][1] === ps[3][1]) {\r\n        stack.push([0, 0.5], [0.5, 1]);\r\n    }\r\n    else if (nodeType === \'cusp\') {\r\n        const t = (0,_intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_4__.bezierSelfIntersection)(ps)[0];\r\n        stack.push([0, t], [t, 1]); // split at cusp\r\n    }\r\n    else if (nodeType === \'crunode\') {\r\n        const ts = (0,_intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_4__.bezierSelfIntersection)(ps);\r\n        if (ts.length > 1) {\r\n            stack.push([0, ts[0]], [ts[0], ts[1]], [ts[1], 1]); // split at intersections\r\n        }\r\n        else {\r\n            // the intersection is outside the range [0,1]\r\n            stack.push([0, 1]);\r\n        }\r\n    }\r\n    else {\r\n        stack.push([0, 1]);\r\n    }\r\n    const qs = [];\r\n    while (stack.length !== 0) {\r\n        const ts = stack.pop();\r\n        const [tS, tE] = ts;\r\n        /** the piece of the cubic bezier to approximate */\r\n        const psCubic = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo3InclErrorBound)(ps, tS, tE).ps;\r\n        const psQuad = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(psCubic);\r\n        const spanRatio = tE - tS;\r\n        if (psQuad === undefined ||\r\n            spanRatio * (0,_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_3__.getAbsAreaBetween)(psQuad, psCubic) > tolerance) {\r\n            const tM = (tE + tS) / 2;\r\n            stack.push([tS, tM], [tM, tE]); // split cubic in 2 equal pieces\r\n        }\r\n        else {\r\n            qs.push(psQuad);\r\n        }\r\n    }\r\n    return qs.reverse();\r\n}\r\n\r\n//# sourceMappingURL=fit-quads-to-cubic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js?')},"./node_modules/flo-bezier3/node/fit/get-abs-area-between.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAbsAreaBetween": () => (/* binding */ getAbsAreaBetween)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../intersection/bezier-bezier-intersection/bezier-bezier-intersection.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js");\n/* harmony import */ var _global_properties_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global-properties/area.js */ "./node_modules/flo-bezier3/node/global-properties/area.js");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transformation/split/from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns the *absolute* area between the two given curves.\r\n *\r\n * * **precondition**: the first and last control points of each curve must be equal\r\n * * **precondition**: neither curve should have self-intersections else the results\r\n * are ambiguous\r\n * * can be used as an excellent error measure of the similarity between the two curves\r\n *\r\n * @doc mdx\r\n */\r\nfunction getAbsAreaBetween(ps1, ps2) {\r\n    const xs = (0,_intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersection)(ps1, ps2);\r\n    let tS1 = 0;\r\n    let tS2 = 0;\r\n    let total = 0;\r\n    for (let i = 0; i < xs.length + 1; i++) {\r\n        const x = xs[i];\r\n        const tE1 = x === undefined ? 1 : (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.mid)(x.ri1);\r\n        const tE2 = x === undefined ? 1 : (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.mid)(x.ri2);\r\n        const piece1 = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_3__.fromTo)(ps1, tS1, tE1);\r\n        const piece2 = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_3__.fromTo)(ps2, tS2, tE2);\r\n        tS1 = tE1;\r\n        tS2 = tE2;\r\n        total += Math.abs((0,_global_properties_area_js__WEBPACK_IMPORTED_MODULE_2__.area)(piece1) - (0,_global_properties_area_js__WEBPACK_IMPORTED_MODULE_2__.area)(piece2));\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=get-abs-area-between.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/fit/get-abs-area-between.js?')},"./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "quadraticToPolyline": () => (/* binding */ quadraticToPolyline)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_is_quad_flat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-quad-flat.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transformation/split/from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\nconst { abs, max } = Math;\r\n/**\r\n * Transforms the given quadratic bezier curve into a polyline approximation to\r\n * within a given tolerance and returns the result.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tolerance defaults to `2**-10` of the maximum coordinate of the given\r\n * bezier curve; a tolerance given as the maximum Hausdorff distance allowed\r\n * between the polyline and the bezier curve\r\n *\r\n * @doc mdx\r\n */\r\nfunction quadraticToPolyline(ps, tolerance) {\r\n    if (tolerance === undefined || tolerance === 0) {\r\n        const [p0, p1, p2] = ps;\r\n        const [x0, y0] = p0;\r\n        const [x1, y1] = p1;\r\n        const [x2, y2] = p2;\r\n        const maxCoordinate = max(abs(x0), abs(y0), abs(x1), abs(y1), abs(x2), abs(y2));\r\n        tolerance = maxCoordinate * 2 ** -10;\r\n    }\r\n    // A quad bezier has the following useful properties (Let the control\r\n    // points be labeled P0, P1 and P2 respectively and let the point at t = 0.5\r\n    // be labeled M1):\r\n    // -------------------------------------------------------------------------\r\n    // * At t = 0.5 P1 has its maximum influence of 0.5 and P0 and P2 each an \r\n    // influence of 0.25.\r\n    // * The tangent at t = 0.5 is given by P2 - P0.\r\n    // * The line implied by the tangent at t = 0.5 cuts the line segments P0-P1\r\n    // and P2-P1 in half. Lets call these points M0 and M2.\r\n    // * The polygon P0-M0-M2-P2 bounds the curve.\r\n    // * The curve can be cut into two quad bezier curves. \r\n    // * If it is cut at t = 0.5, i.e. at M1 so that we have two quad beziers \r\n    // defined by the triangles Q1 = P0-M0-M1 and Q2 = M0-M2-P2 then both \r\n    // the interior angles at P0 and P2 are < 90 degrees (acute). Lets call such\r\n    // a quad acute, otherwise obtuse.\r\n    // * If we split an obtuse quad at t = 0.5 then the resulting quads are both\r\n    // acute.\r\n    // * Acute quads is such that the point at t = 0.5, i.e. at M1) is the \r\n    // furthest away from the line P0-P2.\r\n    // Note: In our algorithm the above property can be used to measure the \r\n    // flatness of the quad reliably.\r\n    // The algorithm: q: quad => lines[] such that the Hausdorff distance \r\n    // between the polyline and the quad < tolerance.\r\n    // Strategy: Use linked list for polyline - makes splitting easier\r\n    // -------------------------------------------------------------------------\r\n    // quad obtuse ? \r\n    //   no  : Push the quad onto the stack\r\n    //   yes : Split the quad at t = 0.5 and push both halves onto the stack\r\n    // Loop while stack not empty\r\n    //   pop from stack => q\r\n    //   d <= calculate distance from t = 0.5 to line p0-p2\r\n    //   tolerance < tol ?\r\n    //     yes : do nothing\r\n    //     no  : split quad at t = 0.5 and push both halves onto the stack\r\n    // Loop end\r\n    // Stack with nodes still to be checked\r\n    const stack = [];\r\n    // Polyline linked list\r\n    let head = {\r\n        ps,\r\n        prev: undefined,\r\n        next: undefined // keep TypeScript happy - it\'s ok, we\'ll set it later\r\n    };\r\n    stack.push(head);\r\n    while (stack.length) {\r\n        // keep TypeScript happy; of course there\'se something in the stack\r\n        const node = stack.pop();\r\n        const ps = node.ps;\r\n        if ((0,_global_properties_classification_is_quad_flat_js__WEBPACK_IMPORTED_MODULE_0__.isQuadFlat)(ps, tolerance)) {\r\n            continue;\r\n        }\r\n        const quads = [\r\n            (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, 0, 0.5),\r\n            (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, 0.5, 1)\r\n        ];\r\n        const prev = node.prev;\r\n        const next = node.next;\r\n        const node1 = {\r\n            ps: quads[0],\r\n            prev,\r\n            next: undefined // keep TypeScript happy - it\'s ok, we\'ll set it later\r\n        };\r\n        const node2 = {\r\n            ps: quads[1],\r\n            prev: undefined,\r\n            next\r\n        };\r\n        node1.next = node2;\r\n        node2.prev = node1;\r\n        if (prev) {\r\n            prev.next = node1;\r\n        }\r\n        if (next) {\r\n            next.prev = node2;\r\n        }\r\n        if (head === node) {\r\n            head = node1;\r\n        }\r\n        stack.push(node1);\r\n        stack.push(node2);\r\n    }\r\n    const linePs = [];\r\n    let node = head;\r\n    linePs.push(head.ps[0]);\r\n    while (node) {\r\n        linePs.push(node.ps[2]);\r\n        node = node.next;\r\n    }\r\n    return linePs;\r\n}\r\n\r\n//# sourceMappingURL=quadratic-to-polyline.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js?')},"./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromPowerBasis\": () => (/* binding */ fromPowerBasis)\n/* harmony export */ });\n/**\r\n * Returns the Bernstein basis representation (i.e. control points) of a line,\r\n * quadratic or cubic bezier given its power bases.\r\n *\r\n * * **non-exact**: due to floating-point round-off (see implementation to\r\n * understand under what conditions the result would be exact)\r\n *\r\n * @param cs An order 1,2 or 3 parametric curve in power bases with the\r\n * x-coordinate coefficients given first (as an array representing the\r\n * polynomial from highest to lowest power coefficient), e.g. `[[1,2,3,4],\r\n * [5,6,7,8]]` represents a cubic parametric curve given by\r\n * `x(t) = t^3 + 2t^2 + 3t^3 + 4t^4, y(t) = 5t^3 + 6t^2 + 7t + 8`.\r\n *\r\n * @doc\r\n */\r\nfunction fromPowerBasis(cs) {\r\n    const len = cs[0].length;\r\n    if (len === 4) {\r\n        const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = cs;\r\n        return [\r\n            [a0,\r\n                b0],\r\n            [a0 + a1 / 3,\r\n                b0 + b1 / 3],\r\n            [a0 + 2 * a1 / 3 + a2 / 3,\r\n                b0 + 2 * b1 / 3 + b2 / 3],\r\n            [a0 + a1 + a2 + a3,\r\n                b0 + b1 + b2 + b3]\r\n        ];\r\n    }\r\n    if (len === 3) {\r\n        const [[a2, a1, a0], [b2, b1, b0]] = cs;\r\n        return [\r\n            [a0,\r\n                b0],\r\n            [a0 + a1 / 2,\r\n                b0 + b1 / 2],\r\n            [a0 + a1 + a2,\r\n                b0 + b1 + b2]\r\n        ];\r\n    }\r\n    if (len === 2) {\r\n        const [[a1, a0], [b1, b0]] = cs;\r\n        return [\r\n            [a0,\r\n                b0],\r\n            [a0 + a1,\r\n                b0 + b1]\r\n        ];\r\n    }\r\n    if (len === 1) {\r\n        const [[a0], [b0]] = cs;\r\n        return [\r\n            [a0,\r\n                b0]\r\n        ];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=from-power-basis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js?")},"./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAbsCurvatureExtremaPolys": () => (/* binding */ getAbsCurvatureExtremaPolys)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js");\n\r\n\r\n\r\n/**\r\n * Returns the polynomials whose zeros are the `t` values of the local\r\n * minima / maxima of the absolute curvature for the given bezier curve.\r\n *\r\n * The polynomials are in the form `p1*p2` where the zeros\r\n * of `p1` are the inflection points and the zeros of `p2` are the other minima /\r\n * maxima.\r\n *\r\n * * **precondition:** must be a `true` cubic bezier (not degenerate to line or\r\n * quadratic)\r\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\r\n * * **non-exact:** due to floating point roundof during calculation\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction getAbsCurvatureExtremaPolys(ps) {\r\n    // It is a real cubic - use the excellent answer from the description:\r\n    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\r\n    // Inflection points at: (x′′y′ − x′y′′) === 0\r\n    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0\r\n    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps); // max bitlength increase === 5\r\n    const [[ddx1, ddx0], [ddy1, ddy0]] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_2ndDerivative)(ps); // max bitlength increase === 6\r\n    const [dddx, dddy] = (0,_to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_3rdDerivative)(ps); // max bitlength increase === 6\r\n    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))\r\n    // or \r\n    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + \r\n    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)\r\n    // The above line becomes\r\n    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))\r\n    // or \r\n    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - \r\n    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt\r\n    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and\r\n    // then expanding and collecting terms)\r\n    const dddx_dy1 = dddx * dy1;\r\n    const dddy_dx1 = dddy * dx1;\r\n    const ddx0_dy0 = ddx0 * dy0;\r\n    const ddx0_dy1 = ddx0 * dy1;\r\n    const ddy1_ddy1 = ddy1 * ddy1;\r\n    const ddx1_dy0 = ddx1 * dy0;\r\n    const ddy0_dx0 = ddy0 * dx0;\r\n    const ddy0_dx1 = ddy0 * dx1;\r\n    const ddy1_dx0 = ddy1 * dx0;\r\n    const dx0_dx1 = dx0 * dx1;\r\n    const dx0_dx2 = dx0 * dx2;\r\n    const dx0_dy2 = dx0 * dy2;\r\n    const dx1_dx1 = dx1 * dx1;\r\n    const dx1_dx2 = dx1 * dx2;\r\n    const dx1_dy1 = dx1 * dy1;\r\n    const dx2_dy0 = dx2 * dy0;\r\n    const dx2_dy2 = dx2 * dy2;\r\n    const dx2_dx2 = dx2 * dx2;\r\n    const dy0_dy1 = dy0 * dy1;\r\n    const dy0_dy2 = dy0 * dy2;\r\n    const dy1_dy1 = dy1 * dy1;\r\n    const dy1_dy2 = dy1 * dy2;\r\n    const dy2_dy2 = dy2 * dy2;\r\n    const ss = dddx * dy0 - dddy * dx0;\r\n    const uu = dddx_dy1 - dddy_dx1;\r\n    const vv = ddx0 * dx0 + ddy0 * dy0;\r\n    const ww = ddx0 * dx1 + ddx1 * dx0 + ddy0 * dy1 + ddy1 * dy0;\r\n    const xx = ddx0_dy0 - ddy0_dx0;\r\n    const yy = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\r\n    const qq = dx0 * dx0 + dy0 * dy0;\r\n    const rr = dx0_dx1 + dy0_dy1;\r\n    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809\r\n    const z1 = dx1_dy1 + dx2_dy0;\r\n    const z2 = dy0_dy2 + dy1_dy1;\r\n    const z3 = dx0_dx2 + dx1_dx1;\r\n    const z4 = dx1 * dy2 + dx2 * dy1;\r\n    const z5 = dx2_dx2 - dy2_dy2;\r\n    const z6 = dx1_dx2 - dy1_dy2;\r\n    const z7 = dx0_dy2 + dx1_dy1;\r\n    const z8 = dx0_dx1 - dy0_dy1;\r\n    const z9 = dx0 * dy1 + dx1 * dy0;\r\n    const x1 = dy0_dy2 + z2;\r\n    const x2 = dx0_dx2 + z3;\r\n    const x3 = dx0_dy2 + z1;\r\n    const x4 = dx1_dy1 + z1;\r\n    const x5 = x2 - x1;\r\n    const x6 = z1 + dx2_dy0;\r\n    const x7 = z7 + dx2_dy0;\r\n    const x8 = 2 * ddy0_dx1 + ddy1_dx0;\r\n    const t5 = dx2_dx2 * (dddx_dy1 - 3 * dddy_dx1) +\r\n        dy2_dy2 * (3 * dddx_dy1 - dddy_dx1) +\r\n        2 * ((dx2_dy2) * ((dddx * dx1 - dddy * dy1) + 3 * (ddy0 * ddy1 - ddx0 * ddx1)) + 3 * ddx1 * ddy1 * z6) +\r\n        3 * (z4 * (ddy1_ddy1 - ddx1 * ddx1) + z5 * (ddx0 * ddy1 + ddy0 * ddx1));\r\n    const t4 = dddx * (dy2 * (x2 + 3 * z2) + dx2 * x4) -\r\n        dddy * (dx0 * (3 * dx2_dx2 + dy2_dy2) + dx1 * (3 * dx1_dx2 + 2 * dy1_dy2) + dx2 * x1) +\r\n        3 * (ddx0 * ((ddy0 * z5 - ddx0 * dx2_dy2) + 2 * (ddy1 * z6 - ddx1 * z4)) +\r\n            ddx1 * (2 * ddy0 * z6 + ddy1 * (2 * (dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1 * x7) +\r\n            ddy0 * (ddy0 * dx2_dy2 + 2 * ddy1 * z4) +\r\n            ddy1_ddy1 * x3);\r\n    const t3 = dddx * (2 * dx0 * z4 + dx1 * x6 + dy1 * (4 * dy0_dy2 + x1)) -\r\n        dddy * (2 * dx0 * (3 * dx1_dx2 + dy1_dy2) + dx1 * (dx1_dx1 + 2 * dy0_dy2) + dy1 * x6) +\r\n        3 * (ddx0 * (2 * (ddy0 * z6 - ddx1 * x7) + ddy1 * x5 - ddx0 * z4) +\r\n            ddx1 * (2 * ddy1 * z8 - ddx1 * z9) +\r\n            ddy0 * (ddy0 * z4 + 2 * ddy1 * x3 + ddx1 * x5) +\r\n            ddy1_ddy1 * z9);\r\n    const t2 = dddx * (dx0 * (dx0_dy2 + 2 * z1) + dy0 * (dx1_dx1 + 3 * z2)) -\r\n        dddy * (dx0 * (3 * z3 + x1) + dy0 * x4) +\r\n        3 * (ddx0 * (ddy0 * x5 - ddx0 * x3 + 2 * (ddy1 * z8 - ddx1 * z9)) +\r\n            ddx1 * (dx0 * (x8 - ddx1 * dy0) - dy0 * (2 * ddy0 * dy1 + ddy1 * dy0)) +\r\n            ddy0 * (ddy0 * z1 + dx0 * (2 * ddy1 * dy1 + ddy0 * dy2)) +\r\n            ddy1 * dy0 * x8);\r\n    const t1 = (qq * uu + 2 * rr * ss) - 3 * (vv * yy + ww * xx);\r\n    const t0 = ss * qq - 3 * vv * xx;\r\n    const r3 = ddx1 * dy2 - ddy1 * dx2;\r\n    const r2 = ddx0 * dy2 + ddx1 * dy1 - ddy0 * dx2 - ddy1 * dx1;\r\n    const r1 = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;\r\n    const r0 = ddx0_dy0 - ddy0_dx0;\r\n    return {\r\n        inflectionPoly: [r3, r2, r1, r0],\r\n        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-abs-curvature-extrema-polys.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js?')},"./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCurvatureExtrema": () => (/* binding */ getCurvatureExtrema)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-abs-curvature-extrema-polys.js */ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-abs-curvature-extrema-polys.js");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global-properties/classification/is-collinear.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum\r\n * absolute curvature for the given bezier curve.\r\n *\r\n * If there are an infinite number of such `t` values (such as is the case for a\r\n * line), an empty array is returned.\r\n *\r\n * * see [MvG](https://math.stackexchange.com/a/1956264/130809)\'s excellent\r\n * answer on math.stackexchange\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getCurvatureExtrema(ps) {\r\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_2__.isCollinear)(ps)) {\r\n        return { minima: [], maxima: [], inflections: [] };\r\n    }\r\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_3__.isCubicReallyQuad)(ps)) {\r\n        ps = (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_4__.cubicToQuadratic)(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        const poly = getCurvatureExtremaQuadraticPoly(ps);\r\n        const maxima = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(poly, 0, 1);\r\n        return {\r\n            minima: [],\r\n            maxima,\r\n            inflections: []\r\n        };\r\n    }\r\n    const polys = (0,_get_abs_curvature_extrema_polys_js__WEBPACK_IMPORTED_MODULE_1__.getAbsCurvatureExtremaPolys)(ps);\r\n    const p1 = polys.inflectionPoly;\r\n    const p2 = polys.otherExtremaPoly;\r\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(p2, 0, 1);\r\n    // get second derivative (using product rule) to see if it is a local \r\n    // minimum or maximum, i.e. diff(p1*p2) = p1\'*p2 + p1*p2\' = dp1*p2 + p1*dp2\r\n    // = p1*dp2 (since dp1*p2 === 0)\r\n    const dp2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.differentiate)(p2);\r\n    const minima = [];\r\n    const maxima = [];\r\n    for (let i = 0; i < ts.length; i++) {\r\n        const t = ts[i];\r\n        const dp2_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(dp2, t);\r\n        const p1_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(p1, t);\r\n        const secondDerivative = p1_ * dp2_;\r\n        if (secondDerivative >= 0) {\r\n            minima.push(t);\r\n        }\r\n        else {\r\n            maxima.push(t);\r\n        }\r\n    }\r\n    const inflections = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(p1, 0, 1);\r\n    return { minima, maxima, inflections };\r\n}\r\n/**\r\n * Returns the polynomial whose zero is the t value of maximum absolute\r\n * curvature for the given *quadratic* bezier curve.\r\n *\r\n * * **precondition:** the given parabola is not degenerate to a line\r\n * * **non-exact:** there is floating point roundof during calculation\r\n * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)\'s\r\n * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)\r\n *\r\n * @param ps an order 2 bezier curve given as an array of control points,\r\n * e.g. `[[0,0],[1,1],[2,1]]`\r\n *\r\n * @internal\r\n */\r\nfunction getCurvatureExtremaQuadraticPoly(ps) {\r\n    // Find the point of max curvature (of the parabola)\r\n    // calculate t*\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const x10 = x1 - x0;\r\n    const x21 = x2 - x1;\r\n    const wx = x21 - x10;\r\n    const y10 = y1 - y0;\r\n    const y21 = y2 - y1;\r\n    const wy = y21 - y10;\r\n    const n = x0 * (wx - x1) - x1 * (x21 - x1) +\r\n        y0 * (wy - y1) - y1 * (y21 - y1);\r\n    const d = wx * wx + wy * wy;\r\n    return [d, -n];\r\n}\r\n\r\n//# sourceMappingURL=get-curvature-extrema.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js?')},"./node_modules/flo-bezier3/node/global-properties/area.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "area": () => (/* binding */ area)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n\r\n\r\n\r\n/**\r\n * Returns the signed area between the given bezier curve and the line between\r\n * its 1st and last control points.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n */\r\nfunction area(ps) {\r\n    let [x, y] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis)(ps);\r\n    let [dx, dy] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_1stDerivative)(ps);\r\n    const poly = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.subtract)((0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.multiply)(x, dy), (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.multiply)(y, dx)), 0);\r\n    // the below is exactly te same as: Horner(poly,1) - Horner(poly,0)\r\n    let total = 0;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        total += poly[i];\r\n    }\r\n    return total / 2;\r\n}\r\n\r\n//# sourceMappingURL=area.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/area.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundingBoxTight": () => (/* binding */ getBoundingBoxTight)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-bounding-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js");\n/* harmony import */ var _length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../length/control-point-lines-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns a **non-certified**, **rotated**, **tight** bounding box of the given\r\n * bezier curve as four ordered points of a rotated rectangle (with each given\r\n * as `[x,y]`)\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBoundingBoxTight(ps) {\r\n    const [xS, yS] = ps[0];\r\n    const [xE, yE] = ps[ps.length - 1];\r\n    let sinθ;\r\n    let cosθ;\r\n    // take care of the case the endpoints are close together\r\n    const len = (0,_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_2__.controlPointLinesLength)(ps);\r\n    if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(ps[0], ps[ps.length - 1]) * 2 ** 8 < len * len) {\r\n        const [xE_, yE_] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_3__.evalDeCasteljau)(ps, 0.5);\r\n        const hypotenuse = Math.sqrt((xE_ - xS) * (xE_ - xS) + (yE_ - yS) * (yE_ - yS));\r\n        sinθ = (yE_ - yS) / hypotenuse;\r\n        cosθ = (xE_ - xS) / hypotenuse;\r\n    }\r\n    else {\r\n        const hypotenuse = Math.sqrt((xE - xS) * (xE - xS) + (yE - yS) * (yE - yS));\r\n        sinθ = (yE - yS) / hypotenuse;\r\n        cosθ = (xE - xS) / hypotenuse;\r\n    }\r\n    const box = getNormalizedBoundingBox(ps, sinθ, cosθ);\r\n    const [[p0x, p0y], [p1x, p1y]] = box;\r\n    const axisAlignedBox = [\r\n        box[0], [p1x, p0y],\r\n        box[1], [p0x, p1y]\r\n    ];\r\n    const rotate_ = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate)(sinθ, cosθ);\r\n    return axisAlignedBox.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(ps[0], rotate_(p)));\r\n}\r\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point\r\n * moved to origin and rotated so that last point lies on x-axis) given cubic\r\n * bezier.\r\n *\r\n * * returns the bounding box in the form [[minX, minY], [maxX,maxY]\r\n *\r\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param sinθ - Sine of angle made by line from first bezier point to\r\n * last with x-axis.\r\n * @param cosθ - Cosine of angle made by line from first bezier point\r\n * to last with x-axis.\r\n *\r\n * @internal\r\n */\r\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\r\n    const vectorToOrigin = ps[0].map(x => -x);\r\n    const f = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(vectorToOrigin);\r\n    const boundingPs = ps.map(p => (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.rotate)(-sinθ, cosθ, f(p)));\r\n    return (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_1__.getBoundingBox)(boundingPs);\r\n}\r\n\r\n//# sourceMappingURL=get-bounding-box-tight.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundingBox": () => (/* binding */ getBoundingBox)\n/* harmony export */ });\n/* harmony import */ var _get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-x-bounds-tight.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js");\n/* harmony import */ var _get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-y-bounds-tight.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js");\n\r\n\r\n/**\r\n * Returns a tight axis-aligned bounding box of the given bezier curve.\r\n *\r\n * * **certified**: the box is guaranteed to engulf the given bezier curve.\r\n *\r\n * * returns the box in the form `[[minX, minY], [maxX, maxY]`\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBoundingBox(ps) {\r\n    const xBounds = (0,_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_0__.getXBoundsTight)(ps);\r\n    const yBounds = (0,_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_1__.getYBoundsTight)(ps);\r\n    return [\r\n        [xBounds.minX.box[0][0], yBounds.minY.box[0][1]],\r\n        [xBounds.maxX.box[1][0], yBounds.maxY.box[1][1]]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-bounding-box.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundingHull": () => (/* binding */ getBoundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-graham-scan */ "./node_modules/flo-graham-scan/node/index.js");\n\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n *\r\n * * see https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * **exact**: this algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n *\r\n * @param ps a set of points, e.g. a bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param includeAllBoundaryPoints set this to `true` to if all boundary points\r\n * should be returned, even redundant ones; defaults to `false`\r\n *\r\n * @dox mdx\r\n */\r\nconst getBoundingHull = flo_graham_scan__WEBPACK_IMPORTED_MODULE_0__.grahamScan;\r\n\r\n//# sourceMappingURL=get-bounding-hull.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBounds": () => (/* binding */ getBounds)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n\r\n\r\n\r\n/**\r\n * Returns an axis-aligned bounding box together with the `t` values where the\r\n * bounds on the bezier are reached.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getBounds(ps) {\r\n    // Roots of derivative\r\n    const dxy = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(dxy[0], 0, 1);\r\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(dxy[1], 0, 1);\r\n    // Endpoints\r\n    rootsX.push(0, 1);\r\n    rootsY.push(0, 1);\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    let tMinX;\r\n    let tMaxX;\r\n    let tMinY;\r\n    let tMaxY;\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        const t = rootsX[i];\r\n        const [x,] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\r\n        if (x < minX) {\r\n            minX = x;\r\n            tMinX = t;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n            tMaxX = t;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        const t = rootsY[i];\r\n        const [, y] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, t);\r\n        if (y < minY) {\r\n            minY = y;\r\n            tMinY = t;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n            tMaxY = t;\r\n        }\r\n    }\r\n    // `tMinX`, ... is guaranteed defined below - TS was (understandably) \r\n    // unable to follow the logic.\r\n    const ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\r\n    const box = [[minX, minY], [maxX, maxY]];\r\n    return { ts, box };\r\n}\r\n\r\n//# sourceMappingURL=get-bounds.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getControlPointBox": () => (/* binding */ getControlPointBox)\n/* harmony export */ });\n/**\r\n * Returns a tight axis-aligned bounding box of the given bezier curve\'s control\r\n * points. (Note that the box is not a tight bound of the bezier curve itself.)\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getControlPointBox(ps) {\r\n    let minX = Number.POSITIVE_INFINITY;\r\n    let maxX = Number.NEGATIVE_INFINITY;\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    let maxY = Number.NEGATIVE_INFINITY;\r\n    for (const p of ps) {\r\n        const x = p[0];\r\n        const y = p[1];\r\n        if (x < minX) {\r\n            minX = x;\r\n        }\r\n        if (x > maxX) {\r\n            maxX = x;\r\n        }\r\n        if (y < minY) {\r\n            minY = y;\r\n        }\r\n        if (y > maxY) {\r\n            maxY = y;\r\n        }\r\n    }\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n\r\n//# sourceMappingURL=get-control-point-box.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getIntervalBoxDd": () => (/* binding */ getIntervalBoxDd)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\nconst ddDiffDd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddDiffDd;\r\nconst ddDivDdWithError = double_double__WEBPACK_IMPORTED_MODULE_3__.ddDivDdWithError;\r\nconst ddAddDouble = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDouble;\r\nconst ddMultDd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst ddAddDd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst ddMultBy2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst ddMin = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMin;\r\nconst ddMax = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMax;\r\nconst u = Number.EPSILON / 2;\r\nconst uu = u * u;\r\nconst abs = Math.abs;\r\nconst qdq = ddDiffDd;\r\nconst qOne = [0, 1];\r\nconst qad = ddAddDouble;\r\nconst qaq = ddAddDd;\r\nconst qmq = ddMultDd;\r\nconst qmd = ddMultDouble2;\r\nconst qm2 = ddMultBy2;\r\nconst qDivQuadWithError = ddDivDdWithError;\r\nconst qMin = ddMin;\r\nconst qMax = ddMax;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__["γγ"])(3);\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\r\n * given bezier curve from `t1` to `t2`. The returned box is given as an array\r\n * of points in double-double precision, e.g. `[[[0,1],[0,1]], [[0,2],[0,2]]]`.\r\n *\r\n * * **precondition**: (to satisfy guarantee) t1 < t2\r\n * * **precondition**: (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ts [first, second] parameter values, given in double-double\r\n * precision, e.g. [[0,0.11], [0,0.12]]. (Use [[getIntervalBox]] instead for\r\n * double precision)\r\n *\r\n * @doc mdx\r\n */\r\nfunction getIntervalBoxDd(ps, ts) {\r\n    if (ts[0][0] !== ts[1][0] || ts[0][1] !== ts[1][1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3Dd(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2Dd(ps, ts);\r\n        }\r\n        return getIntervalBox1Dd(ps, ts);\r\n    }\r\n    else { // ts[0] === ts[1]\r\n        return getIntervalBoxAtTDd(ps, ts[0]);\r\n    }\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox3Dd([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    const tt1 = qmq(t1, t1); // <2>tt1  \r\n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    const ttt1 = qmq(tt1, t1); // <4>(<2>tt1<0>t1)\r\n    const tts1 = qmq(tt1, s1); // <5>(<2>tt1<1>s1)\r\n    const tss1 = qmq(ss1, t1); // <6>(<4>ss1<0>t1)\r\n    const sss1 = qmq(ss1, s1); // <7>(<4>ss1<1>s1)\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const tt2 = qmq(t2, t2); // <2>tt2\r\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    const ttt2 = qmq(tt2, t2); // <4>(<1>tt2<0>t2)\r\n    const tts2 = qmq(tt2, s2); // <5>(<1>tt2<1>s2)\r\n    const tss2 = qmq(ss2, t2); // <6>(<3>ss2<0>t2)\r\n    const sss2 = qmq(ss2, s2); // <7>(<3>ss2<1>s2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _tt1 = abs(tt1[1]);\r\n    const _ts1 = abs(ts1[1]);\r\n    const _ss1 = abs(ss1[1]);\r\n    const _ttt1 = abs(ttt1[1]);\r\n    const _tts1 = abs(tts1[1]);\r\n    const _tss1 = abs(tss1[1]);\r\n    const _sss1 = abs(sss1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    const _tt2 = abs(tt2[1]);\r\n    const _ts2 = abs(ts2[1]);\r\n    const _ss2 = abs(ss2[1]);\r\n    const _ttt2 = abs(ttt2[1]);\r\n    const _tts2 = abs(tts2[1]);\r\n    const _tss2 = abs(tss2[1]);\r\n    const _sss2 = abs(sss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    let _x3 = abs(x3);\r\n    let _y3 = abs(y3);\r\n    //---- x - calculation\r\n    const q8 = qaq(qmd(x3, t1), qmd(x2, s1));\r\n    const q7 = qaq(qaq(qmd(x3, tt1), qmd(2 * x2, ts1)), qmd(x1, ss1));\r\n    const qx0 = qaq(qaq(qmd(x3, ttt1), qmd(x0, sss1)), qmd(3, (qaq(qmd(x2, tts1), qmd(x1, tss1)))));\r\n    const qx1 = qaq(qmq(q7, t2), qmq(qx0, s2));\r\n    const qx2 = qaq(qaq(qmq(q8, tt2), qmq(qx0, ss2)), qmq(qm2(q7), ts2));\r\n    const qx3 = qaq(qaq(qmd(x3, ttt2), qmq(qx0, sss2)), qmd(3, qaq(qmq(q8, tts2), qmq(q7, tss2))));\r\n    const _qx0 = abs(qx0[1]);\r\n    //---- error / abs value calculation\r\n    const _q8 = _x3 * _t1 + _x2 * _s1; // <= <3>\r\n    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))\r\n    const _q7 = _x3 * _tt1 + 2 * _x2 * _ts1 + _x1 * _ss1; // <= <6> \r\n    // q7: <6>(<5>(<3>(x3*<2>tt1) + <4>(2*x2*<3>ts1)) + <5>(x1*<4>ss1));\r\n    _x0 = (_x3 * _ttt1 + _x0 * _sss1) + 3 * (_x2 * _tts1 + _x1 * _tss1); // <= <11>\r\n    // x0: <11>(<9>(x3*<4>ttt1 + x0*<7>sss1) + <10>(3*<9>(<8>(<6>(x2*<5>tts1) + <7>(x1*<6>tss1)))));\r\n    _x1 = _q7 * _t2 + _qx0 * _s2; // <= <15>\r\n    // x1: <15>(<7>(<6>q7*t2) + <14>(<11>x0*<1>s2));\r\n    _x2 = _q8 * _tt2 + _qx0 * _ss2 + 2 * _q7 * _ts2; // <= <20>\r\n    // x2: <20>(<19>(<18>(<3>q8*<2>tt2) + <17>(<11>x0*<4>ss2)) + <11>(2*<6>q7*<3>ts2));\r\n    _x3 = _x3 * _ttt2 + _qx0 * _sss2 + 3 * (_q8 * _tts2 + _q7 * _tss2); // <= <22>\r\n    // x3: <22>(<21>(<5>(x3*<4>ttt2) + <20>(<11>x0*<7>sss2)) + <16>(3*<15>(<10>(<3>q8*<5>tts2) + <14>(<6>q7*<6>tss2)))));\r\n    // max errors: \r\n    _x0 = 11 * uu * _x0;\r\n    _x1 = 15 * uu * _x1;\r\n    _x2 = 20 * uu * _x2;\r\n    _x3 = 22 * uu * _x3;\r\n    //---- y - calculation\r\n    const r8 = qaq(qmd(y3, t1), qmd(y2, s1));\r\n    const r7 = qaq(qaq(qmd(y3, tt1), qmd(2 * y2, ts1)), qmd(y1, ss1));\r\n    const qy0 = qaq(qaq(qmd(y3, ttt1), qmd(y0, sss1)), qmd(3, (qaq(qmd(y2, tts1), qmd(y1, tss1)))));\r\n    const qy1 = qaq(qmq(r7, t2), qmq(qy0, s2));\r\n    const qy2 = qaq(qaq(qmq(r8, tt2), qmq(qy0, ss2)), qmq(qm2(r7), ts2));\r\n    const qy3 = qaq(qaq(qmd(y3, ttt2), qmq(qy0, sss2)), qmd(3, qaq(qmq(r8, tts2), qmq(r7, tss2))));\r\n    const _qy0 = abs(qy0[1]);\r\n    //---- error / abs value calculation\r\n    const _r8 = _y3 * _t1 + _y2 * _s1; // <= <3>\r\n    const _r7 = _y3 * _tt1 + 2 * _y2 * _ts1 + _y1 * _ss1; // <= <6> \r\n    _y0 = (_y3 * _ttt1 + _y0 * _sss1) + 3 * (_y2 * _tts1 + _y1 * _tss1); // <= <11>\r\n    _y1 = _r7 * _t2 + _qy0 * _s2; // <= <15>\r\n    _y2 = _r8 * _tt2 + _qy0 * _ss2 + 2 * _r7 * _ts2; // <= <20>\r\n    _y3 = _y3 * _ttt2 + _qy0 * _sss2 + 3 * (_r8 * _tts2 + _r7 * _tss2); // <= <22>\r\n    // max errors: \r\n    _y0 = 11 * uu * _y0;\r\n    _y1 = 15 * uu * _y1;\r\n    _y2 = 20 * uu * _y2;\r\n    _y3 = 22 * uu * _y3;\r\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qMin(qad(qx2, -_x2), qad(qx3, -_x3)));\r\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qMax(qad(qx2, +_x2), qad(qx3, +_x3)));\r\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qMin(qad(qy2, -_y2), qad(qy3, -_y3)));\r\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qMax(qad(qy2, +_y2), qad(qy3, +_y3)));\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox2Dd([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    //const s1 = (1 - t1);  // <= exact by precondition - not anymore\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate\r\n    const tt1 = qmq(t1, t1); // <2>tt1  \r\n    const ts1 = qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>\r\n    const ss1 = qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const tt2 = qmq(t2, t2); // <2>tt2\r\n    const ts2 = qmq(t2, s2); // <3>(<0>t2<1>s2)\r\n    const ss2 = qmq(s2, s2); // <4>(<1>s2<1>s2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _tt1 = abs(tt1[1]);\r\n    const _ts1 = abs(ts1[1]);\r\n    const _ss1 = abs(ss1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    const _tt2 = abs(tt2[1]);\r\n    const _ts2 = abs(ts2[1]);\r\n    const _ss2 = abs(ss2[1]);\r\n    // all of t1,s1,ts1,... are all positive so simpler to use a relative error\r\n    // bound (using e.g. counters <k>):\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    let _x2 = abs(x2);\r\n    let _y2 = abs(y2);\r\n    //---- x - calculation\r\n    const q1 = qaq(qaq(qmd(x2, tt1), qmd(2 * x1, ts1)), qmd(x0, ss1));\r\n    const q2 = qaq(qmd(x2, t1), qmd(x1, s1));\r\n    const qx0 = q1;\r\n    const qx1 = qaq(qmq(t2, q2), qmq(s2, q1));\r\n    const qx2 = qaq(qaq(qmd(x2, tt2), qmq(qm2(ts2), q2)), qmq(ss2, q1));\r\n    const _q1 = _x2 * _tt1 + 2 * _x1 * _ts1 + _x0 * _ss1; // <= <7>\r\n    // q1: <7>(<6>(<5>(x2*<2>tt1) + <4>(2*x1*<3>ts1)) + <5>(x0*<4>ss1));\r\n    const _q2 = _x2 * _t1 + _x1 * _s1; // <= <3>\r\n    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));\r\n    _x0 = _q1; // <= <7>\r\n    // x0: <7>q1;\r\n    _x1 = _t2 * _q2 + _s2 * _q1; // <= <11>\r\n    // x1: <11>(<5>(t2*<3>q2) + <10>(<1>s2*<7>q1));\r\n    _x2 = (_tt2 * x2 + 2 * _ts2 * _q2) + _ss2 * _q1; // <= <14>\r\n    // x2: <14>(<9>(<3>(<2>tt2*x2) + <8>(2*<3>ts2*<3>q2)) + <13>(<4>ss2*<7>q1));\r\n    // max errors: \r\n    _x0 = 7 * uu * _x0;\r\n    _x1 = 11 * uu * _x1;\r\n    _x2 = 14 * uu * _x2;\r\n    //---- y - calculation\r\n    const r1 = qaq(qaq(qmd(y2, tt1), qmd(2 * y1, ts1)), qmd(y0, ss1));\r\n    const r2 = qaq(qmd(y2, t1), qmd(y1, s1));\r\n    const qy0 = r1;\r\n    const qy1 = qaq(qmq(t2, r2), qmq(s2, r1));\r\n    const qy2 = qaq(qaq(qmd(y2, tt2), qmq(qm2(ts2), r2)), qmq(ss2, r1));\r\n    const _r1 = _y2 * _tt1 + 2 * _y1 * _ts1 + _y0 * _ss1; // <= <7>\r\n    // r1: <7>(<6>(<5>(y2*<2>tt1) + <4>(2*y1*<3>ts1)) + <5>(y0*<4>ss1));\r\n    const _r2 = _y2 * _t1 + _y1 * _s1; // <= <3>\r\n    // r2: <3>(<1>(y2*t1) + <2>(y1*<1>s1));\r\n    _y0 = _r1; // <= <7>\r\n    // y0: <7>r1;\r\n    _y1 = _t2 * _r2 + _s2 * _r1; // <= <11>\r\n    // y1: <11>(<5>(t2*<3>r2) + <10>(<1>s2*<7>r1));\r\n    _y2 = (_tt2 * y2 + 2 * _ts2 * _r2) + _ss2 * _r1; // <= <14>\r\n    // y2: <14>(<9>(<3>(<2>tt2*y2) + <8>(2*<3>ts2*<3>r2)) + <13>(<4>ss2*<7>r1));\r\n    // max errors: \r\n    _y0 = 7 * uu * _y0;\r\n    _y1 = 11 * uu * _y1;\r\n    _y2 = 14 * uu * _y2;\r\n    const minX = qMin(qMin(qad(qx0, -_x0), qad(qx1, -_x1)), qad(qx2, -_x2));\r\n    const maxX = qMax(qMax(qad(qx0, +_x0), qad(qx1, +_x1)), qad(qx2, +_x2));\r\n    const minY = qMin(qMin(qad(qy0, -_y0), qad(qy1, -_y1)), qad(qy2, -_y2));\r\n    const maxY = qMax(qMax(qad(qy0, +_y0), qad(qy1, +_y1)), qad(qy2, +_y2));\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox1Dd([[x0, y0], [x1, y1]], [t1, t2]) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const tDel = qdq(t2, t1);\r\n    const tDel_ = 3 * uu * abs(tDel[1]); // max absolute error in tDel\r\n    const oMt1 = qdq(qOne, t1);\r\n    const oMt1_ = 3 * uu * abs(oMt1[1]); // max absolute error in oMt1\r\n    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2\r\n    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);\r\n    t2 = qad($t2.est, $t2.err); // the max t2 can possibly be\r\n    const s1 = qdq(qOne, t1); // <1>s1\r\n    const s2 = qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)\r\n    const _t1 = abs(t1[1]);\r\n    const _s1 = abs(s1[1]);\r\n    const _t2 = abs(t2[1]);\r\n    const _s2 = abs(s2[1]);\r\n    // counter rules:\r\n    //   <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   <k>a<l>b = <k + l + 1>ab\r\n    //   fl(a) === <1>a\r\n    let _x0 = abs(x0);\r\n    let _y0 = abs(y0);\r\n    let _x1 = abs(x1);\r\n    let _y1 = abs(y1);\r\n    //---- x - calculation\r\n    const qx0 = qaq(qmd(x1, t1), qmd(x0, s1));\r\n    const qx1 = qaq(qmd(x1, t2), qmq(qx0, s2));\r\n    _x0 = _x1 * _t1 + _x0 * _s1; // <= <3>\r\n    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));\r\n    _x1 = _x1 * _t2 + _x0 * _s2; // <= <7>\r\n    // x1: <7>(<1>(x1*t2) + <6>(<3>x0*<1>s2));\r\n    // max errors: \r\n    _x0 = 3 * u * _x0;\r\n    _x1 = 7 * u * _x1;\r\n    //---- y - calculation\r\n    const qy0 = qaq(qmd(y1, t1), qmd(y0, s1));\r\n    const qy1 = qaq(qmd(y1, t2), qmq(qy0, s2));\r\n    _y0 = _y1 * _t1 + _y0 * _s1; // <= <3>\r\n    _y1 = _y1 * _t2 + _y0 * _s2; // <= <7>\r\n    // max errors: \r\n    _y0 = 3 * u * _y0;\r\n    _y1 = 7 * u * _y1;\r\n    const minX = qMin(qad(qx0, -_x0), qad(qx1, -_x1));\r\n    const maxX = qMax(qad(qx0, +_x0), qad(qx1, +_x1));\r\n    const minY = qMin(qad(qy0, -_y0), qad(qy1, -_y1));\r\n    const maxY = qMax(qad(qy0, +_y0), qad(qy1, +_y1));\r\n    //return [[x0,y0],[x1,y1]];\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * quad precision t1, t2\r\n *\r\n * @param ps\r\n * @param t\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBoxAtTDd(ps, t) {\r\n    const _pS = ps[0];\r\n    const _pE = ps[ps.length - 1];\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        const pSx = [0, _pS[0]];\r\n        const pSy = [0, _pS[1]];\r\n        return [\r\n            [pSx, pSy],\r\n            [pSx, pSy]\r\n        ];\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        const pEx = [0, _pE[0]];\r\n        const pEy = [0, _pE[1]];\r\n        return [\r\n            [pEx, pEy],\r\n            [pEx, pEy]\r\n        ];\r\n    }\r\n    const p = (0,_local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauDd)(ps, t);\r\n    let pE;\r\n    if (ps.length === 4) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, t).map(c_ => 8 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 3) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, t).map(c_ => 5 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 2) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, t).map(c_ => 2 * 2 * γγ3 * c_);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return [p, p];\r\n    }\r\n    return [\r\n        [qad(p[0], -pE[0]), qad(p[1], -pE[1])],\r\n        [qad(p[0], +pE[0]), qad(p[1], +pE[1])]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-interval-box-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getIntervalBox": () => (/* binding */ getIntervalBox)\n/* harmony export */ });\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../local-properties-at-t/evaluate/eval-de-casteljau-error.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-3-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-2-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js");\n/* harmony import */ var _transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../transformation/split/from-to/from-to-1-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js");\n\r\n\r\n\r\n\r\n\r\n\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__["γ"])(1);\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire\r\n * given bezier curve from t1 to t2. The returned box is given as a pair\r\n * of points (the box corners) in double precision, e.g. `[[1,1], [2,2]]`.\r\n *\r\n * * **precondition:** (to satisfy guarantee) t1 < t2\r\n * * **precondition:** (to satisfy guarantee) t1,t2 >= 0 && t1,t2 <= 1\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ts [first, second] parameter values, e.g. [0.11, 0.12]\r\n *\r\n * @doc mdx\r\n */\r\nfunction getIntervalBox(ps, ts) {\r\n    if (ts[0] !== ts[1]) {\r\n        if (ps.length === 4) {\r\n            return getIntervalBox3(ps, ts);\r\n        }\r\n        if (ps.length === 3) {\r\n            return getIntervalBox2(ps, ts);\r\n        }\r\n        return getIntervalBox1(ps, ts);\r\n    }\r\n    // ts[0] === ts[1]\r\n    return getIntervalBoxAtT(ps, ts[0]);\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achieved by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points.\r\n * @internal\r\n *\r\n * @param ps\r\n * @param ts\r\n */\r\nfunction getIntervalBox3(ps, ts) {\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromTo3InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const x2 = psI[2][0];\r\n    const x3 = psI[3][0];\r\n    const _x0 = 9 * u * _psI[0][0];\r\n    const _x1 = 9 * u * _psI[1][0];\r\n    const _x2 = 9 * u * _psI[2][0];\r\n    const _x3 = 9 * u * _psI[3][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const y2 = psI[2][1];\r\n    const y3 = psI[3][1];\r\n    const _y0 = 9 * u * _psI[0][1];\r\n    const _y1 = 9 * u * _psI[1][1];\r\n    const _y2 = 9 * u * _psI[2][1];\r\n    const _y3 = 9 * u * _psI[3][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2, x3 - _x3);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2, x3 + _x3);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2, y3 - _y3);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2, y3 + _y3);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achievied by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox2(ps, ts) {\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_4__.fromTo2InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const x2 = psI[2][0];\r\n    const _x0 = 5 * u * _psI[0][0];\r\n    const _x1 = 5 * u * _psI[1][0];\r\n    const _x2 = 5 * u * _psI[2][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const y2 = psI[2][1];\r\n    const _y0 = 5 * u * _psI[0][1];\r\n    const _y1 = 5 * u * _psI[1][1];\r\n    const _y2 = 5 * u * _psI[2][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * Returns an axis-aligned-box that is guaranteed to engulf the entire given\r\n * bezier curve from t1 to t2.\r\n *\r\n * This is achievied by calculating the error bounds of a new curve calculated\r\n * form t1 to t2 using a splitting algorithm and then taking its extreme\r\n * control points and finally finding a box that engulfs the control points\r\n *\r\n * @param param0\r\n * @param param1\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBox1(ps, ts) {\r\n    // Implementation for lines kept for symmetry - there are obviously much\r\n    // simpler ways to calculate the required box in the case of a line.\r\n    const { ps: psI, _ps: _psI } = (0,_transformation_split_from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_5__.fromTo1InclErrorBound)(ps, ts[0], ts[1]);\r\n    const x0 = psI[0][0];\r\n    const x1 = psI[1][0];\r\n    const _x0 = 3 * u * _psI[0][0];\r\n    const _x1 = 3 * u * _psI[1][0];\r\n    const y0 = psI[0][1];\r\n    const y1 = psI[1][1];\r\n    const _y0 = 3 * u * _psI[0][1];\r\n    const _y1 = 3 * u * _psI[1][1];\r\n    const minX = Math.min(x0 - _x0, x1 - _x1);\r\n    const maxX = Math.max(x0 + _x0, x1 + _x1);\r\n    const minY = Math.min(y0 - _y0, y1 - _y1);\r\n    const maxY = Math.max(y0 + _y0, y1 + _y1);\r\n    return [[minX, minY], [maxX, maxY]];\r\n}\r\n/**\r\n * @param ps\r\n * @param t\r\n *\r\n * @internal\r\n */\r\nfunction getIntervalBoxAtT(ps, t) {\r\n    const _pS = ps[0];\r\n    const _pE = ps[ps.length - 1];\r\n    if (t === 0) {\r\n        return [_pS, _pS];\r\n    }\r\n    else if (t === 1) {\r\n        return [_pE, _pE];\r\n    }\r\n    const p = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, t);\r\n    let pE;\r\n    if (ps.length === 4) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 8 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 3) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 5 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 2) {\r\n        pE = (0,_local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauError)(ps, [0, t]).map(c_ => 2 * γ1 * c_);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return [p, p];\r\n    }\r\n    return [\r\n        [p[0] - pE[0], p[1] - pE[1]],\r\n        [p[0] + pE[0], p[1] + pE[1]]\r\n    ];\r\n}\r\n\r\n// 416\r\n//# sourceMappingURL=get-interval-box.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getXBoundsTight": () => (/* binding */ getXBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n\r\n\r\n\r\n/**\r\n * Returns tight x-coordinate bounds of the given bezier curve.\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getXBoundsTight(ps) {\r\n    const pS = ps[0];\r\n    const pE = ps[ps.length - 1];\r\n    let minX;\r\n    let maxX;\r\n    if (pS[0] < pE[0]) {\r\n        minX = { ts: [0, 0], box: [pS, pS] };\r\n        maxX = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minX = { ts: [1, 1], box: [pE, pE] };\r\n        maxX = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minX, maxX };\r\n    }\r\n    const [dx,] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertifiedSimplified)(dx, 0, 1);\r\n    // Test points\r\n    for (let i = 0; i < rootsX.length; i++) {\r\n        const r = rootsX[i];\r\n        const ts = [r.tS, r.tE];\r\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\r\n        if (box[0][0] < minX.box[0][0]) {\r\n            minX = { ts, box };\r\n        }\r\n        if (box[1][0] > maxX.box[0][0]) {\r\n            maxX = { ts, box };\r\n        }\r\n    }\r\n    return { minX, maxX };\r\n}\r\n\r\n//# sourceMappingURL=get-x-bounds-tight.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js?')},"./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getYBoundsTight": () => (/* binding */ getYBoundsTight)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n\r\n\r\n\r\n/**\r\n * Returns tight y-coordinate bounds of the given bezier curve.\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve given as an array of control\r\n * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getYBoundsTight(ps) {\r\n    const pS = ps[0];\r\n    const pE = ps[ps.length - 1];\r\n    let minY;\r\n    let maxY;\r\n    if (pS[1] < pE[1]) {\r\n        minY = { ts: [0, 0], box: [pS, pS] };\r\n        maxY = { ts: [1, 1], box: [pE, pE] };\r\n    }\r\n    else {\r\n        minY = { ts: [1, 1], box: [pE, pE] };\r\n        maxY = { ts: [0, 0], box: [pS, pS] };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { minY, maxY };\r\n    }\r\n    const [, dy] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\r\n    const rootsY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertifiedSimplified)(dy, 0, 1);\r\n    // Test points\r\n    for (let i = 0; i < rootsY.length; i++) {\r\n        const r = rootsY[i];\r\n        const ts = [r.tS, r.tE];\r\n        const box = (0,_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_2__.getIntervalBox)(ps, ts);\r\n        if (box[0][1] < minY.box[0][1]) {\r\n            minY = { ts, box };\r\n        }\r\n        if (box[1][1] > maxY.box[0][1]) {\r\n            maxY = { ts, box };\r\n        }\r\n    }\r\n    return { minY, maxY };\r\n}\r\n\r\n//# sourceMappingURL=get-y-bounds-tight.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/classify.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"classification\": () => (/* binding */ classification),\n/* harmony export */   \"classifications\": () => (/* binding */ classifications),\n/* harmony export */   \"classify\": () => (/* binding */ classify)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ \"./node_modules/double-double/node/index.js\");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ \"./node_modules/flo-bezier3/node/error-analysis/error-analysis.js\");\n/* harmony import */ var _is_really_point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-really-point.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js\");\n/* harmony import */ var _is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is-quad-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js\");\n/* harmony import */ var _is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./is-cubic-really-quad.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js\");\n/* harmony import */ var _is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is-cubic-really-line.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js\");\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./is-collinear.js */ \"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js\");\n/* harmony import */ var _intersection_self_intersection_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../intersection//self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js\");\n/* harmony import */ var _intersection_self_intersection_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js */ \"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst { eSign, eCompare } = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.operators;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\r\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_1__.twoSum;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__[\"γ\"])(1);\r\n// The classifications form an equivalence class, in other words *all* \r\n// possible planar polynomial bezier curves (of order <= 3) are represented and \r\n// all options are mutually exclusive.\r\nconst point = { order: 0, realOrder: 0, collinear: true, nodeType: 'n/a' };\r\nconst lineGeneral = { order: 1, realOrder: 1, collinear: true, nodeType: 'n/a' };\r\nconst lineDegenPoint = { order: 1, realOrder: 0, collinear: true, nodeType: 'n/a' };\r\nconst quadGeneral = { order: 2, realOrder: 2, collinear: false, nodeType: 'n/a' };\r\n/** The curve is collinear but not a line (i.e. evaluating at `t` values won't correspond to same points) */\r\nconst quadDegenCollinear = { order: 2, realOrder: 2, collinear: true, nodeType: 'n/a' };\r\nconst quadDegenLine = { order: 2, realOrder: 1, collinear: true, nodeType: 'n/a' };\r\nconst quadDegenPoint = { order: 2, realOrder: 0, collinear: true, nodeType: 'n/a' };\r\nconst cubicGeneralCrunode = { order: 3, realOrder: 3, collinear: false, nodeType: 'crunode' };\r\nconst cubicGeneralAcnode = { order: 3, realOrder: 3, collinear: false, nodeType: 'acnode' };\r\nconst cubicGeneralCusp = { order: 3, realOrder: 3, collinear: false, nodeType: 'cusp' };\r\nconst cubicGeneralExplicit = { order: 3, realOrder: 3, collinear: false, nodeType: 'explicit' };\r\nconst cubicDegenCollinearCubic = { order: 3, realOrder: 3, collinear: true, nodeType: 'n/a' };\r\nconst cubicDegenQuad = { order: 3, realOrder: 2, collinear: false, nodeType: 'n/a' };\r\nconst cubicDegenCollinearQuad = { order: 3, realOrder: 2, collinear: true, nodeType: 'n/a' };\r\nconst cubicDegenLine = { order: 3, realOrder: 1, collinear: true, nodeType: 'n/a' };\r\nconst cubicDegenPoint = { order: 3, realOrder: 0, collinear: true, nodeType: 'n/a' };\r\n/**\r\n * The classifications form an equivalence class, in other words *all*\r\n * possible planar polynomial bezier curves (of order <= 3) are represented and\r\n * all options are mutually exclusive.\r\n */\r\nconst classifications = {\r\n    point,\r\n    lineGeneral,\r\n    lineDegenPoint,\r\n    quadGeneral,\r\n    quadDegenCollinear,\r\n    quadDegenLine,\r\n    quadDegenPoint,\r\n    cubicGeneralCrunode,\r\n    cubicGeneralAcnode,\r\n    cubicGeneralCusp,\r\n    cubicGeneralExplicit,\r\n    cubicDegenCollinearCubic,\r\n    cubicDegenQuad,\r\n    cubicDegenCollinearQuad,\r\n    cubicDegenLine,\r\n    cubicDegenPoint\r\n};\r\nfunction isPoint(ps) {\r\n    return classify(ps) === point;\r\n}\r\nfunction isLineGeneral(ps) {\r\n    return classify(ps) === lineGeneral;\r\n}\r\nfunction isLineDegenPoint(ps) {\r\n    return classify(ps) === lineDegenPoint;\r\n}\r\nfunction isQuadGeneral(ps) {\r\n    return classify(ps) === quadGeneral;\r\n}\r\nfunction isQuadDegenCollinear(ps) {\r\n    return classify(ps) === quadDegenCollinear;\r\n}\r\nfunction isQuadDegenLine(ps) {\r\n    return classify(ps) === quadDegenLine;\r\n}\r\nfunction isQuadDegenPoint(ps) {\r\n    return classify(ps) === quadDegenPoint;\r\n}\r\nfunction isCubicGeneralCrunode(ps) {\r\n    return classify(ps) === cubicGeneralCrunode;\r\n}\r\nfunction isCubicGeneralAcnode(ps) {\r\n    return classify(ps) === cubicGeneralAcnode;\r\n}\r\nfunction isCubicGeneralCusp(ps) {\r\n    return classify(ps) === cubicGeneralCusp;\r\n}\r\nfunction isCubicGeneralExplicit(ps) {\r\n    return classify(ps) === cubicGeneralExplicit;\r\n}\r\nfunction isCubicDegenCollinearCubic(ps) {\r\n    return classify(ps) === cubicDegenCollinearCubic;\r\n}\r\nfunction isCubicDegenQuad(ps) {\r\n    return classify(ps) === cubicDegenQuad;\r\n}\r\nfunction isCubicDegenCollinearQuad(ps) {\r\n    return classify(ps) === cubicDegenCollinearQuad;\r\n}\r\nfunction isCubicDegenLine(ps) {\r\n    return classify(ps) === cubicDegenLine;\r\n}\r\nfunction isCubicDegenPoint(ps) {\r\n    return classify(ps) === cubicDegenPoint;\r\n}\r\nconst classification = {\r\n    isPoint,\r\n    isLineGeneral,\r\n    isLineDegenPoint,\r\n    isQuadGeneral,\r\n    isQuadDegenCollinear,\r\n    isQuadDegenLine,\r\n    isQuadDegenPoint,\r\n    isCubicGeneralCrunode,\r\n    isCubicGeneralAcnode,\r\n    isCubicGeneralCusp,\r\n    isCubicGeneralExplicit,\r\n    isCubicDegenCollinearCubic,\r\n    isCubicDegenQuad,\r\n    isCubicDegenCollinearQuad,\r\n    isCubicDegenLine,\r\n    isCubicDegenPoint,\r\n};\r\n/**\r\n * Returns a classification of the given bezier curve.\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps a bezier curve of order 0,1,2 or 3 given as an array of its\r\n * control points.\r\n *\r\n * @doc mdx\r\n */\r\nfunction classify(ps) {\r\n    if (ps.length === 4) {\r\n        if ((0,_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_5__.isCubicReallyQuad)(ps)) {\r\n            return (0,_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_6__.isCubicReallyLine)(ps)\r\n                ? (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps) ? cubicDegenPoint : cubicDegenLine\r\n                : (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_7__.isCollinear)(ps) ? cubicDegenCollinearQuad : cubicDegenQuad;\r\n        }\r\n        return (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_7__.isCollinear)(ps)\r\n            ? cubicDegenCollinearCubic\r\n            : classifyGeneralCubic(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_7__.isCollinear)(ps)\r\n            ? (0,_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_4__.isQuadReallyLine)(ps)\r\n                ? (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps) ? quadDegenPoint : quadDegenLine\r\n                : quadDegenCollinear\r\n            : quadGeneral;\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps) ? lineDegenPoint : lineGeneral;\r\n    }\r\n    if (ps.length === 1) {\r\n        return point;\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3');\r\n}\r\n/**\r\n * Return a complete classification of the given *general* cubic bezier curve as\r\n * either having an `acnode`, `crunode`, `cusp` or being an `explicit` curve.\r\n *\r\n * * **precondition**: the given bezier curve is a 'general' cubic, i.e. not all\r\n * points collinear and not degenerate to a quadratic curve, line or point.\r\n *\r\n * @param ps\r\n */\r\nfunction classifyGeneralCubic(ps) {\r\n    // First get fast naively calculated coefficients for self-intersection\r\n    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = (0,_intersection_self_intersection_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez3WithRunningError)(ps);\r\n    // if error in `a` cannot discern it from zero\r\n    if (abs(a) <= a_) {\r\n        // it is rare to get here \r\n        // check for sure if a === 0 exactly\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        //const a3 = (x3 - x0) + 3*(x1 - x2);\r\n        //const a2 = (x2 + x0) - 2*x1;\r\n        //const b3 = (y3 - y0) + 3*(y1 - y2);\r\n        //const b2 = (y2 + y0) - 2*y1;\r\n        const a3 = fes(td(x3, x0), sce(3, (td(x1, x2))));\r\n        const a2 = ge(ts(x2, x0), -2 * x1);\r\n        const b3 = fes(td(y3, y0), sce(3, (td(y1, y2))));\r\n        const b2 = ge(ts(y2, y0), -2 * y1);\r\n        const a2b3 = epr(a2, b3);\r\n        const a3b2 = epr(a3, b2);\r\n        if (eCompare(a2b3, a3b2) === 0) {\r\n            // a === 0 => no roots possible! (also b === 0)\r\n            return cubicGeneralExplicit;\r\n        }\r\n    }\r\n    // `Discr` = discriminant = b^2 - 4ac\r\n    // calculate `Discr` and its absolute error Discr_\r\n    const bb = b * b;\r\n    const bb_ = 2 * b_ * abs(b) + γ1 * bb; // the error in b**2\r\n    const ac4 = 4 * a * c;\r\n    const ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + γ1 * abs(ac4);\r\n    const Discr = bb - ac4;\r\n    const Discr_ = bb_ + ac4_ + γ1 * abs(Discr);\r\n    // if the discriminant is smaller than negative the error bound then\r\n    // certainly there are no roots, i.e. no cusp and no self-intersections\r\n    if (Discr < -Discr_) {\r\n        // discriminant is definitely negative\r\n        return cubicGeneralAcnode;\r\n    }\r\n    // if the discriminant is definitely positive\r\n    if (Discr > Discr_) {\r\n        // calculate roots naively as a fast pre-filter\r\n        return cubicGeneralCrunode;\r\n    }\r\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\r\n    let [A, B, C] = (0,_intersection_self_intersection_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez3Exact)(ps);\r\n    // exact - Discr = b^2 - 4ac\r\n    const eDiscr = edif(epr(B, B), sce(4, epr(A, C)));\r\n    const sgnDiscr = eSign(eDiscr);\r\n    return sgnDiscr < 0\r\n        ? cubicGeneralAcnode\r\n        : sgnDiscr > 0\r\n            ? cubicGeneralCrunode\r\n            : cubicGeneralCusp;\r\n}\r\n\r\n//# sourceMappingURL=classify.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/classify.js?")},"./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isCollinear": () => (/* binding */ isCollinear),\n/* harmony export */   "isHorizontal": () => (/* binding */ isHorizontal),\n/* harmony export */   "isVertical": () => (/* binding */ isVertical)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst { orient2d } = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.operators;\r\n/**\r\n * Returns `true` if the given bezier curve has all control points collinear,\r\n * `false` otherwise.\r\n *\r\n * * if you need to know whether a given bezier curve can be converted to an\r\n * order 1 bezier curve (a line) such that the same `(x,y)` point is returned\r\n * for the same `t` value then use e.g. [[isQuadReallyLine]] instead.\r\n *\r\n * * **exact** not susceptible to floating point round-off\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isCollinear(ps) {\r\n    if (ps.length === 4) {\r\n        // Cubic bezier\r\n        return (orient2d(ps[0], ps[1], ps[2]) === 0 &&\r\n            orient2d(ps[1], ps[2], ps[3]) === 0 &&\r\n            // The below check is necessary for if ps[1] === ps[2]\r\n            orient2d(ps[0], ps[2], ps[3]) === 0);\r\n    }\r\n    if (ps.length === 3) {\r\n        // Quadratic bezier\r\n        return orient2d(ps[0], ps[1], ps[2]) === 0;\r\n    }\r\n    if (ps.length <= 2) {\r\n        // Line (or point)\r\n        return true;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/**\r\n * Returns `true` if the given bezier curve has all control points the\r\n * same `y` value (possibly self-overlapping), `false` otherwise.\r\n *\r\n * @param ps An order 0, 1, 2 or 3 bezier curve.\r\n *\r\n * @doc\r\n */\r\nfunction isHorizontal(ps) {\r\n    const y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][1] !== y) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns `true` if the given bezier curve has all control points the\r\n * same `x` value (possibly self-overlapping), `false` otherwise.\r\n *\r\n * @param ps An order 0, 1, 2 or 3 bezier curve.\r\n *\r\n * @doc\r\n */\r\nfunction isVertical(ps) {\r\n    const x = ps[0][0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (ps[i][0] !== x) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-collinear.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isCubicReallyLine": () => (/* binding */ isCubicReallyLine)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-collinear.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\n/**\r\n * Returns `true` if the given bezier curve has all control points collinear\r\n * *and* it can be converted to an order 1 bezier curve (a line) such that the\r\n * same `(x,y)` point is returned for the same `t` value, `false` otherwise.\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isCubicReallyLine(ps) {\r\n    // note: if cubic is really a quad then\r\n    // x3 + 3*(x1 - x2) === x0 && \r\n    // y3 + 3*(y1 - y2) === y0\r\n    if (!(0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_1__.isCollinear)(ps)) {\r\n        return false;\r\n    }\r\n    const [p0, p1, p2, p3] = ps;\r\n    const [x0, y0] = p0;\r\n    const [x1, y1] = p1;\r\n    const [x2, y2] = p2;\r\n    const [x3, y3] = p3;\r\n    // convert middle two control points to single quad point\r\n    // [\r\n    //   (3*(x1 + x2) - (x0 + x3)) / 4, \r\n    //   (3*(y1 + y2) - (y0 + y3)) / 4\r\n    // ]\r\n    const qx1 = ediff(sce(ts(x1 / 4, x2 / 4), 3), ts(x0 / 4, x3 / 4));\r\n    const qy1 = ediff(sce(ts(y1 / 4, y2 / 4), 3), ts(y0 / 4, y3 / 4));\r\n    // is quad really line:\r\n    //   if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1) OR\r\n    //   if ((x0 + x2)/2 === x1) && ((y0 + y2)/2 === y1)\r\n    return (esign(ediff(ts(x0 / 2, x3 / 2), qx1)) === 0 &&\r\n        esign(ediff(ts(y0 / 2, y3 / 2), qy1)) === 0);\r\n}\r\n\r\n//# sourceMappingURL=is-cubic-really-line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isCubicReallyQuad": () => (/* binding */ isCubicReallyQuad)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst u = Number.EPSILON / 2;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns `true` if the given cubic bezier curve is really a quadratic (or\r\n * lower order) curve in disguise, i.e. it can be represent by a quadratic\r\n * bezier curve, `false` otherwise.\r\n *\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isCubicReallyQuad(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // The line below is unrolled (uses a toHybridQuadratic condition (points same?))\r\n    //if ((x3 + 3*x1) - (x0 + 3*x2) === 0 && \r\n    //    (y3 + 3*y1) - (y0 + 3*y2) === 0) {\r\n    // Calculate an approximation of the above with error bounds and use it as\r\n    // a fast filter.\r\n    const u1 = 3 * x1;\r\n    const u1_ = abs(3 * x1); // the absolute error in u1\r\n    const u2 = x3 + u1;\r\n    const u2_ = u1_ + abs(u2); // the absolute error in u2\r\n    const v1 = 3 * x2;\r\n    const v1_ = abs(3 * x2); // the absolute error in v1\r\n    const v2 = x0 + v1;\r\n    const v2_ = v1_ + abs(v2); // the absolute error in v2\r\n    const w = u2 - v2;\r\n    const w_ = u2_ + v2_ + abs(w); // the absolute error in w\r\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\r\n    if (abs(w) - u * w_ > 0) {\r\n        // fast filter 1 passed\r\n        return false;\r\n    }\r\n    const q1 = 3 * y1;\r\n    const q1_ = abs(3 * y1); // the absolute error in q1\r\n    const q2 = y3 + q1;\r\n    const q2_ = q1_ + abs(q2); // the absolute error in q2\r\n    const r1 = 3 * y2;\r\n    const r1_ = abs(3 * y2); // the absolute error in r1\r\n    const r2 = y0 + r1;\r\n    const r2_ = r1_ + abs(r2); // the absolute error in r2\r\n    const s = q2 - r2;\r\n    const s_ = q2_ + r2_ + abs(s); // the absolute error in s\r\n    if (abs(s) - u * s_ > 0) {\r\n        // fast filter 2 passed\r\n        return false;\r\n    }\r\n    // unable to filter - go slow and exact\r\n    return (esign(ediff(fes([x3], tp(3, x1)), fes([x0], tp(3, x2)))) === 0 &&\r\n        esign(ediff(fes([y3], tp(3, y1)), fes([y0], tp(3, y2)))) === 0);\r\n}\r\n\r\n//# sourceMappingURL=is-cubic-really-quad.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isQuadFlat": () => (/* binding */ isQuadFlat)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-quad-obtuse.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n\r\n\r\n\r\nconst { max, abs } = Math;\r\n/**\r\n * Returns `true` if the given quadratic bezier curve is acute (see `isQuadObtuse`)\r\n * and can be approximated with a line segment with maximum Hausdorff distance\r\n * <= the given tolerance, `false` otherwise.\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6]]`\r\n * @param tolerance a maximum Hausdorff distance tolerance; defaults to `2**-10`\r\n * of the maximum coordinate of the given bezier curve\r\n *\r\n * @internal\r\n */\r\nfunction isQuadFlat(ps, tolerance) {\r\n    if ((0,_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_1__.isQuadObtuse)(ps)) {\r\n        return false;\r\n    }\r\n    const [p0, p1, p2] = ps;\r\n    const [x0, y0] = p0;\r\n    const [x2, y2] = p2;\r\n    if (tolerance === undefined) {\r\n        const [x1, y1] = p1;\r\n        const maxCoordinate = max(abs(x0), abs(y0), abs(x1), abs(y1), abs(x2), abs(y2));\r\n        tolerance = maxCoordinate * 2 ** -10;\r\n    }\r\n    if (x0 === x2 && y0 === y2) {\r\n        const d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p0, p1) / 4;\r\n        return d <= tolerance ** 2;\r\n    }\r\n    const [x, y] = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(ps, 0.5);\r\n    const numerator = ((y2 - y0) * x - (x2 - x0) * y + x2 * y0 - y2 * x0) ** 2;\r\n    const denominator = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(p0, p2);\r\n    const dSquared = numerator / denominator;\r\n    return dSquared <= tolerance ** 2;\r\n}\r\n\r\n//# sourceMappingURL=is-quad-flat.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-flat.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isQuadObtuse": () => (/* binding */ isQuadObtuse)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * Returns `true` if the given quadratic bezier is obtuse, `false` otherwise (i.e.\r\n * `false` if acute).\r\n *\r\n * Obtuse here is defined as follows: let the quad form a triangle through its\r\n * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior\r\n * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,\r\n * otherwise it is considered obtuse.\r\n *\r\n * @doc mdx\r\n */\r\nfunction isQuadObtuse(ps) {\r\n    const v0 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[0], ps[1]);\r\n    const v1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[1], ps[2]);\r\n    const v2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[2], ps[0]);\r\n    const angleP0Obtuse = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(v2, v0) > 0;\r\n    const angleP2Obtuse = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.dot)(v1, v2) > 0;\r\n    return angleP0Obtuse || angleP2Obtuse;\r\n}\r\n\r\n//# sourceMappingURL=is-quad-obtuse.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isQuadReallyLine": () => (/* binding */ isQuadReallyLine)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst { abs } = Math;\r\n/**\r\n * Returns `true` if the given quadratic bezier curve is really a linear curve\r\n * (or a point), i.e. if all control points collinear *and* it can be converted\r\n * to an order 1 bezier curve (a line) such that the\r\n * same `(x,y)` point is returned for the same `t` value, `false` otherwise.\r\n *\r\n * * the required condition is met if: `x0 + x2 = 2*x1` and `y0 + y2 = 2*y1`\r\n * * **exact**: not susceptible to floating point round-off\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isQuadReallyLine(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    //if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1)\r\n    // Calculate an approximation of the above with error bounds and use it as\r\n    // a fast filter.\r\n    const q = x0 + x2;\r\n    const _q_ = abs(q); // the absolute error bound in q (after multipliciation by `u`)\r\n    const w = q - 2 * x1;\r\n    const w_ = _q_ + abs(w); // the absolute error bound in w\r\n    // if w cannot possibly be zero, i.e. if the error is smaller than the value\r\n    if (abs(w) - w_ > 0) {\r\n        // fast filter passed\r\n        return false;\r\n    }\r\n    const r = y0 + y2;\r\n    const _r_ = abs(r); // the absolute error bound in r (after multipliciation by `u`)\r\n    const z = r - 2 * y1;\r\n    const z_ = _r_ + abs(z); // the absolute error bound in w\r\n    // if the error is smaller than the value\r\n    if (abs(z) - z_ > 0) {\r\n        // fast filter passed\r\n        return false;\r\n    }\r\n    // unable to filter - go slow and exact\r\n    return (esign(ediff(ts(x0, x2), [2 * x1])) === 0 &&\r\n        esign(ediff(ts(y0, y2), [2 * y1])) === 0);\r\n}\r\n\r\n//# sourceMappingURL=is-quad-really-line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isReallyPoint": () => (/* binding */ isReallyPoint)\n/* harmony export */ });\n/**\r\n * Returns `true` if the given bezier curve has all control points coincident,\r\n * `false` otherwise.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction isReallyPoint(ps) {\r\n    const x = ps[0][0];\r\n    const y = ps[0][1];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        if (x !== ps[i][0] || y !== ps[i][1]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-really-point.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js?')},"./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isSelfOverlapping": () => (/* binding */ isSelfOverlapping)\n/* harmony export */ });\n/* harmony import */ var _is_collinear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-collinear.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js");\n\r\n/**\r\n * Returns `true` if the given bezier has all control points collinear and\r\n * it is self-overlapping, i.e. if it intersects itself at an infinite number\r\n * of points.\r\n *\r\n * * a bezier curve can only intersect itself at an infinite number of\r\n * points if its locus is a \'self-overlapping line\'.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction isSelfOverlapping(ps) {\r\n    if (!(0,_is_collinear_js__WEBPACK_IMPORTED_MODULE_0__.isCollinear)(ps)) {\r\n        return false;\r\n    }\r\n    // Check if control points are non-strict monotone\r\n    const xs = ps.map(p => p[0]);\r\n    const ys = ps.map(p => p[1]);\r\n    return !(isMonotone(xs) && isMonotone(ys));\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone increasing.\r\n * @param xs an array of numbers\r\n *\r\n * @internal\r\n */\r\nfunction isMonotoneIncreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] > xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns true if the given array of numbers are non-strict monotone decreasing.\r\n * @param xs an array of numbers\r\n *\r\n * @internal\r\n */\r\nfunction isMonotoneDecreasing(xs) {\r\n    for (let i = 1; i < xs.length; i++) {\r\n        if (xs[i - 1] < xs[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @param xs\r\n *\r\n * @internal\r\n */\r\nfunction isMonotone(xs) {\r\n    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);\r\n}\r\n\r\n//# sourceMappingURL=is-self-overlapping.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js?')},"./node_modules/flo-bezier3/node/global-properties/curviness.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "curviness": () => (/* binding */ curviness)\n/* harmony export */ });\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../simultaneous-properties/get-interface-rotation.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js");\n\r\nconst { abs } = Math;\r\n/**\r\n * Returns a \'curviness\' measure of the given bezier curve. `0` is considered\r\n * the `flattest` (as is the case of e.g. a line).\r\n *\r\n * The returned flatness, say `f` is such that `0 <= f <= (order-1)*𝜋`, where\r\n * `order` is the order of the bezier curve (e.g. cubics are of order 3); thus,\r\n * for example, cubics can have a maximum value of `2𝜋` for curviness (the most\r\n * curvy) and a minimum value of `0` (the flattest)\r\n *\r\n * This function is useful as a heuristic to test the `flatness` of curves to\r\n * see if they should be subdivided (in which case they would become flatter)\r\n *\r\n * * curviness is calculated simply as the sum of the absolute rotation (in\r\n * radians) of consecutive vectors formed by the ordered control points of the\r\n * curve\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction curviness(ps) {\r\n    // The below was the old heuristic which did not work well e.g. if an end \r\n    // control point was far away from the other 3\r\n    //return controlPointLinesLength(ps) / distanceBetween(ps[0], ps[ps.length-1]);\r\n    const vs = [];\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        const v = [ps[i + 1][0] - ps[i][0], ps[i + 1][1] - ps[i][1]];\r\n        if ((v[0] !== 0 || v[1]) !== 0) {\r\n            vs.push(v);\r\n        }\r\n    }\r\n    const len = vs.length;\r\n    let total = 0;\r\n    for (let i = 0; i < len - 1; i++) {\r\n        total += abs((0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(vs[i], vs[i + 1]));\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=curviness.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/curviness.js?')},"./node_modules/flo-bezier3/node/global-properties/get-inflections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInflections": () => (/* binding */ getInflections)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n/**\r\n * Returns the given order 1,2 or 3 bezier curve\'s inflection point `t`\r\n * parameter values in ascending order.\r\n *\r\n * * see [Caffeine Owl](http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html)\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getInflections(ps) {\r\n    if (ps.length < 4) {\r\n        // Neither lines, nor parabolas have inflection points\r\n        return [];\r\n    }\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\r\n    const ax = x1 - x0;\r\n    const ay = y1 - y0;\r\n    const bx = x2 - x1 - ax;\r\n    const by = y2 - y1 - ay;\r\n    const cx = x3 - x2 - ax - (2 * bx);\r\n    const cy = y3 - y2 - ay - (2 * by);\r\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\r\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\r\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\r\n    const a = bx * cy - by * cx;\r\n    const b = ax * cy - ay * cx;\r\n    const c = ax * by - ay * bx;\r\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)([a, b, c], 0, 1);\r\n}\r\n\r\n//# sourceMappingURL=get-inflections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/get-inflections.js?')},"./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "controlPointLinesLength": () => (/* binding */ controlPointLinesLength)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * Returns an upper bound for the length of the given bezier curve - this bound\r\n * is not very strict as it uses the sum of the straight-line distances between\r\n * control points as a measure.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction controlPointLinesLength(ps) {\r\n    let totalLength = 0;\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        totalLength += (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(ps[i], ps[i + 1]);\r\n    }\r\n    return totalLength;\r\n}\r\n\r\n//# sourceMappingURL=control-point-lines-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js?')},"./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lengthBez1": () => (/* binding */ lengthBez1)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n/**\r\n * Returns the curve length of the given line within the specified parameter\r\n * interval.\r\n *\r\n * @param interval the paramter interval over which the length is\r\n * to be calculated (often `[0,1]`)\r\n * @param ps a linear bezier curve given by an ordered array of its control\r\n * points, e.g. `[[0,0],[1,1]]`\r\n *\r\n * @internal\r\n */\r\nfunction lengthBez1(interval, ps) {\r\n    let [t1, t2] = interval;\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];\r\n    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];\r\n    return (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(p1, p2);\r\n}\r\n\r\n//# sourceMappingURL=length-bez1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js?')},"./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lengthBez2": () => (/* binding */ lengthBez2)\n/* harmony export */ });\n/* harmony import */ var flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-gauss-quadrature */ "./node_modules/flo-gauss-quadrature/node/index.js");\n/* harmony import */ var _local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../local-properties-at-t/ds.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/ds.js");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transformation/split/from-to/from-to-2-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../transformation/split/split-by-curvature.js */ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns the curve length of the given quadratic bezier curve within the\r\n * specified parameter interval.\r\n *\r\n * @param interval the paramter interval over which the length is\r\n * to be calculated (often `[0,1]`)\r\n * @param ps a quadratic bezier curve given by an ordered array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1]]`\r\n * @param maxCurviness optional maximum \'curviness\' (defined as the total angle\r\n * change between consecutive line segments between the curve control points)\r\n * before subdivision occurs; defaults to 0.4 radians\r\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\r\n * between curve segments; defaults to 16; can be 4,16 or 64\r\n *\r\n * @internal\r\n */\r\nfunction lengthBez2(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\r\n    const tS = interval[0];\r\n    const tE = interval[1];\r\n    if (tS === tE) {\r\n        return 0;\r\n    }\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // Ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {\r\n        return 0;\r\n    }\r\n    const ps_ = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo2InclErrorBound)(ps, tS, tE).ps;\r\n    const ts = (0,_transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_3__.splitByCurvature)(ps_, maxCurviness);\r\n    let total = 0;\r\n    for (let i = 0; i < ts.length - 1; i++) {\r\n        const tS = ts[i];\r\n        const tE = ts[i + 1];\r\n        total += (0,flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_0__.gaussQuadrature)((0,_local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_1__.ds)(ps_), [tS, tE], gaussOrder);\r\n    }\r\n    return total;\r\n}\r\n/**\r\n * Returns the curve length in the specified interval.\r\n *\r\n * * unused because it is not numerically stable in its current form.\r\n *\r\n * See https://gist.github.com/tunght13488/6744e77c242cc7a94859\r\n *\r\n * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]\r\n * @param interval - The paramter interval over which the length is\r\n * to be calculated (often === [0,1]).\r\n */\r\n/*\r\nfunction lengthBez2(interval: number[], ps: number[][]) {\r\n    if (interval[0] === interval[1]) { return 0; }\r\n\r\n    const [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {\r\n        return 0;\r\n    }\r\n\r\n    const [[x0, y0], [x1, y1], [x2, y2]] =\r\n            fromTo(ps)(interval[0], interval[1]);\r\n\r\n    const ax = x0 - 2*x1 + x2;\r\n    const ay = y0 - 2*y1 + y2;\r\n    const bx = 2*x1 - 2*x0;\r\n    const by = 2*y1 - 2*y0;\r\n\r\n    const A = 4 * (ax*ax + ay*ay);\r\n    const B = 4 * (ax*bx + ay*by);\r\n    const C = bx*bx + by*by;\r\n\r\n    const Sabc = 2*Math.sqrt(A+B+C);\r\n    const A_2 = Math.sqrt(A);\r\n    const A_32 = 2*A*A_2;\r\n    const C_2 = 2*Math.sqrt(C);\r\n    const BA = B/A_2;\r\n\r\n    return (\r\n        A_32*Sabc + A_2*B*(Sabc - C_2) +\r\n        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))\r\n    ) / (4*A_32);\r\n}\r\n*/\r\n\r\n//# sourceMappingURL=length-bez2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js?')},"./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lengthBez3": () => (/* binding */ lengthBez3)\n/* harmony export */ });\n/* harmony import */ var flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-gauss-quadrature */ "./node_modules/flo-gauss-quadrature/node/index.js");\n/* harmony import */ var _local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../local-properties-at-t/ds.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/ds.js");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transformation/split/split-by-curvature.js */ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../transformation/split/from-to/from-to-3-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns the curve length of the given cubic bezier curve within the\r\n * specified parameter interval.\r\n *\r\n * @param interval the paramter interval over which the length is\r\n * to be calculated (often `[0,1]`)\r\n * @param ps a cubic bezier curve given by an ordered array of its control\r\n * points, e.g. `[[0,0],[1,1],[2,1],[3,3]]`\r\n * @param maxCurviness optional maximum \'curviness\' (defined as the total angle\r\n * change between consecutive line segments between the curve control points)\r\n * before subdivision occurs; defaults to 0.4 radians\r\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\r\n * between curve segments; defaults to 16; can be 4,16 or 64\r\n *\r\n * @internal\r\n */\r\nfunction lengthBez3(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\r\n    const tS = interval[0];\r\n    const tE = interval[1];\r\n    if (tS === tE) {\r\n        return 0;\r\n    }\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // Keep line below to ensure zero length curve returns zero!\r\n    if (x0 === x1 && x1 === x2 && x2 === x3 &&\r\n        y0 === y1 && y1 === y2 && y2 === y3) {\r\n        return 0;\r\n    }\r\n    const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromTo3InclErrorBound)(ps, tS, tE).ps;\r\n    const ts = (0,_transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_2__.splitByCurvature)(ps_, maxCurviness);\r\n    let total = 0;\r\n    for (let i = 0; i < ts.length - 1; i++) {\r\n        const tS = ts[i];\r\n        const tE = ts[i + 1];\r\n        total += (0,flo_gauss_quadrature__WEBPACK_IMPORTED_MODULE_0__.gaussQuadrature)((0,_local_properties_at_t_ds_js__WEBPACK_IMPORTED_MODULE_1__.ds)(ps_), [tS, tE], gaussOrder);\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=length-bez3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js?')},"./node_modules/flo-bezier3/node/global-properties/length/length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "length": () => (/* binding */ length)\n/* harmony export */ });\n/* harmony import */ var _length_bez1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length-bez1.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js");\n/* harmony import */ var _length_bez2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length-bez2.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js");\n/* harmony import */ var _length_bez3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length-bez3.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js");\n\r\n\r\n\r\n/**\r\n * Returns the curve length (for a linear, quadratic or cubic bezier curve) in\r\n * the specified interval calculated using Gaussian Quadrature *with* adaptive\r\n * subdivision for improved accuracy.\r\n *\r\n * @param interval the paramter interval over which the length is\r\n * to be calculated (typically `[0,1]`)\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n * @param maxCurviness optional maximum \'curviness\' (defined as the total angle\r\n * change between consecutive line segments between the curve control points)\r\n * before subdivision occurs; defaults to 0.4 radians\r\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\r\n * between curve segments; defaults to 16; can be 4,16 or 64\r\n *\r\n * @doc mdx\r\n */\r\nfunction length(interval, ps, maxCurviness = 0.4, gaussOrder = 16) {\r\n    if (ps.length === 4) {\r\n        return (0,_length_bez3_js__WEBPACK_IMPORTED_MODULE_2__.lengthBez3)(interval, ps, maxCurviness, gaussOrder);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_length_bez2_js__WEBPACK_IMPORTED_MODULE_1__.lengthBez2)(interval, ps, maxCurviness, gaussOrder);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_length_bez1_js__WEBPACK_IMPORTED_MODULE_0__.lengthBez1)(interval, ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return 0;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/length.js?')},"./node_modules/flo-bezier3/node/global-properties/length/total-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "totalLength": () => (/* binding */ totalLength)\n/* harmony export */ });\n/* harmony import */ var _length_bez1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length-bez1.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez1.js");\n/* harmony import */ var _length_bez2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length-bez2.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez2.js");\n/* harmony import */ var _length_bez3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./length-bez3.js */ "./node_modules/flo-bezier3/node/global-properties/length/length-bez3.js");\n\r\n\r\n\r\n/**\r\n * Returns the curve (a linear, quadratic or cubic bezier curve) length in the\r\n * specified interval calculated using Gaussian Quadrature *with* adaptive\r\n * subdivision for improved accuracy.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n * @param maxCurviness optional maximum \'curviness\' (defined as the total angle\r\n * change between consecutive line segments between the curve control points)\r\n * before subdivision occurs; defaults to 0.4 radians\r\n * @param gaussOrder the optional order of the Gaussian Quadrature performed\r\n * between curve segments; defaults to 16; can be 4,16 or 64\r\n *\r\n * @doc mdx\r\n */\r\nfunction totalLength(ps, maxCurviness = 0.4, gaussOrder = 16) {\r\n    if (ps.length === 4) {\r\n        return (0,_length_bez3_js__WEBPACK_IMPORTED_MODULE_2__.lengthBez3)([0, 1], ps, maxCurviness, gaussOrder);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_length_bez2_js__WEBPACK_IMPORTED_MODULE_1__.lengthBez2)([0, 1], ps, maxCurviness, gaussOrder);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_length_bez1_js__WEBPACK_IMPORTED_MODULE_0__.lengthBez1)([0, 1], ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return 0;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=total-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/length/total-length.js?')},"./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "totalAbsoluteCurvature": () => (/* binding */ totalAbsoluteCurvature),\n/* harmony export */   "totalCurvature": () => (/* binding */ totalCurvature)\n/* harmony export */ });\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../simultaneous-properties/get-interface-rotation.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js");\n/* harmony import */ var _transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-2-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js");\n/* harmony import */ var _transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformation/split/from-to/from-to-3-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js");\n/* harmony import */ var _classification_classify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classification/classify.js */ "./node_modules/flo-bezier3/node/global-properties/classification/classify.js");\n/* harmony import */ var _get_inflections_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-inflections.js */ "./node_modules/flo-bezier3/node/global-properties/get-inflections.js");\n\r\n\r\n\r\n\r\n\r\nconst { abs, PI: 𝜋 } = Math;\r\n/**\r\n * Returns the total absolute curvature of the given bezier curve over the\r\n * given interval\r\n *\r\n * * the result is given in radians.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,6],[7,8]]`\r\n * @param interval\r\n *\r\n * @doc mdx\r\n */\r\nfunction totalAbsoluteCurvature(ps, interval = [0, 1]) {\r\n    if (ps.length <= 3) {\r\n        return abs(totalCurvature(ps, interval));\r\n    }\r\n    if (ps.length === 4) {\r\n        const [tS, tE] = interval;\r\n        if (tS === tE) {\r\n            return 0;\r\n        }\r\n        const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo3InclErrorBound)(ps, tS, tE).ps;\r\n        const ts = [0, ...(0,_get_inflections_js__WEBPACK_IMPORTED_MODULE_4__.getInflections)(ps_), 1];\r\n        let total = 0;\r\n        for (let i = 0; i < ts.length - 1; i++) {\r\n            total += abs(totalCurvature(ps_, [ts[i], ts[i + 1]]));\r\n        }\r\n        return total;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/**\r\n * Returns the total curvature of the bezier over the given interval.\r\n *\r\n * * the result is given in radians.\r\n *\r\n * @param ps a cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param interval the interval of integration (often === [0,1])\r\n *\r\n * @doc mdx\r\n */\r\nfunction totalCurvature(ps, interval = [0, 1]) {\r\n    if (ps.length <= 2) {\r\n        return 0;\r\n    }\r\n    const [tS, tE] = interval;\r\n    if (tS === tE) {\r\n        return 0;\r\n    }\r\n    if (ps.length === 3) {\r\n        const ps_ = (0,_transformation_split_from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2InclErrorBound)(ps, tS, tE).ps;\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps_;\r\n        const tanS = [x1 - x0, y1 - y0];\r\n        const tanE = [x2 - x1, y2 - y1];\r\n        // guaranteed: |θ| <= 𝜋, curvature = θ\r\n        return (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(tanS, tanE);\r\n    }\r\n    if (ps.length === 4) {\r\n        // guaranteed: curvature <= 2𝜋\r\n        const ps_ = (0,_transformation_split_from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo3InclErrorBound)(ps, tS, tE).ps;\r\n        const bezClass = (0,_classification_classify_js__WEBPACK_IMPORTED_MODULE_3__.classify)(ps_);\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps_;\r\n        const tanS = [x1 - x0, y1 - y0];\r\n        const tanM = [x2 - x1, y2 - y1];\r\n        const tanE = [x3 - x2, y3 - y2];\r\n        if ((tanM[0] === 0 && tanM[1] === 0) ||\r\n            bezClass.realOrder <= 2) {\r\n            return (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(tanS, tanE);\r\n        }\r\n        const cpθ = (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(tanS, tanM) +\r\n            (0,_simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_0__.getInterfaceRotation)(tanM, tanE);\r\n        if (bezClass.nodeType === \'acnode\' ||\r\n            bezClass.nodeType === \'cusp\') {\r\n            return cpθ <= -𝜋\r\n                ? cpθ + 2 * 𝜋\r\n                : cpθ >= +𝜋\r\n                    ? cpθ - 2 * 𝜋\r\n                    : cpθ;\r\n        }\r\n        return cpθ;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=total-absolute-curvature.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm1DdWithRunningError": () => (/* binding */ getImplicitForm1DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a double-double precision implicit form of the given line segment\r\n * and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a line segment given as an array of its control points,\r\n * e.g. `[[1,2],[3,4]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1DdWithRunningError(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis1DdWithRunningError)(ps);\r\n    const vₓ = eno(b1); // exact\r\n    const vᵧ = a1; // exact\r\n    //const v = a1*b0 - a0*b1;\r\n    const a1b0 = qmd(b0, a1);\r\n    const _a1b0_ = abs(a1b0[1]);\r\n    const a0b1 = qmd(a0, b1);\r\n    const _a0b1_ = abs(a0b1[1]);\r\n    const v = qdq(a0b1, a1b0);\r\n    const v_ = _a1b0_ + _a0b1_ + abs(v[1]);\r\n    return {\r\n        coeffs: { vₓ, vᵧ, v },\r\n        errorBound: { v_ } // vₓ_, vᵧ_ === 0\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-dd-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm1Dd": () => (/* binding */ getImplicitForm1Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf;\r\n/**\r\n * Returns a double-double precision implicit form of the given\r\n * linear bezier curve.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are performed in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a line segment given as an array of its control points,\r\n * e.g. `[[1,2],[3,4]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1Dd(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Dd)(ps);\r\n    const vₓ = qno(b1); // exact\r\n    const vᵧ = a1; // exact\r\n    //const v = a0*b1 - a1*b0;\r\n    const v = qdq(qmd(a0, b1), qmd(b0, a1));\r\n    return { vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm2DdWithRunningError": () => (/* binding */ getImplicitForm2DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a double-double precision implicit form of the given quadratic\r\n * bezier curve and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2DdWithRunningError(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const { coeffs: [[a2, a1, [, a0]], [b2, b1, [, b0]]], errorBound: [[a2_], [b2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2DdWithRunningError)(ps);\r\n    const $a2 = a2[1];\r\n    const $a1 = a1[1];\r\n    const $b2 = b2[1];\r\n    const $b1 = b1[1];\r\n    const _a0 = abs(a0);\r\n    const _a1 = abs($a1);\r\n    const _a2 = abs($a2);\r\n    const _b0 = abs(b0);\r\n    const _b1 = abs($b1);\r\n    const _b2 = abs($b2);\r\n    const a2b1 = qmq(a2, b1);\r\n    const a2b1_ = a2_ * _b1 + 2 * abs($a2 * $b1);\r\n    const a1b2 = qmq(a1, b2);\r\n    const a1b2_ = _a1 * b2_ + 2 * abs($a1 * $b2);\r\n    const a2b0 = qmd(b0, a2);\r\n    const a2b0_ = _b0 * a2_ + abs(b0 * $a2);\r\n    const a0b2 = qmd(a0, b2);\r\n    const a0b2_ = _a0 * b2_ + abs(a0 * $b2);\r\n    const a1b0 = qmd(b0, a1);\r\n    const a1b0_ = abs(b0 * $a1);\r\n    const a0b1 = qmd(a0, b1);\r\n    const a0b1_ = abs(a0 * $b1);\r\n    const a2a2 = qmq(a2, a2);\r\n    const a2a2_ = 2 * (a2_ * _a2 + abs($a2 * $a2));\r\n    const a2b2 = qmq(a2, b2);\r\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2 * $b2);\r\n    const b2b2 = qmq(b2, b2);\r\n    const b2b2_ = 2 * (b2_ * _b2 + abs($b2 * $b2));\r\n    const $a2b1 = $a2 * $b1;\r\n    const $a1b2 = $a1 * $b2;\r\n    const $a2b0 = $a2 * b0;\r\n    const $a0b2 = a0 * $b2;\r\n    const $a1b0 = $a1 * b0;\r\n    const $a0b1 = a0 * $b1;\r\n    const $q1 = $a2b1 - $a1b2;\r\n    const $q2 = $a2b0 - $a0b2;\r\n    const $q3 = $a1b0 - $a0b1;\r\n    const q1 = qdq(a2b1, a1b2);\r\n    const _q1 = abs($q1);\r\n    const q1_ = a2b1_ + a1b2_ + abs($q1);\r\n    const q2 = qdq(a2b0, a0b2);\r\n    const _q2 = abs($q2);\r\n    const q2_ = a2b0_ + a0b2_ + abs($q2);\r\n    const q3 = qdq(a1b0, a0b1);\r\n    const _q3 = abs($q3);\r\n    const q3_ = a1b0_ + a0b1_ + abs($q3);\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // -------------\r\n    // b2**2 *x**2\r\n    // -b2**2 *x**2\r\n    // -------------\r\n    const vₓₓ = qno(b2b2);\r\n    const vₓₓ_ = b2b2_;\r\n    // -------------\r\n    // -2*a2*b2 *x*y\r\n    // 2*a2*b2 *x*y\r\n    // -------------\r\n    const vₓᵧ = qm2(a2b2);\r\n    const vₓᵧ_ = a2b2_;\r\n    // -------------\r\n    // a2**2 *y**2 \r\n    // -a2**2 *y**2 \r\n    // -------------\r\n    const vᵧᵧ = qno(a2a2);\r\n    const vᵧᵧ_ = a2a2_;\r\n    // -----------------------------------------------\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //const vₓ = b1*q1 - 2*b2*q2;\r\n    // -----------------------------------------------\r\n    const $w1 = $b1 * $q1;\r\n    const w1 = qmq(b1, q1);\r\n    const w1_ = _b1 * q1_ + 2 * abs($w1);\r\n    const $w2 = 2 * $q2 * $b2;\r\n    const w2 = qm2(qmq(b2, q2));\r\n    const w2_ = 2 * (b2_ * _q2 + _b2 * q2_ + 2 * abs($w2));\r\n    const $vₓ = $w1 - $w2;\r\n    const vₓ = qdq(w1, w2);\r\n    const vₓ_ = w1_ + w2_ + abs($vₓ);\r\n    // -----------------------------------------------\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    // -----------------------------------------------\r\n    const $w3 = 2 * $a2 * $q2;\r\n    const w3 = qm2(qmq(a2, q2));\r\n    const w3_ = 2 * (a2_ * _q2 + _a2 * q2_ + 2 * abs($w3));\r\n    const $w4 = $a1 * $q1;\r\n    const w4 = qmq(a1, q1);\r\n    const w4_ = _a1 * q1_ + 2 * abs($w4);\r\n    const $vᵧ = $w3 - $w4;\r\n    const vᵧ = qdq(w3, w4);\r\n    const vᵧ_ = w3_ + w4_ + abs($vᵧ);\r\n    // --------------------------------------------------------------------------------------------------\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    // --------------------------------------------------------------------------------------------------\r\n    const $w5 = $q1 * $q3;\r\n    const w5 = qmq(q1, q3);\r\n    const w5_ = q1_ * _q3 + _q1 * q3_ + 2 * abs($w5);\r\n    const $w6 = $q2 * $q2;\r\n    const w6 = qmq(q2, q2);\r\n    const w6_ = 2 * (q2_ * _q2 + abs($w6));\r\n    const $v = $w5 - $w6;\r\n    const v = qdq(w5, w6);\r\n    const v_ = w5_ + w6_ + abs($v);\r\n    return {\r\n        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-dd-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm2Dd": () => (/* binding */ getImplicitForm2Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n\r\n\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\n/**\r\n * Returns a double-double precision implicit form of the given quadratic\r\n * bezier curve and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2Dd(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a2, a1, [, a0]], [b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Dd)(ps);\r\n    const q1 = qdq(qmq(a2, b1), qmq(a1, b2));\r\n    const q2 = qdq(qmd(b0, a2), qmd(a0, b2));\r\n    const q3 = qdq(qmd(b0, a1), qmd(a0, b1));\r\n    //----------------------------------------------------------------------------------------------------\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    //----------------------------------------------------------------------------------------------------\r\n    // -------------\r\n    // -b2**2\r\n    // -------------\r\n    const vₓₓ = qno(qmq(b2, b2));\r\n    // -------------\r\n    // 2*a2*b2\r\n    // -------------\r\n    const vₓᵧ = qm2(qmq(a2, b2));\r\n    // -------------\r\n    // -a2**2\r\n    // -------------\r\n    const vᵧᵧ = qno(qmq(a2, a2));\r\n    // -----------------------------------------------\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // b1*q1 - 2*b2*q2\r\n    // -----------------------------------------------\r\n    const vₓ = qdq(qmq(b1, q1), qm2(qmq(b2, q2)));\r\n    // -----------------------------------------------\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // 2*a2*q2 - a1*q1\r\n    // -----------------------------------------------\r\n    const vᵧ = qdq(qm2(qmq(a2, q2)), qmq(a1, q1));\r\n    // --------------------------------------------------------------------------------------------------\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 - q2**2\r\n    // --------------------------------------------------------------------------------------------------\r\n    const v = qdq(qmq(q1, q3), qmq(q2, q2));\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm3DdWithRunningError": () => (/* binding */ getImplicitForm3DdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\nconst abs = Math.abs;\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\nconst qd2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd; // error -> 3*γ²\r\n/**\r\n * Returns a double-double precision implicit form of the given cubic\r\n * bezier curve curve and a coefficientwise error bound.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u) === 3.697785493223493e-32`,\r\n * where `u === Number.EPSILON / 2` before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3DdWithRunningError(ps) {\r\n    // Takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    //--------------------------------------------------------------------------\r\n    // `var` -> a variable\r\n    // `$var` -> the double precision approximation to `var`\r\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\r\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\r\n    // `_var_` -> means both absolute value and absolute error bound\r\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\r\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\r\n    // * the returned errors need to be multiplied by 3γ² to get the true error\r\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\r\n    //   due to multiplication by 3*γ² and not 3*u²\r\n    //--------------------------------------------------------------------------\r\n    // examples:\r\n    // ----------------\r\n    // let qmd === ddMultDouble2, etc.\r\n    //\r\n    // ---------------\r\n    // 1. double-double X by double\r\n    // ---------------\r\n    // qmd(a,b);  // both `a` and `b` is error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + |a*b|\r\n    //                           === |a*b|\r\n    //\r\n    // ---------------\r\n    // 2a. double-double +/- double-double\r\n    // ---------------\r\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === _a_ + _b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 2b. double-double +/- double-double\r\n    // ---------------\r\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 2*_a + 2*_b + |a+b|\r\n    //                           === 2*(_a + _b) + |a+b| OR\r\n    //                           === a_ + b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 3a. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + 2|a*b|\r\n    //                           === 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` not error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //                           === a_|b| + 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 4a. double-double +/- double\r\n    // ---------------\r\n    // qad(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 0 + 0 + |a+b|\r\n    //                           === |a+b| \r\n    //--------------------------------------------------------------------------\r\n    const { coeffs: [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]], errorBound: [[a3_, a2_, a1_], [b3_, b2_, b1_]] // a0, b0 - error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3DdWithRunningError)(ps);\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const $a1 = a1[1];\r\n    const $a2 = a2[1];\r\n    const $a3 = a3[1];\r\n    const $b1 = b1[1];\r\n    const $b2 = b2[1];\r\n    const $b3 = b3[1];\r\n    const _a0 = abs(a0);\r\n    const _a1 = abs($a1);\r\n    const _a2 = abs($a2);\r\n    const _a3 = abs($a3);\r\n    const _b0 = abs(b0);\r\n    const _b1 = abs($b1);\r\n    const _b2 = abs($b2);\r\n    const _b3 = abs($b3);\r\n    const a3b1 = qmq(a3, b1);\r\n    const $a3b1 = $a3 * $b1;\r\n    const a3b1_ = a3_ * _b1 + _a3 * b1_ + 2 * abs($a3b1);\r\n    const a1b3 = qmq(a1, b3);\r\n    const $a1b3 = $a1 * $b3;\r\n    const a1b3_ = a1_ * _b3 + _a1 * b3_ + 2 * abs($a1b3);\r\n    const a3b2 = qmq(a3, b2);\r\n    const $a3b2 = $a3 * $b2;\r\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + 2 * abs($a3b2);\r\n    const a2b2 = qmq(a2, b2);\r\n    const $a2b2 = $a2 * $b2;\r\n    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * abs($a2b2);\r\n    const a2b3 = qmq(a2, b3);\r\n    const $a2b3 = $a2 * $b3;\r\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + 2 * abs($a2b3);\r\n    const a3a3 = qmq(a3, a3);\r\n    const $a3a3 = $a3 * $a3;\r\n    const _a3a3 = abs($a3a3);\r\n    const a3a3_ = a3_ * _a3 + _a3 * a3_ + 2 * abs($a3a3);\r\n    const b2b2 = qmq(b2, b2);\r\n    const $b2b2 = $b2 * $b2;\r\n    const b2b2_ = b2_ * _b2 + _b2 * b2_ + 2 * abs($b2b2);\r\n    const b3b3 = qmq(b3, b3);\r\n    const $b3b3 = $b3 * $b3;\r\n    const _b3b3 = abs($b3b3);\r\n    const b3b3_ = b3_ * _b3 + _b3 * b3_ + 2 * abs($b3b3);\r\n    const a1a3 = qmq(a1, a3);\r\n    const $a1a3 = $a1 * $a3;\r\n    const a1a3_ = a1_ * _a3 + _a1 * a3_ + 2 * abs($a1a3);\r\n    const a2a2 = qmq(a2, a2);\r\n    const $a2a2 = $a2 * $a2;\r\n    const a2a2_ = a2_ * _a2 + _a2 * a2_ + 2 * abs($a2a2);\r\n    const b1b3 = qmq(b1, b3);\r\n    const $b1b3 = $b1 * $b3;\r\n    const b1b3_ = b1_ * _b3 + _b1 * b3_ + 2 * abs($b1b3);\r\n    const b2b3 = qmq(b2, b3);\r\n    const _b2b3 = abs($b2 * $b3); // or equivalently `_b2b3 = _b2*_b3`;\r\n    const b2b3_ = b2_ * _b3 + _b2 * b3_ + 2 * _b2b3;\r\n    const a2a3 = qmq(a2, a3);\r\n    const _a2a3 = abs($a2 * $a3);\r\n    const a2a3_ = a2_ * _a3 + _a2 * a3_ + 2 * _a2a3;\r\n    const a3b3 = qmq(a3, b3);\r\n    const _a3b3 = abs($a3 * $b3);\r\n    const a3b3_ = a3_ * _b3 + _a3 * b3_ + 2 * _a3b3;\r\n    const a3b0 = qmd(b0, a3);\r\n    const $a3b0 = $a3 * b0;\r\n    const a3b0_ = a3_ * _b0 + abs($a3b0);\r\n    const a0b3 = qmd(a0, b3);\r\n    const $a0b3 = a0 * $b3;\r\n    const a0b3_ = _a0 * b3_ + abs($a0b3);\r\n    const a2b0 = qmd(b0, a2);\r\n    const $a2b0 = $a2 * b0;\r\n    const a2b0_ = a2_ * _b0 + abs($a2b0);\r\n    const a0b2 = qmd(a0, b2);\r\n    const $a0b2 = a0 * $b2;\r\n    const a0b2_ = _a0 * b2_ + abs($a0b2);\r\n    const a2b1 = qmq(a2, b1);\r\n    const $a2b1 = $a2 * $b1;\r\n    const a2b1_ = a2_ * _b1 + _a2 * b1_ + 2 * abs($a2b1);\r\n    const a1b2 = qmq(a1, b2);\r\n    const $a1b2 = $a1 * $b2;\r\n    const a1b2_ = a1_ * _b2 + _a1 * b2_ + 2 * abs($a1b2);\r\n    const a1b0 = qmd(b0, a1);\r\n    const $a1b0 = $a1 * b0;\r\n    const a1b0_ = a1_ * _b0 + abs($a1b0);\r\n    const a0b1 = qmd(a0, b1);\r\n    const $a0b1 = a0 * $b1;\r\n    const a0b1_ = _a0 * b1_ + abs($a0b1);\r\n    const q1 = qdq(a3b0, a0b3);\r\n    const q1_ = a3b0_ + a0b3_ + abs($a3b0 - $a0b3);\r\n    const q2 = qdq(a3b1, a1b3);\r\n    const q2_ = a3b1_ + a1b3_ + abs($a3b1 - $a1b3);\r\n    const q3 = qdq(a3b2, a2b3);\r\n    const q3_ = a3b2_ + a2b3_ + abs($a3b2 - $a2b3);\r\n    const q4 = qdq(a2b0, a0b2);\r\n    const q4_ = a2b0_ + a0b2_ + abs($a2b0 - $a0b2);\r\n    const q5 = qdq(a2b1, a1b2);\r\n    const q5_ = a2b1_ + a1b2_ + abs($a2b1 - $a1b2);\r\n    const q6 = qdq(a1b0, a0b1);\r\n    const q6_ = a1b0_ + a0b1_ + abs($a1b0 - $a0b1);\r\n    const _t1 = abs($b1b3 - $b2b2);\r\n    const t1 = qdq(b1b3, b2b2);\r\n    const t1_ = b1b3_ + b2b2_ + _t1;\r\n    const _t2 = abs($a1a3 - $a2a2);\r\n    const t2 = qdq(a1a3, a2a2);\r\n    const t2_ = a1a3_ + a2a2_ + abs($a1a3 - $a2a2);\r\n    const _p1 = abs($a2b3 + $a3b2);\r\n    const p1 = qaq(a2b3, a3b2);\r\n    const p1_ = a2b3_ + a3b2_ + abs($a2b3 + $a3b2);\r\n    const $p2 = $a1b3 + $a3b1;\r\n    const _p2 = abs($p2);\r\n    const p2 = qaq(a1b3, a3b1);\r\n    const p2_ = a1b3_ + a3b1_ + _p2;\r\n    const tq2 = qm2(q2);\r\n    const tq2_ = 2 * q2_;\r\n    const $q1 = $a3b0 - $a0b3;\r\n    const $q2 = $a3b1 - $a1b3;\r\n    const $q3 = $a3b2 - $a2b3;\r\n    const $q4 = $a2b0 - $a0b2;\r\n    const $q5 = $a2b1 - $a1b2;\r\n    const $q6 = $a1b0 - $a0b1;\r\n    const _q1 = abs($q1);\r\n    const _q2 = abs($q2);\r\n    const _q3 = abs($q3);\r\n    const _q4 = abs($q4);\r\n    const _q5 = abs($q5);\r\n    const _q6 = abs($q6);\r\n    const _tq2 = 2 * _q2;\r\n    const q1q1 = qmq(q1, q1);\r\n    const q1q2 = qmq(q1, q2);\r\n    const q1q3 = qmq(q1, q3);\r\n    const q1q5 = qmq(q1, q5);\r\n    const q2q2 = qmq(q2, q2);\r\n    const tq2q4 = qmq(tq2, q4);\r\n    const q3q4 = qmq(q3, q4);\r\n    const q3q5 = qmq(q3, q5);\r\n    const q3q6 = qmq(q3, q6);\r\n    const q1q1_ = q1_ * _q1 + _q1 * q1_ + 2 * abs(q1q1[1]);\r\n    const q1q2_ = q1_ * _q2 + _q1 * q2_ + 2 * abs(q1q2[1]);\r\n    const q1q3_ = q1_ * _q3 + _q1 * q3_ + 2 * abs(q1q3[1]);\r\n    const q1q5_ = q1_ * _q5 + _q1 * q5_ + 2 * abs(q1q5[1]);\r\n    const q2q2_ = q2_ * _q2 + _q2 * q2_ + 2 * abs(q2q2[1]);\r\n    const tq2q4_ = tq2_ * _q4 + _tq2 * q4_ + 2 * abs(tq2q4[1]);\r\n    const q3q4_ = q3_ * _q4 + _q3 * q4_ + 2 * abs(q3q4[1]);\r\n    const q3q5_ = q3_ * _q5 + _q3 * q5_ + 2 * abs(q3q5[1]);\r\n    const q3q6_ = q3_ * _q6 + _q3 * q6_ + 2 * abs(q3q4[1]);\r\n    const vₓₓₓ = qmq(qno(b3), b3b3);\r\n    const vₓₓₓ_ = b3_ * _b3b3 + _b3 * b3b3_ + 2 * abs(vₓₓₓ[1]);\r\n    const _z1 = 3 * _a3;\r\n    const z1 = qmd(3, a3);\r\n    const z1_ = 3 * a3_ + _z1;\r\n    const vₓₓᵧ = qmq(z1, b3b3);\r\n    const vₓₓᵧ_ = z1_ * _b3b3 + _z1 * b3b3_ + 2 * abs(vₓₓᵧ[1]);\r\n    const _z2 = 3 * _b3;\r\n    const z2 = qmd(-3, b3);\r\n    const z2_ = 3 * b3_ + _z2;\r\n    const vₓᵧᵧ = qmq(z2, a3a3);\r\n    const vₓᵧᵧ_ = z2_ * _a3a3 + _z2 * a3a3_ + 2 * abs(vₓᵧᵧ[1]);\r\n    const vᵧᵧᵧ = qmq(a3, a3a3);\r\n    const vᵧᵧᵧ_ = a3_ * _a3a3 + _a3 * a3a3_ + 2 * abs(vᵧᵧᵧ[1]);\r\n    const $z3 = -3 * $q1;\r\n    const _z3 = 3 * _q1;\r\n    const z3 = qmd(-3, q1);\r\n    const z3_ = 3 * q1_ + _z3;\r\n    const u1 = qdq(z3, q5);\r\n    const _u1 = abs($z3 - $q5);\r\n    const u1_ = z3_ + q5_ + _u1;\r\n    //const t1_ = _b1b3 + _b2b2 + _t1;\r\n    //const _t2 = abs(t2);\r\n    //const t2_ = _a1a3 + _a2a2 + abs(t2);\r\n    const w1 = qmq(u1, b3b3);\r\n    const w1_ = u1_ * _b3b3 + _u1 * b3b3_ + 2 * abs(w1[1]);\r\n    const w2 = qmq(q3, t1);\r\n    const w2_ = q3_ * _t1 + _q3 * t1_ + 2 * abs(w2[1]);\r\n    const w3 = qaq(w1, w2);\r\n    const w3_ = w1_ + w2_ + abs(w3[1]);\r\n    const w4 = qmq(tq2, b2b3);\r\n    const w4_ = tq2_ * _b2b3 + _tq2 * b2b3_ + 2 * abs(w4[1]);\r\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    const vₓₓ = qaq(w3, w4);\r\n    const vₓₓ_ = w3_ + w4_ + abs(vₓₓ[1]);\r\n    const w5 = qmq(u1, a3a3);\r\n    const w5_ = u1_ * _a3a3 + _u1 * a3a3_ + 2 * abs(w5[1]);\r\n    const w6 = qmq(q3, t2);\r\n    const w6_ = q3_ * _t2 + _q3 * t2_ + 2 * abs(w6[1]);\r\n    const w7 = qaq(w5, w6);\r\n    const w7_ = w5_ + w6_ + abs(w7[1]);\r\n    const w8 = qmq(tq2, a2a3);\r\n    const w8_ = tq2_ * _a2a3 + _tq2 * a2a3_ + 2 * abs(w8[1]);\r\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    const vᵧᵧ = qaq(w7, w8);\r\n    const vᵧᵧ_ = w7_ + w8_ + abs(vᵧᵧ[1]);\r\n    const _wa = abs($a2b2 - $p2 / 2);\r\n    const wa = qdq(a2b2, qd2(p2));\r\n    const wa_ = a2b2_ + p2_ / 2 + abs(wa[1]);\r\n    const wb = qmq(u1, a3b3);\r\n    const wb_ = u1_ * _a3b3 + _u1 * a3b3_ + 2 * abs(wb[1]);\r\n    const wc = qmq(q2, p1);\r\n    const wc_ = q2_ * _p1 + _q2 * p1_ + 2 * abs(wc[1]);\r\n    const wd = qaq(wb, wc);\r\n    const wd_ = wb_ + wc_ + abs(wd[1]);\r\n    const wq = qmq(q3, wa);\r\n    const wq_ = q3_ * _wa + _q3 * wa_ + 2 * abs(wq[1]);\r\n    //-------------------------------------------------------\r\n    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    //-------------------------------------------------------\r\n    const vₓᵧ = qm2(qdq(wq, wd));\r\n    const vₓᵧ_ = 2 * (wq_ + wd_) + abs(vₓᵧ[1]);\r\n    const wr = qmd(-3, q1q1);\r\n    const wr_ = 3 * q1q1_ + abs(wr[1]);\r\n    const we = qdq(wr, qm2(q1q5));\r\n    const we_ = wr_ + 2 * q1q5_ + abs(we[1]);\r\n    const wf = qaq(tq2q4, q3q6);\r\n    const wf_ = tq2q4_ + q3q6_ + abs(wf[1]);\r\n    //------------------------------------------------\r\n    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    //------------------------------------------------\r\n    const s1 = qaq(we, wf);\r\n    const _s1 = abs(s1[1]);\r\n    const s1_ = we_ + wf_ + _s1;\r\n    //-----------------------------\r\n    // const s2 = 2*(q1q2 - q3q4);\r\n    //-----------------------------\r\n    const s2 = qm2(qdq(q1q2, q3q4));\r\n    const _s2 = abs(s2[1]);\r\n    const s2_ = 2 * (q1q2_ + q3q4_) + _s2;\r\n    const wl = qdq(q1q3, q2q2);\r\n    const wl_ = q1q3_ + q2q2_ + abs(wl[1]);\r\n    //-------------------------------\r\n    // const s3 = q1q3 - q2q2 + q3q5;\r\n    //-------------------------------\r\n    const s3 = qaq(wl, q3q5);\r\n    const _s3 = abs(s3[1]);\r\n    const s3_ = wl_ + q3q5_ + _s3;\r\n    const wm = qmq(b3, s1);\r\n    const wm_ = b3_ * _s1 + _b3 * s1_ + 2 * abs(wm[1]);\r\n    const ws = qmq(b2, s2);\r\n    const ws_ = b2_ * _s2 + _b2 * s2_ + 2 * abs(ws[1]);\r\n    const wt = qmq(b1, s3);\r\n    const wt_ = b1_ * _s3 + _b1 * s3_ + 2 * abs(wt[1]);\r\n    const wn = qaq(ws, wt);\r\n    const wn_ = ws_ + wt_ + abs(wn[1]);\r\n    //-------------------------------\r\n    // const vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    //-------------------------------\r\n    const vₓ = qaq(wm, wn);\r\n    const vₓ_ = wm_ + wn_ + abs(vₓ[1]);\r\n    const wo = qmq(a3, s1);\r\n    const wo_ = a3_ * _s1 + _a3 * s1_ + 2 * abs(wo[1]);\r\n    const wu = qmq(a2, s2);\r\n    const wu_ = a2_ * _s2 + _a2 * s2_ + 2 * abs(wu[1]);\r\n    const wv = qmq(a1, s3);\r\n    const wv_ = a1_ * _s3 + _a1 * s3_ + 2 * abs(wv[1]);\r\n    const wp = qaq(wu, wv);\r\n    const wp_ = wu_ + wv_ + abs(wp[1]);\r\n    //-------------------------------------\r\n    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    //-------------------------------------\r\n    const vᵧ = qno(qaq(wo, wp));\r\n    const vᵧ_ = wo_ + wp_ + abs(vᵧ[1]);\r\n    // the commented part above is re\r\n    const v3 = qdq(tq2q4, q1q1);\r\n    const v1 = qdq(v3, q1q5);\r\n    const _v1 = abs(v1[1]);\r\n    const v4 = qmq(s3, q6);\r\n    const v5 = qmq(q3q4, q4);\r\n    const v2 = qdq(v4, v5);\r\n    const v2_ = s3_ * abs(q6[1]) + 2 * abs(v4[1]) + q3q4_ * abs(q4[1]) + 2 * abs(v5[1]) + abs(v2[1]);\r\n    const v6 = qmq(q1, v1);\r\n    const v6_ = q1_ * _v1 + _q1 * tq2q4_ + q1q1_ + abs(v3[1]) + q1q5_ + _v1 + 2 * abs(v6[1]);\r\n    // -------------------------------------------------------------------------\r\n    //-------------------------------------------------------\r\n    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    //-------------------------------------------------------\r\n    const v = qaq(v6, v2);\r\n    const v_ = v6_ + v2_ + abs(v[1]);\r\n    return {\r\n        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },\r\n        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-dd-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js?')},"./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm3Dd": () => (/* binding */ getImplicitForm3Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n\r\n\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_0__.ddNegativeOf; // error -> 0\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2; // error -> 0 \r\nconst qd2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivBy2; // error -> 0 \r\n//const qmd2 = qMultDouble1;  // error -> 1.5*γ²\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*γ²\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd; // error -> 3*γ²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd; // error -> 3*γ²\r\n/**\r\n * Returns a double-double precision implicit form of the given cubic bezier\r\n * curve.\r\n *\r\n * Returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n *\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3Dd(ps) {\r\n    // Takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Dd)(ps);\r\n    const a3b1 = qmq(a3, b1);\r\n    const a1b3 = qmq(a1, b3);\r\n    const a3b2 = qmq(a3, b2);\r\n    const a2b3 = qmq(a2, b3);\r\n    const a3a3 = qmq(a3, a3);\r\n    const b3b3 = qmq(b3, b3);\r\n    const q1 = qdq(qmd(b0, a3), qmd(a0, b3));\r\n    const q2 = qdq(a3b1, a1b3);\r\n    const q3 = qdq(a3b2, a2b3);\r\n    const q4 = qdq(qmd(b0, a2), qmd(a0, b2));\r\n    const q5 = qdq(qmq(a2, b1), qmq(a1, b2));\r\n    const q6 = qdq(qmd(b0, a1), qmd(a0, b1));\r\n    const tq2 = qm2(q2);\r\n    const q1q1 = qmq(q1, q1);\r\n    const q1q5 = qmq(q1, q5);\r\n    const tq2q4 = qmq(tq2, q4);\r\n    const q3q4 = qmq(q3, q4);\r\n    const u1 = qdq(qmd(-3, q1), q5);\r\n    const vₓₓₓ = qmq(qno(b3), b3b3);\r\n    const vₓₓᵧ = qmq(qmd(3, a3), b3b3);\r\n    const vₓᵧᵧ = qmq(qmd(-3, b3), a3a3);\r\n    const vᵧᵧᵧ = qmq(a3, a3a3);\r\n    const vₓₓ = qaq(qaq(qmq(u1, b3b3), qmq(q3, qdq(qmq(b1, b3), qmq(b2, b2)))), qmq(tq2, qmq(b2, b3)));\r\n    const vᵧᵧ = qaq(qaq(qmq(u1, a3a3), qmq(q3, qdq(qmq(a1, a3), qmq(a2, a2)))), qmq(tq2, qmq(a2, a3)));\r\n    //-------------------------------------------------------\r\n    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    //-------------------------------------------------------\r\n    const vₓᵧ = qm2(qdq(qmq(q3, qdq(qmq(a2, b2), qd2(qaq(a1b3, a3b1)))), qaq(qmq(u1, qmq(a3, b3)), qmq(q2, qaq(a2b3, a3b2)))));\r\n    //------------------------------------------------\r\n    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    //------------------------------------------------\r\n    const s1 = qaq(qdq(qmd(-3, q1q1), qm2(q1q5)), qaq(tq2q4, qmq(q3, q6)));\r\n    //-----------------------------\r\n    // const s2 = 2*(q1q2 - q3q4);\r\n    //-----------------------------\r\n    const s2 = qm2(qdq(qmq(q1, q2), q3q4));\r\n    //-------------------------------\r\n    // const s3 = q1q3 - q2q2 + q3q5;\r\n    //-------------------------------\r\n    const s3 = qaq(qdq(qmq(q1, q3), qmq(q2, q2)), qmq(q3, q5));\r\n    //-------------------------------\r\n    // const vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    //-------------------------------\r\n    const vₓ = qaq(qmq(b3, s1), qaq(qmq(b2, s2), qmq(b1, s3)));\r\n    //-------------------------------------\r\n    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    //-------------------------------------\r\n    const vᵧ = qno(qaq(qmq(a3, s1), qaq(qmq(a2, s2), qmq(a1, s3))));\r\n    //-------------------------------------------------------\r\n    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    //-------------------------------------------------------\r\n    const v = qaq(qmq(q1, qdq(qdq(tq2q4, q1q1), q1q5)), qdq(qmq(s3, q6), qmq(q3q4, q4)));\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js?')},"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm1": () => (/* binding */ getImplicitForm1)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n\r\n/**\r\n * Returns the implicit form of the given linear bezier curve, i.e. line\r\n * segment.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in **double** precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a line segment given as an array of its control points,\r\n * e.g. `[[1,2],[3,4]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    const [[a1, a0], [b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1)(ps);\r\n    const vₓ = -b1;\r\n    const vᵧ = a1;\r\n    const v = a0 * b1 - a1 * b0;\r\n    return { vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js?')},"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm2": () => (/* binding */ getImplicitForm2)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n\r\n/**\r\n * Returns the implicit form of the given quadratic bezier curve.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * intermediate calculations are done in **double** precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a quadratic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a2, a1, a0], [b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2)(ps);\r\n    const q1 = a2 * b1 - a1 * b2;\r\n    const q2 = a2 * b0 - a0 * b2;\r\n    const vₓₓ = -b2 * b2;\r\n    const vₓᵧ = 2 * a2 * b2;\r\n    const vᵧᵧ = -a2 * a2;\r\n    const vₓ = b1 * q1 - 2 * b2 * q2;\r\n    const vᵧ = 2 * a2 * q2 - a1 * q1;\r\n    const v = q1 * (a1 * b0 - a0 * b1) - q2 * q2;\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js?')},"./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm3": () => (/* binding */ getImplicitForm3)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n\r\n/**\r\n * Returns the implicit form of the given cubic bezier curve.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n * * takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79\r\n *\r\n * @param ps a cubic bezier curve given as an array of its control points,\r\n * e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3)(ps);\r\n    const a3b1 = a3 * b1;\r\n    const a1b3 = a1 * b3;\r\n    const a3b2 = a3 * b2;\r\n    const a2b3 = a2 * b3;\r\n    const a3a3 = a3 * a3;\r\n    const b3b3 = b3 * b3;\r\n    const q1 = a3 * b0 - a0 * b3;\r\n    const q2 = a3b1 - a1b3;\r\n    const q3 = a3b2 - a2b3;\r\n    const q4 = a2 * b0 - a0 * b2;\r\n    const q5 = a2 * b1 - a1 * b2;\r\n    const q6 = a1 * b0 - a0 * b1;\r\n    const tq2 = 2 * q2;\r\n    const q1q1 = q1 * q1;\r\n    const q1q5 = q1 * q5;\r\n    const tq2q4 = tq2 * q4;\r\n    const q3q4 = q3 * q4;\r\n    const u1 = -3 * q1 - q5;\r\n    const vₓₓₓ = -b3 * b3b3;\r\n    const vₓₓᵧ = 3 * a3 * b3b3;\r\n    const vₓᵧᵧ = -3 * b3 * a3a3;\r\n    const vᵧᵧᵧ = a3 * a3a3;\r\n    const vₓₓ = (u1 * b3b3 + q3 * (b1 * b3 - b2 * b2)) + tq2 * b2 * b3;\r\n    const vᵧᵧ = (u1 * a3a3 + q3 * (a1 * a3 - a2 * a2)) + tq2 * a2 * a3;\r\n    const vₓᵧ = 2 * (q3 * (a2 * b2 - (a1b3 + a3b1) / 2) - (u1 * a3 * b3 + q2 * (a2b3 + a3b2)));\r\n    const s1 = (-3 * q1q1 - 2 * q1q5) + (tq2q4 + q3 * q6);\r\n    const s2 = 2 * (q1 * q2 - q3q4);\r\n    const s3 = q1 * q3 - q2 * q2 + q3 * q5;\r\n    const vₓ = b3 * s1 + (b2 * s2 + b1 * s3);\r\n    const vᵧ = -a3 * s1 - (a2 * s2 + a1 * s3);\r\n    const v = (q1 * ((tq2q4 - q1q1) - q1q5)) + (s3 * q6 - q3q4 * q4);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js?')},"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateImplicit1": () => (/* binding */ evaluateImplicit1)\n/* harmony export */ });\n/**\r\n * Evaluates and returns the result of evaluating the given implicit function\r\n * (a degree 1 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\r\n *\r\n * * the implicit form is given by: `vₓ*x + vᵧ*y + v`, where the `vₓ`, `vₓ`, `v`,\r\n * etc are constants\r\n *\r\n * @example\r\n * ```typescript\r\n * evaluateImplicit1({ vₓ: 1, vᵧ: 2, v: 3 }, 1, 1);  //=> 6\r\n * ```\r\n *\r\n * @param cs the polynomial to evaluate\r\n * @param x the `x` variable at which to evaluate\r\n * @param y the `y` variable at which to evaluate\r\n *\r\n * @doc\r\n */\r\nfunction evaluateImplicit1(cs, x, y) {\r\n    const { vₓ, vᵧ, v } = cs;\r\n    return vₓ * x + vᵧ * y + v;\r\n}\r\n\r\n//# sourceMappingURL=evaluate-implicit1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js?')},"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateImplicit2": () => (/* binding */ evaluateImplicit2)\n/* harmony export */ });\n/**\r\n * Evaluates and returns the result of evaluating the given implicit function\r\n * (a degree 2 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\r\n *\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`, where the `vₓ`, `vₓ`, `v`,\r\n * etc are constants\r\n *\r\n * @example\r\n * ```typescript\r\n * evaluateImplicit2({ vₓₓ: 4, vₓᵧ: 5, vᵧᵧ: 6, vₓ: 1, vᵧ: 2, v: 3 }, 1, 1);  //=> 21\r\n * ```\r\n *\r\n * @param cs the polynomial to evaluate\r\n * @param x the `x` variable at which to evaluate\r\n * @param y the `y` variable at which to evaluate\r\n *\r\n * @doc\r\n */\r\nfunction evaluateImplicit2(cs, x, y) {\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = cs;\r\n    return vₓₓ * x * x + vₓᵧ * x * y + vᵧᵧ * y * y + vₓ * x + vᵧ * y + v;\r\n}\r\n\r\n//# sourceMappingURL=evaluate-implicit2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js?')},"./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateImplicit3": () => (/* binding */ evaluateImplicit3)\n/* harmony export */ });\n/**\r\n * Evaluates and returns the result of evaluating the given implicit function\r\n * (a degree 3 bivariate polynomial in `x` and `y`) at the point `[x,y]`.\r\n *\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`,\r\n * where the `vₓ`, `vₓ`, `v`, etc are constants\r\n *\r\n * @example\r\n * ```typescript\r\n * evaluateImplicit3({ vₓₓₓ: -1, vₓₓᵧ: -2, vₓᵧᵧ: -3, vᵧᵧᵧ: -4, vₓₓ: 4, vₓᵧ: 5, vᵧᵧ: 6, vₓ: 1, vᵧ: 2, v: 3 }, 7, -4);  //=> 123\r\n * ```\r\n *\r\n * @param cs the polynomial to evaluate\r\n * @param x the `x` variable at which to evaluate\r\n * @param y the `y` variable at which to evaluate\r\n *\r\n * @doc\r\n */\r\nfunction evaluateImplicit3(cs, x, y) {\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = cs;\r\n    return (vₓₓₓ * x * x * x +\r\n        vₓₓᵧ * x * x * y +\r\n        vₓᵧᵧ * x * y * y +\r\n        vᵧᵧᵧ * y * y * y +\r\n        vₓₓ * x * x +\r\n        vₓᵧ * x * y +\r\n        vᵧᵧ * y * y +\r\n        vₓ * x +\r\n        vᵧ * y +\r\n        v);\r\n}\r\n\r\n//# sourceMappingURL=evaluate-implicit3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js?')},"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm1Exact": () => (/* binding */ getImplicitForm1Exact),\n/* harmony export */   "getImplicitForm1ExactPb": () => (/* binding */ getImplicitForm1ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\r\n/**\r\n * Returns the *exact* implicit form of the given linear bezier curve (a line\r\n * segment) or `undefined` if the line degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm1Exact(ps) {\r\n    return getImplicitForm1ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm1Exact]].\r\n *\r\n * @param pspb the power basis representation of a linear bezier curve that\r\n * can be found via [[toPowerBasis1Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm1ExactPb(pspb) {\r\n    const [[a1, [a0]], [b1, [b0]]] = pspb;\r\n    if (eSign(a1) === 0 && eSign(b1) === 0) {\r\n        // the input bezier curve is in fact not linear but has order < 1\r\n        // it is a point and no implicit form is possible\r\n        return undefined;\r\n    }\r\n    const vₓ = eno(b1);\r\n    const vᵧ = a1;\r\n    //const v = a1*b0 - a0*b1;\r\n    const v = edif(sce(a0, b1), sce(b0, a1));\r\n    return { vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js?')},"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm2Exact": () => (/* binding */ getImplicitForm2Exact),\n/* harmony export */   "getImplicitForm2ExactPb": () => (/* binding */ getImplicitForm2ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultBy2;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eDiff;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eNegativeOf;\r\n/**\r\n * Returns the exact implicit form of the given quadratic bezier curve\r\n * or `undefined` if the curve degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm2Exact(ps) {\r\n    return getImplicitForm2ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm2Exact]].\r\n *\r\n * @param pspb the power basis representation of a quadratic bezier curve that\r\n * can be found via [[toPowerBasis2Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm2ExactPb(pspb) {\r\n    const [[a2, a1, [a0]], [b2, b1, [b0]]] = pspb;\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(a2) === 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(b2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm1ExactPb)([[a1, [a0]], [b1, [b0]]]);\r\n    }\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const a2b0 = sce(b0, a2);\r\n    const a0b2 = sce(a0, b2);\r\n    const a1b0 = sce(b0, a1);\r\n    const a0b1 = sce(a0, b1);\r\n    const a2a2 = epr(a2, a2);\r\n    const a2b2 = epr(a2, b2);\r\n    const b2b2 = epr(b2, b2);\r\n    const q1 = edif(a2b1, a1b2);\r\n    const q2 = edif(a2b0, a0b2);\r\n    const q3 = edif(a1b0, a0b1);\r\n    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2\r\n    // b2**2*x**2\r\n    // -b2**2 *x**2\r\n    const vₓₓ = eno(b2b2);\r\n    // -2*a2*b2*x*y\r\n    // 2*a2*b2 *x*y\r\n    const vₓᵧ = em2(a2b2);\r\n    // a2**2*y**2\r\n    // -a2**2 *y**2 \r\n    const vᵧᵧ = eno(a2a2);\r\n    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2\r\n    // (b1*q1 + -2*b2*q2) *x\r\n    //const vₓ = b1*q1 - 2*b2*q2;\r\n    const w1 = epr(b1, q1);\r\n    const w2 = em2(epr(b2, q2));\r\n    const vₓ = edif(w1, w2);\r\n    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0\r\n    // (-a1*q1 + 2*a2*q2) *y\r\n    const w3 = em2(epr(a2, q2));\r\n    const w4 = epr(a1, q1);\r\n    const vᵧ = edif(w3, w4);\r\n    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2\r\n    // q1*q3 + -q2**2\r\n    const w5 = epr(q1, q3);\r\n    const w6 = epr(q2, q2);\r\n    const v = edif(w5, w6);\r\n    //console.log({ vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v })\r\n    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js?')},"./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm3Exact": () => (/* binding */ getImplicitForm3Exact),\n/* harmony export */   "getImplicitForm3ExactPb": () => (/* binding */ getImplicitForm3ExactPb)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiff;\r\nconst eno = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMultBy2;\r\nconst ed2 = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDivBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\r\n/**\r\n * Returns the exact implicit form of the given cubic bezier curve\r\n * or `undefined` if the curve degenerates to a point.\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * returned coefficients are given *exactly* as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps\r\n *\r\n * @doc mdx\r\n */\r\nfunction getImplicitForm3Exact(ps) {\r\n    // Takes about 155 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    return getImplicitForm3ExactPb((0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3Exact)(ps));\r\n}\r\n/**\r\n * The power basis version of [[getImplicitForm3Exact]].\r\n *\r\n * @param pspb the power basis representation of a cubic bezier curve that can\r\n * be found via [[toPowerBasis3Exact]]\r\n *\r\n * @internal\r\n */\r\nfunction getImplicitForm3ExactPb(pspb) {\r\n    const [[a3, a2, a1, [a0]], [b3, b2, b1, [b0]]] = pspb;\r\n    if (eSign(a3) === 0 && eSign(b3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2ExactPb)([[a2, a1, [a0]], [b2, b1, [b0]]]);\r\n    }\r\n    const a3b1 = epr(a3, b1);\r\n    const a1b3 = epr(a1, b3);\r\n    const a3b2 = epr(a3, b2);\r\n    const a2b2 = epr(a2, b2);\r\n    const a2b3 = epr(a2, b3);\r\n    const a3a3 = epr(a3, a3);\r\n    const b2b2 = epr(b2, b2);\r\n    const b3b3 = epr(b3, b3);\r\n    const a1a3 = epr(a1, a3);\r\n    const a2a2 = epr(a2, a2);\r\n    const b1b3 = epr(b1, b3);\r\n    const b2b3 = epr(b2, b3);\r\n    const a2a3 = epr(a2, a3);\r\n    const a3b3 = epr(a3, b3);\r\n    const a3b0 = sce(b0, a3);\r\n    const a0b3 = sce(a0, b3);\r\n    const a2b0 = sce(b0, a2);\r\n    const a0b2 = sce(a0, b2);\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const a1b0 = sce(b0, a1);\r\n    const a0b1 = sce(a0, b1);\r\n    const q1 = edif(a3b0, a0b3);\r\n    const q2 = edif(a3b1, a1b3);\r\n    const q3 = edif(a3b2, a2b3);\r\n    const q4 = edif(a2b0, a0b2);\r\n    const q5 = edif(a2b1, a1b2);\r\n    const q6 = edif(a1b0, a0b1);\r\n    const t1 = edif(b1b3, b2b2);\r\n    const t2 = edif(a1a3, a2a2);\r\n    const p1 = fes(a2b3, a3b2);\r\n    const p2 = fes(a1b3, a3b1);\r\n    const tq2 = em2(q2); // error free\r\n    const q1q1 = epr(q1, q1);\r\n    const q1q2 = epr(q1, q2);\r\n    const q1q3 = epr(q1, q3);\r\n    const q1q5 = epr(q1, q5);\r\n    const q2q2 = epr(q2, q2);\r\n    const tq2q4 = epr(tq2, q4);\r\n    const q3q4 = epr(q3, q4);\r\n    const q3q5 = epr(q3, q5);\r\n    const q3q6 = epr(q3, q6);\r\n    const vₓₓₓ = epr(eno(b3), b3b3);\r\n    const vₓₓᵧ = epr(sce(3, a3), b3b3);\r\n    const vₓᵧᵧ = epr(sce(-3, b3), a3a3);\r\n    const vᵧᵧᵧ = epr(a3, a3a3);\r\n    const u1 = edif(sce(-3, q1), q5);\r\n    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;\r\n    const w1 = epr(u1, b3b3);\r\n    const w2 = epr(q3, t1);\r\n    const w3 = fes(w1, w2);\r\n    const w4 = epr(tq2, b2b3);\r\n    const vₓₓ = fes(w3, w4);\r\n    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;\r\n    const w5 = epr(u1, a3a3);\r\n    const w6 = epr(q3, t2);\r\n    const w7 = fes(w5, w6);\r\n    const w8 = epr(tq2, a2a3);\r\n    const vᵧᵧ = fes(w7, w8);\r\n    //const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));\r\n    const wa = edif(a2b2, ed2(p2));\r\n    const wb = epr(u1, a3b3);\r\n    const wc = epr(q2, p1);\r\n    const wd = fes(wb, wc);\r\n    const wq = epr(q3, wa);\r\n    const vₓᵧ = em2(edif(wq, wd));\r\n    //const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);\r\n    const wr = sce(-3, q1q1);\r\n    const we = edif(wr, em2(q1q5));\r\n    const wf = fes(tq2q4, q3q6);\r\n    const s1 = fes(we, wf);\r\n    //const s2 = 2*(q1q2 - q3q4);\r\n    const s2 = em2(edif(q1q2, q3q4));\r\n    //const s3 = q1q3 - q2q2 + q3q5;\r\n    const wl = edif(q1q3, q2q2);\r\n    const s3 = fes(wl, q3q5);\r\n    //const vₓ = b3*s1 + (b2*s2 + b1*s3);\r\n    const wm = epr(b3, s1);\r\n    const ws = epr(b2, s2);\r\n    const wt = epr(b1, s3);\r\n    const wn = fes(ws, wt);\r\n    const vₓ = fes(wm, wn);\r\n    //const vᵧ = -a3*s1 - (a2*s2 + a1*s3);\r\n    const wo = epr(a3, s1);\r\n    const wu = epr(a2, s2);\r\n    const wv = epr(a1, s3);\r\n    const wp = fes(wu, wv);\r\n    const vᵧ = eno(fes(wo, wp));\r\n    const v3 = edif(tq2q4, q1q1);\r\n    const v1 = edif(v3, q1q5);\r\n    const v4 = epr(s3, q6);\r\n    const v5 = epr(q3q4, q4);\r\n    const v2 = edif(v4, v5);\r\n    const v6 = epr(q1, v1);\r\n    //const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;\r\n    const v = fes(v6, v2);\r\n    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js?')},"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm1ErrorCounters": () => (/* binding */ getImplicitForm1ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js");\n\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the implicit form of the given bezier\r\n * curve (using [[getImplicitForm1]] or [[getImplicitForm1Dd]]).\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓx + vᵧy + v`\r\n * * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\r\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * return {\r\n *      vₓ_,  // <1>\r\n *      vᵧ_,  // <1>\r\n *      v_    // <3>\r\n * }\r\n * ```\r\n *\r\n * @param ps\r\n *\r\n * @doc\r\n */\r\nfunction getImplicitForm1ErrorCounters(ps) {\r\n    // The implicit form is given by:\r\n    // vₓx + vᵧy + v = 0\r\n    //const [[a1, a0], [b1, b0]] = toPowerBasis1ErrorCounters(ps);\r\n    const [a0, b0] = ps[0];\r\n    const [[a1_], // <1>a1\r\n    [b1_] // <1>b1\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1ErrorCounters)(ps);\r\n    // <3>v <-- <3>(<2>(<0>a0*<1>b1) - <2>(<1>a1*<0>b0))\r\n    const v_ = abs(a0) * b1_ + abs(b0) * a1_; // <3>\r\n    return {\r\n        vₓ_: b1_,\r\n        vᵧ_: a1_,\r\n        v_ // <3>\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form1-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js?')},"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm2ErrorCounters": () => (/* binding */ getImplicitForm2ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js");\n\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the implicit form of the given bezier\r\n * curve (using [[getImplicitForm2]] or [[getImplicitForm2Dd]]).\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\r\n * * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\r\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * return {\r\n *      vₓₓ_,  // <5>\r\n *      vₓᵧ_,  // <5>\r\n *      vᵧᵧ_,  // <5>\r\n *      vₓ_,   // <8>\r\n *      vᵧ_,   // <8>\r\n *      v_     // <10>\r\n * }\r\n * ```\r\n *\r\n * @param ps\r\n *\r\n * @doc\r\n */\r\nfunction getImplicitForm2ErrorCounters(ps) {\r\n    // The implicit form is given by:\r\n    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    //const [[,,a0],[,,b0]] = toPowerBasis2ErrorCounters(ps);\r\n    const [a0, b0] = ps[0];\r\n    const [[a2_, a1_], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b2_, b1_] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2ErrorCounters)(ps);\r\n    //-------------------\r\n    // Error calculation\r\n    //-------------------\r\n    const a0_ = abs(a0);\r\n    const b0_ = abs(b0);\r\n    // <5>q1 <-- <5>(<4>(<2>a2*<1>b1) - <4>(a1*b2))\r\n    const q1_ = a2_ * b1_ + a1_ * b2_;\r\n    // <4>q2 <-- <4>(<3>(a2*b0) - <3>(a0*b2))\r\n    const q2_ = a2_ * b0_ + a0_ * b2_;\r\n    // <5>vₓₓ <-- <5>(-<2>b2*<2>b2)\r\n    const vₓₓ_ = b2_ * b2_;\r\n    // <5>vₓᵧ <-- 2*a2*b2\r\n    const vₓᵧ_ = 2 * a2_ * b2_;\r\n    // <5>vᵧᵧ <-- -a2*a2\r\n    const vᵧᵧ_ = a2_ * a2_;\r\n    // <8>vₓ <-- <8>(<7>(<1>b1*<5>q1) - <7>(2*<2>b2*<4>q2))\r\n    const vₓ_ = b1_ * q1_ + 2 * b2_ * q2_;\r\n    // <8>vᵧ <-- <8>(<7>(2*<2>a2<4>q2) - <7>(<1>a1<5>q1))\r\n    const vᵧ_ = 2 * a2_ * q2_ + a1_ * q1_;\r\n    // <10>v <-- <10>(<9>(<5>q1*<3>(<2>(a1*b0) - <2>(a0*b1))) - <9>(<4>q2*<4>q2))\r\n    const v_ = q1_ * (a1_ * b0_ + a0_ * b1_) + q2_ * q2_;\r\n    return {\r\n        vₓₓ_,\r\n        vₓᵧ_,\r\n        vᵧᵧ_,\r\n        vₓ_,\r\n        vᵧ_,\r\n        v_ // <10>\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form2-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js?')},"./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getImplicitForm3ErrorCounters": () => (/* binding */ getImplicitForm3ErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js");\n\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the implicit form of the given bezier\r\n * curve (using [[getImplicitForm1]] or [[getImplicitForm1Dd]]).\r\n *\r\n * * returned coefficients are subscripted to match their monomial\'s variables,\r\n * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`\r\n * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v`\r\n * * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions (provided in this library\r\n * as functions with the same name) with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * errorBound: {\r\n *      vₓₓₓ_,  // <11>\r\n *      vₓₓᵧ_,  // <12>\r\n *      vₓᵧᵧ_,  // <12>\r\n *      vᵧᵧᵧ_,  // <11>\r\n *      vₓₓ_,   // <19>\r\n *      vₓᵧ_,   // <18>\r\n *      vᵧᵧ_,   // <19>\r\n *      vₓ_,    // <22>\r\n *      vᵧ_,    // <22>\r\n *      v_      // <24>\r\n * }\r\n * ```\r\n * @param ps\r\n *\r\n * @doc\r\n */\r\nfunction getImplicitForm3ErrorCounters(ps) {\r\n    // Takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79.\r\n    // The implicit form is given by:\r\n    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0\r\n    //const [[,,,a0],[,,,b0]] = toPowerBasis3ErrorCounters(ps);\r\n    const [a0, b0] = ps[0];\r\n    const [[a3_, a2_, a1_], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b3_, b2_, b1_] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3ErrorCounters)(ps);\r\n    //-------------------\r\n    // Error calculation\r\n    //-------------------\r\n    const a0_ = abs(a0);\r\n    const b0_ = abs(b0);\r\n    // <6>a3b1 <-- <6>(<3>a3*<2>b1);\r\n    const a3b1_ = a3_ * b1_;\r\n    // <6>a1b3 <-- a1*b3;\r\n    const a1b3_ = a1_ * b3_;\r\n    // <7>a3b2 <-- <7>(<3>a3*<3>b2);\r\n    const a3b2_ = a3_ * b2_;\r\n    // <7>a2b3 <-- a2*b3;\r\n    const a2b3_ = a2_ * b3_;\r\n    // <7>a3a3 <-- a3*a3;\r\n    const a3a3_ = a3_ * a3_;\r\n    // <7>b3b3 <-- b3*b3;\r\n    const b3b3_ = b3_ * b3_;\r\n    // <5>q1 <-- <5>(<4>(a3*b0) - <4>(a0*b3));\r\n    const q1_ = a3_ * b0_ + a0_ * b3_;\r\n    // <7>q2 <-- <7>(<6>a3b1 - <6>a1b3);\r\n    const q2_ = a3b1_ + a1b3_;\r\n    // <8>q3 <-- <8>(<7>a3b2 - <7>a2b3);\r\n    const q3_ = a3b2_ + a2b3_;\r\n    // <5>q4 <-- a2*b0 - a0*b2;\r\n    const q4_ = a2_ * b0_ + a0_ * b2_;\r\n    // <7>q5 <-- a2*b1 - a1*b2;\r\n    const q5_ = a2_ * b1_ + a1_ * b2_;\r\n    // <4>q6 <-- <4>(<3>(<2>a1*<0>b0) - <3>(<0>a0*<2>b1));\r\n    const q6_ = a1_ * b0_ + a0_ * b1_;\r\n    // <7>tq2 <-- 2*q2;\r\n    const tq2_ = 2 * q2_;\r\n    // <11>q1q1 <-- <11>(<5>q1*<5>q1)\r\n    const q1q1_ = q1_ * q1_;\r\n    // <13>q1q5 <-- <13>(<5>q1*<7>q5)\r\n    const q1q5_ = q1_ * q5_;\r\n    // <13>tq2q4 <-- <13>(<7>tq2*<5>q4)\r\n    const tq2q4_ = tq2_ * q4_;\r\n    // <14>q3q4 <-- <14>(<8>q3*<5>q4)\r\n    const q3q4_ = q3_ * q4_;\r\n    // <8>u1 <-- <8>(<6>(-3*<5>q1) - <7>q5)\r\n    const u1_ = 3 * q1_ + q5_;\r\n    // <11>vₓₓₓ <-- <11>(-<3>b3*<7>b3b3)\r\n    const vₓₓₓ_ = b3_ * b3b3_;\r\n    // <12>vₓₓᵧ <--  <12>(3*<11>(<3>a3*<7>b3b3))\r\n    const vₓₓᵧ_ = 3 * a3_ * b3b3_;\r\n    // <12>vₓᵧᵧ <-- -3*b3*a3a3\r\n    const vₓᵧᵧ_ = 3 * b3_ * a3a3_;\r\n    // <11>vᵧᵧᵧ <--  a3*a3a3\r\n    const vᵧᵧᵧ_ = a3_ * a3a3_;\r\n    // <19>vₓₓ <-- <19>(<18>(<16>(<8>u1*<7>b3b3) + <17>(<8>q3*(<8>(<6>(b1*b3) - <7>(b2*b2))))) + <15>(<7>tq2*<7>(b2*b3)))\r\n    const vₓₓ_ = (u1_ * b3b3_ + q3_ * (b1_ * b3_ + b2_ * b2_)) + tq2_ * b2_ * b3_;\r\n    // <19>vᵧᵧ <-- <19>((<18>(<16>(<8>u1*<7>a3a3) + <17>(<8>q3*<8>(<6>(a1*a3) - <7>(a2*a2))))) + <15>(<7>tq2*<7>(a2*a3)))\r\n    const vᵧᵧ_ = (u1_ * a3a3_ + q3_ * (a1_ * a3_ + a2_ * a2_)) + tq2_ * a2_ * a3_;\r\n    // <18>vₓᵧ <-- <18>(2*(<17>(<8>q3*<8>(<7>(a2*b2) - <7>(<6>a1b3 + <6>a3b1)/2)) - <17>(<16>(<8>u1*<7>(a3*b3)) + <16>(<7>q2*(<8>(a2b3 + a3b2))))))\r\n    const vₓᵧ_ = 2 * (q3_ * (a2_ * b2_ + (a1b3_ + a3b1_) / 2) + (u1_ * a3_ * b3_ + q2_ * (a2b3_ + a3b2_)));\r\n    // <15>s1 <-- <15>(<14>(<12>(-3*q1q1) - <13>2*q1q5) + <14>(<13>tq2q4 + <13>(<8>q3*<4>q6)))\r\n    const s1_ = (3 * q1q1_ + 2 * q1q5_) + (tq2q4_ + q3_ * q6_);\r\n    // <15>s2 <-- <15>(2*(<13>(<5>q1*<7>q2) - <14>q3q4))\r\n    const s2_ = 2 * (q1_ * q2_ + q3q4_);\r\n    // <17>s3 <-- <17>(<16>(<14>(<5>q1*<8>q3) - <15>(<7>q2*<7>q2)) + <16>(<8>q3*<7>q5))\r\n    const s3_ = q1_ * q3_ + q2_ * q2_ + q3_ * q5_;\r\n    // <22>vₓ <-- <22>(<19>(<3>b3*<15>s1) + <21>(<19>(<3>b2*<15>s2) + <20>(<2>b1*<17>s3)))\r\n    const vₓ_ = b3_ * s1_ + (b2_ * s2_ + b1_ * s3_);\r\n    // <22>vᵧ <-- <22>(<19>(<3>-a3*<15>s1) - <21>(<19>(<3>a2*<15>s2) + <20>(<2>a1*<17>s3)))\r\n    const vᵧ_ = a3_ * s1_ + (a2_ * s2_ + a1_ * s3_);\r\n    // <24>v <-- <24>(<21>(<5>q1*<15>(<14>(<13>tq2q4 - <11>q1q1) - <13>q1q5)) + <23>(<22>(<17>s3*<4>q6) - <20>(<14>q3q4*<5>q4)))\r\n    const v_ = (q1_ * ((tq2q4_ + q1q1_) + q1q5_)) + (s3_ * q6_ + q3q4_ * q4_);\r\n    return {\r\n        vₓₓₓ_,\r\n        vₓₓᵧ_,\r\n        vₓᵧᵧ_,\r\n        vᵧᵧᵧ_,\r\n        vₓₓ_,\r\n        vₓᵧ_,\r\n        vᵧᵧ_,\r\n        vₓ_,\r\n        vᵧ_,\r\n        v_ // <24>\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-implicit-form3-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js?')},"./node_modules/flo-bezier3/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "areBoxesIntersecting": () => (/* reexport safe */ _boxes_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_18__.areBoxesIntersecting),\n/* harmony export */   "area": () => (/* reexport safe */ _global_properties_area_js__WEBPACK_IMPORTED_MODULE_2__.area),\n/* harmony export */   "bezierBezierIntersection": () => (/* reexport safe */ _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_72__.bezierBezierIntersection),\n/* harmony export */   "bezierBezierIntersectionBoundless": () => (/* reexport safe */ _intersection_bezier_bezier_intersection_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_119__.bezierBezierIntersectionBoundless),\n/* harmony export */   "bezierBezierIntersectionFast": () => (/* reexport safe */ _intersection_bezier_bezier_intersection_fast_bezier_bezier_intersection_fast_js__WEBPACK_IMPORTED_MODULE_16__.bezierBezierIntersectionFast),\n/* harmony export */   "bezierSelfIntersection": () => (/* reexport safe */ _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_52__.bezierSelfIntersection),\n/* harmony export */   "circleBezierIntersection": () => (/* reexport safe */ _intersection_circle_bezier_intersection_circle_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_101__.circleBezierIntersection),\n/* harmony export */   "classification": () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_1__.classification),\n/* harmony export */   "classifications": () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_1__.classifications),\n/* harmony export */   "classify": () => (/* reexport safe */ _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_1__.classify),\n/* harmony export */   "clone": () => (/* reexport safe */ _transformation_clone_js__WEBPACK_IMPORTED_MODULE_5__.clone),\n/* harmony export */   "closestPointOnBezier": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_13__.closestPointOnBezier),\n/* harmony export */   "closestPointOnBezierCertified": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_80__.closestPointOnBezierCertified),\n/* harmony export */   "controlPointLinesLength": () => (/* reexport safe */ _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_83__.controlPointLinesLength),\n/* harmony export */   "cubicThroughPointGiven013": () => (/* reexport safe */ _create_cubic_through_point_given013_js__WEBPACK_IMPORTED_MODULE_51__.cubicThroughPointGiven013),\n/* harmony export */   "cubicToHybridQuadratic": () => (/* reexport safe */ _transformation_degree_or_type_cubic_to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_94__.cubicToHybridQuadratic),\n/* harmony export */   "cubicToQuadratic": () => (/* reexport safe */ _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_99__.cubicToQuadratic),\n/* harmony export */   "curvature": () => (/* reexport safe */ _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_74__.curvature),\n/* harmony export */   "curviness": () => (/* reexport safe */ _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_86__.curviness),\n/* harmony export */   "equal": () => (/* reexport safe */ _simultaneous_properties_equal_js__WEBPACK_IMPORTED_MODULE_7__.equal),\n/* harmony export */   "evalDeCasteljau": () => (/* reexport safe */ _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_19__.evalDeCasteljau),\n/* harmony export */   "evalDeCasteljauDd": () => (/* reexport safe */ _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_23__.evalDeCasteljauDd),\n/* harmony export */   "evalDeCasteljauError": () => (/* reexport safe */ _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_20__.evalDeCasteljauError),\n/* harmony export */   "evalDeCasteljauWithErr": () => (/* reexport safe */ _local_properties_at_t_evaluate_double_eval_de_casteljau_with_err_js__WEBPACK_IMPORTED_MODULE_21__.evalDeCasteljauWithErr),\n/* harmony export */   "evalDeCasteljauWithErrDd": () => (/* reexport safe */ _local_properties_at_t_evaluate_double_double_eval_de_casteljau_with_err_dd_js__WEBPACK_IMPORTED_MODULE_22__.evalDeCasteljauWithErrDd),\n/* harmony export */   "evaluate": () => (/* reexport safe */ _local_properties_at_t_evaluate_double_evaluate_js__WEBPACK_IMPORTED_MODULE_103__.evaluate),\n/* harmony export */   "evaluate2ndDerivative": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_107__.evaluate2ndDerivative),\n/* harmony export */   "evaluate2ndDerivativeAt0": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_0_js__WEBPACK_IMPORTED_MODULE_115__.evaluate2ndDerivativeAt0),\n/* harmony export */   "evaluate2ndDerivativeAt0Exact": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_0_exact_js__WEBPACK_IMPORTED_MODULE_111__.evaluate2ndDerivativeAt0Exact),\n/* harmony export */   "evaluate2ndDerivativeAt1": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_1_js__WEBPACK_IMPORTED_MODULE_117__.evaluate2ndDerivativeAt1),\n/* harmony export */   "evaluate2ndDerivativeAt1Exact": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_1_exact_js__WEBPACK_IMPORTED_MODULE_113__.evaluate2ndDerivativeAt1Exact),\n/* harmony export */   "evaluate2ndDerivativeExact": () => (/* reexport safe */ _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_109__.evaluate2ndDerivativeExact),\n/* harmony export */   "evaluateExact": () => (/* reexport safe */ _local_properties_at_t_evaluate_exact_evaluate_exact_js__WEBPACK_IMPORTED_MODULE_102__.evaluateExact),\n/* harmony export */   "evaluateImplicit1": () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit1_js__WEBPACK_IMPORTED_MODULE_41__.evaluateImplicit1),\n/* harmony export */   "evaluateImplicit2": () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit2_js__WEBPACK_IMPORTED_MODULE_35__.evaluateImplicit2),\n/* harmony export */   "evaluateImplicit3": () => (/* reexport safe */ _implicit_form_evaluate_double_evaluate_implicit3_js__WEBPACK_IMPORTED_MODULE_29__.evaluateImplicit3),\n/* harmony export */   "fitQuadsToCubic": () => (/* reexport safe */ _fit_fit_quads_to_cubic_js__WEBPACK_IMPORTED_MODULE_11__.fitQuadsToCubic),\n/* harmony export */   "fromPowerBasis": () => (/* reexport safe */ _from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_47__.fromPowerBasis),\n/* harmony export */   "fromTo": () => (/* reexport safe */ _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_10__.fromTo),\n/* harmony export */   "fromToInclErrorBound": () => (/* reexport safe */ _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_9__.fromToInclErrorBound),\n/* harmony export */   "furthestPointOnBezier": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_14__.furthestPointOnBezier),\n/* harmony export */   "generateCuspAtHalf3": () => (/* reexport safe */ _create_generate_cusp_at_half_t_js__WEBPACK_IMPORTED_MODULE_49__.generateCuspAtHalf3),\n/* harmony export */   "generateQuarterCircle": () => (/* reexport safe */ _create_generate_quarter_circle_js__WEBPACK_IMPORTED_MODULE_15__.generateQuarterCircle),\n/* harmony export */   "generateSelfIntersecting": () => (/* reexport safe */ _create_generate_self_intersecting_js__WEBPACK_IMPORTED_MODULE_50__.generateSelfIntersecting),\n/* harmony export */   "getAbsAreaBetween": () => (/* reexport safe */ _fit_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_126__.getAbsAreaBetween),\n/* harmony export */   "getBoundingBox": () => (/* reexport safe */ _global_properties_bounds_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_93__.getBoundingBox),\n/* harmony export */   "getBoundingBoxTight": () => (/* reexport safe */ _global_properties_bounds_get_bounding_box_tight_js__WEBPACK_IMPORTED_MODULE_92__.getBoundingBoxTight),\n/* harmony export */   "getBoundingHull": () => (/* reexport safe */ _global_properties_bounds_get_bounding_hull_js__WEBPACK_IMPORTED_MODULE_0__.getBoundingHull),\n/* harmony export */   "getBounds": () => (/* reexport safe */ _global_properties_bounds_get_bounds_js__WEBPACK_IMPORTED_MODULE_91__.getBounds),\n/* harmony export */   "getCoeffsBezBez": () => (/* reexport safe */ _intersection_bezier_bezier_intersection_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_28__.getCoeffsBezBez),\n/* harmony export */   "getControlPointBox": () => (/* reexport safe */ _global_properties_bounds_get_control_point_box_js__WEBPACK_IMPORTED_MODULE_12__.getControlPointBox),\n/* harmony export */   "getCurvatureExtrema": () => (/* reexport safe */ _get_curvature_extrema_get_curvature_extrema_js__WEBPACK_IMPORTED_MODULE_85__.getCurvatureExtrema),\n/* harmony export */   "getEndpointIntersections": () => (/* reexport safe */ _intersection_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_53__.getEndpointIntersections),\n/* harmony export */   "getFootpointPoly": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_get_footpoint_poly_js__WEBPACK_IMPORTED_MODULE_123__.getFootpointPoly),\n/* harmony export */   "getFootpointPolyDd": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_double_get_footpoint_poly_dd_js__WEBPACK_IMPORTED_MODULE_124__.getFootpointPolyDd),\n/* harmony export */   "getFootpointPolyExact": () => (/* reexport safe */ _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_exact_get_footpoint_poly_exact_js__WEBPACK_IMPORTED_MODULE_122__.getFootpointPolyExact),\n/* harmony export */   "getHodograph": () => (/* reexport safe */ _transformation_get_hodograph_js__WEBPACK_IMPORTED_MODULE_48__.getHodograph),\n/* harmony export */   "getImplicitForm1": () => (/* reexport safe */ _implicit_form_double_get_implicit_form1_js__WEBPACK_IMPORTED_MODULE_42__.getImplicitForm1),\n/* harmony export */   "getImplicitForm1Dd": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form1_dd_js__WEBPACK_IMPORTED_MODULE_43__.getImplicitForm1Dd),\n/* harmony export */   "getImplicitForm1DdWithRunningError": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_45__.getImplicitForm1DdWithRunningError),\n/* harmony export */   "getImplicitForm1ErrorCounters": () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form1_error_counters_js__WEBPACK_IMPORTED_MODULE_44__.getImplicitForm1ErrorCounters),\n/* harmony export */   "getImplicitForm1Exact": () => (/* reexport safe */ _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_46__.getImplicitForm1Exact),\n/* harmony export */   "getImplicitForm2": () => (/* reexport safe */ _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_36__.getImplicitForm2),\n/* harmony export */   "getImplicitForm2Dd": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form2_dd_js__WEBPACK_IMPORTED_MODULE_37__.getImplicitForm2Dd),\n/* harmony export */   "getImplicitForm2DdWithRunningError": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_39__.getImplicitForm2DdWithRunningError),\n/* harmony export */   "getImplicitForm2ErrorCounters": () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_38__.getImplicitForm2ErrorCounters),\n/* harmony export */   "getImplicitForm2Exact": () => (/* reexport safe */ _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_40__.getImplicitForm2Exact),\n/* harmony export */   "getImplicitForm3": () => (/* reexport safe */ _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_30__.getImplicitForm3),\n/* harmony export */   "getImplicitForm3Dd": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form3_dd_js__WEBPACK_IMPORTED_MODULE_31__.getImplicitForm3Dd),\n/* harmony export */   "getImplicitForm3DdWithRunningError": () => (/* reexport safe */ _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_33__.getImplicitForm3DdWithRunningError),\n/* harmony export */   "getImplicitForm3ErrorCounters": () => (/* reexport safe */ _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_32__.getImplicitForm3ErrorCounters),\n/* harmony export */   "getImplicitForm3Exact": () => (/* reexport safe */ _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_34__.getImplicitForm3Exact),\n/* harmony export */   "getInflections": () => (/* reexport safe */ _global_properties_get_inflections_js__WEBPACK_IMPORTED_MODULE_27__.getInflections),\n/* harmony export */   "getInterfaceRotation": () => (/* reexport safe */ _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_79__.getInterfaceRotation),\n/* harmony export */   "getIntervalBox": () => (/* reexport safe */ _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_77__.getIntervalBox),\n/* harmony export */   "getIntervalBoxDd": () => (/* reexport safe */ _global_properties_bounds_get_interval_box_get_interval_box_dd_js__WEBPACK_IMPORTED_MODULE_78__.getIntervalBoxDd),\n/* harmony export */   "getTAtLength": () => (/* reexport safe */ _local_properties_to_t_get_t_at_length_js__WEBPACK_IMPORTED_MODULE_6__.getTAtLength),\n/* harmony export */   "getXBoundsTight": () => (/* reexport safe */ _global_properties_bounds_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_120__.getXBoundsTight),\n/* harmony export */   "getYBoundsTight": () => (/* reexport safe */ _global_properties_bounds_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_121__.getYBoundsTight),\n/* harmony export */   "hausdorffDistance": () => (/* reexport safe */ _simultaneous_properties_hausdorff_distance_hausdorff_distance_js__WEBPACK_IMPORTED_MODULE_82__.hausdorffDistance),\n/* harmony export */   "hausdorffDistanceOneSided": () => (/* reexport safe */ _simultaneous_properties_hausdorff_distance_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_81__.hausdorffDistanceOneSided),\n/* harmony export */   "intersectBoxes": () => (/* reexport safe */ _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_17__.intersectBoxes),\n/* harmony export */   "isCollinear": () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_89__.isCollinear),\n/* harmony export */   "isCubicReallyLine": () => (/* reexport safe */ _global_properties_classification_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_95__.isCubicReallyLine),\n/* harmony export */   "isCubicReallyQuad": () => (/* reexport safe */ _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_96__.isCubicReallyQuad),\n/* harmony export */   "isHorizontal": () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_89__.isHorizontal),\n/* harmony export */   "isPointOnBezierExtension": () => (/* reexport safe */ _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_24__.isPointOnBezierExtension),\n/* harmony export */   "isQuadObtuse": () => (/* reexport safe */ _global_properties_classification_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_76__.isQuadObtuse),\n/* harmony export */   "isQuadReallyLine": () => (/* reexport safe */ _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_97__.isQuadReallyLine),\n/* harmony export */   "isReallyPoint": () => (/* reexport safe */ _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_98__.isReallyPoint),\n/* harmony export */   "isSelfOverlapping": () => (/* reexport safe */ _global_properties_classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_90__.isSelfOverlapping),\n/* harmony export */   "isVertical": () => (/* reexport safe */ _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_89__.isVertical),\n/* harmony export */   "length": () => (/* reexport safe */ _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_3__.length),\n/* harmony export */   "lineToCubic": () => (/* reexport safe */ _transformation_degree_or_type_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_105__.lineToCubic),\n/* harmony export */   "lineToQuadratic": () => (/* reexport safe */ _transformation_degree_or_type_line_to_quadratic_js__WEBPACK_IMPORTED_MODULE_104__.lineToQuadratic),\n/* harmony export */   "normal": () => (/* reexport safe */ _local_properties_at_t_normal_normal_js__WEBPACK_IMPORTED_MODULE_71__.normal),\n/* harmony export */   "quadraticToCubic": () => (/* reexport safe */ _transformation_degree_or_type_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_100__.quadraticToCubic),\n/* harmony export */   "quadraticToPolyline": () => (/* reexport safe */ _fit_quadratic_to_polyline_js__WEBPACK_IMPORTED_MODULE_75__.quadraticToPolyline),\n/* harmony export */   "reduceOrderIfPossible": () => (/* reexport safe */ _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_125__.reduceOrderIfPossible),\n/* harmony export */   "reverse": () => (/* reexport safe */ _transformation_reverse_js__WEBPACK_IMPORTED_MODULE_26__.reverse),\n/* harmony export */   "splitByCurvature": () => (/* reexport safe */ _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_87__.splitByCurvature),\n/* harmony export */   "splitByCurvatureAndLength": () => (/* reexport safe */ _transformation_split_split_by_curvature_and_length_js__WEBPACK_IMPORTED_MODULE_88__.splitByCurvatureAndLength),\n/* harmony export */   "splitByLength": () => (/* reexport safe */ _transformation_split_split_by_length_js__WEBPACK_IMPORTED_MODULE_84__.splitByLength),\n/* harmony export */   "tFromXY": () => (/* reexport safe */ _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_54__.tFromXY),\n/* harmony export */   "tangent": () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_js__WEBPACK_IMPORTED_MODULE_106__.tangent),\n/* harmony export */   "tangentAt0": () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_at_0_js__WEBPACK_IMPORTED_MODULE_114__.tangentAt0),\n/* harmony export */   "tangentAt0Exact": () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_at_0_exact_js__WEBPACK_IMPORTED_MODULE_110__.tangentAt0Exact),\n/* harmony export */   "tangentAt1": () => (/* reexport safe */ _local_properties_at_t_tangent_double_tangent_at_1_js__WEBPACK_IMPORTED_MODULE_116__.tangentAt1),\n/* harmony export */   "tangentAt1Exact": () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_at_1_exact_js__WEBPACK_IMPORTED_MODULE_112__.tangentAt1Exact),\n/* harmony export */   "tangentExact": () => (/* reexport safe */ _local_properties_at_t_tangent_exact_tangent_exact_js__WEBPACK_IMPORTED_MODULE_108__.tangentExact),\n/* harmony export */   "toCubic": () => (/* reexport safe */ _transformation_degree_or_type_to_cubic_js__WEBPACK_IMPORTED_MODULE_73__.toCubic),\n/* harmony export */   "toPowerBasis": () => (/* reexport safe */ _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_55__.toPowerBasis),\n/* harmony export */   "toPowerBasisDd": () => (/* reexport safe */ _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_59__.toPowerBasisDd),\n/* harmony export */   "toPowerBasisDdWithRunningError": () => (/* reexport safe */ _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_68__.toPowerBasisDdWithRunningError),\n/* harmony export */   "toPowerBasisErrorCounters": () => (/* reexport safe */ _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_69__.toPowerBasisErrorCounters),\n/* harmony export */   "toPowerBasisExact": () => (/* reexport safe */ _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_63__.toPowerBasisExact),\n/* harmony export */   "toPowerBasisWithRunningError": () => (/* reexport safe */ _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_67__.toPowerBasisWithRunningError),\n/* harmony export */   "toPowerBasis_1stDerivative": () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_56__.toPowerBasis_1stDerivative),\n/* harmony export */   "toPowerBasis_1stDerivativeDd": () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_60__.toPowerBasis_1stDerivativeDd),\n/* harmony export */   "toPowerBasis_1stDerivativeErrorCounters": () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_to_power_basis_1st_derivative_error_counters_js__WEBPACK_IMPORTED_MODULE_70__.toPowerBasis_1stDerivativeErrorCounters),\n/* harmony export */   "toPowerBasis_1stDerivativeExact": () => (/* reexport safe */ _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_64__.toPowerBasis_1stDerivativeExact),\n/* harmony export */   "toPowerBasis_2ndDerivative": () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_57__.toPowerBasis_2ndDerivative),\n/* harmony export */   "toPowerBasis_2ndDerivativeDd": () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_61__.toPowerBasis_2ndDerivativeDd),\n/* harmony export */   "toPowerBasis_2ndDerivativeExact": () => (/* reexport safe */ _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_65__.toPowerBasis_2ndDerivativeExact),\n/* harmony export */   "toPowerBasis_3rdDerivative": () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_58__.toPowerBasis_3rdDerivative),\n/* harmony export */   "toPowerBasis_3rdDerivativeDd": () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_62__.toPowerBasis_3rdDerivativeDd),\n/* harmony export */   "toPowerBasis_3rdDerivativeExact": () => (/* reexport safe */ _to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_66__.toPowerBasis_3rdDerivativeExact),\n/* harmony export */   "toString": () => (/* reexport safe */ _transformation_to_string_js__WEBPACK_IMPORTED_MODULE_118__.toString),\n/* harmony export */   "totalAbsoluteCurvature": () => (/* reexport safe */ _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_25__.totalAbsoluteCurvature),\n/* harmony export */   "totalCurvature": () => (/* reexport safe */ _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_25__.totalCurvature),\n/* harmony export */   "totalLength": () => (/* reexport safe */ _global_properties_length_total_length_js__WEBPACK_IMPORTED_MODULE_4__.totalLength),\n/* harmony export */   "γ": () => (/* reexport safe */ _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_8__["γ"]),\n/* harmony export */   "γγ": () => (/* reexport safe */ _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_8__["γγ"]),\n/* harmony export */   "κ": () => (/* reexport safe */ _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_74__["κ"])\n/* harmony export */ });\n/* harmony import */ var _global_properties_bounds_get_bounding_hull_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-hull.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-hull.js");\n/* harmony import */ var _global_properties_classification_classify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global-properties/classification/classify.js */ "./node_modules/flo-bezier3/node/global-properties/classification/classify.js");\n/* harmony import */ var _global_properties_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global-properties/area.js */ "./node_modules/flo-bezier3/node/global-properties/area.js");\n/* harmony import */ var _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global-properties/length/length.js */ "./node_modules/flo-bezier3/node/global-properties/length/length.js");\n/* harmony import */ var _global_properties_length_total_length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./global-properties/length/total-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/total-length.js");\n/* harmony import */ var _transformation_clone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transformation/clone.js */ "./node_modules/flo-bezier3/node/transformation/clone.js");\n/* harmony import */ var _local_properties_to_t_get_t_at_length_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./local-properties-to-t/get-t-at-length.js */ "./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js");\n/* harmony import */ var _simultaneous_properties_equal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./simultaneous-properties/equal.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/equal.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transformation/split/from-to-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./transformation/split/from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n/* harmony import */ var _fit_fit_quads_to_cubic_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fit/fit-quads-to-cubic.js */ "./node_modules/flo-bezier3/node/fit/fit-quads-to-cubic.js");\n/* harmony import */ var _global_properties_bounds_get_control_point_box_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./global-properties/bounds/get-control-point-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-control-point-box.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js");\n/* harmony import */ var _create_generate_quarter_circle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./create/generate-quarter-circle.js */ "./node_modules/flo-bezier3/node/create/generate-quarter-circle.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_fast_bezier_bezier_intersection_fast_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./boxes/intersect-boxes.js */ "./node_modules/flo-bezier3/node/boxes/intersect-boxes.js");\n/* harmony import */ var _boxes_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./boxes/are-boxes-intersecting.js */ "./node_modules/flo-bezier3/node/boxes/are-boxes-intersecting.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n/* harmony import */ var _local_properties_at_t_evaluate_eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/eval-de-casteljau-error.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_with_err_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_with_err_dd_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_double_eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js");\n/* harmony import */ var _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js");\n/* harmony import */ var _global_properties_total_absolute_curvature_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./global-properties/total-absolute-curvature.js */ "./node_modules/flo-bezier3/node/global-properties/total-absolute-curvature.js");\n/* harmony import */ var _transformation_reverse_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./transformation/reverse.js */ "./node_modules/flo-bezier3/node/transformation/reverse.js");\n/* harmony import */ var _global_properties_get_inflections_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./global-properties/get-inflections.js */ "./node_modules/flo-bezier3/node/global-properties/get-inflections.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit3_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit3.js */ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit3.js");\n/* harmony import */ var _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form3.js */ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form3-dd.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd.js");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form3-error-counters.js */ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form3-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit2_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit2.js */ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit2.js");\n/* harmony import */ var _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form2.js */ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form2-dd.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd.js");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form2-error-counters.js */ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n/* harmony import */ var _implicit_form_evaluate_double_evaluate_implicit1_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./implicit-form/evaluate/double/evaluate-implicit1.js */ "./node_modules/flo-bezier3/node/implicit-form/evaluate/double/evaluate-implicit1.js");\n/* harmony import */ var _implicit_form_double_get_implicit_form1_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./implicit-form/double/get-implicit-form1.js */ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form1.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form1-dd.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd.js");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form1_error_counters_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./implicit-form/get-error-counters/get-implicit-form1-error-counters.js */ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form1-error-counters.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./implicit-form/exact/get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n/* harmony import */ var _from_power_basis_from_power_basis_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./from-power-basis/from-power-basis.js */ "./node_modules/flo-bezier3/node/from-power-basis/from-power-basis.js");\n/* harmony import */ var _transformation_get_hodograph_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./transformation/get-hodograph.js */ "./node_modules/flo-bezier3/node/transformation/get-hodograph.js");\n/* harmony import */ var _create_generate_cusp_at_half_t_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./create/generate-cusp-at-half-t.js */ "./node_modules/flo-bezier3/node/create/generate-cusp-at-half-t.js");\n/* harmony import */ var _create_generate_self_intersecting_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./create/generate-self-intersecting.js */ "./node_modules/flo-bezier3/node/create/generate-self-intersecting.js");\n/* harmony import */ var _create_cubic_through_point_given013_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./create/cubic-through-point-given013.js */ "./node_modules/flo-bezier3/node/create/cubic-through-point-given013.js");\n/* harmony import */ var _intersection_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./intersection/self-intersection/bezier-self-intersection.js */ "./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js");\n/* harmony import */ var _intersection_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./intersection/get-endpoint-intersections/get-endpoint-intersections.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js");\n/* harmony import */ var _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./local-properties-to-t/t-from-xy.js */ "./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_to_power_basis_3rd_derivative_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_double_to_power_basis_1st_derivative_dd_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_double_to_power_basis_2nd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_double_double_to_power_basis_3rd_derivative_dd_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_3rd_derivative_exact_to_power_basis_3rd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./to-power-basis/to-power-basis/to-power-basis-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_to_power_basis_1st_derivative_error_counters_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js");\n/* harmony import */ var _local_properties_at_t_normal_normal_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./local-properties-at-t/normal/normal.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/bezier-bezier-intersection.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js");\n/* harmony import */ var _transformation_degree_or_type_to_cubic_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./transformation/degree-or-type/to-cubic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js");\n/* harmony import */ var _local_properties_at_t_curvature_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./local-properties-at-t/curvature.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js");\n/* harmony import */ var _fit_quadratic_to_polyline_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./fit/quadratic-to-polyline.js */ "./node_modules/flo-bezier3/node/fit/quadratic-to-polyline.js");\n/* harmony import */ var _global_properties_classification_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./global-properties/classification/is-quad-obtuse.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-obtuse.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_dd_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./global-properties/bounds/get-interval-box/get-interval-box-dd.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box-dd.js");\n/* harmony import */ var _simultaneous_properties_get_interface_rotation_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./simultaneous-properties/get-interface-rotation.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_closest_point_on_bezier_certified_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js");\n/* harmony import */ var _simultaneous_properties_hausdorff_distance_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js");\n/* harmony import */ var _simultaneous_properties_hausdorff_distance_hausdorff_distance_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./simultaneous-properties/hausdorff-distance/hausdorff-distance.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js");\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./global-properties/length/control-point-lines-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js");\n/* harmony import */ var _transformation_split_split_by_length_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./transformation/split/split-by-length.js */ "./node_modules/flo-bezier3/node/transformation/split/split-by-length.js");\n/* harmony import */ var _get_curvature_extrema_get_curvature_extrema_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./get-curvature-extrema/get-curvature-extrema.js */ "./node_modules/flo-bezier3/node/get-curvature-extrema/get-curvature-extrema.js");\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./global-properties/curviness.js */ "./node_modules/flo-bezier3/node/global-properties/curviness.js");\n/* harmony import */ var _transformation_split_split_by_curvature_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./transformation/split/split-by-curvature.js */ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js");\n/* harmony import */ var _transformation_split_split_by_curvature_and_length_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./transformation/split/split-by-curvature-and-length.js */ "./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./global-properties/classification/is-collinear.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js");\n/* harmony import */ var _global_properties_classification_is_self_overlapping_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./global-properties/classification/is-self-overlapping.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-self-overlapping.js");\n/* harmony import */ var _global_properties_bounds_get_bounds_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./global-properties/bounds/get-bounds.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounds.js");\n/* harmony import */ var _global_properties_bounds_get_bounding_box_tight_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box-tight.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box-tight.js");\n/* harmony import */ var _global_properties_bounds_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./global-properties/bounds/get-bounding-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-bounding-box.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./transformation/degree-or-type/cubic-to-hybrid-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js");\n/* harmony import */ var _global_properties_classification_is_cubic_really_line_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./global-properties/classification/is-cubic-really-line.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-line.js");\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./global-properties/classification/is-cubic-really-quad.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js");\n/* harmony import */ var _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./global-properties/classification/is-quad-really-line.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js");\n/* harmony import */ var _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./global-properties/classification/is-really-point.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _transformation_degree_or_type_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./transformation/degree-or-type/quadratic-to-cubic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js");\n/* harmony import */ var _intersection_circle_bezier_intersection_circle_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./intersection/circle-bezier-intersection/circle-bezier-intersection.js */ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js");\n/* harmony import */ var _local_properties_at_t_evaluate_exact_evaluate_exact_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/exact/evaluate-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_evaluate_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./local-properties-at-t/evaluate/double/evaluate.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js");\n/* harmony import */ var _transformation_degree_or_type_line_to_quadratic_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./transformation/degree-or-type/line-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js");\n/* harmony import */ var _transformation_degree_or_type_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./transformation/degree-or-type/line-to-cubic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_exact_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_at_0_exact_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-at-0-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_0_exact_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js");\n/* harmony import */ var _local_properties_at_t_tangent_exact_tangent_at_1_exact_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./local-properties-at-t/tangent/exact/tangent-at-1-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_exact_evaluate_2nd_derivative_at_1_exact_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_at_0_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent-at-0.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_0_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js");\n/* harmony import */ var _local_properties_at_t_tangent_double_tangent_at_1_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./local-properties-at-t/tangent/double/tangent-at-1.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js");\n/* harmony import */ var _local_properties_at_t_evaluate_2nd_derivative_double_evaluate_2nd_derivative_at_1_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js");\n/* harmony import */ var _transformation_to_string_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./transformation/to-string.js */ "./node_modules/flo-bezier3/node/transformation/to-string.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js");\n/* harmony import */ var _global_properties_bounds_get_x_bounds_tight_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./global-properties/bounds/get-x-bounds-tight.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-x-bounds-tight.js");\n/* harmony import */ var _global_properties_bounds_get_y_bounds_tight_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./global-properties/bounds/get-y-bounds-tight.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-y-bounds-tight.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_exact_get_footpoint_poly_exact_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_get_footpoint_poly_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js");\n/* harmony import */ var _simultaneous_properties_closest_and_furthest_point_on_bezier_get_coeffs_double_double_get_footpoint_poly_dd_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./transformation/reduce-order-if-possible.js */ "./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js");\n/* harmony import */ var _fit_get_abs_area_between_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./fit/get-abs-area-between.js */ "./node_modules/flo-bezier3/node/fit/get-abs-area-between.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/index.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierBezierIntersectionFast": () => (/* binding */ bezierBezierIntersectionFast)\n/* harmony export */ });\n/* harmony import */ var _check_intersection_in_ranges_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./check-intersection-in-ranges.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js");\n/* harmony import */ var _bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bezier-bezier-intersection/bezier-bezier-intersection.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js");\n\r\n\r\nconst checkIntersectionInRanges = _check_intersection_in_ranges_js__WEBPACK_IMPORTED_MODULE_0__.checkIntersectionInRanges;\r\nconst bezierBezierIntersection = _bezier_bezier_intersection_bezier_bezier_intersection_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersection;\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst abs = Math.abs;\r\n/**\r\n * The guarantee in accuracy of the `t` parameter value chosen to be reasonable\r\n * for this type of intersection algorithm.\r\n */\r\nconst δ = 2 ** -33; // 2**(-33) === 1.1641532182693481e-10\r\n/** a heuristic value for the minimum t-span of the final iteration */\r\nconst Δ = 2 ** (-43); // 2**(-43) === 1.1368683772161603e-13\r\n/**\r\n * Accurate, fast (*eventually* cubically convergent) algorithm that returns\r\n * the intersections between two bezier curves (of order <= 3).\r\n *\r\n * * returns an array that contains the `t` paramater pairs at intersection\r\n * of the first and second bezier curves respectively.\r\n *\r\n * * Each returned `t` paramter value is mathematically guaranteed to be\r\n * accurate to within 2**-33 or about ten billionths of a unit.\r\n *\r\n * * the algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\r\n * that finds the intersection of a fat line and a so-called geometric interval\r\n * making it faster than the standard fat-line intersection algorithm (that\r\n * is *eventually* only *quadratically* convergent)\r\n * * *eventually* cubically convergent (usually converging in about 4 to 8\r\n * iterations for typical intersections) but for hard intersections can become\r\n * extremely slow due to sub-linear convergence (and similarly for *all* fatline\r\n * algorithms) in those cases; luckily this algorithm detects those cases and\r\n * reverts to implicitization with strict error bounds to guarantee accuracy\r\n * and efficiency (implicitization is roughly 5x slower but is very rare)\r\n *\r\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction bezierBezierIntersectionFast(ps1, ps2) {\r\n    if (ps1.length <= 2 || ps2.length <= 2) {\r\n        // revert to implicit form when it\'s going to be fast anyway\r\n        return implicit(ps1, ps2);\r\n    }\r\n    /** Intersection `t` values for both beziers */\r\n    let ts = [];\r\n    /** an iteration still left to check for intersections */\r\n    let iteration = {\r\n        F: ps1,\r\n        G: ps2,\r\n        fRange: [0, 1],\r\n        gRange: [0, 1],\r\n        last: undefined\r\n    };\r\n    let stack = [iteration];\r\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n        globalThis.__debug__.tree = iteration;\r\n    }\r\n    let iters = 0;\r\n    // A slight improvement to the algorithm may be possible by doing a \r\n    // breath-first (rather than depth-first) traversal and reverting to \r\n    // implicitization once the tree reaches a certain width\r\n    /** max iteration heuristic before reverting to implicitization */\r\n    const maxIters = 60;\r\n    while (stack.length !== 0 && iters < maxIters) {\r\n        iters++;\r\n        // keep TypeScript happy; `stack` cannot be empty here\r\n        const iter = stack.pop();\r\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n            globalThis.__debug__.currentIter = iter;\r\n            iter.uid = globalThis.__debug__.uid++;\r\n        }\r\n        let newIterations = checkIntersectionInRanges(iter);\r\n        if (newIterations.length === 1) {\r\n            const newIter = newIterations[0];\r\n            const fRange = newIter.fRange;\r\n            const δδ = abs(fRange[1] - fRange[0]);\r\n            // if the previous iteration was precise enough\r\n            if (newIter.last) {\r\n                const lfRange = newIter.last.fRange;\r\n                if (δδ > δ) {\r\n                    // This case can occur when the geometric interval clips a\r\n                    // piece of the other bezier very far away but is by \r\n                    // coincidence of length < δ.\r\n                    // It can also occur in some other edge cases such as \r\n                    // self-overlapping cubic curves, etc.\r\n                    // revert to implicitization\r\n                    return implicit(ps1, ps2);\r\n                }\r\n                ts.push(iter.F === ps2\r\n                    ? [fRange, lfRange]\r\n                    : [lfRange, fRange]);\r\n                // else if this iteration is precise enough\r\n            }\r\n            else {\r\n                if (δδ < δ) {\r\n                    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n                        newIter.foundX = true;\r\n                    }\r\n                    if (δδ < Δ) {\r\n                        // destructively change the `fRange` as a heuristic so its not\r\n                        // too narrow for the final clip; this might only be a \r\n                        // problem if `fRange === 0` \r\n                        fRange[0] = max(0, fRange[0] - Δ);\r\n                        fRange[1] = min(1, fRange[1] + Δ);\r\n                    }\r\n                    newIter.last = newIter;\r\n                }\r\n                stack.push(newIter); // push the (possibly) final iteration\r\n            }\r\n        }\r\n        else if (newIterations.length === 2) {\r\n            //stack.push(...newIterations);\r\n            stack.push(newIterations[0], newIterations[1]);\r\n        }\r\n    }\r\n    if (iters === maxIters) {\r\n        if (globalThis.__debug__ !== undefined /* && !globalThis.__debug__.already*/) {\r\n            globalThis.__debug__.maxItersCount++;\r\n        }\r\n        return implicit(ps1, ps2);\r\n    }\r\n    if (globalThis.__debug__ !== undefined) {\r\n        // prevent further debugging\r\n        globalThis.__debug__.already = true;\r\n    }\r\n    //---------------------------------------------------------------\r\n    // check for possible duplicate intersections at split points\r\n    //---------------------------------------------------------------\r\n    ts.sort((t1, t2) => t1[0][0] - t2[0][0]);\r\n    combineXs(ts);\r\n    return ts.map(tPair => tPair.map(t => (t[0] + t[1]) / 2));\r\n}\r\nfunction combineXs(xs) {\r\n    let testAgain = true;\r\n    while (testAgain) {\r\n        testAgain = false;\r\n        for (let i = 1; i < xs.length; i++) {\r\n            const x1bez1 = xs[i - 1][0];\r\n            const x2bez1 = xs[i][0];\r\n            // if the prior tmax value is higher than the next t value\'s tmin\r\n            // then they overlap\r\n            if (x1bez1[1] >= x2bez1[0]) { // if overlap found\r\n                // Check if the second bezier\'s `t` values also overlap, else we\r\n                // have a loop getting intersected at its self-intersection point.\r\n                const x1bez2 = xs[i - 1][1];\r\n                const x2bez2 = xs[i][1];\r\n                const x1min = x1bez2[0];\r\n                const x1max = x1bez2[1];\r\n                const x2min = x2bez2[0];\r\n                const x2max = x2bez2[1];\r\n                const overlap = (x1min <= x2max && x1max >= x2min) ||\r\n                    (x2min <= x1max && x2max >= x1min);\r\n                if (overlap) {\r\n                    // combine ranges and test agin\r\n                    testAgain = true;\r\n                    const tMinBez2 = min(x1min, x1max, x2min, x2max);\r\n                    const tMaxBez2 = max(x1min, x1max, x2min, x2max);\r\n                    const x1min1 = x1bez1[0];\r\n                    const x1max1 = x1bez1[1];\r\n                    const x2min1 = x2bez1[0];\r\n                    const x2max1 = x2bez1[1];\r\n                    const tMinBez1 = min(x1min1, x1max1, x2min1, x2max1);\r\n                    const tMaxBez1 = max(x1min1, x1max1, x2min1, x2max1);\r\n                    const x = [\r\n                        [tMinBez1, tMaxBez1],\r\n                        [tMinBez2, tMaxBez2]\r\n                    ];\r\n                    // insert new combined intersection\r\n                    xs.splice(i - 1, 2, x);\r\n                    break; // break out of inner loop\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction implicit(ps1, ps2) {\r\n    return bezierBezierIntersection(ps1, ps2).map(x => [x.t1, x.t2]);\r\n}\r\n\r\n//# sourceMappingURL=bezier-bezier-intersection-fast.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/bezier-bezier-intersection-fast.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "checkIntersectionInRanges": () => (/* binding */ checkIntersectionInRanges)\n/* harmony export */ });\n/* harmony import */ var _clip_geo_clip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clip/geo-clip.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-distance-to-line-function.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js");\n/* harmony import */ var _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../transformation/split/from-to-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js");\n\r\n\r\n\r\n\r\n\r\n\r\nconst getDistanceToLineFunction = _get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_2__.getDistanceToLineFunction;\r\nconst geoClip = _clip_geo_clip_js__WEBPACK_IMPORTED_MODULE_0__.geoClip;\r\nconst fromToInclErrorBound = _transformation_split_from_to_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_3__.fromToInclErrorBound;\r\nconst fromToVect = flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.fromTo;\r\nconst translate = flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.translate;\r\nconst toLength = flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toLength;\r\nconst noIntersection = undefined;\r\n/**\r\n * the heuristic value indicating the maximum `t` parameter span allowed after\r\n * clipping before perpendicular fatline clipping or curve splitting is\r\n * employed.\r\n */\r\nconst maxClipTSpan = 0.7;\r\n/**\r\n * Returns 0, 1 or 2 new narrowed ranges of possible intersections based on the\r\n * given current iteration\'s ranges.\r\n *\r\n * * helper function to the geometric interval bezier-bezier intersection\r\n * algorithm\r\n *\r\n * @param iter\r\n *\r\n * @internal\r\n */\r\nfunction checkIntersectionInRanges(iter) {\r\n    //--------------------------------------\r\n    // let { F, G, fRange, gRange } = iter;\r\n    const F = iter.F;\r\n    const G = iter.G;\r\n    const fRange = iter.fRange;\r\n    const gRange = iter.gRange;\r\n    //--------------------------------------\r\n    //-----------------------------------------------------------------------\r\n    // an invariant at this stage is that `eps | ftMin, ftMax, gtMin, gtMax`\r\n    //-----------------------------------------------------------------------\r\n    /**\r\n     * the minimum `t` value bound for the bezier that will be fatline bounded;\r\n     * it will not change during normal geo clipping\r\n     */\r\n    const ftMin = fRange[0];\r\n    /**\r\n     * the maximum `t` value bound for the bezier that will be fatline bounded;\r\n     * it will not change during normal geo clipping\r\n     */\r\n    const ftMax = fRange[1];\r\n    /**\r\n     * the minimum `t` value bound for the bezier that will be geo bounded;\r\n     * it will be geo clipped for the next iteration\r\n     */\r\n    const gtMin = gRange[0];\r\n    /**\r\n     * the maximum `t` value bound for the bezier that will be geo bounded;\r\n     * it will be geo clipped for the next iteration\r\n     */\r\n    const gtMax = gRange[1];\r\n    // Get the bezier curves (and an error bound) within the narrowed ranges\r\n    // Note: the error bound need be multiplied by `8u`, where \r\n    // `u === Number.EPSILON/2` (see `fromTo3` for details).\r\n    const F_ = fromToInclErrorBound(F, ftMin, ftMax);\r\n    const G_ = fromToInclErrorBound(G, gtMin, gtMax);\r\n    const Fps = F_.ps;\r\n    const F_ps = F_._ps;\r\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n        globalThis.__debug__.currentIter.F_ = F_;\r\n        globalThis.__debug__.currentIter.G_ = G_;\r\n    }\r\n    const lenF = Fps.length;\r\n    // Q will be fat line bounded. Get start and endpoint of curve\r\n    let FS = Fps[0];\r\n    let FE = Fps[lenF - 1];\r\n    // Note: The case where `FS` and `FE` are the same point will result in\r\n    // `geoClip` not clipping and returning \'no intersection\' so we don\'t\r\n    // explicitly test for it here.\r\n    // Get the implict line equation for the line defined by the first and \r\n    // last control point of Q. This equation gives the distance between any \r\n    // point and the line (but scaled for efficiency *and* robustness).\r\n    let dF = getDistanceToLineFunction(FS, FE);\r\n    // Signed distances to cubic mid control points *plus* the first and last\r\n    // control points since there is an error bound involved that need to\r\n    // be included to ensure robustness\r\n    let dF0 = dF(Fps[0], F_ps[0]);\r\n    let dF1 = dF(Fps[1], F_ps[1]);\r\n    let dF2 = dF(Fps[2], F_ps[2]);\r\n    let dF3 = lenF === 4 ? dF(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };\r\n    // Calculate the fat line of F.\r\n    // Calculate the distance from the control points of F to the line.\r\n    //let C = len === 4 ? (dF1*dF2 > 0) ? 3/4 : 4/9 : 1/2;\r\n    // The above calculation of C has been replaced by the one below so we can\r\n    // ensure robustness (`dF1` and `dF2` are not simply numbers but also have\r\n    // an error bound associated with them)\r\n    let C = lenF === 4 ? 3 / 4 : 1 / 2;\r\n    const dMin = C * Math.min(0, dF0.dMin, dF1.dMin, dF2.dMin, dF3.dMin);\r\n    const dMax = C * Math.max(0, dF0.dMax, dF1.dMax, dF2.dMax, dF3.dMax);\r\n    // Add fatline debug info\r\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n        globalThis.__debug__.currentIter.fatline = getFatlineDebugInfo(FS, FE, dMin, dMax);\r\n    }\r\n    const tRange = geoClip(G_, dF, dMin, dMax);\r\n    const last = iter.last;\r\n    if (tRange === noIntersection) {\r\n        return [];\r\n    }\r\n    let tMin = tRange[0];\r\n    let tMax = tRange[1];\r\n    if (!last && tMax - tMin > maxClipTSpan) {\r\n        // This optimization is for cases where the bezier curves meet nearly \r\n        // collinearly at interface points.\r\n        if (!clipPerp()) {\r\n            return [];\r\n        }\r\n        ;\r\n    }\r\n    if (!last && tMax - tMin > maxClipTSpan) {\r\n        return split();\r\n    }\r\n    const gtSpan = gtMax - gtMin;\r\n    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\r\n    const tMin_ = gtMin + tMin * gtSpan + 1 - 1;\r\n    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMax_`\r\n    const tMax_ = gtMin + tMax * gtSpan + 1 - 1;\r\n    // Swap Q and P and iterate.\r\n    const newIter = {\r\n        F: G, G: F,\r\n        fRange: [tMin_, tMax_],\r\n        gRange: fRange,\r\n        last\r\n    };\r\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n        newIter.parent = globalThis.__debug__.currentIter;\r\n        globalThis.__debug__.currentIter.children = [newIter];\r\n    }\r\n    return [newIter];\r\n    function clipPerp() {\r\n        // First try a fatline perpendicular to the prior one. This is \r\n        // important for efficiency especially in cases where the bezier\r\n        // curves meet (or almost meet) with nearly the same tangent and\r\n        // curvature.\r\n        const FSx = FS[0];\r\n        const FSy = FS[1];\r\n        const FEx = FE[0];\r\n        const FEy = FE[1];\r\n        // rotate [FS,FE] 90 degrees about FS\r\n        const V = [FSx + FSy - FEy, FSy + FEx - FSx];\r\n        let dQ_ = getDistanceToLineFunction(FS, V);\r\n        // Signed distances to other 3 control points *plus* the first\r\n        // control point since there is an error bound involved that need to\r\n        // be included to ensure robustness\r\n        let dF0_ = dQ_(Fps[0], F_ps[0]);\r\n        let dF1_ = dQ_(Fps[1], F_ps[1]);\r\n        let dF2_ = dQ_(Fps[2], F_ps[2]);\r\n        let dF3_ = lenF === 4 ? dQ_(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };\r\n        const dMin_ = Math.min(0, dF0_.dMin, dF1_.dMin, dF2_.dMin, dF3_.dMin);\r\n        const dMax_ = Math.max(0, dF0_.dMax, dF1_.dMax, dF2_.dMax, dF3_.dMax);\r\n        // Add fatline debug info\r\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n            globalThis.__debug__.currentIter.fatlinePerp = getFatlineDebugInfo(FS, V, dMin_, dMax_);\r\n        }\r\n        const tRange = geoClip(G_, dQ_, dMin_, dMax_);\r\n        if (tRange === noIntersection) {\r\n            return false;\r\n        }\r\n        const tMin_ = tRange[0];\r\n        const tMax_ = tRange[1];\r\n        tMin = Math.max(tMin, tMin_);\r\n        tMax = Math.min(tMax, tMax_);\r\n        return true;\r\n    }\r\n    /**\r\n     * Split the bezier curve.\r\n     */\r\n    function split() {\r\n        // The paper calls for a heuristic that if less than 30% will be\r\n        // clipped, rather split the longest curve and find intersections in the\r\n        // two halfs seperately.\r\n        const gtSpan = gtMax - gtMin;\r\n        const ftSpan = ftMax - ftMin;\r\n        // Split the curve in half\r\n        if (gtSpan >= ftSpan) {\r\n            // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\r\n            const tMid = gtMin + gtSpan / 2 + 1 - 1;\r\n            const iter1 = { F, G, fRange, gRange: [gtMin, tMid], last };\r\n            const iter2 = { F, G, fRange, gRange: [tMid, gtMax], last };\r\n            if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n                iter1.parent = globalThis.__debug__.currentIter;\r\n                iter2.parent = globalThis.__debug__.currentIter;\r\n                globalThis.__debug__.currentIter.children = [iter2, iter1];\r\n            }\r\n            return [iter2, iter1];\r\n        }\r\n        // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`\r\n        const tMid = ftMin + ftSpan / 2 + 1 - 1;\r\n        const iter1 = { F, G, fRange: [ftMin, tMid], gRange, last };\r\n        const iter2 = { F, G, fRange: [tMid, ftMax], gRange, last };\r\n        if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n            iter1.parent = globalThis.__debug__.currentIter;\r\n            iter2.parent = globalThis.__debug__.currentIter;\r\n            globalThis.__debug__.currentIter.children = [iter2, iter1];\r\n        }\r\n        return [iter2, iter1];\r\n    }\r\n}\r\nfunction getFatlineDebugInfo(FS, FE, dMin, dMax) {\r\n    let vF = fromToVect(FS, FE); // Move [FS, FE] to the origin\r\n    let vFr = [-vF[1], vF[0]]; // Rotate vector by -90 degrees\r\n    // get scale factor `d` to scale back to actual distances \r\n    // (not perfectly accurate due to rounding)\r\n    const xS = FS[0];\r\n    const yS = FS[1];\r\n    const xE = FE[0];\r\n    const yE = FE[1];\r\n    let s = yS - yE;\r\n    let t = xE - xS;\r\n    let u = xS * yE - xE * yS;\r\n    let d = Math.sqrt(s ** 2 + t ** 2);\r\n    let offsetMin = toLength(vFr, dMin / d);\r\n    let offsetMax = toLength(vFr, dMax / d);\r\n    let psMin = [translate(FS, offsetMin), translate(FE, offsetMin)];\r\n    let psMax = [translate(FS, offsetMax), translate(FE, offsetMax)];\r\n    return {\r\n        psBase: [FS, FE],\r\n        psMin, psMax\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=check-intersection-in-ranges.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/check-intersection-in-ranges.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"geoClip\": () => (/* binding */ geoClip)\n/* harmony export */ });\n/* harmony import */ var _to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./to-hybrid-quadratic.js */ \"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js\");\n\r\nconst toHybridQuadratic = _to_hybrid_quadratic_js__WEBPACK_IMPORTED_MODULE_0__.toHybridQuadratic;\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst abs = Math.abs;\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\nconst onemin = 1 - eps;\r\nconst onemax = 1 + eps;\r\nconst noIntersection = undefined;\r\nconst noClip = [0, 1];\r\n/**\r\n * Performs geometric clipping of the given bezier curve and returns the new\r\n * minimum and maximum `t` parameter values.\r\n *\r\n * * helper function to the geometric interval bezier-bezier intersection\r\n * algorithm\r\n * * the returned min and max `t` values has the following guarantees:\r\n *   * `Number.EPSILON | t`\r\n *   * `0 <= t <= 1`\r\n *\r\n * @param G the bezier curve to be geo clipped - coordinate error bounds are\r\n * assumed to have counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\r\n * @param dF function to calculate a min and max distance to the fat line's 'baseline'\r\n * @param dMin fat line min signed distance\r\n * @param dMax fat line max signed distance\r\n *\r\n * @internal\r\n */\r\nfunction geoClip(G, dF, dMin, dMax) {\r\n    // estimated bezier control points\r\n    const Gps = G.ps;\r\n    const lenG = Gps.length;\r\n    const _hq_ = lenG === 4\r\n        ? toHybridQuadratic(G)\r\n        : { hq: [Gps[1], Gps[1]], _hq: [[0, 0], [0, 0]] }; // degenerate\r\n    // estimated hybrid coordinates\r\n    const hq = _hq_.hq;\r\n    // hybrid coordinate error bounds with error counters of <8> and <12> for\r\n    // the two points respectively (both x and y coordinates have same error\r\n    // counters)\r\n    const _hq = _hq_._hq;\r\n    // coordinate error bounds are assumed to have counters \r\n    // of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\r\n    const G_ps = G._ps;\r\n    /** min/max distance (from line) to hybrid quadratic (and cubic) first control point */\r\n    const dH0 = dF(Gps[0], G_ps[0]);\r\n    /** min/max distance (from line) to hybrid quadratic (and cubic) last control point */\r\n    const dH2 = dF(Gps[lenG - 1], G_ps[lenG - 1]);\r\n    /** min/max distance (from line) to hybrid quadratic's moving control point start */\r\n    const dH10 = dF(hq[0], _hq[0]);\r\n    /** min/max distance (from line) to hybrid quadratic's moving control point end */\r\n    const dH11 = dF(hq[1], _hq[1]);\r\n    const dH1min = min(dH10.dMin, dH11.dMin);\r\n    const dH1max = max(dH10.dMax, dH11.dMax);\r\n    if (globalThis.__debug__ !== undefined && !globalThis.__debug__.already) {\r\n        const currentIter = globalThis.__debug__.currentIter;\r\n        // just for drawing purposes (not perfectle accurate)\r\n        currentIter.hq = [G.ps[0], ...hq, G.ps[lenG - 1]];\r\n        if (currentIter.geo) {\r\n            // we already did the first geoclip - assume this to be the perpendicular clip\r\n            currentIter.geoPerp = { dH0, dH10, dH11, dH2, dMin, dMax };\r\n        }\r\n        else {\r\n            currentIter.geo = { dH0, dH10, dH11, dH2, dMin, dMax };\r\n        }\r\n    }\r\n    const dH0Min = dH0.dMin;\r\n    const dH0Max = dH0.dMax;\r\n    const dH2Min = dH2.dMin;\r\n    const dH2Max = dH2.dMax;\r\n    //--------------------------------------------------------------------------\r\n    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)\r\n    // After writing eq. (3.16) and (3.17) in power basis (by simply multiplying \r\n    // out and collecting terms) and taking error bounds into account:\r\n    //--------------------------------------------------------------------------\r\n    /** the quadratic term coefficient of the *lower* Bernstein basis polynomial */\r\n    const a = dH0Min - 2 * dH1min + dH2Min; // t^2 \r\n    /** the linear term coefficient of the *lower* Bernstein basis polynomial */\r\n    const b = -2 * (dH0Min - dH1min); // t^1\r\n    /**\r\n     * the constant term coefficient of the *lower* Bernstein basis polynomial's\r\n     * intersection with the lower fat line (dMin)\r\n     */\r\n    const c1 = dH0Min - dMin; // t^0 - dMin\r\n    /**\r\n     * the constant term coefficient of the *lower* Bernstein basis polynomial's\r\n     * intersection with the upper fat line (dMax)\r\n     */\r\n    const c2 = dH0Min - dMax; // t^0 - dMax\r\n    /** the quadratic term coefficient of the *upper* Bernstein basis polynomial */\r\n    const d = dH0Max - 2 * dH1max + dH2Max;\r\n    /** the linear term coefficient of the *upper* Bernstein basis polynomial */\r\n    const e = -2 * (dH0Max - dH1max);\r\n    /**\r\n     * the constant term coefficient of the *upper* Bernstein basis polynomial's\r\n     * intersection with the *lower* fat line (dMin)\r\n     */\r\n    const f1 = dH0Max - dMin;\r\n    /**\r\n     * the constant term coefficient of the *upper* Bernstein basis polynomial's\r\n     * intersection with the *upper* fat line (dMax)\r\n     */\r\n    const f2 = dH0Max - dMax;\r\n    //--------------------------------------------------------------------------\r\n    let tMin = Number.POSITIVE_INFINITY;\r\n    let tMax = Number.NEGATIVE_INFINITY;\r\n    /** *lower* Bernstein *lower* fatline roots */\r\n    const rootsMinBMinF = quadraticRoots(a, b, c1);\r\n    /** *lower* Bernstein *upper* fatline roots */\r\n    const rootsMinBMaxF = quadraticRoots(a, b, c2);\r\n    /** *upper* Bernstein *lower* fatline roots */\r\n    const rootsMaxBMinF = quadraticRoots(d, e, f1);\r\n    /** *upper* Bernstein *upper* fatline roots */\r\n    const rootsMaxBMaxF = quadraticRoots(d, e, f2);\r\n    // if there are an infinite number of roots, i.e. if the quadratic is\r\n    // really the zero polynomial\r\n    if (rootsMinBMinF === undefined || rootsMinBMaxF === undefined ||\r\n        rootsMaxBMinF === undefined || rootsMaxBMaxF === undefined) {\r\n        // no clipping could happen\r\n        return noClip;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)\r\n    // According to the paper we can do clipping such that 2 intervals are\r\n    // sometimes returned. We just return the combined interval in those cases\r\n    // which might make the algorithm slightly slower but a bit simpler.\r\n    //--------------------------------------------------------------------------\r\n    for (let i = 0; i < rootsMinBMinF.length; i++) {\r\n        const r = rootsMinBMinF[i];\r\n        if (r < tMin) {\r\n            tMin = r;\r\n        }\r\n        if (r > tMax) {\r\n            tMax = r;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsMinBMaxF.length; i++) {\r\n        const r = rootsMinBMaxF[i];\r\n        if (r < tMin) {\r\n            tMin = r;\r\n        }\r\n        if (r > tMax) {\r\n            tMax = r;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsMaxBMinF.length; i++) {\r\n        const r = rootsMaxBMinF[i];\r\n        if (r < tMin) {\r\n            tMin = r;\r\n        }\r\n        if (r > tMax) {\r\n            tMax = r;\r\n        }\r\n    }\r\n    for (let i = 0; i < rootsMaxBMaxF.length; i++) {\r\n        const r = rootsMaxBMaxF[i];\r\n        if (r < tMin) {\r\n            tMin = r;\r\n        }\r\n        if (r > tMax) {\r\n            tMax = r;\r\n        }\r\n    }\r\n    if (dH0Max >= dMin && dH0Min <= dMax) {\r\n        tMin = 0;\r\n    }\r\n    if (dH2Max >= dMin && dH2Min <= dMax) {\r\n        tMax = 1;\r\n    }\r\n    if (tMin === Number.POSITIVE_INFINITY) {\r\n        // will have here also: `tMax === Number.NEGATIVE_INFINITY`\r\n        return noIntersection;\r\n    }\r\n    return [tMin, tMax];\r\n}\r\n/**\r\n * Floating-point-stably calculates and returns the (ordered) quadratic roots of\r\n * the given quadratic polynomial in [0,1].\r\n *\r\n * * **precondition:** the input polynomial must be quadratic (given as an array\r\n * of exactly 3 values with the first value *unequal* to zero)\r\n *\r\n * @param p a quadratic polynomial with coefficients given as an array\r\n * of double floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the quadratic `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * quadraticRoots([1, -3, 2]); //=> [1,2]\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction quadraticRoots(a, b, c) {\r\n    if (a === 0) {\r\n        if (b === 0) {\r\n            // degenerate constant (degree 0 polynomial)\r\n            if (c === 0) {\r\n                // degenerate zero polynomial (degree -infinity polynomial)\r\n                // infinite number of roots\r\n                return undefined;\r\n            }\r\n            // no roots\r\n            return [];\r\n        }\r\n        // degenerate linear\r\n        //return [-c/b];\r\n        const r = -c / b;\r\n        const E = abs(r * u);\r\n        const Emin = r - E;\r\n        const Emax = r + E;\r\n        if (Emax < 0 || Emin > 1) {\r\n            return [];\r\n        }\r\n        if (Emin < 0 && Emax > 0) {\r\n            return [0, Emax];\r\n        }\r\n        if (Emin < 1 && Emax > 1) {\r\n            return [Emin, 1];\r\n        }\r\n        // we return the root interval pairs inline to account for error\r\n        return [Emin, Emax];\r\n    }\r\n    if (c === 0) {\r\n        const r = -b / a;\r\n        const E = abs(r * u);\r\n        const Emin = r - E;\r\n        const Emax = r + E;\r\n        if (Emax < 0 || Emin > 1) {\r\n            return [0];\r\n        }\r\n        if (Emin < 0 && Emax > 0) {\r\n            return [0, Emax];\r\n        }\r\n        if (Emin < 1 && Emax > 1) {\r\n            return [0, Emin, 1];\r\n        }\r\n        // we return the root interval pairs inline to account for error\r\n        return [0, Emin, Emax];\r\n    }\r\n    const D1 = b * b; // <1>D1 (error counters)\r\n    const D2 = 4 * a * c; // <1>D2\r\n    const D = D1 - D2;\r\n    // <2>D <= D1 - D2;  // <2>(<1>D1 + <1>D2)\r\n    const _D = D1 + abs(D2);\r\n    const D_ = 2 * u * _D;\r\n    if (D + D_ < 0) {\r\n        // no real roots possible\r\n        return [];\r\n    }\r\n    // at this point `D + D_ >= 0`\r\n    if (D + D_ === 0) {\r\n        const r = -b / (2 * a);\r\n        const E = abs(r * u); // single division error\r\n        const Emin = r - E;\r\n        const Emax = r + E;\r\n        if (Emax < 0 || Emin > 1) {\r\n            return [];\r\n        }\r\n        if (Emin < 0 && Emax > 0) {\r\n            return [0, Emax];\r\n        }\r\n        if (Emin < 1 && Emax > 1) {\r\n            return [Emin, 1];\r\n        }\r\n        // we return the root interval pairs inline to account for error\r\n        return [Emin, Emax];\r\n    }\r\n    // at this point `D + D_ > 0`\r\n    const Dmin = D - D_ < 0 ? 0 : D - D_;\r\n    const DDmin = Math.sqrt(Dmin) * (onemin);\r\n    const DDmax = Math.sqrt(D + D_) * (onemax);\r\n    // at this point DDMax > 0\r\n    // at this point `DDmax > 0` and `DDmin >= 0`\r\n    let numerMaxAbs;\r\n    let numerMinAbs;\r\n    if (b >= 0) {\r\n        numerMaxAbs = -b - DDmax;\r\n        numerMinAbs = -b - DDmin;\r\n    }\r\n    else {\r\n        numerMinAbs = -b + DDmin;\r\n        numerMaxAbs = -b + DDmax;\r\n    }\r\n    const a2 = 2 * a;\r\n    const c2 = 2 * c;\r\n    //const r1 = numerMin / a2;\r\n    //const r2 = c2 / numerMin;\r\n    // at this point `numerMin` and `numerMax` have the same sign (or numerMin is zero)\r\n    let r1min;\r\n    let r1max;\r\n    let r2min;\r\n    let r2max;\r\n    if (numerMaxAbs * a2 >= 0) {\r\n        // same signs - `r1min >= 0` and `r1max > 0`\r\n        r1min = (numerMinAbs / a2) * (onemin);\r\n        r1max = (numerMaxAbs / a2) * (onemax);\r\n    }\r\n    else {\r\n        // opposite signs - `r1min <= 0` and `r1max < 0`\r\n        r1min = (numerMaxAbs / a2) * (onemax);\r\n        r1max = (numerMinAbs / a2) * (onemin);\r\n    }\r\n    if (numerMaxAbs * c2 > 0) {\r\n        // same signs - `r2min > 0` and `r2Max >= 0`\r\n        r2min = (c2 / numerMaxAbs) * (onemin);\r\n        // `r2max` cannot be a `NaN` since `c2` is > 0\r\n        r2max = (c2 / numerMinAbs) * (onemax); // could be +-inf\r\n    }\r\n    else if (numerMaxAbs * c2 < 0) {\r\n        // opposite signs - `r2min < 0` and `r2Max <= 0`\r\n        // `r2min` cannot be a `NaN` since `c2` is > 0\r\n        r2min = (c2 / numerMinAbs) * (onemax); // could be +-inf \r\n        r2max = (c2 / numerMaxAbs) * (onemin);\r\n    }\r\n    const rs = [];\r\n    if (r1max < 0 || r1min > 1) {\r\n        // root is outside of range\r\n    }\r\n    else {\r\n        // we return the root interval pairs inline\r\n        // at this stage r1min might be (slightly) < 0 and r1max > 1\r\n        rs.push(r1min < 0 ? 0 : r1min, r1max > 1 ? 1 : r1max);\r\n    }\r\n    // keep TypeScript happy; `r2max` cannot be `undefined` at this point\r\n    if (r2max < 0 || r2min > 1) {\r\n        // root is outside of range\r\n    }\r\n    else {\r\n        // we return the root interval pairs inline\r\n        // at this stage r2min might be (slightly) < 0 and r2max > 1\r\n        // keep TypeScript happy; `r2max` cannot be `undefined` at this point\r\n        rs.push(r2min < 0 ? 0 : r2min, r2max > 1 ? 1 : r2max);\r\n    }\r\n    return rs; // not ordered\r\n}\r\n\r\n//# sourceMappingURL=geo-clip.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/geo-clip.js?")},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toHybridQuadratic\": () => (/* binding */ toHybridQuadratic)\n/* harmony export */ });\n/**\r\n * Returns a hybrid quadratic bezier curve with error bounds (with the first\r\n * and last control points omitted).\r\n *\r\n * * **the returned error bounds have counters of <8> and <12> respectively for\r\n * the 1st and 2nd control points (i.e. for the hybrid control points)**\r\n * * specifically modified for use in the geometric interval bezier-bezier\r\n * intersection algorithm, e.g. for efficiency the first and last points are\r\n * not returned\r\n * * **precondition:** coordinate-wise error bound 'Wilson counters' on the\r\n * cubic bezier control points of\r\n * `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]` are assumed (due to other\r\n * parts of the algorithm)\r\n *\r\n * @param G a cubic bezier curve - coordinate error bounds are assumed to have\r\n * counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`\r\n *\r\n * @internal\r\n */\r\nfunction toHybridQuadratic(G) {\r\n    // the below is too slow\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const Gps = G.ps; // the cubic bezier curve\r\n    const G_ps = G._ps; // and its error bound coordinates\r\n    const p0 = Gps[0];\r\n    const p1 = Gps[1];\r\n    const p2 = Gps[2];\r\n    const p3 = Gps[3];\r\n    const x0 = p0[0]; // <6>x0\r\n    const y0 = p0[1]; // <6>y0\r\n    const x1 = p1[0]; // <6>x1\r\n    const y1 = p1[1]; // <6>y1\r\n    const x2 = p2[0]; // <10>x2\r\n    const y2 = p2[1]; // <10>y2\r\n    const x3 = p3[0]; // <11>x3\r\n    const y3 = p3[1]; // <11>y3\r\n    const _p0 = G_ps[0];\r\n    const _p1 = G_ps[1];\r\n    const _p2 = G_ps[2];\r\n    const _p3 = G_ps[3];\r\n    const _x0 = _p0[0];\r\n    const _y0 = _p0[1];\r\n    const _x1 = _p1[0];\r\n    const _y1 = _p1[1];\r\n    const _x2 = _p2[0];\r\n    const _y2 = _p2[1];\r\n    const _x3 = _p3[0];\r\n    const _y3 = _p3[1];\r\n    // <8> <= <8>(<7>(<0>3*<6>x1) + <6>x0)\r\n    const _hq1 = [(3 * _x1 + _x0) / 2, (3 * _y1 + _y0) / 2];\r\n    // <12> <= <12>(<11>(<0>3*<10>x2) + <11>x3)\r\n    const _hq2 = [(3 * _x2 + _x3) / 2, (3 * _y2 + _y3) / 2];\r\n    return {\r\n        hq: [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\r\n            [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]],\r\n        // error bounds (still need to be multiplied by 4*u and 6*u)\r\n        _hq: [_hq1, _hq2]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/clip/to-hybrid-quadratic.js?")},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getDistanceToLineFunction": () => (/* binding */ getDistanceToLineFunction)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst abs = Math.abs;\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\n/*\r\nfunction getDistanceToLineFunction(\r\n        pS: number[],\r\n        pE: number[]): (p: number[]) => number {\r\n\r\n    const xS = pS[0];\r\n    const yS = pS[1];\r\n    const xE = pE[0];\r\n    const yE = pE[1];\r\n\r\n    const s = yS - yE;\r\n    const t = xE - xS;\r\n    const u = qdq(tp(xS,yE), tp(xE,yS))[1];\r\n\r\n    return function(p: number[]) {\r\n        return s*p[0] + t*p[1] + u;\r\n    }\r\n}\r\n*/\r\n/**\r\n * @param pS\r\n * @param pE\r\n *\r\n * @internal\r\n */\r\nfunction getDistanceToLineFunction(pS, pE) {\r\n    const xS = pS[0];\r\n    const yS = pS[1];\r\n    const xE = pE[0];\r\n    const yE = pE[1];\r\n    // note: td(yS, yE) nearly always has low double === 0 -> could potentially be taken advantage of in future\r\n    const s = yS - yE; // <1>s\r\n    const t = xE - xS; // <1>t\r\n    const v = qdq(tp(xS, yE), tp(xE, yS))[1]; // <1>v\r\n    const _s = abs(s);\r\n    const _t = abs(t);\r\n    const _v = abs(v);\r\n    return function (p, _p) {\r\n        // error counter assumed <12> \r\n        // (the max of <3>,<5>,<8> and <12> from other functions (`fromTo3` and `toHybridQuadratic`))\r\n        const x = p[0]; // <12>x \r\n        const y = p[1]; // <12>y\r\n        //return s*x + t*y + u;\r\n        const _x = _p[0];\r\n        const _y = _p[1];\r\n        // error counter of <12> on all coordinates\r\n        const d = s * x + t * y + v;\r\n        // <16>r <= <16>(<15>(<14>(<1>s*<12>x) + <14>(<1>t*<12>y)) + <1>v)\r\n        const _d = _s * _x + _t * _y + _v;\r\n        const E = 16 * u * _d;\r\n        return { dMin: d - E, dMax: d + E };\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-distance-to-line-function.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection-fast/get-distance-to-line-function.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierBezierIntersectionBoundless": () => (/* binding */ bezierBezierIntersectionBoundless)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coefficients/get-coeffs-bez-bez.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js");\n\r\n\r\n/**\r\n * Returns the intersection between any of two linear, quadratic or cubic bezier\r\n * curves without limiting the `t` parameter value of the first given curve\r\n * in [0,1], i.e. `t ∈ [-∞,+∞]`.\r\n *\r\n * * if the two curves have an infinite number of intersections `undefined` is returned\r\n * * the second bezier curve\'s parameter `t` values are returned *ordered* by `t` value\r\n *\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order, i.e. cubics are really cubics, etc. (else\r\n * use [[reduceOrderIfPossible]] first)\r\n *\r\n * @param ps1 an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n * @param ps2 an order 1,2 or 3 bezier curve given as an array of its control\r\n * points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n *\r\n * @internal but still exported for backwards compatibility\r\n */\r\nfunction bezierBezierIntersectionBoundless(ps1, ps2) {\r\n    const { coeffs, errBound, getPExact } = (0,_get_coefficients_get_coeffs_bez_bez_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsBezBez)(ps1, ps2);\r\n    ;\r\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(coeffs, 0, 1, errBound, getPExact, true);\r\n}\r\n\r\n//# sourceMappingURL=bezier-bezier-intersection-boundless.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierBezierIntersection": () => (/* binding */ bezierBezierIntersection)\n/* harmony export */ });\n/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js");\n/* harmony import */ var _bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier-bezier-intersection-boundless.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.js");\n/* harmony import */ var _simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js");\n/* harmony import */ var _local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../local-properties-to-t/t-from-xy.js */ "./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../boxes/intersect-boxes.js */ "./node_modules/flo-bezier3/node/boxes/intersect-boxes.js");\n/* harmony import */ var _self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../self-intersection/bezier-self-intersection.js */ "./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js");\n/* harmony import */ var _get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../get-endpoint-intersections/get-endpoint-intersections.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js");\n/* harmony import */ var _global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../global-properties/classification/is-collinear.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-collinear.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transformation/reduce-order-if-possible.js */ "./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst eps = Number.EPSILON;\r\nconst eps2 = 2 * eps;\r\n/**\r\n * Returns an array of intersections between two bezier curves up to cubic order\r\n * (i.e. points, linear, quadratic or cubic bezier curves (i.e. order 0,1,2 or 3\r\n * curves).\r\n *\r\n * The algorithm employed uses advanced techniques such as floating point error\r\n * bounding, adaptive multi-precision floating point arithmetic, pre-filtering\r\n * of easy cases, certified root finding and algebraic implicitization of the\r\n * curves in order to find *guaranteed* accurate results.\r\n *\r\n * * this algorithm is mathematically guaranteed accurate to within\r\n * `4 * Number.EPSILON` in the returned `t` parameter values of the bezier\r\n * curves (bar underflow/overflow)\r\n *\r\n * * the returned intersections are *ordered* by `t` parameter value of the\r\n * first bezier curve\r\n * * if the two curves have an infinite number of intersections then the\r\n * intersection of the endpoints of each curve with the other is returned\r\n * instead (and the intersection `kind` property will equal `5`)\r\n *\r\n * * each intersection in the returned array of intersections is an object with\r\n * the following properties (see the type [[X]]`):\r\n *      * `p`: point of intersection (calculated from the guaranteed root interval)\r\n *      * `t1`: first bezier curve\'s parameter `t` value (calculated from the guaranteed root interval)\r\n *      * `t2`: second bezier curve\'s parameter `t` value (calculated from the guaranteed root interval)\r\n *      * `kind`: kind of intersection (see [[X]] for details)\r\n *      * `ri1`: first bezier curve\'s root interval guaranteed to contain the\r\n *               correct `t` value in the form `{ tS, tE, multiplicity }`,\r\n *               where `tS` and `tE` are the start and end of the interval\r\n *      * `ri2`: second bezier curve\'s root interval guaranteed to contain the\r\n *               correct `t` value in the form `{ tS, tE, multiplicity }`,\r\n *               where `tS` and `tE` are the start and end of the interval\r\n *      * `box`: small box that is guaranteed to contain the intersection\r\n *               (calculated from the guaranteed root interval)\r\n *\r\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction bezierBezierIntersection(ps1, ps2) {\r\n    ps1 = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_10__.reduceOrderIfPossible)(ps1);\r\n    ps2 = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_10__.reduceOrderIfPossible)(ps2);\r\n    if (ps1.length === 1 || ps2.length === 1) {\r\n        return handlePointDegenerateCases(ps1, ps2);\r\n    }\r\n    const ris2 = (0,_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersectionBoundless)(ps1, ps2);\r\n    if (ris2 === undefined) {\r\n        return handleInfiniteIntersections(ps1, ps2);\r\n    }\r\n    if (ris2.length === 0) {\r\n        return [];\r\n    }\r\n    // `ris1` are ordered by inersection `t` values of `ps1`\r\n    const ris1 = (0,_bezier_bezier_intersection_boundless_js__WEBPACK_IMPORTED_MODULE_1__.bezierBezierIntersectionBoundless)(ps2, ps1);\r\n    if (ris1.length === 0) {\r\n        return [];\r\n    }\r\n    let is1 = ris1.map(ri => (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(ps1, [ri.tS, ri.tE]));\r\n    let is2 = ris2.map(ri => (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(ps2, [ri.tS, ri.tE]));\r\n    let xs = [];\r\n    for (let i = 0; i < ris1.length; i++) {\r\n        let box1 = is1[i];\r\n        for (let j = 0; j < ris2.length; j++) {\r\n            let box2 = is2[j];\r\n            let box = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_5__.intersectBoxes)(box1, box2);\r\n            if (box !== undefined) {\r\n                const ri1 = ris1[i];\r\n                const ri2 = ris2[j];\r\n                let x = {\r\n                    p: (0,_x_js__WEBPACK_IMPORTED_MODULE_0__.getPFromBox)(box), kind: 1, box,\r\n                    t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri1), ri1: ri1,\r\n                    t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri2), ri2: ri2\r\n                };\r\n                xs.push(x);\r\n            }\r\n        }\r\n    }\r\n    return xs;\r\n}\r\n/**\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order\r\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\r\n * return `undefined` to represent the fact of an infinite number of\r\n * intersections exist\r\n * * **precondition:** neither bezier curve may be of order 1 (a point)\r\n *\r\n * @param ps1 an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ps2 an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction handleInfiniteIntersections(ps1, ps2) {\r\n    // At this point there are an infinite number of intersections, i.e.:\r\n    // `bezierBezierIntersectionBoundless(ps1, ps2) === undefined`\r\n    if ((0,_global_properties_classification_is_collinear_js__WEBPACK_IMPORTED_MODULE_8__.isCollinear)(ps1) && !(ps1.length === 2 && ps2.length === 2)) {\r\n        // `ps2` must also be collinear\r\n        return handleCollinearIntersections(ps1, ps2);\r\n    }\r\n    // Now neither `ps1` nor `ps2` is collinear and they are thus algebraically\r\n    // identical\r\n    return [\r\n        ...(0,_get_endpoint_intersections_get_endpoint_intersections_js__WEBPACK_IMPORTED_MODULE_7__.getEndpointIntersections)(ps1, ps2, true),\r\n        ...getCoincidingSelfIntersections(ps1, ps2)\r\n    ].sort((a, b) => a.t1 - b.t1);\r\n}\r\n/**\r\n * Get the intersection (if it exist) that is the double-point of both given\r\n * algebraically identical curves if both the double-points are given for `t`\r\n * values in `[0,1]` for each curve.\r\n *\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order\r\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\r\n * return `undefined` to represent the fact of an infinite number of\r\n * intersections exist\r\n * * **precondition:** neither curve is allowed to have all points collinear\r\n *\r\n * @param ps1 a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ps2 a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction getCoincidingSelfIntersections(ps1, ps2) {\r\n    const ts1 = (0,_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_6__.bezierSelfIntersection)(ps1, false);\r\n    const ts2 = (0,_self_intersection_bezier_self_intersection_js__WEBPACK_IMPORTED_MODULE_6__.bezierSelfIntersection)(ps2, false);\r\n    const len1 = ts1.length;\r\n    const len2 = ts2.length;\r\n    if (len1 < 1 || len2 < 1) {\r\n        return [];\r\n    }\r\n    const xs = [];\r\n    // this is a *very* rare case\r\n    for (let t1 of ts1) {\r\n        for (let t2 of ts2) {\r\n            const ri1 = { tS: t1 - eps2, tE: t1 + eps2, multiplicity: 1 };\r\n            const ri2 = { tS: t2 - eps2, tE: t2 + eps2, multiplicity: 1 };\r\n            const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_4__.getIntervalBox)(ps1, [t1 - eps2, t1 + eps2]);\r\n            // const box2 = getIntervalBox(ps2, [t2-eps2, t2+eps2]);\r\n            xs.push({\r\n                // this is actually *also* a self-intersection\r\n                p: (0,_x_js__WEBPACK_IMPORTED_MODULE_0__.getPFromBox)(box), kind: 1, box,\r\n                t1: t1, ri1: ri1,\r\n                t2: t2, ri2: ri2\r\n            });\r\n        }\r\n    }\r\n    return xs;\r\n}\r\n/**\r\n * * self-overlap is not considered, only endpoints\r\n *\r\n * * **precondition:** one curve must be of at least order 1 (line) and the\r\n * other of at least order 2 (quadratic)\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order\r\n * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must\r\n * return `undefined` to represent the fact of an infinite number of\r\n * intersections exist\r\n * * **precondition:** all points (from both curves) must be collinear\r\n *\r\n * @param psA an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param psB an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction handleCollinearIntersections(psA, psB) {\r\n    const A0 = psA[0];\r\n    const A1 = psA[psA.length - 1];\r\n    const B0 = psB[0];\r\n    const B1 = psB[psB.length - 1];\r\n    // Check for exact endpoint overlap\r\n    const overlapSS = A0[0] === B0[0] && A0[1] == B0[1];\r\n    const overlapSE = A0[0] === B1[0] && A0[1] == B1[1];\r\n    const overlapES = A1[0] === B0[0] && A1[1] == B0[1];\r\n    const overlapEE = A1[0] === B1[0] && A1[1] == B1[1];\r\n    const overlapB0 = overlapSS || overlapES;\r\n    const overlapB1 = overlapSE || overlapEE;\r\n    const root0 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.createRootExact)(0);\r\n    const root1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.createRootExact)(1);\r\n    const tA_B0 = overlapSS ? [root0] : overlapES ? [root1] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(psA, B0);\r\n    const tA_B1 = overlapSE ? [root0] : overlapEE ? [root1] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(psA, B1);\r\n    const tB_A0 = overlapSS || overlapSE ? [] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(psB, A0);\r\n    const tB_A1 = overlapES || overlapEE ? [] : (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(psB, A1);\r\n    return [\r\n        ...tA_B0.map(ri => {\r\n            const box = [B0, B0];\r\n            const kind = overlapB0 ? 4 : 5;\r\n            return {\r\n                p: B0, kind, box,\r\n                t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri1: ri,\r\n                t2: 0, ri2: root0\r\n            };\r\n        }),\r\n        ...tA_B1.map(ri => {\r\n            const box = [B1, B1];\r\n            const kind = overlapB1 ? 4 : 5;\r\n            return {\r\n                p: B1, kind, box,\r\n                t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri1: ri,\r\n                t2: 1, ri2: root1\r\n            };\r\n        }),\r\n        ...tB_A0.map(ri => {\r\n            const box = [A0, A0];\r\n            const kind = 5;\r\n            return {\r\n                p: A0, kind, box,\r\n                t1: 0, ri1: root0,\r\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri2: ri\r\n            };\r\n        }),\r\n        ...tB_A1.map(ri => {\r\n            const box = [A1, A1];\r\n            const kind = 5;\r\n            return {\r\n                p: A1, kind, box,\r\n                t1: 1, ri1: root1,\r\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri2: ri\r\n            };\r\n        })\r\n    ]\r\n        .sort((a, b) => a.t1 - b.t1);\r\n}\r\n/**\r\n * Handles the degenerate cases where either bezier curve is really a point and\r\n * returns the relevant intersections if any.\r\n *\r\n * * **precondition:** either or both bezier curves must be a point\r\n * * **precondition:** the bezier curves must be of lowest possible\r\n * representable order\r\n *\r\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param ps2 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @internal\r\n */\r\nfunction handlePointDegenerateCases(ps1, ps2) {\r\n    if (ps1.length === 1) {\r\n        const p1 = ps1[0];\r\n        const box = [p1, p1];\r\n        if (ps2.length === 1) {\r\n            const p2 = ps2[0];\r\n            if (p1[0] === p2[0] && p1[1] === p2[1]) {\r\n                // literally the same points - very degenerate\r\n                const ri = { tS: 0.5, tE: 0.5, multiplicity: 1 };\r\n                return [\r\n                    {\r\n                        p: p1, kind: 6, box,\r\n                        t1: 0.5, ri1: ri,\r\n                        t2: 0.5, ri2: ri,\r\n                    }\r\n                ];\r\n            }\r\n            return [];\r\n        }\r\n        if ((0,_simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_2__.isPointOnBezierExtension)(ps2, [[p1[0]], [p1[1]]])) {\r\n            // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`\r\n            return (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(ps2, p1).map(ri => ({\r\n                p: p1, kind: 6, box,\r\n                t1: 0.5, ri1: { tS: 0.5, tE: 0.5, multiplicity: 1 },\r\n                t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri2: ri,\r\n            }));\r\n        }\r\n        return [];\r\n    }\r\n    const p2 = ps2[0];\r\n    const box = [p2, p2];\r\n    if ((0,_simultaneous_properties_is_point_on_bezier_extension_is_point_on_bezier_extension_js__WEBPACK_IMPORTED_MODULE_2__.isPointOnBezierExtension)(ps1, [[p2[0]], [p2[1]]])) {\r\n        // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`\r\n        return (0,_local_properties_to_t_t_from_xy_js__WEBPACK_IMPORTED_MODULE_3__.tFromXY)(ps1, p2).map(ri => ({\r\n            p: p2, kind: 6, box,\r\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(ri), ri1: ri,\r\n            t2: 0.5, ri2: { tS: 0.5, tE: 0.5, multiplicity: 1 },\r\n        }));\r\n    }\r\n    return [];\r\n}\r\n\r\n//# sourceMappingURL=bezier-bezier-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/bezier-bezier-intersection.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez1Dd": () => (/* binding */ getCoeffsBez1Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of two\r\n * order 1 bezier curves (i.e. 2 lines).\r\n *\r\n * The returned polynomial degree will be 1\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, // all these are double-doubles\r\n    errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    //----------------------------------\r\n    // const v1 = c1*vₓ + d1*vᵧ;\r\n    //----------------------------------\r\n    const $p1 = $c1 * $vₓ;\r\n    const _p1 = abs($p1);\r\n    const p1_ = 2 * _p1;\r\n    const p1 = qmq(c1, vₓ);\r\n    const $p2 = $d1 * $vᵧ;\r\n    const _p2 = abs($p2);\r\n    const p2_ = 2 * _p2;\r\n    const p2 = qmq(d1, vᵧ);\r\n    const $v1 = $p1 + $p2;\r\n    //const _$v1 = abs($v1);\r\n    const v1 = qaq(p1, p2);\r\n    const v1_ = p1_ + p2_ + abs($v1);\r\n    //----------------------------------\r\n    // const v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    //----------------------------------\r\n    const $p3 = c0 * $vₓ;\r\n    const p3 = qmd(c0, vₓ);\r\n    const _p3_ = abs($p3);\r\n    const $p4 = d0 * $vᵧ;\r\n    const p4 = qmd(d0, vᵧ);\r\n    const _p4_ = abs($p4);\r\n    const $p5 = $p3 + $p4;\r\n    //const _p5 = abs($p5);\r\n    const p5 = qaq(p3, p4);\r\n    const p5_ = _p3_ + _p4_ + abs($p5);\r\n    const v0 = qaq(p5, v);\r\n    const v0_ = p5_ + v_ + abs($p5 + $v);\r\n    return {\r\n        coeffs: [v1, v0],\r\n        errBound: [γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez1-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez2Dd": () => (/* binding */ getCoeffsBez1Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const _v = abs($v);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    // --------------------------\r\n    // a2*v_x + b2*v_y\r\n    // const v2 = c2*vₓ + d2*vᵧ;\r\n    // --------------------------\r\n    const $p1 = $c2 * $vₓ;\r\n    const p1 = qmq(c2, vₓ);\r\n    const p1_ = c2_ * _vₓ + 2 * abs($p1);\r\n    const $p2 = $d2 * $vᵧ;\r\n    const p2 = qmq(d2, vᵧ);\r\n    const p2_ = d2_ * _vᵧ + 2 * abs($p2);\r\n    const $v2 = $p1 + $p2;\r\n    const v2 = qaq(p1, p2);\r\n    const v2_ = p1_ + p2_ + abs($v2);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const $p3 = $c1 * $vₓ;\r\n    const p3 = qmq(c1, vₓ);\r\n    const p3_ = 2 * abs($p3);\r\n    const $p4 = $d1 * $vᵧ;\r\n    const p4 = qmq(d1, vᵧ);\r\n    const p4_ = 2 * abs($p4);\r\n    const $v1 = $p3 + $p4;\r\n    const v1 = qaq(p3, p4);\r\n    const v1_ = p3_ + p4_ + abs($v1);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p5 = qmd(c0, vₓ);\r\n    const $p5 = c0 * $vₓ;\r\n    const p5_ = abs($p5);\r\n    const p6 = qmd(d0, vᵧ);\r\n    const $p6 = d0 * $vᵧ;\r\n    const p6_ = abs($p6);\r\n    const $p7 = $p5 + $p6;\r\n    const p7 = qaq(p5, p6);\r\n    const p7_ = p5_ + p6_ + abs($p7);\r\n    const $v0 = $p7 + $v;\r\n    const v0 = qaq(p7, v);\r\n    const v0_ = p7_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez2-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez3Dd": () => (/* binding */ getCoeffsBez1Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez3Dd(ps1, ps2) {\r\n    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm1DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const _vₓ = abs(vₓ[1]);\r\n    const _vᵧ = abs(vᵧ[1]);\r\n    // a3*v_x + b3*v_y\r\n    //const v3 = c3*vₓ + d3*vᵧ;\r\n    const p1 = qmq(c3, vₓ); // vₓ is error free\r\n    const p1_ = c3_ * _vₓ + 2 * abs(p1[1]);\r\n    const p2 = qmq(d3, vᵧ); // vᵧ is error free\r\n    const p2_ = d3_ * _vᵧ + 2 * abs(p2[1]);\r\n    const v3 = qaq(p1, p2);\r\n    const v3_ = p1_ + p2_ + abs(v3[1]);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p3 = qmq(c2, vₓ); // vₓ is error free\r\n    const p3_ = c2_ * _vₓ + 2 * abs(p3[1]);\r\n    const p4 = qmq(d2, vᵧ); // vᵧ is error free\r\n    const p4_ = d2_ * _vᵧ + 2 * abs(p4[1]);\r\n    const v2 = qaq(p3, p4);\r\n    const v2_ = p3_ + p4_ + abs(v2[1]);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p5 = qmq(c1, vₓ); // vₓ is error free\r\n    const p5_ = c1_ * _vₓ + 2 * abs(p5[1]);\r\n    const p6 = qmq(d1, vᵧ); // vᵧ is error free\r\n    const p6_ = d1_ * _vᵧ + 2 * abs(p6[1]);\r\n    const v1 = qaq(p5, p6);\r\n    const v1_ = p5_ + p6_ + abs(v1[1]);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p7 = qmd(c0, vₓ); // vₓ is error free\r\n    const p7_ = abs(p7[1]);\r\n    const p8 = qmd(d0, vᵧ); // vᵧ is error free\r\n    const p8_ = abs(p8[1]);\r\n    const p9 = qaq(p7, p8);\r\n    const p9_ = p7_ + p8_ + abs(p9[1]);\r\n    const v0 = qaq(p9, v);\r\n    const v0_ = p9_ + v_ + abs(v0[1]);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez3-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez1Dd": () => (/* binding */ getCoeffsBez2Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_3__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d1d1 = $d1 * $d1;\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1_ = abs($c0c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const _c1c1 = abs($c1c1);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * _c1c1;\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const _c1d1 = abs($c1d1);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * _c1d1;\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1_ = abs($d0d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * _d1d1;\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    const $p1 = $c1c1 * $vₓₓ;\r\n    const p1 = qmq(c1c1, vₓₓ);\r\n    const p1_ = c1c1_ * _vₓₓ * _c1c1 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $d1d1 * $vᵧᵧ;\r\n    const p2 = qmq(d1d1, vᵧᵧ);\r\n    const p2_ = d1d1_ * _vᵧᵧ * _d1d1 * vᵧᵧ_ + 2 * abs($p2);\r\n    const $p3 = $c1d1 * $vₓᵧ;\r\n    const p3 = qmq(c1d1, vₓᵧ);\r\n    const p3_ = c1d1_ * _vₓᵧ * _c1d1 * vₓᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v2 = $p4 + $p3;\r\n    const v2 = qaq(p4, p3);\r\n    const v2_ = p4_ + p3_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    const $p5 = $c0c1 * $vₓₓ;\r\n    const p5 = qmq(c0c1, vₓₓ);\r\n    const p5_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($p5);\r\n    const $p6 = $d0d1 * $vᵧᵧ;\r\n    const p6 = qmq(d0d1, vᵧᵧ);\r\n    const p6_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($p6);\r\n    const $p7 = $c0d1 + $c1d0;\r\n    const p7 = qaq(c0d1, c1d0);\r\n    const p7_ = c0d1_ + c1d0_ + abs($p7);\r\n    const $pn = $p7 * $vₓᵧ;\r\n    const pn = qmq(p7, vₓᵧ);\r\n    const pn_ = p7_ * _vₓᵧ + abs($p7) * vₓᵧ_ + 2 * abs($pn);\r\n    const $p8 = 2 * ($p5 + $p6);\r\n    const p8 = qm2(qaq(p5, p6));\r\n    const p8_ = 2 * (p5_ + p6_) + abs($p8);\r\n    const $p9 = $p8 + $pn;\r\n    const p9 = qaq(p8, pn);\r\n    const p9_ = p8_ + pn_ + abs($p9);\r\n    const $pa = $c1 * $vₓ;\r\n    const pa = qmq(c1, vₓ);\r\n    const pa_ = _c1 * vₓ_ + 2 * abs($pa);\r\n    const $pb = $d1 * $vᵧ;\r\n    const pb = qmq(d1, vᵧ);\r\n    const pb_ = _d1 * vᵧ_ + 2 * abs($pb);\r\n    const $pc = $pa + $pb;\r\n    const pc = qaq(pa, pb);\r\n    const pc_ = pa_ + pb_ + abs($pc);\r\n    const $v1 = $p9 + $pc;\r\n    const v1 = qaq(p9, pc);\r\n    const v1_ = p9_ + pc_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    const $pe = $c0c0 * $vₓₓ;\r\n    const pe = qmq(c0c0, vₓₓ);\r\n    const pe_ = 2 * abs($pe);\r\n    const $pf = $c0d0 * $vₓᵧ;\r\n    const pf = qmq(c0d0, vₓᵧ);\r\n    const pf_ = 2 * abs($pf);\r\n    const $pg = $d0d0 * $vᵧᵧ;\r\n    const pg = qmq(d0d0, vᵧᵧ);\r\n    const pg_ = 2 * abs($pg);\r\n    const $ph = $pe + $pf;\r\n    const ph = qaq(pe, pf);\r\n    const ph_ = pe_ + pf_ + abs($ph);\r\n    const $pi = $ph + $pg;\r\n    const pi = qaq(ph, pg);\r\n    const pi_ = ph_ + pg_ + abs($pi);\r\n    const $pj = c0 * $vₓ;\r\n    const pj = qmd(c0, vₓ);\r\n    const pj_ = _c0 * vₓ_ + abs($pj);\r\n    const $pk = d0 * $vᵧ;\r\n    const pk = qmd(d0, vᵧ);\r\n    const pk_ = _d0 * vᵧ_ + abs($pk);\r\n    const $pl = $pj + $pk;\r\n    const pl = qaq(pj, pk);\r\n    const pl_ = pj_ + pk_ + abs($pl);\r\n    const $pm = $pi + $pl;\r\n    const pm = qaq(pi, pl);\r\n    const pm_ = pi_ + pl_ + abs($pm);\r\n    const $v0 = $pm + $v;\r\n    const v0 = qaq(pm, v);\r\n    const v0_ = pm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v2, v1, v0],\r\n        errBound: [γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez1-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez2Dd": () => (/* binding */ getCoeffsBez2Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\r\n *\r\n * The returned polynomial degree will be 4\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_3__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d2d2 = $d2 * $d2;\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0d0 = abs($c0d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1_ = abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const _c0c2_ = abs($c0c2);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const _c0d1_ = abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const _c0d2_ = abs($c0d2);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const _c1c2 = abs($c1c2);\r\n    const c1c2_ = _c1 * c2_ + 2 * _c1c2;\r\n    const c1d0 = qmd(d0, c1);\r\n    const _c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\r\n    const c2d0 = qmd(d0, c2);\r\n    const _c2d0_ = abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const _c2d2 = abs($c2d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * _c2d2;\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1_ = abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const _d0d2_ = abs($d0d2);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const _d1d2 = abs($d1d2);\r\n    const d1d2_ = _d1 * d2_ + 2 * _d1d2;\r\n    const d2d2 = qmq(d2, d2);\r\n    const _d2d2 = abs($d2d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //const v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    const $p1 = $c2c2 * $vₓₓ;\r\n    const p1 = qmq(c2c2, vₓₓ);\r\n    const p1_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $c2d2 * $vₓᵧ;\r\n    const p2 = qmq(c2d2, vₓᵧ);\r\n    const p2_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($p2);\r\n    const $p3 = $d2d2 * $vᵧᵧ;\r\n    const p3 = qmq(d2d2, vᵧᵧ);\r\n    const p3_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v4 = $p4 + $p3;\r\n    const v4 = qaq(p4, p3);\r\n    const v4_ = p4_ + p3_ + abs($v4);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    const $p5 = $c1c2 * $vₓₓ;\r\n    const p5 = qmq(c1c2, vₓₓ);\r\n    const p5_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($p5);\r\n    const $p6 = $d1d2 * $vᵧᵧ;\r\n    const p6 = qmq(d1d2, vᵧᵧ);\r\n    const p6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($p6);\r\n    const $p7 = $c1d2 + $c2d1;\r\n    const p7 = qaq(c1d2, c2d1);\r\n    const _p7 = abs($p7);\r\n    const p7_ = c1d2_ + c2d1_ + _p7;\r\n    const $p8 = $p7 * $vₓᵧ;\r\n    const p8 = qmq(p7, vₓᵧ);\r\n    const p8_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + 2 * abs($p8);\r\n    const $p9 = 2 * ($p5 + $p6);\r\n    const p9 = qm2(qaq(p5, p6));\r\n    const p9_ = 2 * (p5_ + p6_) + abs($p9);\r\n    const $v3 = $p9 + $p8;\r\n    const v3 = qaq(p9, p8);\r\n    const v3_ = p9_ + p8_ + abs($v3);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    const $pa = 2 * $c0c2 + $c1c1;\r\n    const _pa = abs($pa);\r\n    const pa = qaq(qm2(c0c2), c1c1);\r\n    const pa_ = 2 * _c0c2_ + c1c1_ + abs($pa);\r\n    const $pb = 2 * $d0d2 + $d1d1;\r\n    const _pb = abs($pb);\r\n    const pb = qaq(qm2(d0d2), d1d1);\r\n    const pb_ = 2 * _d0d2_ + d1d1_ + abs($pb);\r\n    const $pc = $c0d2 + $c1d1;\r\n    const _pc = abs($pc);\r\n    const pc = qaq(c0d2, c1d1);\r\n    const pc_ = _c0d2_ + c1d1_ + abs($pc);\r\n    const $pd = $pc + $c2d0;\r\n    const pd = qaq(pc, c2d0);\r\n    const _pd = abs($pd);\r\n    const pd_ = pc_ + _c2d0_ + _pd;\r\n    const $pe = $pa * $vₓₓ;\r\n    const pe = qmq(pa, vₓₓ);\r\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\r\n    const $pf = $pb * $vᵧᵧ;\r\n    const pf = qmq(pb, vᵧᵧ);\r\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\r\n    const $pg = $pd * $vₓᵧ;\r\n    const pg = qmq(pd, vₓᵧ);\r\n    const pg_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($pg);\r\n    const $ph = $c2 * $vₓ;\r\n    const ph = qmq(c2, vₓ);\r\n    const ph_ = c2_ * _vₓ + _c2 * vₓ_ + abs($ph);\r\n    const $pi = $d2 * $vᵧ;\r\n    const pi = qmq(d2, vᵧ);\r\n    const pi_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($pi);\r\n    const $pj = $pe + $pf;\r\n    const pj = qaq(pe, pf);\r\n    const pj_ = pe_ + pf_ + abs($pj);\r\n    const $pk = $pj + $pg;\r\n    const pk = qaq(pj, pg);\r\n    const pk_ = pj_ + pg_ + abs($pk);\r\n    const $pl = $ph + $pi;\r\n    const pl = qaq(ph, pi);\r\n    const pl_ = ph_ + pi_ + abs($pl);\r\n    const $v2 = $pk + $pl;\r\n    const v2 = qaq(pk, pl);\r\n    const v2_ = pk_ + pl_ + abs($v2);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    const $pm = $c0c1 * $vₓₓ;\r\n    const pm = qmq(c0c1, vₓₓ);\r\n    const pm_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * abs($pm);\r\n    const $pn = $d0d1 * $vᵧᵧ;\r\n    const pn = qmq(d0d1, vᵧᵧ);\r\n    const pn_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * abs($pn);\r\n    const $po = $c0d1 + $c1d0;\r\n    const po = qaq(c0d1, c1d0);\r\n    const _po = abs($po);\r\n    const po_ = _c0d1_ + _c1d0_ + _po;\r\n    const $pp = $po * $vₓᵧ;\r\n    const pp = qmq(po, vₓᵧ);\r\n    const pp_ = po_ * _vₓᵧ + _po * vₓᵧ_ + 2 * abs($pp);\r\n    const $pq = 2 * ($pm + $pn);\r\n    const pq = qm2(qaq(pm, pn));\r\n    const pq_ = 2 * (pm_ + pn_) + abs($pq);\r\n    const $pr = $c1 * $vₓ;\r\n    const pr = qmq(c1, vₓ);\r\n    const pr_ = _c1 * vₓ_ + 2 * abs($pr);\r\n    const $ps = $d1 * $vᵧ;\r\n    const ps = qmq(d1, vᵧ);\r\n    const ps_ = _d1 * vᵧ_ + 2 * abs($ps);\r\n    const $pt = $pq + $pp;\r\n    const pt = qaq(pq, pp);\r\n    const pt_ = pq_ + pp_ + abs($pt);\r\n    const $pu = $pr + $ps;\r\n    const pu = qaq(pr, ps);\r\n    const pu_ = pr_ + ps_ + abs($pu);\r\n    const $v1 = $pt + $pu;\r\n    const v1 = qaq(pt, pu);\r\n    const v1_ = pt_ + pu_ + abs($v1);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    const $pv = $c0c0 * $vₓₓ;\r\n    const pv = qmq(c0c0, vₓₓ);\r\n    const pv_ = _c0c0 * vₓₓ_ + 2 * abs($pv);\r\n    const $pw = $c0d0 * $vₓᵧ;\r\n    const pw = qmq(c0d0, vₓᵧ);\r\n    const pw_ = _c0d0 * vₓᵧ_ + 2 * abs($pw);\r\n    const $px = $d0d0 * $vᵧᵧ;\r\n    const px = qmq(d0d0, vᵧᵧ);\r\n    const px_ = _d0d0 * vᵧᵧ_ + 2 * abs($px);\r\n    const $py = c0 * $vₓ;\r\n    const py = qmd(c0, vₓ);\r\n    const py_ = _c0 * vₓ_ + abs($py);\r\n    const $pz = d0 * $vᵧ;\r\n    const pz = qmd(d0, vᵧ);\r\n    const pz_ = _d0 * vᵧ_ + abs($pz);\r\n    const $q1 = $pv + $pw;\r\n    const q1 = qaq(pv, pw);\r\n    const q1_ = pv_ + pw_ + abs($q1);\r\n    const $q2 = $q1 + $px;\r\n    const q2 = qaq(q1, px);\r\n    const q2_ = q1_ + px_ + abs($q2);\r\n    const $q3 = $py + $pz;\r\n    const q3 = qaq(py, pz);\r\n    const q3_ = py_ + pz_ + abs($q3);\r\n    const $q4 = $q2 + $q3;\r\n    const q4 = qaq(q2, q3);\r\n    const q4_ = q2_ + q3_ + abs($q4);\r\n    const $v0 = $q4 + $v;\r\n    const v0 = qaq(q4, v);\r\n    const v0_ = q4_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez2-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez3Dd": () => (/* binding */ getCoeffsBez2Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_3__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n  * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez3Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm2DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $c3 = c3[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const $d3 = d3[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _c3 = abs($c3);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const _d3 = abs($d3);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0c3 = c0 * $c3;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c0d3 = c0 * $d3;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1c3 = $c1 * $c3;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c1d3 = $c1 * $d3;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2c3 = $c2 * $c3;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $c2d3 = $c2 * $d3;\r\n    const $c3c3 = $c3 * $c3;\r\n    const $c3d0 = $c3 * d0;\r\n    const $c3d1 = $c3 * $d1;\r\n    const $c3d2 = $c3 * $d2;\r\n    const $c3d3 = $c3 * $d3;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d0d3 = d0 * $d3;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d3d3 = $d3 * $d3;\r\n    const $d2d2 = $d2 * $d2;\r\n    const $d2d3 = $d2 * $d3;\r\n    const $d1d3 = $d1 * $d3;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const _c0c0 = abs($c0c0);\r\n    const c0c1 = qmd(c0, c1);\r\n    const _c0c1 = abs($c0c1);\r\n    const c0c1_ = _c0 * c1_ + _c0c1;\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0c3 = qmd(c0, c3);\r\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const _c0d0 = abs($c0d0);\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c0d3 = qmd(c0, d3);\r\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = c1_ * _c1 + _c1 * c1_ + 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1c3 = qmq(c1, c3);\r\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\r\n    const c1d3 = qmq(c1, d3);\r\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const c2c2_ = c2_ * _c2 + _c2 * c2_ + 2 * abs($c2c2);\r\n    const c2c3 = qmq(c2, c3);\r\n    const _c2c3 = abs($c2c3);\r\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * _c2c3;\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const c2d3 = qmq(c2, d3);\r\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\r\n    const c3c3 = qmq(c3, c3);\r\n    const _c3c3 = abs($c3c3);\r\n    const c3c3_ = c3_ * _c3 + _c3 * c3_ + 2 * _c3c3;\r\n    const c3d0 = qmd(d0, c3);\r\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\r\n    const c3d1 = qmq(c3, d1);\r\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\r\n    const c3d2 = qmq(c3, d2);\r\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * abs($c3d2);\r\n    const c3d3 = qmq(c3, d3);\r\n    const _c3d3 = abs($c3d3);\r\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * _c3d3;\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const _d0d0 = abs($d0d0);\r\n    const d0d1 = qmd(d0, d1);\r\n    const _d0d1 = abs($d0d1);\r\n    const d0d1_ = _d0 * d1_ + _d0d1;\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d0d3 = qmd(d0, d3);\r\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = d1_ * _d1 + _d1 * d1_ + 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\r\n    const d3d3 = qmq(d3, d3);\r\n    const _d3d3 = abs($d3d3);\r\n    const d3d3_ = d3_ * _d3 + _d3 * d3_ + 2 * _d3d3;\r\n    const d2d2 = qmq(d2, d2);\r\n    const d2d2_ = d2_ * _d2 + _d2 * d2_ + 2 * abs($d2d2);\r\n    const d2d3 = qmq(d2, d3);\r\n    const _d2d3 = abs($d2d3);\r\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * _d2d3;\r\n    const d1d3 = qmq(d1, d3);\r\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * abs($d1d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //const v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    const $p1 = $c3c3 * $vₓₓ;\r\n    const p1 = qmq(c3c3, vₓₓ);\r\n    const p1_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($p1);\r\n    const $p2 = $c3d3 * $vₓᵧ;\r\n    const p2 = qmq(c3d3, vₓᵧ);\r\n    const p2_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($p2);\r\n    const $p3 = $d3d3 * $vᵧᵧ;\r\n    const p3 = qmq(d3d3, vᵧᵧ);\r\n    const p3_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $v6 = $p4 + $p3;\r\n    const v6 = qaq(p4, p3);\r\n    const v6_ = p4_ + p3_ + abs($v6);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //const v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    const $p5 = $c2c3 * $vₓₓ;\r\n    const p5 = qmq(c2c3, vₓₓ);\r\n    const p5_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($p5);\r\n    const $p6 = $d2d3 * $vᵧᵧ;\r\n    const p6 = qmq(d2d3, vᵧᵧ);\r\n    const p6_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($p6);\r\n    const $p7 = $p5 + $p6;\r\n    const p7 = qaq(p5, p6);\r\n    const p7_ = p5_ + p6_ + abs($p7);\r\n    const $p8 = $c2d3 + $c3d2;\r\n    const p8 = qaq(c2d3, c3d2);\r\n    const _p8 = abs($p8);\r\n    const p8_ = c2d3_ + c3d2_ + _p8;\r\n    const $p9 = $p8 * $vₓᵧ;\r\n    const p9 = qmq(p8, vₓᵧ);\r\n    const p9_ = p8_ * _vₓᵧ + _p8 * vₓᵧ_ + 2 * abs($p9);\r\n    const $v5 = 2 * $p7 + $p9;\r\n    const v5 = qaq(qm2(p7), p9);\r\n    const v5_ = 2 * p7_ + p9_ + abs($v5);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //const v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    const $pa = 2 * $c1c3 + $c2c2;\r\n    const pa = qaq(qm2(c1c3), c2c2);\r\n    const _pa = abs($pa);\r\n    const pa_ = 2 * c1c3_ + c2c2_ + abs($pa);\r\n    const $pb = 2 * $d1d3 + $d2d2;\r\n    const pb = qaq(qm2(d1d3), d2d2);\r\n    const _pb = abs($pb);\r\n    const pb_ = 2 * d1d3_ + d2d2_ + abs($pb);\r\n    const $pc = $c1d3 + $c2d2;\r\n    const pc = qaq(c1d3, c2d2);\r\n    const pc_ = c1d3_ + c2d2_ + abs($pc);\r\n    const $pd = $pc + $c3d1;\r\n    const pd = qaq(pc, c3d1);\r\n    const _pd = abs($pd);\r\n    const pd_ = pc_ + c3d1_ + _pd;\r\n    const $pe = $pa * $vₓₓ;\r\n    const pe = qmq(pa, vₓₓ);\r\n    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * abs($pe);\r\n    const $pf = $pb * $vᵧᵧ;\r\n    const pf = qmq(pb, vᵧᵧ);\r\n    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * abs($pf);\r\n    const $pg = $pe + $pf;\r\n    const pg = qaq(pe, pf);\r\n    const pg_ = pe_ + pf_ + abs($pg);\r\n    const $rp = $pd * $vₓᵧ;\r\n    const rp = qmq(pd, vₓᵧ);\r\n    const rp_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * abs($rp);\r\n    const $v4 = $pg + $rp;\r\n    const v4 = qaq(pg, rp);\r\n    const v4_ = pg_ + rp_ + abs($v4);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //const v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    const $ph = $c0c3 + $c1c2;\r\n    const ph = qaq(c0c3, c1c2);\r\n    const _ph = abs($ph);\r\n    const ph_ = c0c3_ + c1c2_ + _ph;\r\n    const $pi = $d0d3 + $d1d2;\r\n    const pi = qaq(d0d3, d1d2);\r\n    const _pi = abs($pi);\r\n    const pi_ = d0d3_ + d1d2_ + _pi;\r\n    const $pj = $c0d3 + $c1d2;\r\n    const pj = qaq(c0d3, c1d2);\r\n    const pj_ = c0d3_ + c1d2_ + abs($pj);\r\n    const $pk = $c2d1 + $c3d0;\r\n    const pk = qaq(c2d1, c3d0);\r\n    const pk_ = c2d1_ + c3d0_ + abs($pk);\r\n    const $pl = $pj + $pk;\r\n    const pl = qaq(pj, pk);\r\n    const _pl = abs($pl);\r\n    const pl_ = pj_ + pk_ + _pl;\r\n    const $pm = $ph * $vₓₓ;\r\n    const pm = qmq(ph, vₓₓ);\r\n    const pm_ = ph_ * _vₓₓ + _ph * vₓₓ_ + 2 * abs($pm);\r\n    const $pn = $pi * $vᵧᵧ;\r\n    const pn = qmq(pi, vᵧᵧ);\r\n    const pn_ = pi_ * _vᵧᵧ + _pi * vᵧᵧ_ + 2 * abs($pn);\r\n    const $po = 2 * ($pm + $pn);\r\n    const po = qm2(qaq(pm, pn));\r\n    const po_ = 2 * (pm_ + pn_) + abs($po);\r\n    const $pp = $pl * $vₓᵧ;\r\n    const pp = qmq(pl, vₓᵧ);\r\n    const pp_ = pl_ * _vₓᵧ + _pl * vₓᵧ_ + 2 * abs($pp);\r\n    const $rn = $c3 * $vₓ;\r\n    const rn = qmq(c3, vₓ);\r\n    const rn_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($rn);\r\n    const $ro = $d3 * $vᵧ;\r\n    const ro = qmq(d3, vᵧ);\r\n    const ro_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($ro);\r\n    const $pq = $rn + $ro;\r\n    const pq = qaq(rn, ro);\r\n    const pq_ = rn_ + ro_ + abs($pq);\r\n    const $pr = $po + $pp;\r\n    const pr = qaq(po, pp);\r\n    const pr_ = po_ + pp_ + abs($pr);\r\n    const $v3 = $pr + $pq;\r\n    const v3 = qaq(pr, pq);\r\n    const v3_ = pr_ + pq_ + abs($v3);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //const v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const $ps = 2 * $c0c2 + $c1c1;\r\n    const ps = qaq(qm2(c0c2), c1c1);\r\n    const _ps = abs($ps);\r\n    const ps_ = 2 * c0c2_ + c1c1_ + _ps;\r\n    const $pt = 2 * $d0d2 + $d1d1;\r\n    const pt = qaq(qm2(d0d2), d1d1);\r\n    const _pt = abs($pt);\r\n    const pt_ = 2 * d0d2_ + d1d1_ + _pt;\r\n    const $pu = $c0d2 + $c1d1;\r\n    const pu = qaq(c0d2, c1d1);\r\n    const pu_ = c0d2_ + c1d1_ + abs($pu);\r\n    const $pv = $pu + $c2d0;\r\n    const pv = qaq(pu, c2d0);\r\n    const _pv = abs($pv);\r\n    const pv_ = pu_ + c2d0_ + _pv;\r\n    const $pw = $ps * $vₓₓ;\r\n    const pw = qmq(ps, vₓₓ);\r\n    const pw_ = ps_ * _vₓₓ + _ps * vₓₓ_ + 2 * abs($pw);\r\n    const $px = $pt * $vᵧᵧ;\r\n    const px = qmq(pt, vᵧᵧ);\r\n    const px_ = pt_ * _vᵧᵧ + _pt * vᵧᵧ_ + 2 * abs($px);\r\n    const $py = $pv * $vₓᵧ;\r\n    const py = qmq(pv, vₓᵧ);\r\n    const py_ = pv_ * _vₓᵧ + _pv * vₓᵧ_ + 2 * abs($py);\r\n    const $pz = $pw + $px;\r\n    const pz = qaq(pw, px);\r\n    const pz_ = pw_ + px_ + abs($pz);\r\n    const $r1 = $pz + $py;\r\n    const r1 = qaq(pz, py);\r\n    const r1_ = pz_ + py_ + abs($r1);\r\n    const $r2 = $c2 * $vₓ;\r\n    const r2 = qmq(c2, vₓ);\r\n    const r2_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($r2);\r\n    const $r3 = $d2 * $vᵧ;\r\n    const r3 = qmq(d2, vᵧ);\r\n    const r3_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($r3);\r\n    const $r4 = $r2 + $r3;\r\n    const r4 = qaq(r2, r3);\r\n    const r4_ = r2_ + r3_ + abs($r4);\r\n    const $v2 = $r1 + $r4;\r\n    const v2 = qaq(r1, r4);\r\n    const v2_ = r1_ + r4_ + abs($v2);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //const v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    const $r5 = $c0c1 * $vₓₓ;\r\n    const r5 = qmq(c0c1, vₓₓ);\r\n    const r5_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($r5);\r\n    const $r6 = $d0d1 * $vᵧᵧ;\r\n    const r6 = qmq(d0d1, vᵧᵧ);\r\n    const r6_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($r6);\r\n    const $r7 = $c0d1 + $c1d0;\r\n    const r7 = qaq(c0d1, c1d0);\r\n    const _r7 = abs($r7);\r\n    const r7_ = c0d1_ + c1d0_ + _r7;\r\n    const $r8 = $r7 * $vₓᵧ;\r\n    const r8 = qmq(r7, vₓᵧ);\r\n    const r8_ = r7_ * _vₓᵧ + _r7 * vₓᵧ_ + 2 * abs($r8);\r\n    const $r9 = 2 * ($r5 + $r6);\r\n    const r9 = qm2(qaq(r5, r6));\r\n    const r9_ = 2 * (r5_ + r6_) + abs($r9);\r\n    const $ra = $r9 + $r8;\r\n    const ra = qaq(r9, r8);\r\n    const ra_ = r9_ + r8_ + abs($ra);\r\n    const $rb = $c1 * $vₓ;\r\n    const rb = qmq(c1, vₓ);\r\n    const rb_ = c1_ * _vₓ + _c1 * vₓ_ + 2 * abs($rb);\r\n    const $rc = $d1 * $vᵧ;\r\n    const rc = qmq(d1, vᵧ);\r\n    const rc_ = d1_ * _vᵧ + _d1 * vᵧ_ + 2 * abs($rc);\r\n    const $rd = $rb + $rc;\r\n    const rd = qaq(rb, rc);\r\n    const rd_ = rb_ + rc_ + abs($rd);\r\n    const $v1 = $ra + $rd;\r\n    const v1 = qaq(ra, rd);\r\n    const v1_ = ra_ + rd_ + abs($v1);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const $re = $c0c0 * $vₓₓ;\r\n    const re = qmq(c0c0, vₓₓ);\r\n    const re_ = _c0c0 * vₓₓ_ + 2 * abs($re);\r\n    const $rf = $c0d0 * $vₓᵧ;\r\n    const rf = qmq(c0d0, vₓᵧ);\r\n    const rf_ = _c0d0 * vₓᵧ_ + 2 * abs($rf);\r\n    const $rg = $d0d0 * $vᵧᵧ;\r\n    const rg = qmq(d0d0, vᵧᵧ);\r\n    const rg_ = _d0d0 * vᵧᵧ_ + 2 * abs($rg);\r\n    const $rh = c0 * $vₓ;\r\n    const rh = qmd(c0, vₓ);\r\n    const rh_ = _c0 * vₓ_ + abs($rh);\r\n    const $ri = d0 * $vᵧ;\r\n    const ri = qmd(d0, vᵧ);\r\n    const ri_ = _d0 * vᵧ_ + abs($ri);\r\n    const $rj = $re + $rf;\r\n    const rj = qaq(re, rf);\r\n    const rj_ = re_ + rf_ + abs($rj);\r\n    const $rk = $rj + $rg;\r\n    const rk = qaq(rj, rg);\r\n    const rk_ = rj_ + rg_ + abs($rk);\r\n    const $rl = $rh + $ri;\r\n    const rl = qaq(rh, ri);\r\n    const rl_ = rh_ + ri_ + abs($rl);\r\n    const $rm = $rk + $rl;\r\n    const rm = qaq(rk, rl);\r\n    const rm_ = rk_ + rl_ + abs($rm);\r\n    const $v0 = $rm + $v;\r\n    const v0 = qaq(rm, v);\r\n    const v0_ = rm_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez3-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez1Dd": () => (/* binding */ getCoeffsBez3Bez1Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_3__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez1Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const [[c1, [, c0]], [d1, [, d0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const $c1 = c1[1];\r\n    const $d1 = d1[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d1d1 = $d1 * $d1;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = abs($c0c1);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = abs($d0d1);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c0d0 = abs($c0d0);\r\n    const _c0d1 = abs($c0d1);\r\n    const _c1c1 = abs($c1c1);\r\n    const _c1d0 = abs($c1d0);\r\n    const _c1d1 = abs($c1d1);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const $z1 = c0 * $vₓₓₓ;\r\n    const z1 = qmd(c0, vₓₓₓ);\r\n    const z1_ = _c0 * vₓₓₓ_ + abs($z1);\r\n    const $za = 3 * c0;\r\n    const za = tp(3, c0);\r\n    const _za = abs($za);\r\n    const $z7 = $za * $vₓₓₓ;\r\n    const z7 = qmq(za, vₓₓₓ);\r\n    const z7_ = _za * vₓₓₓ_ + 2 * abs($z7);\r\n    const $z2 = c0 * $vₓₓᵧ;\r\n    const z2 = qmd(c0, vₓₓᵧ);\r\n    const z2_ = _c0 * vₓₓᵧ_ + abs($z2);\r\n    const $z3 = d0 * $vₓₓᵧ;\r\n    const z3 = qmd(d0, vₓₓᵧ);\r\n    const z3_ = _d0 * vₓₓᵧ_ + abs($z3);\r\n    const $z4 = c0 * $vₓᵧᵧ;\r\n    const z4 = qmd(c0, vₓᵧᵧ);\r\n    const z4_ = _c0 * vₓᵧᵧ_ + abs($z4);\r\n    const $z5 = d0 * $vₓᵧᵧ;\r\n    const z5 = qmd(d0, vₓᵧᵧ);\r\n    const z5_ = _d0 * vₓᵧᵧ_ + abs($z5);\r\n    const $z6 = d0 * $vᵧᵧᵧ;\r\n    const z6 = qmd(d0, vᵧᵧᵧ);\r\n    const z6_ = _d0 * vᵧᵧᵧ_ + abs($z6);\r\n    const $zb = 3 * d0;\r\n    const zb = tp(3, d0);\r\n    const _zb = abs($zb);\r\n    const $z8 = $zb * $vᵧᵧᵧ;\r\n    const z8 = qmq(zb, vᵧᵧᵧ);\r\n    const z8_ = _zb * vᵧᵧᵧ_ + 2 * abs($z8);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //const v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    const $u1 = $c1 * $vₓₓₓ;\r\n    const u1 = qmq(c1, vₓₓₓ);\r\n    const u1_ = _c1 * vₓₓₓ_ + 2 * abs($u1);\r\n    const $u2 = $c1 * $vₓᵧᵧ;\r\n    const u2 = qmq(c1, vₓᵧᵧ);\r\n    const u2_ = _c1 * vₓᵧᵧ_ + 2 * abs($u2);\r\n    const $u3 = $d1 * $vₓₓᵧ;\r\n    const u3 = qmq(d1, vₓₓᵧ);\r\n    const u3_ = _d1 * vₓₓᵧ_ + 2 * abs($u3);\r\n    const $u4 = $d1 * $vᵧᵧᵧ;\r\n    const u4 = qmq(d1, vᵧᵧᵧ);\r\n    const u4_ = _d1 * vᵧᵧᵧ_ + 2 * abs($u4);\r\n    const $u5 = $u1 + $u3;\r\n    const u5 = qaq(u1, u3);\r\n    const _u5 = abs($u5);\r\n    const u5_ = u1_ + u3_ + _u5;\r\n    const $u6 = $u2 + $u4;\r\n    const u6 = qaq(u2, u4);\r\n    const _u6 = abs($u6);\r\n    const u6_ = u2_ + u4_ + _u6;\r\n    const $u7 = $c1c1 * $u5;\r\n    const u7 = qmq(c1c1, u5);\r\n    const u7_ = c1c1_ * _u5 + _c1c1 * u5_ + 2 * abs($u7);\r\n    const $u8 = $d1d1 * $u6;\r\n    const u8 = qmq(d1d1, u6);\r\n    const u8_ = d1d1_ * _u6 + _d1d1 * u6_ + 2 * abs($u8);\r\n    const $v3 = $u7 + $u8;\r\n    const v3 = qaq(u7, u8);\r\n    const v3_ = u7_ + u8_ + abs($v3);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //const v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //const v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    const $u9 = $z7 + $z3;\r\n    const u9 = qaq(z7, z3);\r\n    const u9_ = z7_ + z3_ + abs($u9);\r\n    const $ua = 2 * ($z2 + $z5);\r\n    const ua = qm2(qaq(z2, z5));\r\n    const ua_ = 2 * (z2_ + z5_) + abs($ua);\r\n    const $ub = $z4 + $z8;\r\n    const ub = qaq(z4, z8);\r\n    const ub_ = z4_ + z8_ + abs($ub);\r\n    const $uc = $u9 + $vₓₓ;\r\n    const uc = qaq(u9, vₓₓ);\r\n    const _uc = abs($uc);\r\n    const uc_ = u9_ + vₓₓ_ + _uc;\r\n    const $ud = $ua + $vₓᵧ;\r\n    const ud = qaq(ua, vₓᵧ);\r\n    const _ud = abs($ud);\r\n    const ud_ = ua_ + vₓᵧ_ + _ud;\r\n    const $ue = $ub + $vᵧᵧ;\r\n    const ue = qaq(ub, vᵧᵧ);\r\n    const _ue = abs($ue);\r\n    const ue_ = ub_ + vᵧᵧ_ + _ue;\r\n    const $uf = $c1c1 * $uc;\r\n    const uf = qmq(c1c1, uc);\r\n    const uf_ = c1c1_ * _uc + _c1c1 * uc_ + 2 * abs($uf);\r\n    const $ug = $c1d1 * $ud;\r\n    const ug = qmq(c1d1, ud);\r\n    const ug_ = c1d1_ * _ud + _c1d1 * ud_ + 2 * abs($ug);\r\n    const $uh = $d1d1 * $ue;\r\n    const uh = qmq(d1d1, ue);\r\n    const uh_ = d1d1_ * _ue + _d1d1 * ue_ + 2 * abs($uh);\r\n    const $ui = $uf + $ug;\r\n    const ui = qaq(uf, ug);\r\n    const ui_ = uf_ + ug_ + abs($ui);\r\n    const $v2 = $ui + $uh;\r\n    const v2 = qaq(ui, uh);\r\n    const v2_ = ui_ + uh_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    const $uj = 2 * ($z3 + $vₓₓ);\r\n    const uj = qm2(qaq(z3, vₓₓ));\r\n    const uj_ = 2 * (z3_ + vₓₓ_) + abs($uj);\r\n    const $uk = 2 * ($z4 + $vᵧᵧ);\r\n    const uk = qm2(qaq(z4, vᵧᵧ));\r\n    const uk_ = 2 * (z4_ + vᵧᵧ_) + abs($uk);\r\n    const $un = $z7 + $uj;\r\n    const un = qaq(z7, uj);\r\n    const _un = abs($un);\r\n    const un_ = z7_ + uj_ + _un;\r\n    const $uo = $z8 + $uk;\r\n    const uo = qaq(z8, uk);\r\n    const _uo = abs($uo);\r\n    const uo_ = z8_ + uk_ + _uo;\r\n    const $up = $z2 + $vₓᵧ;\r\n    const up = qaq(z2, vₓᵧ);\r\n    const _up = abs($up);\r\n    const up_ = z2_ + vₓᵧ_ + _up;\r\n    const $uq = $z5 + $vₓᵧ;\r\n    const uq = qaq(z5, vₓᵧ);\r\n    const _uq = abs($uq);\r\n    const uq_ = z5_ + vₓᵧ_ + _uq;\r\n    const $ur = $c0c1 * $un;\r\n    const ur = qmq(c0c1, un);\r\n    const ur_ = c0c1_ * _un + _c0c1 * un_ + 2 * abs($ur);\r\n    const $us = $d0d1 * $uo;\r\n    const us = qmq(d0d1, uo);\r\n    const us_ = d0d1_ * _uo + _d0d1 * uo_ + 2 * abs($us);\r\n    const $ut = $c0d1 * $up;\r\n    const ut = qmq(c0d1, up);\r\n    const ut_ = c0d1_ * _up + _c0d1 * up_ + 2 * abs($ut);\r\n    const $uu = $c1d0 * $uq;\r\n    const uu = qmq(c1d0, uq);\r\n    const uu_ = c1d0_ * _uq + _c1d0 * uq_ + 2 * abs($uu);\r\n    const $uv = $c1 * $vₓ;\r\n    const uv = qmq(c1, vₓ);\r\n    const uv_ = _c1 * vₓ_ + 2 * abs($uv);\r\n    const $uw = $d1 * $vᵧ;\r\n    const uw = qmq(d1, vᵧ);\r\n    const uw_ = _d1 * vᵧ_ + 2 * abs($uw);\r\n    const $ux = $ur + $us;\r\n    const ux = qaq(ur, us);\r\n    const ux_ = ur_ + us_ + abs($ux);\r\n    const $uy = $ut + $uu;\r\n    const uy = qaq(ut, uu);\r\n    const uy_ = ut_ + uu_ + abs($uy);\r\n    const $uz = $ux + $uy;\r\n    const uz = qaq(ux, uy);\r\n    const uz_ = ux_ + uy_ + abs($uz);\r\n    const $u0 = $uv + $uw;\r\n    const u0 = qaq(uv, uw);\r\n    const u0_ = uv_ + uw_ + abs($u0);\r\n    const $v1 = $uz + $u0;\r\n    const v1 = qaq(uz, u0);\r\n    const v1_ = uz_ + u0_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //const v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    const $f1 = $z1 + $z3;\r\n    const f1 = qaq(z1, z3);\r\n    const f1_ = z1_ + z3_ + abs($f1);\r\n    const $f2 = $z6 + $z4;\r\n    const f2 = qaq(z6, z4);\r\n    const f2_ = z6_ + z4_ + abs($f2);\r\n    const $f3 = $f1 + $vₓₓ;\r\n    const f3 = qaq(f1, vₓₓ);\r\n    const _f3 = abs($f3);\r\n    const f3_ = f1_ + vₓₓ_ + _f3;\r\n    const $f4 = $f2 + $vᵧᵧ;\r\n    const f4 = qaq(f2, vᵧᵧ);\r\n    const _f4 = abs($f4);\r\n    const f4_ = f2_ + vᵧᵧ_ + _f4;\r\n    const $f5 = $c0c0 * $f3;\r\n    const f5 = qmq(c0c0, f3);\r\n    const f5_ = _c0c0 * f3_ + 2 * abs($f5);\r\n    const $f6 = $d0d0 * $f4;\r\n    const f6 = qmq(d0d0, f4);\r\n    const f6_ = _d0d0 * f4_ + 2 * abs($f6);\r\n    const $f7 = $c0d0 * $vₓᵧ;\r\n    const f7 = qmq(c0d0, vₓᵧ);\r\n    const f7_ = _c0d0 * vₓᵧ_ + 2 * abs($f7);\r\n    const $f8 = $f5 + $f6;\r\n    const f8 = qaq(f5, f6);\r\n    const f8_ = f5_ + f6_ + abs($f8);\r\n    const $f9 = $f8 + $f7;\r\n    const f9 = qaq(f8, f7);\r\n    const f9_ = f8_ + f7_ + abs($f9);\r\n    const $fa = c0 * $vₓ;\r\n    const fa = qmd(c0, vₓ);\r\n    const fa_ = _c0 * vₓ_ + abs($fa);\r\n    const $fb = d0 * $vᵧ;\r\n    const fb = qmd(d0, vᵧ);\r\n    const fb_ = _d0 * vᵧ_ + abs($fb);\r\n    const $fc = $fa + $fb;\r\n    const fc = qaq(fa, fb);\r\n    const fc_ = fa_ + fb_ + abs($fc);\r\n    const $fd = $f9 + $fc;\r\n    const fd = qaq(f9, fc);\r\n    const fd_ = f9_ + fc_ + abs($fd);\r\n    const $v0 = $fd + $v;\r\n    const v0 = qaq(fd, v);\r\n    const v0_ = fd_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v3, v2, v1, v0],\r\n        errBound: [γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez1-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez2Dd": () => (/* binding */ getCoeffsBez3Bez2Dd)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_3__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez2Dd(ps1, ps2) {\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const { coeffs: [[c2, c1, [, c0]], [d2, d1, [, d0]]], errorBound: [[c2_], [d2_]] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis2DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓₓ = abs($vₓₓₓ);\r\n    const _vₓₓᵧ = abs($vₓₓᵧ);\r\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d2d2 = $d2 * $d2;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c1c1 = qmq(c1, c1);\r\n    const c1c1_ = 2 * abs($c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = _c1 * d2_ + 2 * abs($c1d2);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + abs($c2c2));\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d1d1 = qmq(d1, d1);\r\n    const d1d1_ = 2 * abs($d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = _d1 * d2_ + 2 * abs($d1d2);\r\n    const d2d2 = qmq(d2, d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + abs($d2d2));\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c0d0 = abs($c0d0);\r\n    const _c0d1 = abs($c0d1);\r\n    const _c1c2 = abs($c1c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const _c2d2 = abs($c2d2);\r\n    const _c1d0 = abs($c1d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d1d2 = abs($d1d2);\r\n    const _d2d2 = abs($d2d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //const v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    const e1 = qmq(c2, vₓₓₓ);\r\n    const $e1 = $c2 * $vₓₓₓ;\r\n    const e1_ = c2_ * _vₓₓₓ + _c2 * vₓₓₓ_ + 2 * abs($e1);\r\n    const e2 = qmq(c2, vₓᵧᵧ);\r\n    const $e2 = $c2 * $vₓᵧᵧ;\r\n    const e2_ = c2_ * _vₓᵧᵧ + _c2 * vₓᵧᵧ_ + 2 * abs($e2);\r\n    const e3 = qmq(d2, vₓₓᵧ);\r\n    const $e3 = $d2 * $vₓₓᵧ;\r\n    const e3_ = d2_ * _vₓₓᵧ + _d2 * vₓₓᵧ_ + 2 * abs($e3);\r\n    const e4 = qmq(d2, vᵧᵧᵧ);\r\n    const $e4 = $d2 * $vᵧᵧᵧ;\r\n    const e4_ = d2_ * _vᵧᵧᵧ + _d2 * vᵧᵧᵧ_ + 2 * abs($e4);\r\n    const $e5 = $e1 + $e3;\r\n    const e5 = qaq(e1, e3);\r\n    const _e5 = abs($e5);\r\n    const e5_ = e1_ + e3_ + _e5;\r\n    const $e6 = $e2 + $e4;\r\n    const e6 = qaq(e2, e4);\r\n    const _e6 = abs($e6);\r\n    const e6_ = e2_ + e4_ + _e6;\r\n    const $e7 = $c2c2 * $e5;\r\n    const e7 = qmq(c2c2, e5);\r\n    const e7_ = c2c2_ * _e5 + _c2c2 * e5_ + 2 * abs($e7);\r\n    const $e8 = $d2d2 * $e6;\r\n    const e8 = qmq(d2d2, e6);\r\n    const e8_ = d2d2_ * _e6 + _d2d2 * e6_ + 2 * abs($e8);\r\n    const $v6 = $e7 + $e8;\r\n    const v6 = qaq(e7, e8);\r\n    const v6_ = e7_ + e8_ + abs($v6);\r\n    ///\r\n    const $z1 = $c0c2 + $c1c1;\r\n    const z1 = qaq(c0c2, c1c1);\r\n    const _z1 = abs($z1);\r\n    const z1_ = c0c2_ + c1c1_ + _z1;\r\n    const $z2 = $d0d2 + $d1d1;\r\n    const z2 = qaq(d0d2, d1d1);\r\n    const _z2 = abs($z2);\r\n    const z2_ = d0d2_ + d1d1_ + _z2;\r\n    const $z3 = 2 * $c0c2 + $c1c1;\r\n    const _z3 = abs($z3);\r\n    const z3 = qaq(qm2(c0c2), c1c1);\r\n    const z3_ = 2 * c0c2_ + c1c1_ + _z3;\r\n    const $z4 = 2 * $d0d2 + $d1d1;\r\n    const z4 = qaq(qm2(d0d2), d1d1);\r\n    const _z4 = abs($z4);\r\n    const z4_ = 2 * d0d2_ + d1d1_ + _z4;\r\n    const $z5 = 2 * $c1d1 + $c2d0;\r\n    const z5 = qaq(qm2(c1d1), c2d0);\r\n    const _z5 = abs($z5);\r\n    const z5_ = 2 * c1d1_ + c2d0_ + _z5;\r\n    const $z6 = 2 * $c1d1 + $c0d2;\r\n    const z6 = qaq(qm2(c1d1), c0d2);\r\n    const _z6 = abs($z6);\r\n    const z6_ = 2 * c1d1_ + c0d2_ + _z6;\r\n    const $z7 = 2 * $c2d0 + $c1d1;\r\n    const z7 = qaq(qm2(c2d0), c1d1);\r\n    const z7_ = 2 * c2d0_ + c1d1_ + abs($z7);\r\n    const $z8 = 6 * $c0c2 + $c1c1;\r\n    const $q1 = 6 * $c0c2;\r\n    const q1 = qmd(6, c0c2);\r\n    const q1_ = 6 * c0c2_ + abs($q1);\r\n    const z8 = qaq(q1, c1c1);\r\n    const z8_ = q1_ + c1c1_ + abs($q1 + $c1c1);\r\n    const $z9 = 6 * $d0d2 + $d1d1;\r\n    const $q2 = 6 * $d0d2;\r\n    const q2 = qmd(6, d0d2);\r\n    const q2_ = 6 * d0d2_ + abs($q2);\r\n    const z9 = qaq(q2, d1d1);\r\n    const z9_ = q2_ + d1d1_ + abs($q2 + $d1d1);\r\n    const $za = $c1d2 + $c2d1;\r\n    const za = qaq(c1d2, c2d1);\r\n    const _za = abs($za);\r\n    const za_ = c1d2_ + c2d1_ + _za;\r\n    const $zb = $c0d2 + $c2d0;\r\n    const zb = qaq(c0d2, c2d0);\r\n    const zb_ = c0d2_ + c2d0_ + abs($zb);\r\n    const $zc = 2 * $c1d0 + $c0d1;\r\n    const zc = qaq(qm2(c1d0), c0d1);\r\n    const zc_ = 2 * c1d0_ + c0d1_ + abs($zc);\r\n    const $zd = 2 * $c0d1 + $c1d0;\r\n    const zd = qaq(qm2(c0d1), c1d0);\r\n    const zd_ = 2 * c0d1_ + c1d0_ + abs($zd);\r\n    const $zf = $c0d2 + $c1d1;\r\n    const zf = qaq(c0d2, c1d1);\r\n    const zf_ = c0d2_ + c1d1_ + abs($zf);\r\n    const $ze = $zf + $c2d0;\r\n    const ze = qaq(zf, c2d0);\r\n    const _ze = abs($ze);\r\n    const ze_ = zf_ + c2d0_ + _ze;\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //const v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    const $s0 = 3 * $c2c2;\r\n    const s0 = qmd(3, c2c2);\r\n    const s0_ = 3 * c2c2_ + abs($s0);\r\n    const _s0 = abs($s0);\r\n    const $t1 = 3 * $d2d2;\r\n    const t1 = qmd(3, d2d2);\r\n    const t1_ = 3 * d2d2_ + abs($t1);\r\n    const _t1 = abs($t1);\r\n    const $s1 = $s0 * $vₓₓₓ;\r\n    const s1 = qmq(s0, vₓₓₓ);\r\n    const s1_ = s0_ * _vₓₓₓ + _s0 * vₓₓₓ_ + 2 * abs($s1);\r\n    const $s2 = $c2c2 * $vₓₓᵧ;\r\n    const s2 = qmq(c2c2, vₓₓᵧ);\r\n    const s2_ = c2c2_ * _vₓₓᵧ + _c2c2 * vₓₓᵧ_ + 2 * abs($s2);\r\n    const $s3 = 2 * $c2d2 * $vₓₓᵧ;\r\n    const s3 = qm2(qmq(c2d2, vₓₓᵧ));\r\n    const s3_ = 2 * (c2d2_ * _vₓₓᵧ + _c2d2 * vₓₓᵧ_ + abs($s3));\r\n    const $s4 = 2 * $c2d2 * $vₓᵧᵧ;\r\n    const s4 = qm2(qmq(c2d2, vₓᵧᵧ));\r\n    const s4_ = 2 * (c2d2_ * _vₓᵧᵧ + _c2d2 * vₓᵧᵧ_ + abs($s4));\r\n    const $s5 = $d2d2 * $vₓᵧᵧ;\r\n    const s5 = qmq(d2d2, vₓᵧᵧ);\r\n    const s5_ = d2d2_ * _vₓᵧᵧ + _d2d2 * vₓᵧᵧ_ + 2 * abs($s5);\r\n    const $s6 = $t1 * $vᵧᵧᵧ;\r\n    const s6 = qmq(t1, vᵧᵧᵧ);\r\n    const s6_ = t1_ * _vᵧᵧᵧ + _t1 * vᵧᵧᵧ_ + 2 * abs($s6);\r\n    const $s7 = $s1 + $s3;\r\n    const s7 = qaq(s1, s3);\r\n    const s7_ = s1_ + s3_ + abs($s7);\r\n    const $s8 = $s2 + $s4;\r\n    const s8 = qaq(s2, s4);\r\n    const s8_ = s2_ + s4_ + abs($s8);\r\n    const $s9 = $s7 + $s5;\r\n    const s9 = qaq(s7, s5);\r\n    const s9_ = s7_ + s5_ + abs($s9);\r\n    const $sa = $s8 + $s6;\r\n    const sa = qaq(s8, s6);\r\n    const sa_ = s8_ + s6_ + abs($sa);\r\n    const $sb = $c1 * $s9;\r\n    const sb = qmq(c1, s9);\r\n    const sb_ = _c1 * s9_ + abs($sb);\r\n    const $sc = $d1 * $sa;\r\n    const sc = qmq(d1, sa);\r\n    const sc_ = _d1 * sa_ + abs($sc);\r\n    const $v5 = $sb + $sc;\r\n    const v5 = qaq(sb, sc);\r\n    const v5_ = sb_ + sc_ + abs($v5);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //const v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //const v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    const $sd = $d2 * $z3;\r\n    const sd = qmq(d2, z3);\r\n    const sd_ = d2_ * _z3 + _d2 * z3_ + 2 * abs($sd);\r\n    const $se = $d2 * $z6;\r\n    const se = qmq(d2, z6);\r\n    const se_ = d2_ * _z6 + _d2 * z6_ + 2 * abs($se);\r\n    const $sf = $c2 * $z5;\r\n    const sf = qmq(c2, z5);\r\n    const sf_ = c2_ * _z5 + _c2 * z5_ + 2 * abs($sf);\r\n    const $sg = $c2 * $z4;\r\n    const sg = qmq(c2, z4);\r\n    const sg_ = c2_ * _z4 + _c2 * z4_ + 2 * abs($sg);\r\n    const $q3 = 3 * $c2;\r\n    const q3 = qmd(3, c2);\r\n    const _q3 = abs($q3);\r\n    const q3_ = 3 * c2_ + _q3;\r\n    const $sh = $q3 * $z1;\r\n    const sh = qmq(q3, z1);\r\n    const _sh = abs($sh);\r\n    const sh_ = q3_ * _z1 + _q3 * z1_ + _sh;\r\n    const $q4 = 3 * $d2;\r\n    const q4 = qmd(3, d2);\r\n    const _q4 = abs($q4);\r\n    const q4_ = 3 * d2_ + _q4;\r\n    const $si = $q4 * $z2;\r\n    const si = qmq(q4, z2);\r\n    const _si = abs($si);\r\n    const si_ = q4_ * _z2 + _q4 * z2_ + _si;\r\n    const $sj = $sd + $sf;\r\n    const sj = qaq(sd, sf);\r\n    const _sj = abs($sj);\r\n    const sj_ = sd_ + sf_ + _sj;\r\n    const $sk = $se + $sg;\r\n    const sk = qaq(se, sg);\r\n    const _sk = abs($sk);\r\n    const sk_ = se_ + sg_ + _sk;\r\n    const $sl = $sh * $vₓₓₓ;\r\n    const sl = qmq(sh, vₓₓₓ);\r\n    const sl_ = sh_ * _vₓₓₓ + _sh * vₓₓₓ_ + 2 * abs($sl);\r\n    const $sm = $si * $vᵧᵧᵧ;\r\n    const sm = qmq(si, vᵧᵧᵧ);\r\n    const sm_ = si_ * _vᵧᵧᵧ + _si * vᵧᵧᵧ_ + 2 * abs($sm);\r\n    const $sn = $sj * $vₓₓᵧ;\r\n    const sn = qmq(sj, vₓₓᵧ);\r\n    const sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + 2 * abs($sn);\r\n    const $so = $sk * $vₓᵧᵧ;\r\n    const so = qmq(sk, vₓᵧᵧ);\r\n    const so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + 2 * abs($so);\r\n    const $sp = $sl + $sm;\r\n    const sp = qaq(sl, sm);\r\n    const sp_ = sl_ + sm_ + abs($sp);\r\n    const $sq = $sn + $so;\r\n    const sq = qaq(sn, so);\r\n    const sq_ = sn_ + so_ + abs($sq);\r\n    const $sr = $c2c2 * $vₓₓ;\r\n    const sr = qmq(c2c2, vₓₓ);\r\n    const sr_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * abs($sr);\r\n    const $ss = $d2d2 * $vᵧᵧ;\r\n    const ss = qmq(d2d2, vᵧᵧ);\r\n    const ss_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * abs($ss);\r\n    const $st = $c2d2 * $vₓᵧ;\r\n    const st = qmq(c2d2, vₓᵧ);\r\n    const st_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * abs($st);\r\n    const $su = $sr + $ss;\r\n    const su = qaq(sr, ss);\r\n    const su_ = sr_ + ss_ + abs($su);\r\n    const $sv = $sp + $sq;\r\n    const sv = qaq(sp, sq);\r\n    const sv_ = sp_ + sq_ + abs($sv);\r\n    const $sw = $su + $st;\r\n    const sw = qaq(su, st);\r\n    const sw_ = su_ + st_ + abs($sw);\r\n    const $v4 = $sv + $sw;\r\n    const v4 = qaq(sv, sw);\r\n    const v4_ = sv_ + sw_ + abs($v4);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //const v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    const $sx = $c1 * $z8;\r\n    const sx = qmq(c1, z8);\r\n    const _sx = _c1 * z8_ + 2 * abs($sx);\r\n    const sx_ = 2 * _sx;\r\n    const $sy = $d1 * $z9;\r\n    const sy = qmq(d1, z9);\r\n    const _sy = _d1 * z9_ + 2 * abs($sy);\r\n    const sy_ = 2 * _sy;\r\n    const $sz = 2 * c0 * $za;\r\n    const sz = qmd(2 * c0, za);\r\n    const sz_ = 2 * _c0 * za_ + abs($sz);\r\n    const $o1 = 2 * $d1 * $zb;\r\n    const o1 = qmq(qm2(d1), zb);\r\n    const o1_ = 2 * _d1 * zb_ + 2 * abs($o1);\r\n    const $o2 = $c1 * $z7;\r\n    const o2 = qmq(c1, z7);\r\n    const o2_ = _c1 * z7_ + 2 * abs($o2);\r\n    const $o3 = $c1 * $z4;\r\n    const o3 = qmq(c1, z4);\r\n    const o3_ = _c1 * z4_ + 2 * abs($o3);\r\n    const $o4 = $sz + $o2;\r\n    const o4 = qaq(sz, o2);\r\n    const _o4 = sz_ + o2_ + abs($o4);\r\n    const o4_ = sz_ + o2_ + _o4;\r\n    const $o5 = $o1 + $o3;\r\n    const o5 = qaq(o1, o3);\r\n    const _o5 = o1_ + o3_ + abs($o5);\r\n    const o5_ = o1_ + o3_ + _o5;\r\n    const $o6 = $d1d2 * $vᵧᵧ;\r\n    const o6 = qmq(d1d2, vᵧᵧ);\r\n    const o6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * abs($o6);\r\n    const $o7 = $c1c2 * $vₓₓ;\r\n    const o7 = qmq(c1c2, vₓₓ);\r\n    const o7_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * abs($o7);\r\n    const $o8 = $za * $vₓᵧ;\r\n    const o8 = qmq(za, vₓᵧ);\r\n    const o8_ = za_ * _vₓᵧ + _za * vₓᵧ_ + 2 * abs($o8);\r\n    const $o9 = $o6 + $o7;\r\n    const o9 = qaq(o6, o7);\r\n    const o9_ = o6_ + o7_ + abs($o9);\r\n    const $oa = $sx * $vₓₓₓ;\r\n    const oa = qmq(sx, vₓₓₓ);\r\n    const oa_ = sx_ * _vₓₓₓ + _sx * vₓₓₓ_ + 2 * abs($oa);\r\n    const $ob = $o4 * $vₓₓᵧ;\r\n    const ob = qmq(o4, vₓₓᵧ);\r\n    const ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + 2 * abs($ob);\r\n    const $oc = $sy * $vᵧᵧᵧ;\r\n    const oc = qmq(sy, vᵧᵧᵧ);\r\n    const oc_ = sy_ * _vᵧᵧᵧ + _sy * vᵧᵧᵧ_ + 2 * abs($oc);\r\n    const $od = $o5 * $vₓᵧᵧ;\r\n    const od = qmq(o5, vₓᵧᵧ);\r\n    const od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + 2 * abs($od);\r\n    const $oe = $oa + $oc;\r\n    const oe = qaq(oa, oc);\r\n    const oe_ = oa_ + oc_ + abs($oe);\r\n    const $og = $ob + $od;\r\n    const og = qaq(ob, od);\r\n    const og_ = ob_ + od_ + abs($og);\r\n    const $oh = $oe + $og;\r\n    const oh = qaq(oe, og);\r\n    const oh_ = oe_ + og_ + abs($oh);\r\n    const $oi = 2 * $o9 + $o8;\r\n    const oi = qaq(qm2(o9), o8);\r\n    const oi_ = 2 * o9_ + o8_ + abs($oi);\r\n    const $v3 = $oh + $oi;\r\n    const v3 = qaq(oh, oi);\r\n    const v3_ = oh_ + oi_ + abs($v3);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    //const v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const $q5 = 3 * c0;\r\n    const _q5 = abs($q5);\r\n    const q5 = tp(3, c0); // error free\r\n    const $oj = $q5 * $z1;\r\n    const oj = qmq(q5, z1);\r\n    const _oj = abs($oj);\r\n    const oj_ = _q5 * z1_ + 2 * abs($oj);\r\n    const $q6 = 3 * d0;\r\n    const _q6 = abs($q6);\r\n    const q6 = tp(3, d0); // error free\r\n    const $ok = $q6 * $z2;\r\n    const ok = qmq(q6, z2);\r\n    const _ok = abs($ok);\r\n    const ok_ = _q6 * z2_ + 2 * abs($ok);\r\n    const $ol = c0 * $z6;\r\n    const ol = qmd(c0, z6);\r\n    const ol_ = _c0 * z6_ + abs($ol);\r\n    const $om = c0 * $z4;\r\n    const om = qmd(c0, z4);\r\n    const om_ = _c0 * z4_ + abs($om);\r\n    const $on = d0 * $z3;\r\n    const on = qmd(d0, z3);\r\n    const on_ = _d0 * z3_ + abs($on);\r\n    const $oo = d0 * $z5;\r\n    const oo = qmd(d0, z5);\r\n    const oo_ = _d0 * z5_ + abs($oo);\r\n    const $op = $ol + $on;\r\n    const op = qaq(ol, on);\r\n    const _op = abs($op);\r\n    const op_ = ol_ + on_ + _op;\r\n    const $oq = $om + $oo;\r\n    const oq = qaq(om, oo);\r\n    const _oq = abs($oq);\r\n    const oq_ = om_ + oo_ + _oq;\r\n    const $or = $oj * $vₓₓₓ;\r\n    const or = qmq(oj, vₓₓₓ);\r\n    const or_ = oj_ * _vₓₓₓ + _oj * vₓₓₓ_ + 2 * abs($or);\r\n    const $os = $ok * $vᵧᵧᵧ;\r\n    const os = qmq(ok, vᵧᵧᵧ);\r\n    const os_ = ok_ * _vᵧᵧᵧ + _ok * vᵧᵧᵧ_ + 2 * abs($os);\r\n    const $ot = $op * $vₓₓᵧ;\r\n    const ot = qmq(op, vₓₓᵧ);\r\n    const ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + 2 * abs($ot);\r\n    const $ou = $oq * $vₓᵧᵧ;\r\n    const ou = qmq(oq, vₓᵧᵧ);\r\n    const ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + 2 * abs($ou);\r\n    const $ov = $z3 * $vₓₓ;\r\n    const ov = qmq(z3, vₓₓ);\r\n    const ov_ = z3_ * _vₓₓ + _z3 * vₓₓ_ + 2 * abs($ov);\r\n    const $ow = $z4 * $vᵧᵧ;\r\n    const ow = qmq(z4, vᵧᵧ);\r\n    const ow_ = z4_ * _vᵧᵧ + _z4 * vᵧᵧ_ + 2 * abs($ow);\r\n    const $ox = $ze * $vₓᵧ;\r\n    const ox = qmq(ze, vₓᵧ);\r\n    const ox_ = ze_ * _vₓᵧ + _ze * vₓᵧ_ + 2 * abs($ox);\r\n    const $oy = $c2 * $vₓ;\r\n    const oy = qmq(c2, vₓ);\r\n    const oy_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * abs($oy);\r\n    const $oz = $d2 * $vᵧ;\r\n    const oz = qmq(d2, vᵧ);\r\n    const oz_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * abs($oz);\r\n    const $p1 = $or + $os;\r\n    const p1 = qaq(or, os);\r\n    const p1_ = or_ + os_ + abs($p1);\r\n    const $p2 = $ot + $ou;\r\n    const p2 = qaq(ot, ou);\r\n    const p2_ = ot_ + ou_ + abs($p2);\r\n    const $p3 = $ov + $ow;\r\n    const p3 = qaq(ov, ow);\r\n    const p3_ = ov_ + ow_ + abs($p3);\r\n    const $p4 = $p1 + $p2;\r\n    const p4 = qaq(p1, p2);\r\n    const p4_ = p1_ + p2_ + abs($p4);\r\n    const $p5 = $p3 + $ox;\r\n    const p5 = qaq(p3, ox);\r\n    const p5_ = p3_ + ox_ + abs($p5);\r\n    const $p6 = $oy + $oz;\r\n    const p6 = qaq(oy, oz);\r\n    const p6_ = oy_ + oz_ + abs($p6);\r\n    const $p7 = $p4 + $p5;\r\n    const p7 = qaq(p4, p5);\r\n    const p7_ = p4_ + p5_ + abs($p7);\r\n    const $v2 = $p7 + $p6;\r\n    const v2 = qaq(p7, p6);\r\n    const v2_ = p7_ + p6_ + abs($v2);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    const $p8 = $q5 * $c0c1;\r\n    const p8 = qmq(q5, c0c1);\r\n    const _p8 = abs($p8);\r\n    const p8_ = _q5 * c0c1_ + 2 * _p8;\r\n    const $p9 = $q6 * $d0d1;\r\n    const p9 = qmq(q6, d0d1);\r\n    const _p9 = abs($p9);\r\n    const p9_ = _q6 * d0d1_ + 2 * _p9;\r\n    const $pa = c0 * $zc;\r\n    const pa = qmd(c0, zc);\r\n    const _pa = abs($pa);\r\n    const pa_ = _c0 * zc_ + abs($pa);\r\n    const $pb = d0 * $zd;\r\n    const pb = qmd(d0, zd);\r\n    const _pb = abs($pb);\r\n    const pb_ = _d0 * zd_ + abs($pb);\r\n    const $pc = $c0c1 * $vₓₓ;\r\n    const pc = qmq(c0c1, vₓₓ);\r\n    const pc_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($pc);\r\n    const $pd = $d0d1 * $vᵧᵧ;\r\n    const pd = qmq(d0d1, vᵧᵧ);\r\n    const pd_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($pd);\r\n    const $pe = $c0d1 * $vₓᵧ;\r\n    const pe = qmq(c0d1, vₓᵧ);\r\n    const pe_ = c0d1_ * _vₓᵧ + _c0d1 * vₓᵧ_ + 2 * abs($pe);\r\n    const $pf = $c1d0 * $vₓᵧ;\r\n    const pf = qmq(c1d0, vₓᵧ);\r\n    const pf_ = c1d0_ * _vₓᵧ + _c1d0 * vₓᵧ_ + 2 * abs($pf);\r\n    const $pg = 2 * ($pc + $pd);\r\n    const pg = qm2(qaq(pc, pd));\r\n    const pg_ = 2 * (pc_ + pd_) + abs($pg);\r\n    const $ph = $pe + $pf;\r\n    const ph = qaq(pe, pf);\r\n    const ph_ = pe_ + pf_ + abs($ph);\r\n    const $pi = $c1 * $vₓ;\r\n    const pi = qmq(c1, vₓ);\r\n    const pi_ = _c1 * vₓ_ + 2 * abs($pi);\r\n    const $pj = $d1 * $vᵧ;\r\n    const pj = qmq(d1, vᵧ);\r\n    const pj_ = _d1 * vᵧ_ + 2 * abs($pj);\r\n    const $pk = $p8 * $vₓₓₓ;\r\n    const pk = qmq(p8, vₓₓₓ);\r\n    const pk_ = p8_ * _vₓₓₓ + _p8 * vₓₓₓ_ + 2 * abs($pk);\r\n    const $pl = $p9 * $vᵧᵧᵧ;\r\n    const pl = qmq(p9, vᵧᵧᵧ);\r\n    const pl_ = p9_ * _vᵧᵧᵧ + _p9 * vᵧᵧᵧ_ + 2 * abs($pl);\r\n    const $pm = $pa * $vₓₓᵧ;\r\n    const pm = qmq(pa, vₓₓᵧ);\r\n    const pm_ = pa_ * _vₓₓᵧ + _pa * vₓₓᵧ_ + 2 * abs($pm);\r\n    const $pn = $pb * $vₓᵧᵧ;\r\n    const pn = qmq(pb, vₓᵧᵧ);\r\n    const pn_ = pb_ * _vₓᵧᵧ + _pb * vₓᵧᵧ_ + 2 * abs($pn);\r\n    const $po = $pk + $pl;\r\n    const po = qaq(pk, pl);\r\n    const po_ = pk_ + pl_ + abs($po);\r\n    const $pp = $pm + $pn;\r\n    const pp = qaq(pm, pn);\r\n    const pp_ = pm_ + pn_ + abs($pp);\r\n    const $pq = $po + $pp;\r\n    const pq = qaq(po, pp);\r\n    const pq_ = po_ + pp_ + abs($pq);\r\n    const $pr = $pg + $ph;\r\n    const pr = qaq(pg, ph);\r\n    const pr_ = pg_ + ph_ + abs($pr);\r\n    const $ps = $pi + $pj;\r\n    const ps = qaq(pi, pj);\r\n    const ps_ = pi_ + pj_ + abs($ps);\r\n    const $pt = $pq + $pr;\r\n    const pt = qaq(pq, pr);\r\n    const pt_ = pq_ + pr_ + abs($pt);\r\n    const $v1 = $pt + $ps;\r\n    const v1 = qaq(pt, ps);\r\n    const v1_ = pt_ + ps_ + abs($v1);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const $pu = c0 * $vₓₓₓ;\r\n    const pu = qmd(c0, vₓₓₓ);\r\n    const pu_ = _c0 * vₓₓₓ_ + abs($pu);\r\n    const $pv = c0 * $vₓᵧᵧ;\r\n    const pv = qmd(c0, vₓᵧᵧ);\r\n    const pv_ = _c0 * vₓᵧᵧ_ + abs($pv);\r\n    const $pw = d0 * $vₓₓᵧ;\r\n    const pw = qmd(d0, vₓₓᵧ);\r\n    const pw_ = _d0 * vₓₓᵧ_ + abs($pw);\r\n    const $px = d0 * $vᵧᵧᵧ;\r\n    const px = qmd(d0, vᵧᵧᵧ);\r\n    const px_ = _d0 * vᵧᵧᵧ_ + abs($px);\r\n    const $py = $pu + $pw;\r\n    const py = qaq(pu, pw);\r\n    const py_ = pu_ + pw_ + abs($py);\r\n    const $pz = $pv + $px;\r\n    const pz = qaq(pv, px);\r\n    const pz_ = pv_ + px_ + abs($pz);\r\n    const $u1 = $py + $vₓₓ;\r\n    const u1 = qaq(py, vₓₓ);\r\n    const _u1 = abs($u1);\r\n    const u1_ = py_ + vₓₓ_ + _u1;\r\n    const $u2 = $pz + $vᵧᵧ;\r\n    const u2 = qaq(pz, vᵧᵧ);\r\n    const _u2 = abs($u2);\r\n    const u2_ = pz_ + vᵧᵧ_ + _u2;\r\n    const $u3 = $c0c0 * $u1;\r\n    const u3 = qmq(c0c0, u1);\r\n    const u3_ = _c0c0 * u1_ + 2 * abs($u3);\r\n    const $u4 = $d0d0 * $u2;\r\n    const u4 = qmq(d0d0, u2);\r\n    const u4_ = _d0d0 * u2_ + 2 * abs($u4);\r\n    const $u5 = $c0d0 * $vₓᵧ;\r\n    const u5 = qmq(c0d0, vₓᵧ);\r\n    const u5_ = _c0d0 * vₓᵧ_ + 2 * abs($u5);\r\n    const $u6 = c0 * $vₓ;\r\n    const u6 = qmd(c0, vₓ);\r\n    const u6_ = _c0 * vₓ_ + abs($u6);\r\n    const $u7 = d0 * $vᵧ;\r\n    const u7 = qmd(d0, vᵧ);\r\n    const u7_ = _d0 * vᵧ_ + abs($u7);\r\n    const $u8 = $u3 + $u4;\r\n    const u8 = qaq(u3, u4);\r\n    const u8_ = u3_ + u4_ + abs($u8);\r\n    const $u9 = $u8 + $u5;\r\n    const u9 = qaq(u8, u5);\r\n    const u9_ = u8_ + u5_ + abs($u9);\r\n    const $ua = $u6 + $u7;\r\n    const ua = qaq(u6, u7);\r\n    const ua_ = u6_ + u7_ + abs($ua);\r\n    const $ub = $u9 + $ua;\r\n    const ub = qaq(u9, ua);\r\n    const ub_ = u9_ + ua_ + abs($ub);\r\n    const $v0 = $ub + $v;\r\n    const v0 = qaq(ub, v);\r\n    const v0_ = ub_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez2-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez3Dd": () => (/* binding */ getCoeffsBez3Bez3Dd)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_3__.twoProduct;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultBy2;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_3__.ddAddDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_1__["γγ"])(3);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 3 bezier curves (i.e. 2 cubic bezier curves).\r\n *\r\n * The returned polynomial degree will be 9\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez3Dd(ps1, ps2) {\r\n    //--------------------------------------------------------------------------\r\n    // `var` -> a variable\r\n    // `$var` -> the double precision approximation to `var`\r\n    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)\r\n    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)\r\n    // `_var_` -> means both absolute value and absolute error bound\r\n    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)\r\n    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)\r\n    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)\r\n    // * the returned errors need to be multiplied by 3γ² to get the true error\r\n    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations\r\n    //   due to multiplication by 3*γ² and not 3*u²\r\n    //--------------------------------------------------------------------------\r\n    // examples: (all?)\r\n    // ----------------\r\n    // let qmd === ddMultDouble2, etc.\r\n    //\r\n    // ---------------\r\n    // 1. double-double X by double\r\n    // ---------------\r\n    // qmd(a,b);  // both `a` and `b` is error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + |a*b|\r\n    //                           === |a*b|\r\n    //\r\n    // ---------------\r\n    // 2a. double-double +/- double-double\r\n    // ---------------\r\n    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === _a_ + _b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 2b. double-double +/- double-double\r\n    // ---------------\r\n    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 2*_a + 2*_b + |a+b|\r\n    //                           === 2*(_a + _b) + |a+b| OR\r\n    //                           === a_ + b_ + |a+b|\r\n    //\r\n    // ---------------\r\n    // 3a. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)\r\n    //                           === 0|b| + |a|0 + 2|a*b|\r\n    //                           === 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` and `b` not error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //\r\n    // ---------------\r\n    // 3b. double-double X double-double\r\n    // ---------------\r\n    // qmq(a,b);  // both `a` not error-free and `b` error-free\r\n    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)\r\n    //                           === a_|b| + 2|a*b| \r\n    //\r\n    // ---------------\r\n    // 4a. double-double +/- double\r\n    // ---------------\r\n    // qad(a,b);  // both `a` and `b` error-free\r\n    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)\r\n    //                           === 0 + 0 + |a+b|\r\n    //                           === |a+b| \r\n    //--------------------------------------------------------------------------\r\n    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm3DdWithRunningError)(ps1);\r\n    const { coeffs: [[c3, c2, c1, [, c0]], [d3, d2, d1, [, d0]]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free\r\n     } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis3DdWithRunningError)(ps2);\r\n    const $vₓₓₓ = vₓₓₓ[1];\r\n    const $vₓₓᵧ = vₓₓᵧ[1];\r\n    const $vₓᵧᵧ = vₓᵧᵧ[1];\r\n    const $vᵧᵧᵧ = vᵧᵧᵧ[1];\r\n    const $vₓₓ = vₓₓ[1];\r\n    const $vₓᵧ = vₓᵧ[1];\r\n    const $vᵧᵧ = vᵧᵧ[1];\r\n    const $vₓ = vₓ[1];\r\n    const $vᵧ = vᵧ[1];\r\n    const $v = v[1];\r\n    const _vₓₓₓ = abs($vₓₓₓ);\r\n    const _vₓₓᵧ = abs($vₓₓᵧ);\r\n    const _vₓᵧᵧ = abs($vₓᵧᵧ);\r\n    const _vᵧᵧᵧ = abs($vᵧᵧᵧ);\r\n    const _vₓₓ = abs($vₓₓ);\r\n    const _vₓᵧ = abs($vₓᵧ);\r\n    const _vᵧᵧ = abs($vᵧᵧ);\r\n    const _vₓ = abs($vₓ);\r\n    const _vᵧ = abs($vᵧ);\r\n    const _v = abs($v);\r\n    const $c1 = c1[1];\r\n    const $c2 = c2[1];\r\n    const $c3 = c3[1];\r\n    const $d1 = d1[1];\r\n    const $d2 = d2[1];\r\n    const $d3 = d3[1];\r\n    const _c0 = abs(c0);\r\n    const _c1 = abs($c1);\r\n    const _c2 = abs($c2);\r\n    const _c3 = abs($c3);\r\n    const _d0 = abs(d0);\r\n    const _d1 = abs($d1);\r\n    const _d2 = abs($d2);\r\n    const _d3 = abs($d3);\r\n    const $c0c0 = c0 * c0;\r\n    const $c0c1 = c0 * $c1;\r\n    const $c0c2 = c0 * $c2;\r\n    const $c0c3 = c0 * $c3;\r\n    const $c0d0 = c0 * d0;\r\n    const $c0d1 = c0 * $d1;\r\n    const $c0d2 = c0 * $d2;\r\n    const $c0d3 = c0 * $d3;\r\n    const $c1c1 = $c1 * $c1;\r\n    const $c1c2 = $c1 * $c2;\r\n    const $c1c3 = $c1 * $c3;\r\n    const $c1d0 = $c1 * d0;\r\n    const $c1d1 = $c1 * $d1;\r\n    const $c1d2 = $c1 * $d2;\r\n    const $c1d3 = $c1 * $d3;\r\n    const $c2d1 = $c2 * $d1;\r\n    const $c2c2 = $c2 * $c2;\r\n    const $c2c3 = $c2 * $c3;\r\n    const $c2d0 = $c2 * d0;\r\n    const $c2d2 = $c2 * $d2;\r\n    const $c2d3 = $c2 * $d3;\r\n    const $c3c3 = $c3 * $c3;\r\n    const $c3d0 = $c3 * d0;\r\n    const $c3d1 = $c3 * $d1;\r\n    const $c3d2 = $c3 * $d2;\r\n    const $c3d3 = $c3 * $d3;\r\n    const $d0d0 = d0 * d0;\r\n    const $d0d1 = d0 * $d1;\r\n    const $d0d2 = d0 * $d2;\r\n    const $d0d3 = d0 * $d3;\r\n    const $d1d1 = $d1 * $d1;\r\n    const $d1d2 = $d1 * $d2;\r\n    const $d3d3 = $d3 * $d3;\r\n    const $d2d2 = $d2 * $d2;\r\n    const $d2d3 = $d2 * $d3;\r\n    const $d1d3 = $d1 * $d3;\r\n    const c0c0 = tp(c0, c0); // error free\r\n    const c0c1 = qmd(c0, c1);\r\n    const c0c1_ = _c0 * c1_ + abs($c0c1);\r\n    const c0c2 = qmd(c0, c2);\r\n    const c0c2_ = _c0 * c2_ + abs($c0c2);\r\n    const c0c3 = qmd(c0, c3);\r\n    const c0c3_ = _c0 * c3_ + abs($c0c3);\r\n    const c0d0 = tp(c0, d0); // error free\r\n    const c0d1 = qmd(c0, d1);\r\n    const c0d1_ = _c0 * d1_ + abs($c0d1);\r\n    const c0d2 = qmd(c0, d2);\r\n    const c0d2_ = _c0 * d2_ + abs($c0d2);\r\n    const c0d3 = qmd(c0, d3);\r\n    const c0d3_ = _c0 * d3_ + abs($c0d3);\r\n    const c1c1 = qmq(c1, c1);\r\n    const _c1c1 = abs($c1c1);\r\n    const c1c1_ = 2 * (c1_ * _c1 + _c1c1);\r\n    const c1c2 = qmq(c1, c2);\r\n    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * abs($c1c2);\r\n    const c1c3 = qmq(c1, c3);\r\n    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * abs($c1c3);\r\n    const c1d0 = qmd(d0, c1);\r\n    const c1d0_ = _d0 * c1_ + abs($c1d0);\r\n    const c1d1 = qmq(c1, d1);\r\n    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * abs($c1d1);\r\n    const c1d2 = qmq(c1, d2);\r\n    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * abs($c1d2);\r\n    const c1d3 = qmq(c1, d3);\r\n    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * abs($c1d3);\r\n    const c2d1 = qmq(c2, d1);\r\n    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * abs($c2d1);\r\n    const c2c2 = qmq(c2, c2);\r\n    const _c2c2 = abs($c2c2);\r\n    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);\r\n    const c2c3 = qmq(c2, c3);\r\n    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * abs($c2c3);\r\n    const c2d0 = qmd(d0, c2);\r\n    const c2d0_ = _d0 * c2_ + abs($c2d0);\r\n    const c2d2 = qmq(c2, d2);\r\n    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * abs($c2d2);\r\n    const c2d3 = qmq(c2, d3);\r\n    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * abs($c2d3);\r\n    const c3c3 = qmq(c3, c3);\r\n    const c3c3_ = 2 * (c3_ * _c3 + abs($c3c3));\r\n    const c3d0 = qmd(d0, c3);\r\n    const c3d0_ = _d0 * c3_ + abs($c3d0);\r\n    const c3d1 = qmq(c3, d1);\r\n    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * abs($c3d1);\r\n    const c3d2 = qmq(c3, d2);\r\n    const _c3d2 = abs($c3d2);\r\n    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * _c3d2;\r\n    const c3d3 = qmq(c3, d3);\r\n    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * abs($c3d3);\r\n    const d0d0 = tp(d0, d0); // error free\r\n    const d0d1 = qmd(d0, d1);\r\n    const d0d1_ = _d0 * d1_ + abs($d0d1);\r\n    const d0d2 = qmd(d0, d2);\r\n    const d0d2_ = _d0 * d2_ + abs($d0d2);\r\n    const d0d3 = qmd(d0, d3);\r\n    const d0d3_ = _d0 * d3_ + abs($d0d3);\r\n    const d1d1 = qmq(d1, d1);\r\n    const _d1d1 = abs($d1d1);\r\n    const d1d1_ = 2 * (d1_ * _d1 + _d1d1);\r\n    const d1d2 = qmq(d1, d2);\r\n    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * abs($d1d2);\r\n    const d3d3 = qmq(d3, d3);\r\n    const d3d3_ = 2 * (d3_ * _d3 + abs($d3d3));\r\n    const d2d2 = qmq(d2, d2);\r\n    const _d2d2 = abs($d2d2);\r\n    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);\r\n    const d2d3 = qmq(d2, d3);\r\n    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * abs($d2d3);\r\n    const d1d3 = qmq(d1, d3);\r\n    const _d1d3 = abs($d1d3);\r\n    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * _d1d3;\r\n    const _c0c0 = abs($c0c0);\r\n    const _c0c1 = abs($c0c1);\r\n    const _c2c3 = abs($c2c3);\r\n    const _c3c3 = abs($c3c3);\r\n    const _c3d3 = abs($c3d3);\r\n    const _c0d0 = abs($c0d0);\r\n    const _d0d0 = abs($d0d0);\r\n    const _d0d1 = abs($d0d1);\r\n    const _d2d3 = abs($d2d3);\r\n    const _d3d3 = abs($d3d3);\r\n    //-----------------------\r\n    //const v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;\r\n    //-----------------------\r\n    const $g1 = $c3 * $c3c3;\r\n    const g1 = qmq(c3, c3c3);\r\n    const _g1 = _c3 * _c3c3;\r\n    const g1_ = c3_ * _c3c3 + _c3 * c3c3_ + 2 * _g1;\r\n    const $g2 = $c3 * $d3d3;\r\n    const g2 = qmq(c3, d3d3);\r\n    const _g2 = _c3 * _d3d3;\r\n    const g2_ = c3_ * _d3d3 + _c3 * d3d3_ + 2 * _g2;\r\n    const $g3 = $d3 * $c3c3;\r\n    const g3 = qmq(d3, c3c3);\r\n    const _g3 = _d3 * _c3c3;\r\n    const g3_ = d3_ * _c3c3 + _d3 * c3c3_ + 2 * _g3;\r\n    const $g4 = $d3 * $d3d3;\r\n    const g4 = qmq(d3, d3d3);\r\n    const _g4 = _d3 * _d3d3;\r\n    const g4_ = d3_ * _d3d3 + _d3 * d3d3_ + 2 * _g4;\r\n    const $g5 = $g1 * $vₓₓₓ;\r\n    const g5 = qmq(g1, vₓₓₓ);\r\n    const g5_ = g1_ * _vₓₓₓ + _g1 * vₓₓₓ_ + 2 * abs($g5);\r\n    const $g6 = $g2 * $vₓᵧᵧ;\r\n    const g6 = qmq(g2, vₓᵧᵧ);\r\n    const g6_ = g2_ * _vₓᵧᵧ + _g2 * vₓᵧᵧ_ + 2 * abs($g6);\r\n    const $g7 = $g3 * $vₓₓᵧ;\r\n    const g7 = qmq(g3, vₓₓᵧ);\r\n    const g7_ = g3_ * _vₓₓᵧ + _g3 * vₓₓᵧ_ + 2 * abs($g7);\r\n    const $g8 = $g4 * $vᵧᵧᵧ;\r\n    const g8 = qmq(g4, vᵧᵧᵧ);\r\n    const g8_ = g4_ * _vᵧᵧᵧ + _g4 * vᵧᵧᵧ_ + 2 * abs($g8);\r\n    const $g9 = $g5 + $g6;\r\n    const g9 = qaq(g5, g6);\r\n    const g9_ = g5_ + g6_ + abs($g9);\r\n    const $ga = $g7 + $g8;\r\n    const ga = qaq(g7, g8);\r\n    const ga_ = g7_ + g8_ + abs($ga);\r\n    const $v9 = $g9 + $ga;\r\n    const v9 = qaq(g9, ga);\r\n    const v9_ = g9_ + ga_ + abs($v9);\r\n    //-----------------------\r\n    //const v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    //-----------------------\r\n    const $w1 = 2 * $c2d3 + $c3d2;\r\n    const _w1 = abs($w1);\r\n    const w1 = qaq(qm2(c2d3), c3d2);\r\n    const w1_ = 2 * c2d3_ + c3d2_ + _w1;\r\n    const $w2 = 2 * $c3d2 + $c2d3;\r\n    const _w2 = abs($w2);\r\n    const w2 = qaq(qm2(c3d2), c2d3);\r\n    const w2_ = 2 * c3d2_ + c2d3_ + abs($w2);\r\n    const $w3 = $c3 * $w1;\r\n    const _w3 = abs($w3);\r\n    const w3 = qmq(c3, w1);\r\n    const w3_ = c3_ * _w1 + _c3 * w1_ + 2 * _w3;\r\n    const $w4 = $d3 * $w2;\r\n    const _w4 = abs($w4);\r\n    const w4 = qmq(d3, w2);\r\n    const w4_ = d3_ * _w2 + _d3 * w2_ + 2 * _w4;\r\n    const $w5 = $c2 * $c3c3;\r\n    const _w5 = abs($w5);\r\n    const w5 = qmq(c2, c3c3);\r\n    const w5_ = c2_ * _c3c3 + _c2 * c3c3_ + 2 * _w5;\r\n    const $w6 = $d2 * $d3d3;\r\n    const _w6 = abs($w6);\r\n    const w6 = qmq(d2, d3d3);\r\n    const w6_ = d2_ * _d3d3 + _d2 * d3d3_ + 2 * _w6;\r\n    const $w7 = $vₓₓₓ * $w5;\r\n    const w7 = qmq(vₓₓₓ, w5);\r\n    const w7_ = w5_ * _vₓₓₓ + _vₓₓₓ * w5_ + 2 * abs($w7);\r\n    const $u1 = $vᵧᵧᵧ * $w6;\r\n    const u1 = qmq(vᵧᵧᵧ, w6);\r\n    const u1_ = w6_ * _vᵧᵧᵧ + _vᵧᵧᵧ * w6_ + 2 * abs($u1);\r\n    const $u2 = $vₓₓᵧ * $w3;\r\n    const u2 = qmq(vₓₓᵧ, w3);\r\n    const u2_ = w3_ * _vₓₓᵧ + _vₓₓᵧ * w3_ + 2 * abs($u2);\r\n    const $u3 = $vₓᵧᵧ * $w4;\r\n    const u3 = qmq(vₓᵧᵧ, w4);\r\n    const u3_ = w4_ * _vₓᵧᵧ + _vₓᵧᵧ * w4_ + 2 * abs($u3);\r\n    const $u4 = $u2 + $u3;\r\n    const u4 = qaq(u2, u3);\r\n    const u4_ = u2_ + u3_ + abs($u4);\r\n    const $u5 = 3 * ($w7 + $u1);\r\n    const u5 = qmd(3, qaq(w7, u1));\r\n    const u5_ = 3 * (w7_ + u1_) + 2 * abs($u5);\r\n    const $v8 = $u4 + $u5;\r\n    const v8 = qaq(u4, u5);\r\n    const v8_ = u4_ + u5_ + abs($v8);\r\n    //-----------------------\r\n    //const v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    //-----------------------\r\n    const $o1 = $c1 * $c3d3;\r\n    const o1 = qmq(c1, c3d3);\r\n    const o1_ = c1_ * _c3d3 + _c1 * c3d3_ + 2 * abs($o1);\r\n    const $o2 = $d1 * $c3c3;\r\n    const o2 = qmq(d1, c3c3);\r\n    const o2_ = d1_ * _c3c3 + _d1 * c3c3_ + 2 * abs($o2);\r\n    const $o3 = $c2 * $d2d3;\r\n    const o3 = qmq(c2, d2d3);\r\n    const o3_ = c2_ * _d2d3 + _c2 * d2d3_ + 2 * abs($o3);\r\n    const $o4 = $c1 * $d3d3;\r\n    const o4 = qmq(c1, d3d3);\r\n    const o4_ = c1_ * _d3d3 + _c1 * d3d3_ + 2 * abs($o4);\r\n    const $o5 = $c2 * $c3d2;\r\n    const o5 = qmq(c2, c3d2);\r\n    const o5_ = c2_ * _c3d2 + _c2 * c3d2_ + 2 * abs($o5);\r\n    const $o6 = $d3 * $c2c2;\r\n    const o6 = qmq(d3, c2c2);\r\n    const o6_ = d3_ * _c2c2 + _d3 * c2c2_ + 2 * abs($o6);\r\n    const $o7 = $c3 * $d1d3;\r\n    const o7 = qmq(c3, d1d3);\r\n    const o7_ = c3_ * _d1d3 + _c3 * d1d3_ + 2 * abs($o7);\r\n    const $o8 = $d2 * $c3d2;\r\n    const o8 = qmq(d2, c3d2);\r\n    const o8_ = d2_ * _c3d2 + _d2 * c3d2_ + 2 * abs($o8);\r\n    const $w8 = $o1 + $o5;\r\n    const w8 = qaq(o1, o5);\r\n    const w8_ = o1_ + o5_ + abs($w8);\r\n    const $w9 = $o2 + $o6;\r\n    const w9 = qaq(o2, o6);\r\n    const w9_ = o2_ + o6_ + abs($w9);\r\n    const $wa = $o3 + $o7;\r\n    const wa = qaq(o3, o7);\r\n    const wa_ = o3_ + o7_ + abs($wa);\r\n    const $wb = $o4 + $o8;\r\n    const wb = qaq(o4, o8);\r\n    const wb_ = o4_ + o8_ + abs($wb);\r\n    const $wc = $c1c3 + $c2c2;\r\n    const wc = qaq(c1c3, c2c2);\r\n    const _wc = abs($wc);\r\n    const wc_ = c1c3_ + c2c2_ + _wc;\r\n    const $wd = $d1d3 + $d2d2;\r\n    const _wd = abs($wd);\r\n    const wd = qaq(d1d3, d2d2);\r\n    const wd_ = d1d3_ + d2d2_ + _wd;\r\n    const $we = 2 * $w8 + $w9;\r\n    const we = qaq(qm2(w8), w9);\r\n    const _we = abs($we);\r\n    const we_ = 2 * w8_ + w9_ + _we;\r\n    const $wf = 2 * $wa + $wb;\r\n    const wf = qaq(qm2(wa), wb);\r\n    const _wf = abs($wf);\r\n    const wf_ = 2 * wa_ + wb_ + _wf;\r\n    const $wg = $vₓₓᵧ * $we;\r\n    const wg = qmq(vₓₓᵧ, we);\r\n    const wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + 2 * abs($wg);\r\n    const $wh = $vₓᵧᵧ * $wf;\r\n    const wh = qmq(vₓᵧᵧ, wf);\r\n    const wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + 2 * abs($wh);\r\n    const $wi = $c3 * $wc;\r\n    const wi = qmq(c3, wc);\r\n    const _wi = abs($wi);\r\n    const wi_ = c3_ * _wc + _c3 * wc_ + 2 * _wi;\r\n    const $wj = $d3 * $wd;\r\n    const wj = qmq(d3, wd);\r\n    const _wj = abs($wj);\r\n    const wj_ = d3_ * _wd + _d3 * wd_ + 2 * _wj;\r\n    const $wk = $vₓₓₓ * $wi;\r\n    const wk = qmq(vₓₓₓ, wi);\r\n    const wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + 2 * abs($wk);\r\n    const $wl = $vᵧᵧᵧ * $wj;\r\n    const wl = qmq(vᵧᵧᵧ, wj);\r\n    const wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + 2 * abs($wl);\r\n    const $wm = $wg + $wh;\r\n    const wm = qaq(wg, wh);\r\n    const wm_ = wg_ + wh_ + abs($wm);\r\n    const $wn = 3 * ($wk + $wl);\r\n    const wn = qmd(3, qaq(wk, wl));\r\n    const wn_ = 3 * (wk_ + wl_) + 2 * abs($wn);\r\n    const $v7 = $wm + $wn;\r\n    const v7 = qaq(wm, wn);\r\n    const v7_ = wm_ + wn_ + abs($v7);\r\n    //const v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    const $wo = $c2d3 + $c3d2;\r\n    const wo = qaq(c2d3, c3d2);\r\n    const _wo = abs($wo);\r\n    const wo_ = c2d3_ + c3d2_ + _wo;\r\n    const $zc = $d2 * $c2c2;\r\n    const zc = qmq(d2, c2c2);\r\n    const zc_ = d2_ * _c2c2 + _d2 * c2c2_ + 2 * abs($zc);\r\n    const $zd = 2 * $c1 * $wo;\r\n    const zd = qm2(qmq(c1, wo));\r\n    const zd_ = 2 * (c1_ * _wo + _c1 * wo_ + 2 * abs($zd));\r\n    const $wp = $zc + $zd;\r\n    const wp = qaq(zc, zd);\r\n    const wp_ = zc_ + zd_ + abs($wp);\r\n    const $wq = 2 * ($c0d3 + $c2d1);\r\n    const wq = qm2(qaq(c0d3, c2d1));\r\n    const wq_ = 2 * (c0d3_ + c2d1_) + abs($wq);\r\n    const $wr = $wq + $c3d0;\r\n    const _wr = abs($wr);\r\n    const wr = qaq(wq, c3d0);\r\n    const wr_ = wq_ + c3d0_ + _wr;\r\n    const $ze = $c3 * $wr;\r\n    const ze = qmq(c3, wr);\r\n    const ze_ = c3_ * _wr + _c3 * wr_ + 2 * abs($ze);\r\n    const $ws = $wp + $ze;\r\n    const ws = qaq(wp, ze);\r\n    const _ws = abs($ws);\r\n    const ws_ = wp_ + ze_ + _ws;\r\n    const $zf = $c2 * $d2d2;\r\n    const zf = qmq(c2, d2d2);\r\n    const zf_ = c2_ * _d2d2 + _c2 * d2d2_ + 2 * abs($zf);\r\n    const $zg = 2 * $d1 * $wo;\r\n    const zg = qm2(qmq(d1, wo));\r\n    const zg_ = 2 * (d1_ * _wo + _d1 * wo_ + abs($zg));\r\n    const $wt = $zf + $zg;\r\n    const wt = qaq(zf, zg);\r\n    const wt_ = zf_ + zg_ + abs($wt);\r\n    const $wu = 2 * ($c1d2 + $c3d0);\r\n    const wu = qm2(qaq(c1d2, c3d0));\r\n    const wu_ = 2 * (c1d2_ + c3d0_) + abs($wu);\r\n    const $wv = $wu + $c0d3;\r\n    const wv = qaq(wu, c0d3);\r\n    const _wv = abs($wv);\r\n    const wv_ = wu_ + c0d3_ + _wv;\r\n    const $zh = $d3 * $wv;\r\n    const zh = qmq(d3, wv);\r\n    const zh_ = d3_ * _wv + _d3 * wv_ + 2 * abs($zh);\r\n    const $ww = $wt + $zh;\r\n    const ww = qaq(wt, zh);\r\n    const _ww = abs($ww);\r\n    const ww_ = wt_ + zh_ + _ww;\r\n    const $wx = $c2 * $c2c2;\r\n    const wx = qmq(c2, c2c2);\r\n    const wx_ = c2_ * _c2c2 + _c2 * c2c2_ + 2 * abs($wx);\r\n    const $wy = 2 * $c1c2 + $c0c3;\r\n    const wy = qaq(qm2(c1c2), c0c3);\r\n    const _wy = abs($wy);\r\n    const wy_ = 2 * c1c2_ + c0c3_ + _wy;\r\n    const $q1 = 3 * $c3;\r\n    const q1 = qmd(3, c3);\r\n    const _q1 = abs($q1);\r\n    const q1_ = 3 * c3_ + _q1;\r\n    const $wz = $q1 * $wy;\r\n    const wz = qmq(q1, wy);\r\n    const wz_ = q1_ * _wy + _q1 * wy_ + 2 * abs($wz);\r\n    const $z1 = $wx + $wz;\r\n    const z1 = qaq(wx, wz);\r\n    const _z1 = abs($z1);\r\n    const z1_ = wx_ + wz_ + _z1;\r\n    const $z2 = $d2 * $d2d2;\r\n    const z2 = qmq(d2, d2d2);\r\n    const z2_ = d2_ * _d2d2 + _d2 * d2d2_ + 2 * abs($z2);\r\n    const $z3 = 2 * $d1d2 + $d0d3;\r\n    const z3 = qaq(qm2(d1d2), d0d3);\r\n    const _z3 = abs($z3);\r\n    const z3_ = 2 * d1d2_ + d0d3_ + _z3;\r\n    const $q2 = 3 * $d3;\r\n    const q2 = qmd(3, d3);\r\n    const _q2 = abs($q2);\r\n    const q2_ = 3 * d3_ + _q2;\r\n    const $z4 = $q2 * $z3;\r\n    const z4 = qmq(q2, z3);\r\n    const z4_ = q2_ * _z3 + _q2 * z3_ + 2 * abs($z4);\r\n    const $z5 = $z2 + $z4;\r\n    const z5 = qaq(z2, z4);\r\n    const _z5 = abs($z5);\r\n    const z5_ = z2_ + z4_ + _z5;\r\n    const $zi = $vₓₓᵧ * $ws;\r\n    const zi = qmq(vₓₓᵧ, ws);\r\n    const zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + 2 * abs($zi);\r\n    const $zj = $vₓᵧᵧ * $ww;\r\n    const zj = qmq(vₓᵧᵧ, ww);\r\n    const zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + 2 * abs($zj);\r\n    const $z6 = $zi + $zj;\r\n    const z6 = qaq(zi, zj);\r\n    const z6_ = zi_ + zj_ + abs($z6);\r\n    const $zk = $vₓₓₓ * $z1;\r\n    const zk = qmq(vₓₓₓ, z1);\r\n    const zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + 2 * abs($zk);\r\n    const $zl = $vᵧᵧᵧ * $z5;\r\n    const zl = qmq(vᵧᵧᵧ, z5);\r\n    const zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + 2 * abs($zl);\r\n    const $z7 = $zk + $zl;\r\n    const z7 = qaq(zk, zl);\r\n    const z7_ = zk_ + zl_ + abs($z7);\r\n    const $zm = $vₓₓ * $c3c3;\r\n    const zm = qmq(c3c3, vₓₓ);\r\n    const zm_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * abs($zm);\r\n    const $zn = $vᵧᵧ * $d3d3;\r\n    const zn = qmq(d3d3, vᵧᵧ);\r\n    const zn_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * abs($zn);\r\n    const $z8 = $zm + $zn;\r\n    const z8 = qaq(zm, zn);\r\n    const z8_ = zm_ + zn_ + abs($z8);\r\n    const $z9 = $vₓᵧ * $c3d3;\r\n    const z9 = qmq(c3d3, vₓᵧ);\r\n    const z9_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * abs($z9);\r\n    const $za = $z6 + $z7;\r\n    const za = qaq(z6, z7);\r\n    const za_ = z6_ + z7_ + abs($za);\r\n    const $zb = $z8 + $z9;\r\n    const zb = qaq(z8, z9);\r\n    const zb_ = z8_ + z9_ + abs($zb);\r\n    const $v6 = $za + $zb;\r\n    const v6 = qaq(za, zb);\r\n    const v6_ = za_ + zb_ + abs($v6);\r\n    //const r4 = c2d2 + c3d1;\r\n    //const r5 = c1d3 + c2d2;\r\n    //const v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    const $r4 = $c2d2 + $c3d1;\r\n    const r4 = qaq(c2d2, c3d1);\r\n    const _r4 = abs($r4);\r\n    const r4_ = c2d2_ + c3d1_ + _r4;\r\n    const $r5 = $c1d3 + $c2d2;\r\n    const r5 = qaq(c1d3, c2d2);\r\n    const _r5 = abs($r5);\r\n    const r5_ = c1d3_ + c2d2_ + _r5;\r\n    const $k1 = c0 * $wo;\r\n    const k1 = qmd(c0, wo);\r\n    const k1_ = _c0 * wo_ + abs($k1);\r\n    const $k2 = d0 * $wo;\r\n    const k2 = qmd(d0, wo);\r\n    const k2_ = _d0 * wo_ + abs($k2);\r\n    const $k3 = $c1 * $r4;\r\n    const k3 = qmq(c1, r4);\r\n    const k3_ = c1_ * _r4 + _c1 * r4_ + 2 * abs($k3);\r\n    const $k4 = $d1 * $r5;\r\n    const k4 = qmq(d1, r5);\r\n    const k4_ = d1_ * _r5 + _d1 * r5_ + 2 * abs($k4);\r\n    const $k5 = 2 * $c3d0 + $c2d1;\r\n    const k5 = qaq(qm2(c3d0), c2d1);\r\n    const _k5 = abs($k5);\r\n    const k5_ = 2 * c3d0_ + c2d1_ + _k5;\r\n    const $k6 = 2 * $c0d3 + $c1d2;\r\n    const k6 = qaq(qm2(c0d3), c1d2);\r\n    const _k6 = abs($k6);\r\n    const k6_ = 2 * c0d3_ + c1d2_ + _k6;\r\n    const $k7 = $d3 * $c1c1;\r\n    const k7 = qmq(d3, c1c1);\r\n    const k7_ = d3_ * _c1c1 + _d3 * c1c1_ + 2 * abs($k7);\r\n    const $k8 = $c3 * $d1d1;\r\n    const k8 = qmq(c3, d1d1);\r\n    const k8_ = c3_ * _d1d1 + _c3 * d1d1_ + 2 * abs($k8);\r\n    const $k9 = $c2 * $k5;\r\n    const k9 = qmq(c2, k5);\r\n    const k9_ = c2_ * _k5 + _c2 * k5_ + 2 * abs($k9);\r\n    const $ka = $d2 * $k6;\r\n    const ka = qmq(d2, k6);\r\n    const ka_ = d2_ * _k6 + _d2 * k6_ + 2 * abs($ka);\r\n    const $kb = 2 * ($k1 + $k3);\r\n    const kb = qm2(qaq(k1, k3));\r\n    const kb_ = 2 * (k1_ + k3_) + abs($kb);\r\n    const $kc = 2 * ($k2 + $k4);\r\n    const kc = qm2(qaq(k2, k4));\r\n    const kc_ = 2 * (k2_ + k4_) + abs($kc);\r\n    const $kd = 2 * c0 * $c2c3;\r\n    const kd = qm2(qmd(c0, c2c3));\r\n    const kd_ = 2 * _c0 * c2c3_ + abs($kd);\r\n    const $ke = 2 * d0 * $d2d3;\r\n    const ke = qm2(qmd(d0, d2d3));\r\n    const ke_ = 2 * _d0 * d2d3_ + abs($ke);\r\n    const $kf = $c1 * $wc;\r\n    const kf = qmq(c1, wc);\r\n    const kf_ = c1_ * _wc + _c1 * wc_ + 2 * abs($kf);\r\n    const $kg = $d1 * $wd;\r\n    const kg = qmq(d1, wd);\r\n    const kg_ = d1_ * _wd + _d1 * wd_ + 2 * abs($kg);\r\n    const $kh = $vₓₓ * $c2c3;\r\n    const kh = qmq(c2c3, vₓₓ);\r\n    const kh_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * abs($kh);\r\n    const $ki = $vᵧᵧ * $d2d3;\r\n    const ki = qmq(d2d3, vᵧᵧ);\r\n    const ki_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * abs($ki);\r\n    const $kj = $kb + $k7;\r\n    const kj = qaq(kb, k7);\r\n    const _kj = abs($kj);\r\n    const kj_ = kb_ + k7_ + _kj;\r\n    const $kk = $kc + $k8;\r\n    const kk = qaq(kc, k8);\r\n    const _kk = abs($kk);\r\n    const kk_ = kc_ + k8_ + _kk;\r\n    const $kl = $kj + $k9;\r\n    const kl = qaq(kj, k9);\r\n    const _kl = abs($kl);\r\n    const kl_ = kj_ + k9_ + _kl;\r\n    const $km = $kk + $ka;\r\n    const km = qaq(kk, ka);\r\n    const _km = abs($km);\r\n    const km_ = kk_ + ka_ + _km;\r\n    const $kn = $kd + $kf;\r\n    const kn = qaq(kd, kf);\r\n    const _kn = abs($kn);\r\n    const kn_ = kd_ + kf_ + _kn;\r\n    const $ko = $ke + $kg;\r\n    const ko = qaq(ke, kg);\r\n    const _ko = abs($ko);\r\n    const ko_ = ke_ + kg_ + _ko;\r\n    const $kp = 2 * ($kh + $ki);\r\n    const kp = qm2(qaq(kh, ki));\r\n    const kp_ = 2 * (kh_ + ki_) + abs($kp);\r\n    const $kq = $vₓₓᵧ * $kl;\r\n    const kq = qmq(vₓₓᵧ, kl);\r\n    const kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + 2 * abs($kq);\r\n    const $kr = $vₓᵧᵧ * $km;\r\n    const kr = qmq(vₓᵧᵧ, km);\r\n    const kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + 2 * abs($kr);\r\n    const $ks = $vₓₓₓ * $kn;\r\n    const ks = qmq(vₓₓₓ, kn);\r\n    const ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + 2 * abs($ks);\r\n    const $kt = $vᵧᵧᵧ * $ko;\r\n    const kt = qmq(vᵧᵧᵧ, ko);\r\n    const kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + 2 * abs($kt);\r\n    const $ku = $kq + $kr;\r\n    const ku = qaq(kq, kr);\r\n    const ku_ = kq_ + kr_ + abs($ku);\r\n    const $kv = 3 * ($ks + $kt);\r\n    const kv = qmd(3, qaq(ks, kt));\r\n    const kv_ = 3 * (ks_ + kt_) + 2 * abs($kv);\r\n    const $kw = $vₓᵧ * $wo;\r\n    const kw = qmq(vₓᵧ, wo);\r\n    const kw_ = vₓᵧ_ * _wo + _vₓᵧ * wo_ + 2 * abs($kw);\r\n    const $kx = $ku + $kv;\r\n    const kx = qaq(ku, kv);\r\n    const kx_ = ku_ + kv_ + abs($kx);\r\n    const $ky = $kw + $kp;\r\n    const ky = qaq(kw, kp);\r\n    const ky_ = kw_ + kp_ + abs($ky);\r\n    const $v5 = $kx + $ky;\r\n    const v5 = qaq(kx, ky);\r\n    const v5_ = kx_ + ky_ + abs($v5);\r\n    //const r1 = c1d3 + r4;\r\n    //const r2 = 2*c1c3 + c2c2;\r\n    //const r3 = 2*d1d3 + d2d2;\r\n    //const v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    const $r1 = $c1d3 + $r4;\r\n    const r1 = qaq(c1d3, r4);\r\n    const _r1 = abs($r1);\r\n    const r1_ = c1d3_ + r4_ + _r1;\r\n    const $r2 = 2 * $c1c3 + $c2c2;\r\n    const r2 = qaq(qm2(c1c3), c2c2);\r\n    const _r2 = abs($r2);\r\n    const r2_ = 2 * c1c3_ + c2c2_ + _r2;\r\n    const $r3 = 2 * $d1d3 + $d2d2;\r\n    const r3 = qaq(qm2(d1d3), d2d2);\r\n    const _r3 = abs($r3);\r\n    const r3_ = 2 * d1d3_ + d2d2_ + _r3;\r\n    const $s1 = 2 * c0 * $r1;\r\n    const s1 = qmd(2 * c0, r1);\r\n    const s1_ = 2 * _c0 * r1_ + abs($s1);\r\n    const $s2 = 2 * d0 * $r1;\r\n    const s2 = qmd(2 * d0, r1);\r\n    const s2_ = 2 * _d0 * r1_ + abs($s2);\r\n    const $s5 = $c1d2 + 2 * $c2d1;\r\n    const s5 = qaq(c1d2, qm2(c2d1));\r\n    const _s5 = abs($s5);\r\n    const s5_ = c1d2_ + 2 * c2d1_ + _s5;\r\n    const $s6 = $c2d1 + 2 * $c1d2;\r\n    const s6 = qaq(c2d1, qm2(c1d2));\r\n    const _s6 = abs($s6);\r\n    const s6_ = c2d1_ + 2 * c1d2_ + _s6;\r\n    const $s3 = d0 * $r2;\r\n    const s3 = qmd(d0, r2);\r\n    const s3_ = _d0 * r2_ + abs($s3);\r\n    const $s4 = c0 * $r3;\r\n    const s4 = qmd(c0, r3);\r\n    const s4_ = _c0 * r3_ + abs($s4);\r\n    const $s7 = $c1 * $s5;\r\n    const s7 = qmq(c1, s5);\r\n    const s7_ = c1_ * _s5 + _c1 * s5_ + 2 * abs($s7);\r\n    const $s8 = $d1 * $s6;\r\n    const s8 = qmq(d1, s6);\r\n    const s8_ = d1_ * _s6 + _d1 * s6_ + 2 * abs($s8);\r\n    const $s9 = c0 * $r2;\r\n    const s9 = qmd(c0, r2);\r\n    const s9_ = _c0 * r2_ + abs($s9);\r\n    const $sa = d0 * $r3;\r\n    const sa = qmd(d0, r3);\r\n    const sa_ = _d0 * r3_ + abs($sa);\r\n    const $sb = $c2 * $c1c1;\r\n    const sb = qmq(c2, c1c1);\r\n    const sb_ = c2_ * _c1c1 + _c2 * c1c1_ + 2 * abs($sb);\r\n    const $sc = $d2 * $d1d1;\r\n    const sc = qmq(d2, d1d1);\r\n    const sc_ = d2_ * _d1d1 + _d2 * d1d1_ + 2 * abs($sc);\r\n    const $sd = $s1 + $s3;\r\n    const sd = qaq(s1, s3);\r\n    const sd_ = s1_ + s3_ + abs($sd);\r\n    const $se = $s2 + $s4;\r\n    const se = qaq(s2, s4);\r\n    const se_ = s2_ + s4_ + abs($se);\r\n    const $sf = $sd + $s7;\r\n    const sf = qaq(sd, s7);\r\n    const _sf = abs($sf);\r\n    const sf_ = sd_ + s7_ + _sf;\r\n    const $sg = $se + $s8;\r\n    const sg = qaq(se, s8);\r\n    const _sg = abs($sg);\r\n    const sg_ = se_ + s8_ + _sg;\r\n    const $sh = $s9 + $sb;\r\n    const sh = qaq(s9, sb);\r\n    const _sh = abs($sh);\r\n    const sh_ = s9_ + sb_ + _sh;\r\n    const $si = $sa + $sc;\r\n    const si = qaq(sa, sc);\r\n    const _si = abs($si);\r\n    const si_ = sa_ + sc_ + _si;\r\n    const $sj = $vₓₓᵧ * $sf;\r\n    const sj = qmq(vₓₓᵧ, sf);\r\n    const sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + 2 * abs($sj);\r\n    const $sk = $vₓᵧᵧ * $sg;\r\n    const sk = qmq(vₓᵧᵧ, sg);\r\n    const sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + 2 * abs($sk);\r\n    const $sl = $vₓₓₓ * $sh;\r\n    const sl = qmq(vₓₓₓ, sh);\r\n    const sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + 2 * abs($sl);\r\n    const $sm = $vᵧᵧᵧ * $si;\r\n    const sm = qmq(vᵧᵧᵧ, si);\r\n    const sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + 2 * abs($sm);\r\n    const $sn = $sl + $sm;\r\n    const _sn = abs($sn);\r\n    const sn = qaq(sl, sm);\r\n    const sn_ = sl_ + sm_ + _sn;\r\n    const $so = $sj + $sk;\r\n    const so = qaq(sj, sk);\r\n    const so_ = sj_ + sk_ + abs($so);\r\n    const $sp = $so + 3 * $sn;\r\n    const sp = qaq(so, qmd(3, sn));\r\n    const sp_ = so_ + 3 * (sn_ + _sn) + abs($sp);\r\n    const $ss = $vₓᵧ * $r1;\r\n    const ss = qmq(vₓᵧ, r1);\r\n    const ss_ = vₓᵧ_ * _r1 + _vₓᵧ * r1_ + 2 * abs($ss);\r\n    const $st = $vₓₓ * $r2;\r\n    const st = qmq(vₓₓ, r2);\r\n    const st_ = vₓₓ_ * _r2 + _vₓₓ * r2_ + 2 * abs($st);\r\n    const $sq = $ss + $st;\r\n    const sq = qaq(ss, st);\r\n    const sq_ = ss_ + st_ + abs($sq);\r\n    const $su = $vᵧᵧ * $r3;\r\n    const su = qmq(vᵧᵧ, r3);\r\n    const su_ = vᵧᵧ_ * _r3 + _vᵧᵧ * r3_ + 2 * abs($su);\r\n    const $sr = $sq + $su;\r\n    const sr = qaq(sq, su);\r\n    const sr_ = sq_ + su_ + abs($sr);\r\n    const $v4 = $sp + $sr;\r\n    const v4 = qaq(sp, sr);\r\n    const v4_ = sp_ + sr_ + abs($v4);\r\n    //const r6 = c1d2 + c2d1;\r\n    //const r7 = c3d0 + c0d3;\r\n    //const r8 = c1c2 + c0c3;\r\n    //const r9 = d1d2 + d0d3;\r\n    //const v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    const $r6 = $c1d2 + $c2d1;\r\n    const r6 = qaq(c1d2, c2d1);\r\n    const r6_ = c1d2_ + c2d1_ + abs($r6);\r\n    const $r7 = $c3d0 + $c0d3;\r\n    const r7 = qaq(c3d0, c0d3);\r\n    const r7_ = c3d0_ + c0d3_ + abs($r7);\r\n    const $r8 = $c1c2 + $c0c3;\r\n    const r8 = qaq(c1c2, c0c3);\r\n    const r8_ = c1c2_ + c0c3_ + abs($r8);\r\n    const _r8 = abs($r8);\r\n    const $r9 = $d1d2 + $d0d3;\r\n    const r9 = qaq(d1d2, d0d3);\r\n    const r9_ = d1d2_ + d0d3_ + abs($r9);\r\n    const _r9 = abs($r9);\r\n    const $m1 = 2 * $r6 + $c3d0;\r\n    const m1 = qaq(qm2(r6), c3d0);\r\n    const m1_ = 2 * r6_ + c3d0_ + abs($m1);\r\n    const $m2 = 2 * $r6 + $c0d3;\r\n    const m2 = qaq(qm2(r6), c0d3);\r\n    const m2_ = 2 * r6_ + c0d3_ + abs($m2);\r\n    const $m3 = 2 * $c2d0 + $c1d1;\r\n    const m3 = qaq(qm2(c2d0), c1d1);\r\n    const _m3 = abs($m3);\r\n    const m3_ = 2 * c2d0_ + c1d1_ + _m3;\r\n    const $m4 = 2 * $c0d2 + $c1d1;\r\n    const m4 = qaq(qm2(c0d2), c1d1);\r\n    const _m4 = abs($m4);\r\n    const m4_ = 2 * c0d2_ + c1d1_ + _m4;\r\n    const $m5 = $r8 + $c1c2;\r\n    const m5 = qaq(r8, c1c2);\r\n    const m5_ = r8_ + c1c2_ + abs($m5);\r\n    const $m6 = $r9 + $d1d2;\r\n    const m6 = qaq(r9, d1d2);\r\n    const m6_ = r9_ + d1d2_ + abs($m6);\r\n    const $q3 = 3 * c0;\r\n    const q3 = tp(3, c0); // error free\r\n    const $m7 = $q3 * $m5;\r\n    const m7 = qmq(q3, m5);\r\n    const m7_ = abs($q3) * m5_ + 2 * abs($m7);\r\n    const $q4 = 3 * d0;\r\n    const q4 = tp(3, d0); // error free\r\n    const $m8 = $q4 * $m6;\r\n    const m8 = qmq(q4, m6);\r\n    const m8_ = abs($q4) * m6_ + 2 * abs($m8);\r\n    const $m9 = $c1 * $c1c1;\r\n    const m9 = qmq(c1, c1c1);\r\n    const m9_ = c1_ * _c1c1 + _c1 * c1c1_ + 2 * abs($m9);\r\n    const $ma = $d1 * $d1d1;\r\n    const ma = qmq(d1, d1d1);\r\n    const ma_ = d1_ * _d1d1 + _d1 * d1d1_ + 2 * abs($ma);\r\n    const $mb = $vₓₓ * $r8;\r\n    const mb = qmq(vₓₓ, r8);\r\n    const mb_ = vₓₓ_ * _r8 + _vₓₓ * r8_ + abs($mb);\r\n    const $mc = $vᵧᵧ * $r9;\r\n    const mc = qmq(vᵧᵧ, r9);\r\n    const mc_ = vᵧᵧ_ * _r9 + _vᵧᵧ * r9_ + abs($mc);\r\n    const $md = $m1 + $r7;\r\n    const md = qaq(m1, r7);\r\n    const md_ = m1_ + r7_ + abs($md);\r\n    const $me = $m2 + $r7;\r\n    const me = qaq(m2, r7);\r\n    const me_ = m2_ + r7_ + abs($me);\r\n    const $mf = c0 * $md;\r\n    const mf = qmd(c0, md);\r\n    const mf_ = _c0 * md_ + abs($mf);\r\n    const $mg = d0 * $me;\r\n    const mg = qmd(d0, me);\r\n    const mg_ = _d0 * me_ + abs($mg);\r\n    const $mh = $c1 * $m3;\r\n    const mh = qmq(c1, m3);\r\n    const mh_ = c1_ * _m3 + _c1 * m3_ + 2 * abs($mh);\r\n    const $mi = $d1 * $m4;\r\n    const mi = qmq(d1, m4);\r\n    const mi_ = d1_ * _m4 + _d1 * m4_ + 2 * abs($mi);\r\n    const $mj = $c3 * $vₓ;\r\n    const mj = qmq(c3, vₓ);\r\n    const mj_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * abs($mj);\r\n    const $mk = $d3 * $vᵧ;\r\n    const mk = qmq(d3, vᵧ);\r\n    const mk_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * abs($mk);\r\n    const $ml = $mf + $mh;\r\n    const ml = qaq(mf, mh);\r\n    const _ml = abs($ml);\r\n    const ml_ = mf_ + mh_ + _ml;\r\n    const $mm = $mg + $mi;\r\n    const mm = qaq(mg, mi);\r\n    const _mm = abs($mm);\r\n    const mm_ = mg_ + mi_ + _mm;\r\n    const $mn = $m7 + $m9;\r\n    const mn = qaq(m7, m9);\r\n    const _mn = abs($mn);\r\n    const mn_ = m7_ + m9_ + _mn;\r\n    const $mo = $m8 + $ma;\r\n    const mo = qaq(m8, ma);\r\n    const _mo = abs($mo);\r\n    const mo_ = m8_ + ma_ + _mo;\r\n    const $mp = $r7 + $r6;\r\n    const mp = qaq(r7, r6);\r\n    const _mp = abs($mp);\r\n    const mp_ = r7_ + r6_ + _mp;\r\n    const $mq = 2 * ($mb + $mc);\r\n    const mq = qm2(qaq(mb, mc));\r\n    const mq_ = 2 * (mb_ + mc_) + abs($mq);\r\n    const $mr = $vₓₓᵧ * $ml;\r\n    const mr = qmq(vₓₓᵧ, ml);\r\n    const mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + 2 * abs($mr);\r\n    const $ms = $vₓᵧᵧ * $mm;\r\n    const ms = qmq(vₓᵧᵧ, mm);\r\n    const ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + 2 * abs($ms);\r\n    const $mt = $vₓₓₓ * $mn;\r\n    const mt = qmq(vₓₓₓ, mn);\r\n    const mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + 2 * abs($mt);\r\n    const $mu = $vᵧᵧᵧ * $mo;\r\n    const mu = qmq(vᵧᵧᵧ, mo);\r\n    const mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + 2 * abs($mu);\r\n    const $mv = $vₓᵧ * $mp;\r\n    const mv = qmq(vₓᵧ, mp);\r\n    const mv_ = vₓᵧ_ * _mp + _vₓᵧ * mp_ + 2 * abs($mv);\r\n    const $mw = $mr + $ms;\r\n    const mw = qaq(mr, ms);\r\n    const mw_ = mr_ + ms_ + abs($mw);\r\n    const $mx = $mt + $mu;\r\n    const mx = qaq(mt, mu);\r\n    const mx_ = mt_ + mu_ + abs($mx);\r\n    const $my = $mv + $mq;\r\n    const my = qaq(mv, mq);\r\n    const my_ = mv_ + mq_ + abs($my);\r\n    const $mz = $mj + $mk;\r\n    const mz = qaq(mj, mk);\r\n    const mz_ = mj_ + mk_ + abs($mz);\r\n    const $n1 = $mw + $mx;\r\n    const n1 = qaq(mw, mx);\r\n    const n1_ = mw_ + mx_ + abs($n1);\r\n    const $n2 = $my + $mz;\r\n    const n2 = qaq(my, mz);\r\n    const n2_ = my_ + mz_ + abs($n2);\r\n    const $v3 = $n1 + $n2;\r\n    const v3 = qaq(n1, n2);\r\n    const v3_ = n1_ + n2_ + abs($v3);\r\n    //const ra = c1d1 + c2d0;\r\n    //const rb = c1d1 + c0d2;\r\n    //const v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    const $ra = $c1d1 + $c2d0;\r\n    const ra = qaq(c1d1, c2d0);\r\n    const ra_ = c1d1_ + c2d0_ + abs($ra);\r\n    const $rb = $c1d1 + $c0d2;\r\n    const rb = qaq(c1d1, c0d2);\r\n    const rb_ = c1d1_ + c0d2_ + abs($rb);\r\n    const $l1 = 2 * $ra + $c0d2;\r\n    const l1 = qaq(qm2(ra), c0d2);\r\n    const l1_ = 2 * ra_ + c0d2_ + abs($l1);\r\n    const $l2 = 2 * $rb + $c2d0;\r\n    const l2 = qaq(qm2(rb), c2d0);\r\n    const l2_ = 2 * rb_ + c2d0_ + abs($l2);\r\n    const $l3 = c0 * $l1;\r\n    const l3 = qmd(c0, l1);\r\n    const l3_ = _c0 * l1_ + abs($l3);\r\n    const $l4 = d0 * $c1c1;\r\n    const l4 = qmd(d0, c1c1);\r\n    const l4_ = _d0 * c1c1_ + abs($l4);\r\n    const $l5 = d0 * $l2;\r\n    const l5 = qmd(d0, l2);\r\n    const l5_ = _d0 * l2_ + abs($l5);\r\n    const $l6 = c0 * $d1d1;\r\n    const l6 = qmd(c0, d1d1);\r\n    const l6_ = _c0 * d1d1_ + abs($l6);\r\n    const $l7 = c0 * $c1c1;\r\n    const l7 = qmd(c0, c1c1);\r\n    const l7_ = _c0 * c1c1_ + abs($l7);\r\n    const $l8 = $c2 * $c0c0;\r\n    const l8 = qmq(c2, c0c0);\r\n    const l8_ = c2_ * _c0c0 + 2 * abs($l8);\r\n    const $l9 = d0 * $d1d1;\r\n    const l9 = qmd(d0, d1d1);\r\n    const l9_ = _d0 * d1d1_ + abs($l9);\r\n    const $la = $d2 * $d0d0;\r\n    const la = qmq(d2, d0d0);\r\n    const la_ = d2_ * _d0d0 + 2 * abs($la);\r\n    const $lb = $l3 + $l4;\r\n    const lb = qaq(l3, l4);\r\n    const _lb = l3_ + l4_ + abs($lb);\r\n    const lb_ = l3_ + l4_ + _lb;\r\n    const $lc = $l5 + $l6;\r\n    const lc = qaq(l5, l6);\r\n    const _lc = l5_ + l6_ + abs($lc);\r\n    const lc_ = l5_ + l6_ + _lc;\r\n    const $ld = $l7 + $l8;\r\n    const ld = qaq(l7, l8);\r\n    const _ld = abs($ld);\r\n    const ld_ = l7_ + l8_ + _ld;\r\n    const $le = $l9 + $la;\r\n    const le = qaq(l9, la);\r\n    const _le = abs($le);\r\n    const le_ = l9_ + la_ + _le;\r\n    const $lf = $vₓₓₓ * $ld;\r\n    const lf = qmq(vₓₓₓ, ld);\r\n    const lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + 2 * abs($lf);\r\n    const $lg = $vᵧᵧᵧ * $le;\r\n    const lg = qmq(vᵧᵧᵧ, le);\r\n    const lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + 2 * abs($lg);\r\n    const $lh = 3 * ($lf + $lg);\r\n    const lh = qmd(3, qaq(lf, lg));\r\n    const lh_ = 3 * (lf_ + lg_) + 2 * abs($lh);\r\n    const $li = $ra + $c0d2;\r\n    const li = qaq(ra, c0d2);\r\n    const _li = abs($li);\r\n    const li_ = ra_ + c0d2_ + _li;\r\n    const $lj = 2 * $c0c2 + $c1c1;\r\n    const lj = qaq(qm2(c0c2), c1c1);\r\n    const _lj = abs($lj);\r\n    const lj_ = 2 * c0c2_ + c1c1_ + _lj;\r\n    const $lk = 2 * $d0d2 + $d1d1;\r\n    const lk = qaq(qm2(d0d2), d1d1);\r\n    const _lk = abs($lk);\r\n    const lk_ = 2 * d0d2_ + d1d1_ + _lk;\r\n    const $ll = $vₓₓᵧ * $lb;\r\n    const ll = qmq(vₓₓᵧ, lb);\r\n    const ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + 2 * abs($ll);\r\n    const $lm = $vₓᵧᵧ * $lc;\r\n    const lm = qmq(vₓᵧᵧ, lc);\r\n    const lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + 2 * abs($lm);\r\n    const $ln = $vₓᵧ * $li;\r\n    const ln = qmq(vₓᵧ, li);\r\n    const ln_ = vₓᵧ_ * _li + _vₓᵧ * li_ + 2 * abs($ln);\r\n    const $lo = $vₓₓ * $lj;\r\n    const lo = qmq(vₓₓ, lj);\r\n    const lo_ = vₓₓ_ * _lj + _vₓₓ * lj_ + 2 * abs($lo);\r\n    const $lp = $vᵧᵧ * $lk;\r\n    const lp = qmq(vᵧᵧ, lk);\r\n    const lp_ = vᵧᵧ_ * _lk + _vᵧᵧ * lk_ + 2 * abs($lp);\r\n    const $lq = $c2 * $vₓ;\r\n    const lq = qmq(c2, vₓ);\r\n    const lq_ = c2_ * _vₓ + _c2 * vₓ_ + abs($lq);\r\n    const $lr = $d2 * $vᵧ;\r\n    const lr = qmq(d2, vᵧ);\r\n    const lr_ = d2_ * _vᵧ + _d2 * vᵧ_ + abs($lr);\r\n    const $ls = $lq + $lr;\r\n    const ls = qaq(lq, lr);\r\n    const ls_ = lq_ + lr_ + abs($ls);\r\n    const $lt = $ll + $lm;\r\n    const lt = qaq(ll, lm);\r\n    const lt_ = ll_ + lm_ + abs($lt);\r\n    const $lu = $lh + $ln;\r\n    const lu = qaq(lh, ln);\r\n    const lu_ = lh_ + ln_ + abs($lu);\r\n    const $lv = $lo + $lp;\r\n    const lv = qaq(lo, lp);\r\n    const lv_ = lo_ + lp_ + abs($lv);\r\n    const $lw = $lt + $lu;\r\n    const lw = qaq(lt, lu);\r\n    const lw_ = lt_ + lu_ + abs($lw);\r\n    const $lx = $lv + $ls;\r\n    const lx = qaq(lv, ls);\r\n    const lx_ = lv_ + ls_ + abs($lx);\r\n    const $v2 = $lw + $lx;\r\n    const v2 = qaq(lw, lx);\r\n    const v2_ = lw_ + lx_ + abs($v2);\r\n    //const rc = c1d0 + c0d1;\r\n    //const v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    const $rc = $c1d0 + $c0d1;\r\n    const rc = qaq(c1d0, c0d1);\r\n    const _rc = abs($rc);\r\n    const rc_ = c1d0_ + c0d1_ + _rc;\r\n    const $rd = c0 * $vₓₓᵧ;\r\n    const rd = qmd(c0, vₓₓᵧ);\r\n    const _rd = abs($rd);\r\n    const rd_ = _c0 * vₓₓᵧ_ + _rd;\r\n    const $re = d0 * $vₓᵧᵧ;\r\n    const re = qmd(d0, vₓᵧᵧ);\r\n    const _re = abs($re);\r\n    const re_ = _d0 * vₓᵧᵧ_ + _re;\r\n    const $rf = $rc + $c1d0;\r\n    const rf = qaq(rc, c1d0);\r\n    const _rf = abs($rf);\r\n    const rf_ = rc_ + c1d0_ + _rf;\r\n    const $rg = $rc + $c0d1;\r\n    const rg = qaq(rc, c0d1);\r\n    const _rg = abs($rg);\r\n    const rg_ = rc_ + c0d1_ + _rg;\r\n    const $rx = $c1 * $c0c0;\r\n    const rx = qmq(c1, c0c0);\r\n    const _rx = abs($rx);\r\n    const rx_ = c1_ * _c0c0 + 2 * _rx;\r\n    const $rh = $rx * $vₓₓₓ;\r\n    const rh = qmq(rx, vₓₓₓ);\r\n    const rh_ = rx_ * _vₓₓₓ + _rx * vₓₓₓ_ + 2 * abs($rh);\r\n    const $ry = $d1 * $d0d0;\r\n    const ry = qmq(d1, d0d0);\r\n    const _ry = abs($ry);\r\n    const ry_ = d1_ * _d0d0 + 2 * _ry;\r\n    const $ri = $ry * $vᵧᵧᵧ;\r\n    const ri = qmq(ry, vᵧᵧᵧ);\r\n    const ri_ = ry_ * _vᵧᵧᵧ + _ry * vᵧᵧᵧ_ + 2 * abs($ri);\r\n    const $rj = $vₓᵧ * $rc;\r\n    const rj = qmq(vₓᵧ, rc);\r\n    const rj_ = vₓᵧ_ * _rc + _vₓᵧ * rc_ + 2 * abs($rj);\r\n    const $rk = $c0c1 * $vₓₓ;\r\n    const rk = qmq(c0c1, vₓₓ);\r\n    const rk_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * abs($rk);\r\n    const $rl = $d0d1 * $vᵧᵧ;\r\n    const rl = qmq(d0d1, vᵧᵧ);\r\n    const rl_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * abs($rl);\r\n    const $rm = $rk + $rl;\r\n    const rm = qaq(rk, rl);\r\n    const rm_ = rk_ + rl_ + abs($rm);\r\n    const $rn = $c1 * $vₓ;\r\n    const rn = qmq(c1, vₓ);\r\n    const rn_ = c1_ * _vₓ + _c1 * vₓ_ + abs($rn);\r\n    const $ro = $d1 * $vᵧ;\r\n    const ro = qmq(d1, vᵧ);\r\n    const ro_ = d1_ * _vᵧ + _d1 * vᵧ_ + abs($ro);\r\n    const $rp = $rn + $ro;\r\n    const rp = qaq(rn, ro);\r\n    const rp_ = rn_ + ro_ + abs($rp);\r\n    const $rq = $rd * $rf;\r\n    const rq = qmq(rd, rf);\r\n    const rq_ = rd_ * _rf + _rd * rf_ + 2 * abs($rq);\r\n    const $rr = $re * $rg;\r\n    const rr = qmq(re, rg);\r\n    const rr_ = re_ * _rg + _re * rg_ + 2 * abs($rr);\r\n    const $rs = $rq + $rr;\r\n    const rs = qaq(rq, rr);\r\n    const rs_ = rq_ + rr_ + abs($rs);\r\n    const $rt = 3 * ($rh + $ri);\r\n    const rt = qmd(3, qaq(rh, ri));\r\n    const rt_ = 3 * (rh_ + ri_) + 2 * abs($rt);\r\n    const $ru = $rj + 2 * $rm;\r\n    const ru = qaq(rj, qm2(rm));\r\n    const ru_ = rj_ + 2 * rm_ + abs($ru);\r\n    const $rv = $rs + $rt;\r\n    const rv = qaq(rs, rt);\r\n    const rv_ = rs_ + rt_ + abs($rv);\r\n    const $rw = $ru + $rp;\r\n    const rw = qaq(ru, rp);\r\n    const rw_ = ru_ + rp_ + abs($rw);\r\n    const $v1 = $rv + $rw;\r\n    const v1 = qaq(rv, rw);\r\n    const v1_ = rv_ + rw_ + abs($v1);\r\n    //-----\r\n    // v0\r\n    //-----\r\n    const $t1 = c0 * $vₓₓₓ;\r\n    const t1 = qmd(c0, vₓₓₓ);\r\n    const t1_ = _c0 * vₓₓₓ_ + abs($t1);\r\n    const $t2 = d0 * $vₓₓᵧ;\r\n    const t2 = qmd(d0, vₓₓᵧ);\r\n    const t2_ = _d0 * vₓₓᵧ_ + abs($t2);\r\n    const $p4 = $t1 + $t2;\r\n    const p4 = qaq(t1, t2);\r\n    const p4_ = t1_ + t2_ + abs($p4);\r\n    const $t3 = c0 * $vₓᵧᵧ;\r\n    const t3 = qmd(c0, vₓᵧᵧ);\r\n    const t3_ = _c0 * vₓᵧᵧ_ + abs($t3);\r\n    const $t4 = d0 * $vᵧᵧᵧ;\r\n    const t4 = qmd(d0, vᵧᵧᵧ);\r\n    const t4_ = _d0 * vᵧᵧᵧ_ + abs($t4);\r\n    const $p5 = $t3 + $t4;\r\n    const p5 = qaq(t3, t4);\r\n    const p5_ = t3_ + t4_ + abs($p5);\r\n    const $p7 = $p4 + $vₓₓ;\r\n    const p7 = qaq(p4, vₓₓ);\r\n    const _p7 = abs($p7);\r\n    const p7_ = p4_ + vₓₓ_ + _p7;\r\n    const $p8 = $p5 + $vᵧᵧ;\r\n    const p8 = qaq(p5, vᵧᵧ);\r\n    const _p8 = abs($p8);\r\n    const p8_ = p5_ + vᵧᵧ_ + _p8;\r\n    const $pc = $c0c0 * $p7;\r\n    const pc = qmq(c0c0, p7);\r\n    const pc_ = _c0c0 * p7_ + 2 * abs($pc);\r\n    const $pd = $d0d0 * $p8;\r\n    const pd = qmq(d0d0, p8);\r\n    const pd_ = _d0d0 * p8_ + 2 * abs($pd);\r\n    const $p6 = $pc + $pd;\r\n    const p6 = qaq(pc, pd);\r\n    const p6_ = pc_ + pd_ + abs($p6);\r\n    const $pe = $c0d0 * $vₓᵧ;\r\n    const pe = qmq(c0d0, vₓᵧ);\r\n    const pe_ = _c0d0 * vₓᵧ_ + abs($pe);\r\n    const $p9 = $p6 + $pe;\r\n    const p9 = qaq(p6, pe);\r\n    const p9_ = p6_ + pe_ + abs($p9);\r\n    const $pf = c0 * $vₓ;\r\n    const pf = qmd(c0, vₓ);\r\n    const pf_ = _c0 * vₓ_ + abs($pf);\r\n    const $pg = d0 * $vᵧ;\r\n    const pg = qmd(d0, vᵧ);\r\n    const pg_ = _d0 * vᵧ_ + abs($pg);\r\n    const $pa = $pf + $pg;\r\n    const pa = qaq(pf, pg);\r\n    const pa_ = pf_ + pg_ + abs($pa);\r\n    const $pb = $p9 + $pa;\r\n    const pb = qaq(p9, pa);\r\n    const pb_ = p9_ + pa_ + abs($pb);\r\n    const $v0 = $pb + $v;\r\n    const v0 = qaq(pb, v);\r\n    const v0_ = pb_ + v_ + abs($v0);\r\n    return {\r\n        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],\r\n        errBound: [γγ3 * v9_, γγ3 * v8_, γγ3 * v7_, γγ3 * v6_, γγ3 * v5_, γγ3 * v4_, γγ3 * v3_, γγ3 * v2_, γγ3 * v1_, γγ3 * v0_]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez3-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez1Exact": () => (/* binding */ getCoeffsBez1Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\r\n * values of the intersection points of two order 1 bezier curves (i.e. 2 lines).\r\n *\r\n * The returned polynomial degree will be 1\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials\' linear terms are exactly zero then it really is a point\r\n    //if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    //}\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Exact)(ps2);\r\n    //if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    //}\r\n    const { vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 1\r\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm1ExactPb)(ps1pb);\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p1 = epr(c1, vₓ);\r\n    const p2 = epr(d1, vᵧ);\r\n    const v1 = fes(p1, p2);\r\n    //const v0 = c0*vₓ + d0*vᵧ + v_0;\r\n    const p3 = sce(c0, vₓ);\r\n    const p4 = sce(d0, vᵧ);\r\n    const p5 = fes(p3, p4);\r\n    const v0 = fes(p5, v);\r\n    const r = [v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez2Exact": () => (/* binding */ getCoeffsBez1Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials\' linear terms are exactly zero then it really is a point\r\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    // }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez1Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 1\r\n    (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm1ExactPb)(ps1pb);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p1 = epr(c2, vₓ);\r\n    const p2 = epr(d2, vᵧ);\r\n    const v2 = fes(p1, p2);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p3 = epr(c1, vₓ);\r\n    const p4 = epr(d1, vᵧ);\r\n    const v1 = fes(p3, p4);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p5 = sce(c0, vₓ);\r\n    const p6 = sce(d0, vᵧ);\r\n    const p7 = fes(p5, p6);\r\n    const v0 = fes(p7, v);\r\n    const r = [v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez2-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez1Bez3Exact": () => (/* binding */ getCoeffsBez1Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez1Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Exact)(ps1);\r\n    // if both polynomials\' linear terms are exactly zero then it really is a point\r\n    // if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    // }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez1Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_2__.cubicToQuadratic)(ps2));\r\n    }\r\n    // it is a precondition that the curve really has order 1\r\n    // keep TypeScript happy; `getImplicitForm1ExactPb` cannot return `undefined` here\r\n    const { vₓ, vᵧ, v } = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm1ExactPb)(ps1pb);\r\n    // a3*v_x + b3*v_y\r\n    //const v3 = c3*vₓ + d3*vᵧ;\r\n    const p1 = epr(c3, vₓ);\r\n    const p2 = epr(d3, vᵧ);\r\n    const v3 = fes(p1, p2);\r\n    // a2*v_x + b2*v_y\r\n    //const v2 = c2*vₓ + d2*vᵧ;\r\n    const p3 = epr(c2, vₓ);\r\n    const p4 = epr(d2, vᵧ);\r\n    const v2 = fes(p3, p4);\r\n    // a1*v_x + b1*v_y\r\n    //const v1 = c1*vₓ + d1*vᵧ;\r\n    const p5 = epr(c1, vₓ);\r\n    const p6 = epr(d1, vᵧ);\r\n    const v1 = fes(p5, p6);\r\n    // a0*v_x + b0*v_y + v_0\r\n    //const v0 = c0*vₓ + d0*vᵧ + v;\r\n    const p7 = sce(c0, vₓ);\r\n    const p8 = sce(d0, vᵧ);\r\n    const p9 = fes(p7, p8);\r\n    const v0 = fes(p9, v);\r\n    const r = [v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez1-bez3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez1Exact": () => (/* binding */ getCoeffsBez2Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs-bez1-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps1);\r\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\r\n    // if both polynomials\' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez1Bez1Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis1Exact)(ps2);\r\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    // }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d1d1 = epr(d1, d1);\r\n    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ\r\n    const p1 = epr(c1c1, vₓₓ);\r\n    const p2 = epr(d1d1, vᵧᵧ);\r\n    const p3 = epr(c1d1, vₓᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v2 = fes(p4, p3);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ\r\n    const p5 = epr(c0c1, vₓₓ);\r\n    const p6 = epr(d0d1, vᵧᵧ);\r\n    const p7 = fes(c0d1, c1d0);\r\n    const pn = epr(p7, vₓᵧ);\r\n    const p8 = em2(fes(p5, p6));\r\n    const p9 = fes(p8, pn);\r\n    const pa = epr(c1, vₓ);\r\n    const pb = epr(d1, vᵧ);\r\n    const pc = fes(pa, pb);\r\n    const v1 = fes(p9, pc);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0\r\n    const pe = epr(c0c0, vₓₓ);\r\n    const pf = epr(c0d0, vₓᵧ);\r\n    const pg = epr(d0d0, vᵧᵧ);\r\n    const ph = fes(pe, pf);\r\n    const pi = fes(ph, pg);\r\n    const pj = sce(c0, vₓ);\r\n    const pk = sce(d0, vᵧ);\r\n    const pl = fes(pj, pk);\r\n    const pm = fes(pi, pl);\r\n    const v0 = fes(pm, v);\r\n    const r = [v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez2Exact": () => (/* binding */ getCoeffsBez2Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs-bez1-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 2 bezier curves (i.e. 2 quadratic bezier curves).\r\n *\r\n * The returned polynomial degree will be 4\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps1);\r\n    // if both polynomials\' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez1Bez2Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez2Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d2d2 = epr(d2, d2);\r\n    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy\r\n    //const v4 = \r\n    //    (c2*c2)*vₓₓ +\r\n    //    (c2*d2)*vₓᵧ +\r\n    //    (d2*d2)*vᵧᵧ;\r\n    const p1 = epr(c2c2, vₓₓ);\r\n    const p2 = epr(c2d2, vₓᵧ);\r\n    const p3 = epr(d2d2, vᵧᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v4 = fes(p4, p3);\r\n    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +\r\n    //    ((c1*d2) + (c2*d1))*vₓᵧ;\r\n    const p5 = epr(c1c2, vₓₓ);\r\n    const p6 = epr(d1d2, vᵧᵧ);\r\n    const p7 = fes(c1d2, c2d1);\r\n    const p8 = epr(p7, vₓᵧ);\r\n    const p9 = em2(fes(p5, p6));\r\n    const v3 = fes(p9, p8);\r\n    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + \r\n    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + \r\n    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 = \r\n    //    (2*(c0*c2) + (c1*c1))*vₓₓ +\r\n    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          \r\n    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +\r\n    //    c2*vₓ  +          \r\n    //    d2*vᵧ;\r\n    const pa = fes(em2(c0c2), c1c1);\r\n    const pb = fes(em2(d0d2), d1d1);\r\n    const pc = fes(c0d2, c1d1);\r\n    const pd = fes(pc, c2d0);\r\n    const pe = epr(pa, vₓₓ);\r\n    const pf = epr(pb, vᵧᵧ);\r\n    const pg = epr(pd, vₓᵧ);\r\n    const ph = epr(c2, vₓ);\r\n    const pi = epr(d2, vᵧ);\r\n    const pj = fes(pe, pf);\r\n    const pk = fes(pj, pg);\r\n    const pl = fes(ph, pi);\r\n    const v2 = fes(pk, pl);\r\n    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + \r\n    // a1*v_x + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +\r\n    //    ((c0*d1) + (c1*d0))*vₓᵧ +\r\n    //    c1*vₓ  +\r\n    //    d1*vᵧ;\r\n    const pm = epr(c0c1, vₓₓ);\r\n    const pn = epr(d0d1, vᵧᵧ);\r\n    const po = fes(c0d1, c1d0);\r\n    const pp = epr(po, vₓᵧ);\r\n    const pq = em2(fes(pm, pn));\r\n    const pr = epr(c1, vₓ);\r\n    const ps = epr(d1, vᵧ);\r\n    const pt = fes(pq, pp);\r\n    const pu = fes(pr, ps);\r\n    const v1 = fes(pt, pu);\r\n    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + \r\n    // b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    (c0*c0)*vₓₓ + \r\n    //    (c0*d0)*vₓᵧ + \r\n    //    (d0*d0)*vᵧᵧ + \r\n    //    c0*vₓ  +         \r\n    //    d0*vᵧ  +\r\n    //    v;\r\n    const pv = epr(c0c0, vₓₓ);\r\n    const pw = epr(c0d0, vₓᵧ);\r\n    const px = epr(d0d0, vᵧᵧ);\r\n    const py = sce(c0, vₓ);\r\n    const pz = sce(d0, vᵧ);\r\n    const q1 = fes(pv, pw);\r\n    const q2 = fes(q1, px);\r\n    const q3 = fes(py, pz);\r\n    const q4 = fes(q2, q3);\r\n    const v0 = fes(q4, v);\r\n    const r = [v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez2-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez2Bez3Exact": () => (/* binding */ getCoeffsBez2Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs-bez1-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez2Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps1);\r\n    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;\r\n    // if both polynomials\' quadratic terms are exactly zero then its really a line\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez1Bez3Exact)([ps1[0], ps1[2]], ps2);\r\n    }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez2Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_5__.cubicToQuadratic)(ps2));\r\n    }\r\n    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 2\r\n    (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm2ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0c3 = sce(c0, c3);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c0d3 = sce(c0, d3);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1c3 = epr(c1, c3);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c1d3 = epr(c1, d3);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2c3 = epr(c2, c3);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const c2d3 = epr(c2, d3);\r\n    const c3c3 = epr(c3, c3);\r\n    const c3d0 = sce(d0, c3);\r\n    const c3d1 = epr(c3, d1);\r\n    const c3d2 = epr(c3, d2);\r\n    const c3d3 = epr(c3, d3);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d0d3 = sce(d0, d3);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d3d3 = epr(d3, d3);\r\n    const d2d2 = epr(d2, d2);\r\n    const d2d3 = epr(d2, d3);\r\n    const d1d3 = epr(d1, d3);\r\n    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ\r\n    //const v6 =\r\n    //    c3c3*vₓₓ +\r\n    //    c3d3*vₓᵧ +\r\n    //    d3d3*vᵧᵧ;\r\n    const p1 = epr(c3c3, vₓₓ);\r\n    const p2 = epr(c3d3, vₓᵧ);\r\n    const p3 = epr(d3d3, vᵧᵧ);\r\n    const p4 = fes(p1, p2);\r\n    const v6 = fes(p4, p3);\r\n    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ\r\n    //const v5 =\r\n    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +\r\n    //    vₓᵧ*(c2d3 + c3d2);\r\n    const p5 = epr(c2c3, vₓₓ);\r\n    const p6 = epr(d2d3, vᵧᵧ);\r\n    const p7 = fes(p5, p6);\r\n    const p8 = fes(c2d3, c3d2);\r\n    const p9 = epr(p8, vₓᵧ);\r\n    const v5 = fes(em2(p7), p9);\r\n    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ\r\n    //const v4 =\r\n    //    (2*c1c3 + c2c2)*vₓₓ +\r\n    //    (2*d1d3 + d2d2)*vᵧᵧ +\r\n    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;\r\n    const pa = fes(em2(c1c3), c2c2);\r\n    const pb = fes(em2(d1d3), d2d2);\r\n    const pc = fes(c1d3, c2d2);\r\n    const pd = fes(pc, c3d1);\r\n    const pe = epr(pa, vₓₓ);\r\n    const pf = epr(pb, vᵧᵧ);\r\n    const pg = fes(pe, pf);\r\n    const rp = epr(pd, vₓᵧ);\r\n    const v4 = fes(pg, rp);\r\n    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + \r\n    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + \r\n    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y\r\n    //const v3 =\r\n    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +\r\n    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +\r\n    //    c3*vₓ +\r\n    //    d3*vᵧ;\r\n    const ph = fes(c0c3, c1c2);\r\n    const pi = fes(d0d3, d1d2);\r\n    const pj = fes(c0d3, c1d2);\r\n    const pk = fes(c2d1, c3d0);\r\n    const pl = fes(pj, pk);\r\n    const pm = epr(ph, vₓₓ);\r\n    const pn = epr(pi, vᵧᵧ);\r\n    const po = em2(fes(pm, pn));\r\n    const pp = epr(pl, vₓᵧ);\r\n    const rn = epr(c3, vₓ);\r\n    const ro = epr(d3, vᵧ);\r\n    const pq = fes(rn, ro);\r\n    const pr = fes(po, pp);\r\n    const v3 = fes(pr, pq);\r\n    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + \r\n    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + \r\n    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y\r\n    //const v2 =\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ +\r\n    //    d2*vᵧ;\r\n    const ps = fes(em2(c0c2), c1c1);\r\n    const pt = fes(em2(d0d2), d1d1);\r\n    const pu = fes(c0d2, c1d1);\r\n    const pv = fes(pu, c2d0);\r\n    const pw = epr(ps, vₓₓ);\r\n    const px = epr(pt, vᵧᵧ);\r\n    const py = epr(pv, vₓᵧ);\r\n    const pz = fes(pw, px);\r\n    const r1 = fes(pz, py);\r\n    const r2 = epr(c2, vₓ);\r\n    const r3 = epr(d2, vᵧ);\r\n    const r4 = fes(r2, r3);\r\n    const v2 = fes(r1, r4);\r\n    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y\r\n    //const v1 =\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    (c0d1 + c1d0)*vₓᵧ +\r\n    //    c1*vₓ +\r\n    //    d1*vᵧ;\r\n    const r5 = epr(c0c1, vₓₓ);\r\n    const r6 = epr(d0d1, vᵧᵧ);\r\n    const r7 = fes(c0d1, c1d0);\r\n    const r8 = epr(r7, vₓᵧ);\r\n    const r9 = em2(fes(r5, r6));\r\n    const ra = fes(r9, r8);\r\n    const rb = epr(c1, vₓ);\r\n    const rc = epr(d1, vᵧ);\r\n    const rd = fes(rb, rc);\r\n    const v1 = fes(ra, rd);\r\n    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*vₓₓ +\r\n    //    c0d0*vₓᵧ +\r\n    //    d0d0*vᵧᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const re = epr(c0c0, vₓₓ);\r\n    const rf = epr(c0d0, vₓᵧ);\r\n    const rg = epr(d0d0, vᵧᵧ);\r\n    const rh = sce(c0, vₓ);\r\n    const ri = sce(d0, vᵧ);\r\n    const rj = fes(re, rf);\r\n    const rk = fes(rj, rg);\r\n    const rl = fes(rh, ri);\r\n    const rm = fes(rk, rl);\r\n    const v0 = fes(rm, v);\r\n    const r = [v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez2-bez3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez1Exact": () => (/* binding */ getCoeffsBez3Bez1Exact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs-bez2-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).\r\n *\r\n * The returned polynomial degree will be 3\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez1Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials\' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez2Bez1Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_3__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c1, [c0]], [d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1Exact)(ps2);\r\n    // if (eSign(c1) === 0 && eSign(d1) === 0) {\r\n    // The input bezier curve is in fact not a line but has order < 1, i.e. it is a point.\r\n    // This shouldn\'t happen due to being checked for earlier.\r\n    // }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_4__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d1d1 = epr(d1, d1);\r\n    const z1 = sce(c0, vₓₓₓ);\r\n    const z7 = epr(tp(3, c0), vₓₓₓ);\r\n    const z2 = sce(c0, vₓₓᵧ);\r\n    const z3 = sce(d0, vₓₓᵧ);\r\n    const z4 = sce(c0, vₓᵧᵧ);\r\n    const z5 = sce(d0, vₓᵧᵧ);\r\n    const z6 = sce(d0, vᵧᵧᵧ);\r\n    const z8 = epr(tp(3, d0), vᵧᵧᵧ);\r\n    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy\r\n    //const v3 =\r\n    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +\r\n    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);\r\n    const u1 = epr(c1, vₓₓₓ);\r\n    const u2 = epr(c1, vₓᵧᵧ);\r\n    const u3 = epr(d1, vₓₓᵧ);\r\n    const u4 = epr(d1, vᵧᵧᵧ);\r\n    const u5 = fes(u1, u3);\r\n    const u6 = fes(u2, u4);\r\n    const u7 = epr(c1c1, u5);\r\n    const u8 = epr(d1d1, u6);\r\n    const v3 = fes(u7, u8);\r\n    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy\r\n    //const v2 =\r\n    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +\r\n    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);\r\n    //const v2 =\r\n    //    c1c1*(3*z1 +   z3 + vₓₓ) +\r\n    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +\r\n    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);\r\n    const u9 = fes(z7, z3);\r\n    const ua = em2(fes(z2, z5));\r\n    const ub = fes(z4, z8);\r\n    const uc = fes(u9, vₓₓ);\r\n    const ud = fes(ua, vₓᵧ);\r\n    const ue = fes(ub, vᵧᵧ);\r\n    const uf = epr(c1c1, uc);\r\n    const ug = epr(c1d1, ud);\r\n    const uh = epr(d1d1, ue);\r\n    const ui = fes(uf, ug);\r\n    const v2 = fes(ui, uh);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +\r\n    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +\r\n    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +\r\n    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +\r\n    //    vₓ*c1 +\r\n    //    vᵧ*d1;\r\n    const uj = em2(fes(z3, vₓₓ));\r\n    const uk = em2(fes(z4, vᵧᵧ));\r\n    const un = fes(z7, uj);\r\n    const uo = fes(z8, uk);\r\n    const up = fes(z2, vₓᵧ);\r\n    const uq = fes(z5, vₓᵧ);\r\n    const ur = epr(c0c1, un);\r\n    const us = epr(d0d1, uo);\r\n    const ut = epr(c0d1, up);\r\n    const uu = epr(c1d0, uq);\r\n    const uv = epr(c1, vₓ);\r\n    const uw = epr(d1, vᵧ);\r\n    const ux = fes(ur, us);\r\n    const uy = fes(ut, uu);\r\n    const uz = fes(ux, uy);\r\n    const u0 = fes(uv, uw);\r\n    const v1 = fes(uz, u0);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    //const v0 =\r\n    //    c0c0*(z1 + z3 + vₓₓ) +\r\n    //    d0d0*(z6 + z4 + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ    +\r\n    //    d0*vᵧ    +\r\n    //    v;\r\n    const f1 = fes(z1, z3);\r\n    const f2 = fes(z6, z4);\r\n    const f3 = fes(f1, vₓₓ);\r\n    const f4 = fes(f2, vᵧᵧ);\r\n    const f5 = epr(c0c0, f3);\r\n    const f6 = epr(d0d0, f4);\r\n    const f7 = epr(c0d0, vₓᵧ);\r\n    const f8 = fes(f5, f6);\r\n    const f9 = fes(f8, f7);\r\n    const fa = sce(c0, vₓ);\r\n    const fb = sce(d0, vᵧ);\r\n    const fc = fes(fa, fb);\r\n    const fd = fes(f9, fc);\r\n    const v0 = fes(fd, v);\r\n    const r = [v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez2Exact": () => (/* binding */ getCoeffsBez3Bez2Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs-bez2-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs-bez3-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_5__.eSign;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of an order\r\n * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n  * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez2Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials\' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez2Bez2Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_3__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c2, c1, [c0]], [d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps2);\r\n    if (eSign(c2) === 0 && eSign(d2) === 0) {\r\n        // the input bezier curve is in fact not quadratic but has order < 2\r\n        return (0,_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez3Bez1Exact)(ps1, [ps2[0], ps2[2]]);\r\n    }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d2d2 = epr(d2, d2);\r\n    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy\r\n    //const v6 =\r\n    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +\r\n    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);\r\n    const e1 = epr(c2, vₓₓₓ);\r\n    const e2 = epr(c2, vₓᵧᵧ);\r\n    const e3 = epr(d2, vₓₓᵧ);\r\n    const e4 = epr(d2, vᵧᵧᵧ);\r\n    const e5 = fes(e1, e3);\r\n    const e6 = fes(e2, e4);\r\n    const e7 = epr(c2c2, e5);\r\n    const e8 = epr(d2d2, e6);\r\n    const v6 = fes(e7, e8);\r\n    const z1 = fes(c0c2, c1c1);\r\n    const z2 = fes(d0d2, d1d1);\r\n    const z3 = fes(em2(c0c2), c1c1);\r\n    const z4 = fes(em2(d0d2), d1d1);\r\n    const z5 = fes(em2(c1d1), c2d0);\r\n    const z6 = fes(em2(c1d1), c0d2);\r\n    const z7 = fes(em2(c2d0), c1d1);\r\n    const z8 = fes(sce(6, c0c2), c1c1);\r\n    const z9 = fes(sce(6, d0d2), d1d1);\r\n    const za = fes(c1d2, c2d1);\r\n    const zb = fes(c0d2, c2d0);\r\n    const zc = fes(em2(c1d0), c0d1);\r\n    const zd = fes(em2(c0d1), c1d0);\r\n    const zf = fes(c0d2, c1d1);\r\n    const ze = fes(zf, c2d0);\r\n    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + \r\n    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy\r\n    //const v5 =\r\n    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +\r\n    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);\r\n    const s0 = sce(3, c2c2);\r\n    const t1 = sce(3, d2d2);\r\n    const s1 = epr(s0, vₓₓₓ);\r\n    const s2 = epr(c2c2, vₓₓᵧ);\r\n    const s3 = em2(epr(c2d2, vₓₓᵧ));\r\n    const s4 = em2(epr(c2d2, vₓᵧᵧ));\r\n    const s5 = epr(d2d2, vₓᵧᵧ);\r\n    const s6 = epr(t1, vᵧᵧᵧ);\r\n    const s7 = fes(s1, s3);\r\n    const s8 = fes(s2, s4);\r\n    const s9 = fes(s7, s5);\r\n    const sa = fes(s8, s6);\r\n    const sb = epr(c1, s9);\r\n    const sc = epr(d1, sa);\r\n    const v5 = fes(sb, sc);\r\n    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + \r\n    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + \r\n    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + \r\n    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + \r\n    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy\r\n    //const v4 =\r\n    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + \r\n    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + \r\n    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +\r\n    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    //const v4 =\r\n    //    (3*c2)*z1*vₓₓₓ + \r\n    //    (3*d2)*z2*vᵧᵧᵧ + \r\n    //    (d2*z3 + c2*z5)*vₓₓᵧ +\r\n    //    (d2*z6 + c2*z4)*vₓᵧᵧ +\r\n    //    vₓₓ*c2c2 +\r\n    //    vᵧᵧ*d2d2 +\r\n    //    vₓᵧ*c2d2;\r\n    const sd = epr(d2, z3);\r\n    const se = epr(d2, z6);\r\n    const sf = epr(c2, z5);\r\n    const sg = epr(c2, z4);\r\n    const sh = epr(sce(3, c2), z1);\r\n    const si = epr(sce(3, d2), z2);\r\n    const sj = fes(sd, sf);\r\n    const sk = fes(se, sg);\r\n    const sl = epr(sh, vₓₓₓ);\r\n    const sm = epr(si, vᵧᵧᵧ);\r\n    const sn = epr(sj, vₓₓᵧ);\r\n    const so = epr(sk, vₓᵧᵧ);\r\n    const sp = fes(sl, sm);\r\n    const sq = fes(sn, so);\r\n    const sr = epr(c2c2, vₓₓ);\r\n    const ss = epr(d2d2, vᵧᵧ);\r\n    const st = epr(c2d2, vₓᵧ);\r\n    const su = fes(sr, ss);\r\n    const sv = fes(sp, sq);\r\n    const sw = fes(su, st);\r\n    const v4 = fes(sv, sw);\r\n    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + \r\n    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + \r\n    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + \r\n    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + \r\n    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + \r\n    // 2*b1*b2*v_yy\r\n    //const v3 =\r\n    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +\r\n    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        \r\n    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +\r\n    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    c1d2*vₓᵧ + c2d1*vₓᵧ;\r\n    //const v3 =\r\n    //    c1*z8*vₓₓₓ +\r\n    //    d1*z9*vᵧᵧᵧ +        \r\n    //    (2*c0*za + c1*z7)*vₓₓᵧ +\r\n    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +\r\n    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +\r\n    //    za*vₓᵧ;\r\n    const sx = epr(c1, z8);\r\n    const sy = epr(d1, z9);\r\n    const sz = sce(2 * c0, za);\r\n    const o1 = epr(em2(d1), zb);\r\n    const o2 = epr(c1, z7);\r\n    const o3 = epr(c1, z4);\r\n    const o4 = fes(sz, o2);\r\n    const o5 = fes(o1, o3);\r\n    const o6 = epr(d1d2, vᵧᵧ);\r\n    const o7 = epr(c1c2, vₓₓ);\r\n    const o8 = epr(za, vₓᵧ);\r\n    const o9 = fes(o6, o7);\r\n    const oa = epr(sx, vₓₓₓ);\r\n    const ob = epr(o4, vₓₓᵧ);\r\n    const oc = epr(sy, vᵧᵧᵧ);\r\n    const od = epr(o5, vₓᵧᵧ);\r\n    const oe = fes(oa, oc);\r\n    const og = fes(ob, od);\r\n    const oh = fes(oe, og);\r\n    const oi = fes(em2(o9), o8);\r\n    const v3 = fes(oh, oi);\r\n    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + \r\n    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + \r\n    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + \r\n    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y\r\n    //const v2 =\r\n    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +\r\n    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +\r\n    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +\r\n    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +\r\n    //    (2*c0c2 + c1c1)*vₓₓ +\r\n    //    (2*d0d2 + d1d1)*vᵧᵧ +\r\n    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    //const v2 =\r\n    //    (3*c0*z1)*vₓₓₓ +\r\n    //    (3*d0*z2)*vᵧᵧᵧ +\r\n    //    (c0*z6 + d0*z3)*vₓₓᵧ +\r\n    //    (c0*z4 + d0*z5)*vₓᵧᵧ +\r\n    //    z3*vₓₓ +\r\n    //    z4*vᵧᵧ +\r\n    //    ze*vₓᵧ +\r\n    //    c2*vₓ    +\r\n    //    d2*vᵧ;\r\n    const oj = epr(tp(3, c0), z1);\r\n    const ok = epr(tp(3, d0), z2);\r\n    const ol = sce(c0, z6);\r\n    const om = sce(c0, z4);\r\n    const on = sce(d0, z3);\r\n    const oo = sce(d0, z5);\r\n    const op = fes(ol, on);\r\n    const oq = fes(om, oo);\r\n    const or = epr(oj, vₓₓₓ);\r\n    const os = epr(ok, vᵧᵧᵧ);\r\n    const ot = epr(op, vₓₓᵧ);\r\n    const ou = epr(oq, vₓᵧᵧ);\r\n    const ov = epr(z3, vₓₓ);\r\n    const ow = epr(z4, vᵧᵧ);\r\n    const ox = epr(ze, vₓᵧ);\r\n    const oy = epr(c2, vₓ);\r\n    const oz = epr(d2, vᵧ);\r\n    const p1 = fes(or, os);\r\n    const p2 = fes(ot, ou);\r\n    const p3 = fes(ov, ow);\r\n    const p4 = fes(p1, p2);\r\n    const p5 = fes(p3, ox);\r\n    const p6 = fes(oy, oz);\r\n    const p7 = fes(p4, p5);\r\n    const v2 = fes(p7, p6);\r\n    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + \r\n    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +\r\n    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    //const v1 =\r\n    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +\r\n    //    c0*zc*vₓₓᵧ +\r\n    //    d0*zd*vₓᵧᵧ +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c0d1*vₓᵧ + c1d0*vₓᵧ +\r\n    //    c1*vₓ + d1*vᵧ;\r\n    const p8 = epr(tp(3, c0), c0c1);\r\n    const p9 = epr(tp(3, d0), d0d1);\r\n    const pa = sce(c0, zc);\r\n    const pb = sce(d0, zd);\r\n    const pc = epr(c0c1, vₓₓ);\r\n    const pd = epr(d0d1, vᵧᵧ);\r\n    const pe = epr(c0d1, vₓᵧ);\r\n    const pf = epr(c1d0, vₓᵧ);\r\n    const pg = em2(fes(pc, pd));\r\n    const ph = fes(pe, pf);\r\n    const pi = epr(c1, vₓ);\r\n    const pj = epr(d1, vᵧ);\r\n    const pk = epr(p8, vₓₓₓ);\r\n    const pl = epr(p9, vᵧᵧᵧ);\r\n    const pm = epr(pa, vₓₓᵧ);\r\n    const pn = epr(pb, vₓᵧᵧ);\r\n    const po = fes(pk, pl);\r\n    const pp = fes(pm, pn);\r\n    const pq = fes(po, pp);\r\n    const pr = fes(pg, ph);\r\n    const ps = fes(pi, pj);\r\n    const pt = fes(pq, pr);\r\n    const v1 = fes(pt, ps);\r\n    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + \r\n    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0\r\n    //const v0 =\r\n    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +\r\n    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +\r\n    //    c0d0*vₓᵧ +\r\n    //    c0*vₓ +\r\n    //    d0*vᵧ +\r\n    //    v;\r\n    const pu = sce(c0, vₓₓₓ);\r\n    const pv = sce(c0, vₓᵧᵧ);\r\n    const pw = sce(d0, vₓₓᵧ);\r\n    const px = sce(d0, vᵧᵧᵧ);\r\n    const py = fes(pu, pw);\r\n    const pz = fes(pv, px);\r\n    const u1 = fes(py, vₓₓ);\r\n    const u2 = fes(pz, vᵧᵧ);\r\n    const u3 = epr(c0c0, u1);\r\n    const u4 = epr(d0d0, u2);\r\n    const u5 = epr(c0d0, vₓᵧ);\r\n    const u6 = sce(c0, vₓ);\r\n    const u7 = sce(d0, vᵧ);\r\n    const u8 = fes(u3, u4);\r\n    const u9 = fes(u8, u5);\r\n    const ua = fes(u6, u7);\r\n    const ub = fes(u9, ua);\r\n    const v0 = fes(ub, v);\r\n    const r = [v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez2-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Bez3Exact": () => (/* binding */ getCoeffsBez3Bez3Exact)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../implicit-form/exact/get-implicit-form3-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs-bez3-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js");\n/* harmony import */ var _transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../transformation/degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs-bez2-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoProduct; // error -> 0\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.scaleExpansion2;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.fastExpansionSum;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eMultBy2;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign;\r\n/**\r\n * Returns an error-free polynomial in in 1 variable\r\n * whose roots are the parameter values of the intersection points of 2 order\r\n * 3 bezier curves (i.e. 2 cubic bezier curves).\r\n *\r\n * The returned polynomial degree will be 9\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Bez3Exact(ps1, ps2) {\r\n    /** ps1 in power bases */\r\n    const ps1pb = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps1);\r\n    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;\r\n    // if both polynomials\' cubic terms are exactly zero then its really a quadratic\r\n    if (eSign(ps1pb[0][0]) === 0 && eSign(ps1pb[1][0]) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez2Bez3Exact)((0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_4__.cubicToQuadratic)(ps1), ps2);\r\n    }\r\n    const [[c3, c2, c1, [c0]], [d3, d2, d1, [d0]]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps2);\r\n    if (eSign(c3) === 0 && eSign(d3) === 0) {\r\n        // the input bezier curve is in fact not cubic but has order < 3\r\n        return (0,_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez3Bez2Exact)(ps1, (0,_transformation_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_4__.cubicToQuadratic)(ps2));\r\n    }\r\n    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = \r\n    // this type coercion is justified since we already checked that the\r\n    // curve really has order 3\r\n    (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm3ExactPb)(ps1pb);\r\n    const c0c0 = tp(c0, c0);\r\n    const c0c1 = sce(c0, c1);\r\n    const c0c2 = sce(c0, c2);\r\n    const c0c3 = sce(c0, c3);\r\n    const c0d0 = tp(c0, d0);\r\n    const c0d1 = sce(c0, d1);\r\n    const c0d2 = sce(c0, d2);\r\n    const c0d3 = sce(c0, d3);\r\n    const c1c1 = epr(c1, c1);\r\n    const c1c2 = epr(c1, c2);\r\n    const c1c3 = epr(c1, c3);\r\n    const c1d0 = sce(d0, c1);\r\n    const c1d1 = epr(c1, d1);\r\n    const c1d2 = epr(c1, d2);\r\n    const c1d3 = epr(c1, d3);\r\n    const c2d1 = epr(c2, d1);\r\n    const c2c2 = epr(c2, c2);\r\n    const c2c3 = epr(c2, c3);\r\n    const c2d0 = sce(d0, c2);\r\n    const c2d2 = epr(c2, d2);\r\n    const c2d3 = epr(c2, d3);\r\n    const c3c3 = epr(c3, c3);\r\n    const c3d0 = sce(d0, c3);\r\n    const c3d1 = epr(c3, d1);\r\n    const c3d2 = epr(c3, d2);\r\n    const c3d3 = epr(c3, d3);\r\n    const d0d0 = tp(d0, d0);\r\n    const d0d1 = sce(d0, d1);\r\n    const d0d2 = sce(d0, d2);\r\n    const d0d3 = sce(d0, d3);\r\n    const d1d1 = epr(d1, d1);\r\n    const d1d2 = epr(d1, d2);\r\n    const d3d3 = epr(d3, d3);\r\n    const d2d2 = epr(d2, d2);\r\n    const d2d3 = epr(d2, d3);\r\n    const d1d3 = epr(d1, d3);\r\n    //const v9 =  \r\n    //    (c3*c3c3)*vₓₓₓ + \r\n    //    (c3*d3d3)*vₓᵧᵧ + \r\n    //    (d3*c3c3)*vₓₓᵧ + \r\n    //    (d3*d3d3)*vᵧᵧᵧ;  \r\n    const g1 = epr(c3, c3c3); // c3*c3c3\r\n    const g2 = epr(c3, d3d3); // c3*d3d3\r\n    const g3 = epr(d3, c3c3); // d3*c3c3\r\n    const g4 = epr(d3, d3d3); // d3*d3d3\r\n    const g5 = epr(g1, vₓₓₓ); // g1*vₓₓₓ\r\n    const g6 = epr(g2, vₓᵧᵧ); // g2*vₓᵧᵧ\r\n    const g7 = epr(g3, vₓₓᵧ); // g3*vₓₓᵧ \r\n    const g8 = epr(g4, vᵧᵧᵧ); // g4*vᵧᵧᵧ\r\n    const g9 = fes(g5, g6); // g5 + g6\r\n    const ga = fes(g7, g8); // g7 + g8\r\n    const v9 = fes(g9, ga); // g9 + ga\r\n    //const v8 =  \r\n    //    2*c2*c3d3*vₓₓᵧ + \r\n    //    2*c3*d2d3*vₓᵧᵧ + \r\n    //      c2*d3d3*vₓᵧᵧ + \r\n    //      d2*c3c3*vₓₓᵧ + \r\n    //    3*c2*c3c3*vₓₓₓ + \r\n    //    3*d2*d3d3*vᵧᵧᵧ;  \r\n    const w1 = fes(em2(c2d3), c3d2);\r\n    const w2 = fes(em2(c3d2), c2d3);\r\n    const w3 = epr(c3, w1);\r\n    const w4 = epr(d3, w2);\r\n    const w5 = epr(c2, c3c3);\r\n    const w6 = epr(d2, d3d3);\r\n    const w7 = epr(vₓₓₓ, w5);\r\n    const u1 = epr(vᵧᵧᵧ, w6);\r\n    const u2 = epr(vₓₓᵧ, w3);\r\n    const u3 = epr(vₓᵧᵧ, w4);\r\n    const u4 = fes(u2, u3);\r\n    const u5 = sce(3, fes(w7, u1));\r\n    const v8 = fes(u4, u5);\r\n    //const v7 =  \r\n    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +\r\n    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +\r\n    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +\r\n    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);\r\n    const o1 = epr(c1, c3d3);\r\n    const o2 = epr(d1, c3c3);\r\n    const o3 = epr(c2, d2d3);\r\n    const o4 = epr(c1, d3d3);\r\n    const o5 = epr(c2, c3d2);\r\n    const o6 = epr(d3, c2c2);\r\n    const o7 = epr(c3, d1d3);\r\n    const o8 = epr(d2, c3d2);\r\n    const w8 = fes(o1, o5);\r\n    const w9 = fes(o2, o6);\r\n    const wa = fes(o3, o7);\r\n    const wb = fes(o4, o8);\r\n    const wc = fes(c1c3, c2c2);\r\n    const wd = fes(d1d3, d2d2);\r\n    const we = fes(em2(w8), w9);\r\n    const wf = fes(em2(wa), wb);\r\n    const wg = epr(vₓₓᵧ, we);\r\n    const wh = epr(vₓᵧᵧ, wf);\r\n    const wi = epr(c3, wc);\r\n    const wj = epr(d3, wd);\r\n    const wk = epr(vₓₓₓ, wi);\r\n    const wl = epr(vᵧᵧᵧ, wj);\r\n    const wm = fes(wg, wh);\r\n    const wn = sce(3, fes(wk, wl));\r\n    const v7 = fes(wm, wn);\r\n    //const v6 =\r\n    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +\r\n    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +\r\n    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +\r\n    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +\r\n    //    vₓₓ *c3c3 +\r\n    //    vᵧᵧ *d3d3 +\r\n    //    vₓᵧ *c3d3;\r\n    const wo = fes(c2d3, c3d2);\r\n    const zc = epr(d2, c2c2);\r\n    const zd = em2(epr(c1, wo));\r\n    const wp = fes(zc, zd);\r\n    const wq = em2(fes(c0d3, c2d1));\r\n    const wr = fes(wq, c3d0);\r\n    const ze = epr(c3, wr);\r\n    const ws = fes(wp, ze);\r\n    const zf = epr(c2, d2d2);\r\n    const zg = em2(epr(d1, wo));\r\n    const wt = fes(zf, zg);\r\n    const wu = em2(fes(c1d2, c3d0));\r\n    const wv = fes(wu, c0d3);\r\n    const zh = epr(d3, wv);\r\n    const ww = fes(wt, zh);\r\n    const wx = epr(c2, c2c2);\r\n    const wy = fes(em2(c1c2), c0c3);\r\n    const wz = epr(sce(3, c3), wy);\r\n    const z1 = fes(wx, wz);\r\n    const z2 = epr(d2, d2d2);\r\n    const z3 = fes(em2(d1d2), d0d3);\r\n    const z4 = epr(sce(3, d3), z3);\r\n    const z5 = fes(z2, z4);\r\n    const zi = epr(vₓₓᵧ, ws);\r\n    const zj = epr(vₓᵧᵧ, ww);\r\n    const z6 = fes(zi, zj);\r\n    const zk = epr(vₓₓₓ, z1);\r\n    const zl = epr(vᵧᵧᵧ, z5);\r\n    const z7 = fes(zk, zl);\r\n    const zm = epr(c3c3, vₓₓ);\r\n    const zn = epr(d3d3, vᵧᵧ);\r\n    const z8 = fes(zm, zn);\r\n    const z9 = epr(c3d3, vₓᵧ);\r\n    const za = fes(z6, z7);\r\n    const zb = fes(z8, z9);\r\n    const v6 = fes(za, zb);\r\n    //const r4 = c2d2 + c3d1;\r\n    //const r5 = c1d3 + c2d2;\r\n    //const v5 =\r\n    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +\r\n    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +\r\n    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + \r\n    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +\r\n    //    vₓᵧ*wo +\r\n    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);\r\n    const r4 = fes(c2d2, c3d1);\r\n    const r5 = fes(c1d3, c2d2);\r\n    const k1 = sce(c0, wo);\r\n    const k2 = sce(d0, wo);\r\n    const k3 = epr(c1, r4);\r\n    const k4 = epr(d1, r5);\r\n    const k5 = fes(em2(c3d0), c2d1);\r\n    const k6 = fes(em2(c0d3), c1d2);\r\n    const k7 = epr(d3, c1c1);\r\n    const k8 = epr(c3, d1d1);\r\n    const k9 = epr(c2, k5);\r\n    const ka = epr(d2, k6);\r\n    const kb = em2(fes(k1, k3));\r\n    const kc = em2(fes(k2, k4));\r\n    const kd = em2(sce(c0, c2c3));\r\n    const ke = em2(sce(d0, d2d3));\r\n    const kf = epr(c1, wc);\r\n    const kg = epr(d1, wd);\r\n    const kh = epr(c2c3, vₓₓ);\r\n    const ki = epr(d2d3, vᵧᵧ);\r\n    const kj = fes(kb, k7);\r\n    const kk = fes(kc, k8);\r\n    const kl = fes(kj, k9);\r\n    const km = fes(kk, ka);\r\n    const kn = fes(kd, kf);\r\n    const ko = fes(ke, kg);\r\n    const kp = em2(fes(kh, ki));\r\n    const kq = epr(vₓₓᵧ, kl);\r\n    const kr = epr(vₓᵧᵧ, km);\r\n    const ks = epr(vₓₓₓ, kn);\r\n    const kt = epr(vᵧᵧᵧ, ko);\r\n    const ku = fes(kq, kr);\r\n    const kv = sce(3, fes(ks, kt));\r\n    const kw = epr(vₓᵧ, wo);\r\n    const kx = fes(ku, kv);\r\n    const ky = fes(kw, kp);\r\n    const v5 = fes(kx, ky);\r\n    //const r1 = c1d3 + r4;\r\n    //const r2 = 2*c1c3 + c2c2;\r\n    //const r3 = 2*d1d3 + d2d2;\r\n    //const v4 =\r\n    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +\r\n    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +\r\n    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +\r\n    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +\r\n    //    vₓᵧ*r1 +\r\n    //    vₓₓ*r2 +\r\n    //    vᵧᵧ*r3;\r\n    const r1 = fes(c1d3, r4);\r\n    const r2 = fes(em2(c1c3), c2c2);\r\n    const r3 = fes(em2(d1d3), d2d2);\r\n    const s1 = sce((2 * c0), r1);\r\n    const s2 = sce((2 * d0), r1);\r\n    const s5 = fes(c1d2, em2(c2d1));\r\n    const s6 = fes(c2d1, em2(c1d2));\r\n    const s3 = sce(d0, r2);\r\n    const s4 = sce(c0, r3);\r\n    const s7 = epr(c1, s5);\r\n    const s8 = epr(d1, s6);\r\n    const s9 = sce(c0, r2);\r\n    const sa = sce(d0, r3);\r\n    const sb = epr(c2, c1c1);\r\n    const sc = epr(d2, d1d1);\r\n    const sd = fes(s1, s3);\r\n    const se = fes(s2, s4);\r\n    const sf = fes(sd, s7);\r\n    const sg = fes(se, s8);\r\n    const sh = fes(s9, sb);\r\n    const si = fes(sa, sc);\r\n    const sj = epr(vₓₓᵧ, sf);\r\n    const sk = epr(vₓᵧᵧ, sg);\r\n    const sl = epr(vₓₓₓ, sh);\r\n    const sm = epr(vᵧᵧᵧ, si);\r\n    const sn = fes(sl, sm);\r\n    const so = fes(sj, sk);\r\n    const sp = fes(so, sce(3, sn));\r\n    const ss = epr(vₓᵧ, r1);\r\n    const st = epr(vₓₓ, r2);\r\n    const sq = fes(ss, st);\r\n    const su = epr(vᵧᵧ, r3);\r\n    const sr = fes(sq, su);\r\n    const v4 = fes(sp, sr);\r\n    //const r6 = c1d2 + c2d1;\r\n    //const r7 = c3d0 + c0d3;\r\n    //const r8 = c1c2 + c0c3;\r\n    //const r9 = d1d2 + d0d3;\r\n    //const v3 =\r\n    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +\r\n    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +\r\n    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + \r\n    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +\r\n    //    vₓᵧ*(r7 + r6) +\r\n    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +\r\n    //    vₓ*c3 + vᵧ*d3;\r\n    const r6 = fes(c1d2, c2d1);\r\n    const r7 = fes(c3d0, c0d3);\r\n    const r8 = fes(c1c2, c0c3);\r\n    const r9 = fes(d1d2, d0d3);\r\n    const m1 = fes(em2(r6), c3d0);\r\n    const m2 = fes(em2(r6), c0d3);\r\n    const m3 = fes(em2(c2d0), c1d1);\r\n    const m4 = fes(em2(c0d2), c1d1);\r\n    const m5 = fes(r8, c1c2);\r\n    const m6 = fes(r9, d1d2);\r\n    const m7 = epr(tp(3, c0), m5);\r\n    const m8 = epr(tp(3, d0), m6);\r\n    const m9 = epr(c1, c1c1);\r\n    const ma = epr(d1, d1d1);\r\n    const mb = epr(vₓₓ, r8);\r\n    const mc = epr(vᵧᵧ, r9);\r\n    const md = fes(m1, r7);\r\n    const me = fes(m2, r7);\r\n    const mf = sce(c0, md);\r\n    const mg = sce(d0, me);\r\n    const mh = epr(c1, m3);\r\n    const mi = epr(d1, m4);\r\n    const mj = epr(c3, vₓ);\r\n    const mk = epr(d3, vᵧ);\r\n    const ml = fes(mf, mh);\r\n    const mm = fes(mg, mi);\r\n    const mn = fes(m7, m9);\r\n    const mo = fes(m8, ma);\r\n    const mp = fes(r7, r6);\r\n    const mq = em2(fes(mb, mc));\r\n    const mr = epr(vₓₓᵧ, ml);\r\n    const ms = epr(vₓᵧᵧ, mm);\r\n    const mt = epr(vₓₓₓ, mn);\r\n    const mu = epr(vᵧᵧᵧ, mo);\r\n    const mv = epr(vₓᵧ, mp);\r\n    const mw = fes(mr, ms);\r\n    const mx = fes(mt, mu);\r\n    const my = fes(mv, mq);\r\n    const mz = fes(mj, mk);\r\n    const n1 = fes(mw, mx);\r\n    const n2 = fes(my, mz);\r\n    const v3 = fes(n1, n2);\r\n    //const ra = c1d1 + c2d0;\r\n    //const rb = c1d1 + c0d2;\r\n    //const v2 =\r\n    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +\r\n    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +\r\n    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + \r\n    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +\r\n    //    vₓᵧ*(ra + c0d2) +\r\n    //    vₓₓ*(2*c0c2 + c1c1) + \r\n    //    vᵧᵧ*(2*d0d2 + d1d1) +\r\n    //    c2*vₓ + d2*vᵧ;\r\n    const ra = fes(c1d1, c2d0);\r\n    const rb = fes(c1d1, c0d2);\r\n    const l1 = fes(em2(ra), c0d2);\r\n    const l2 = fes(em2(rb), c2d0);\r\n    const l3 = sce(c0, l1);\r\n    const l4 = sce(d0, c1c1);\r\n    const l5 = sce(d0, l2);\r\n    const l6 = sce(c0, d1d1);\r\n    const l7 = sce(c0, c1c1);\r\n    const l8 = epr(c2, c0c0);\r\n    const l9 = sce(d0, d1d1);\r\n    const la = epr(d2, d0d0);\r\n    const lb = fes(l3, l4);\r\n    const lc = fes(l5, l6);\r\n    const ld = fes(l7, l8);\r\n    const le = fes(l9, la);\r\n    const lf = epr(vₓₓₓ, ld);\r\n    const lg = epr(vᵧᵧᵧ, le);\r\n    const lh = sce(3, fes(lf, lg));\r\n    const li = fes(ra, c0d2);\r\n    const lj = fes(em2(c0c2), c1c1);\r\n    const lk = fes(em2(d0d2), d1d1);\r\n    const ll = epr(vₓₓᵧ, lb);\r\n    const lm = epr(vₓᵧᵧ, lc);\r\n    const ln = epr(vₓᵧ, li);\r\n    const lo = epr(vₓₓ, lj);\r\n    const lp = epr(vᵧᵧ, lk);\r\n    const lq = epr(c2, vₓ);\r\n    const lr = epr(d2, vᵧ);\r\n    const ls = fes(lq, lr);\r\n    const lt = fes(ll, lm);\r\n    const lu = fes(lh, ln);\r\n    const lv = fes(lo, lp);\r\n    const lw = fes(lt, lu);\r\n    const lx = fes(lv, ls);\r\n    const v2 = fes(lw, lx);\r\n    //const rc = c1d0 + c0d1;\r\n    //const v1 =\r\n    //    vₓₓᵧ*c0*(rc + c1d0) +\r\n    //    vₓᵧᵧ*d0*(rc + c0d1) +\r\n    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +\r\n    //    vₓᵧ*rc +\r\n    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +\r\n    //    c1*vₓ + d1*vᵧ ;\r\n    const rc = fes(c1d0, c0d1);\r\n    const rd = sce(c0, vₓₓᵧ);\r\n    const re = sce(d0, vₓᵧᵧ);\r\n    const rf = fes(rc, c1d0);\r\n    const rg = fes(rc, c0d1);\r\n    const rx = epr(c1, c0c0);\r\n    const rh = epr(rx, vₓₓₓ);\r\n    const ry = epr(d1, d0d0);\r\n    const ri = epr(ry, vᵧᵧᵧ);\r\n    const rj = epr(vₓᵧ, rc);\r\n    const rk = epr(c0c1, vₓₓ);\r\n    const rl = epr(d0d1, vᵧᵧ);\r\n    const rm = fes(rk, rl);\r\n    const rn = epr(c1, vₓ);\r\n    const ro = epr(d1, vᵧ);\r\n    const rp = fes(rn, ro);\r\n    const rq = epr(rd, rf);\r\n    const rr = epr(re, rg);\r\n    const rs = fes(rq, rr);\r\n    const rt = sce(3, fes(rh, ri));\r\n    const ru = fes(rj, em2(rm));\r\n    const rv = fes(rs, rt);\r\n    const rw = fes(ru, rp);\r\n    const v1 = fes(rv, rw);\r\n    // v0\r\n    const t1 = sce(c0, vₓₓₓ);\r\n    const t2 = sce(d0, vₓₓᵧ);\r\n    const p4 = fes(t1, t2);\r\n    const t3 = sce(c0, vₓᵧᵧ);\r\n    const t4 = sce(d0, vᵧᵧᵧ);\r\n    const p5 = fes(t3, t4);\r\n    const p7 = fes(p4, vₓₓ);\r\n    const p8 = fes(p5, vᵧᵧ);\r\n    const pc = epr(c0c0, p7);\r\n    const pd = epr(d0d0, p8);\r\n    const p6 = fes(pc, pd);\r\n    const pe = epr(c0d0, vₓᵧ);\r\n    const p9 = fes(p6, pe);\r\n    const pf = sce(c0, vₓ);\r\n    const pg = sce(d0, vᵧ);\r\n    const pa = fes(pf, pg);\r\n    const pb = fes(p9, pa);\r\n    const v0 = fes(pb, v);\r\n    const r = [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-bez3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBezBez": () => (/* binding */ getCoeffsBezBez)\n/* harmony export */ });\n/* harmony import */ var _double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez1-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez1-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez1-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez2-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez2-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez2-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./double-double/get-coeffs-bez1-bez3-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./double-double/get-coeffs-bez2-bez3-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.js");\n/* harmony import */ var _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./double-double/get-coeffs-bez3-bez3-dd.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.js");\n/* harmony import */ var _exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez1-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez2-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./exact/get-coeffs-bez1-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./exact/get-coeffs-bez2-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.js");\n/* harmony import */ var _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./exact/get-coeffs-bez3-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst coeffFunctionsDd = [\r\n    [_double_double_get_coeffs_bez1_bez1_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsBez1Bez1Dd, _double_double_get_coeffs_bez1_bez2_dd_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez1Bez2Dd, _double_double_get_coeffs_bez1_bez3_dd_js__WEBPACK_IMPORTED_MODULE_6__.getCoeffsBez1Bez3Dd],\r\n    [_double_double_get_coeffs_bez2_bez1_dd_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsBez2Bez1Dd, _double_double_get_coeffs_bez2_bez2_dd_js__WEBPACK_IMPORTED_MODULE_4__.getCoeffsBez2Bez2Dd, _double_double_get_coeffs_bez2_bez3_dd_js__WEBPACK_IMPORTED_MODULE_7__.getCoeffsBez2Bez3Dd],\r\n    [_double_double_get_coeffs_bez3_bez1_dd_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez3Bez1Dd, _double_double_get_coeffs_bez3_bez2_dd_js__WEBPACK_IMPORTED_MODULE_5__.getCoeffsBez3Bez2Dd, _double_double_get_coeffs_bez3_bez3_dd_js__WEBPACK_IMPORTED_MODULE_8__.getCoeffsBez3Bez3Dd]\r\n];\r\nconst coeffFunctionsExact = [\r\n    [_exact_get_coeffs_bez1_bez1_exact_js__WEBPACK_IMPORTED_MODULE_9__.getCoeffsBez1Bez1Exact, _exact_get_coeffs_bez1_bez2_exact_js__WEBPACK_IMPORTED_MODULE_12__.getCoeffsBez1Bez2Exact, _exact_get_coeffs_bez1_bez3_exact_js__WEBPACK_IMPORTED_MODULE_15__.getCoeffsBez1Bez3Exact],\r\n    [_exact_get_coeffs_bez2_bez1_exact_js__WEBPACK_IMPORTED_MODULE_10__.getCoeffsBez2Bez1Exact, _exact_get_coeffs_bez2_bez2_exact_js__WEBPACK_IMPORTED_MODULE_13__.getCoeffsBez2Bez2Exact, _exact_get_coeffs_bez2_bez3_exact_js__WEBPACK_IMPORTED_MODULE_16__.getCoeffsBez2Bez3Exact],\r\n    [_exact_get_coeffs_bez3_bez1_exact_js__WEBPACK_IMPORTED_MODULE_11__.getCoeffsBez3Bez1Exact, _exact_get_coeffs_bez3_bez2_exact_js__WEBPACK_IMPORTED_MODULE_14__.getCoeffsBez3Bez2Exact, _exact_get_coeffs_bez3_bez3_exact_js__WEBPACK_IMPORTED_MODULE_17__.getCoeffsBez3Bez3Exact]\r\n];\r\n/**\r\n * Returns an object with properties containing (1) the coefficients (in double-double\r\n * precision) of a polynomial in 1 variable whose roots are the parameter values\r\n * (of the second curve) of the intersection points of two given order 1, 2 or 3 bezier curves (i.e. lines,\r\n * quadratic and cubic bezier curves), (2) the coefficientwise error bound of the polyomial,\r\n * and (3) a function that returns the *exact* polynomial coefficients as\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * if there is an infinite number of intersections `undefined` is returned\r\n * * intermediate calculations are done in double-double precision with\r\n * fallback to infinite precision (bar underflow / overflow)\r\n *\r\n * @param ps1\r\n * @param ps2\r\n *\r\n * @doc mdx\r\n */\r\nfunction getCoeffsBezBez(ps1, ps2) {\r\n    const { coeffs, errBound } = coeffFunctionsDd[ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    const getPExact = () => coeffFunctionsExact[ps1.length - 2][ps2.length - 2](ps1, ps2);\r\n    return { coeffs, errBound, getPExact };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez-bez.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.js?')},"./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getPFromBox": () => (/* binding */ getPFromBox)\n/* harmony export */ });\n/** @internal */\r\nfunction getPFromBox(box) {\r\n    const tl = box[0];\r\n    const br = box[1];\r\n    return [\r\n        (tl[0] + br[0]) / 2,\r\n        (tl[1] + br[1]) / 2,\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js?')},"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "circleBezierIntersection": () => (/* binding */ circleBezierIntersection)\n/* harmony export */ });\n/* harmony import */ var _double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./double-double/get-coeffs-dd.js */ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js");\n/* harmony import */ var _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exact/get-coeffs-exact.js */ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-circle-bezier-intersection-error-counters.js */ "./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../bezier-bezier-intersection/x.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @internal */\r\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γγ"])(6);\r\n/**\r\n * Returns the intersection between a circle and linear, quadratic or cubic bezier\r\n * curve.\r\n *\r\n * The algorithm employed uses advanced techniques such\r\n * as floating point error bounding, adaptive multi-precision floating\r\n * point arithmetic, pre-filtering of easy cases, certified root finding and\r\n * algebraic implicitization of the curves in order to find *guaranteed* accurate\r\n * results (see points below)\r\n *\r\n * * the bezier curve\'s parameter `t` values are retuned in objects very\r\n * similar to the type [[X]]\r\n * * this algorithm is mathematically guaranteed accurate to within\r\n * `4 * Number.EPSILON` in the `t` parameter values of the bezier curve\r\n *\r\n * @param circle a circle given as the object `{ center: number[], radius: number }`\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction circleBezierIntersection(circle, ps) {\r\n    let poly;\r\n    let _polyE;\r\n    let getCoeffsExact;\r\n    if (ps.length === 4) {\r\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsCubicDd)(circle, ps);\r\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsCubicErrorCounters)(circle, ps);\r\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsCubicExact;\r\n    }\r\n    else if (ps.length === 3) {\r\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsQuadraticDd)(circle, ps);\r\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsQuadraticErrorCounters)(circle, ps);\r\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsQuadraticExact;\r\n    }\r\n    else if (ps.length === 2) {\r\n        poly = (0,_double_double_get_coeffs_dd_js__WEBPACK_IMPORTED_MODULE_0__.getCoeffsLinearDd)(circle, ps);\r\n        _polyE = (0,_get_circle_bezier_intersection_error_counters_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsLinearErrorCounters)(circle, ps);\r\n        getCoeffsExact = _exact_get_coeffs_exact_js__WEBPACK_IMPORTED_MODULE_1__.getCoeffsLinearExact;\r\n    }\r\n    else {\r\n        throw new Error(\'The given bezier curve must be of order 1, 2 or 3.\');\r\n    }\r\n    const polyE = _polyE.map(e => γγ6 * e);\r\n    const ris = ((0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.allRootsCertified)(poly, 0, 1, polyE, () => getCoeffsExact(circle, ps), true) ||\r\n        [{ tS: 0.5, tE: 0.5, multiplicity: 1 }]);\r\n    return ris.map(ri => {\r\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_6__.getIntervalBox)(ps, [ri.tS, ri.tE]);\r\n        return { p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_5__.getPFromBox)(box), box, t: (0,flo_poly__WEBPACK_IMPORTED_MODULE_2__.mid)(ri), ri };\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=circle-bezier-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/circle-bezier-intersection.js?')},"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsCubicDd": () => (/* binding */ getCoeffsCubicDd),\n/* harmony export */   "getCoeffsLinearDd": () => (/* binding */ getCoeffsLinearDd),\n/* harmony export */   "getCoeffsQuadraticDd": () => (/* binding */ getCoeffsQuadraticDd)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultBy2;\r\nconst qmn2 = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultByNeg2;\r\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddDiffDd;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\n/**\r\n * @param circle a circle\r\n * @param ps a cubic bezier curve\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsCubicDd(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a3, a2, a1, [, a0]], [b3, b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3Dd)(ps);\r\n    // a3*a3 + b3*b3\r\n    const t6 = qaq(qmq(a3, a3), qmq(b3, b3));\r\n    // 2*(a2*a3 + b2*b3)\r\n    const t5 = qm2(qaq(qmq(a2, a3), qmq(b2, b3)));\r\n    // 2*(a1*a3 + b1*b3) + (a2*a2 + b2*b2)\r\n    const t4 = qaq(qm2(qaq(qmq(a1, a3), qmq(b1, b3))), qaq(qmq(a2, a2), qmq(b2, b2)));\r\n    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)\r\n    const t3 = qaq(qaq(qaq(qmd(2 * a0, a3), qmq(qm2(a1), a2)), qaq(qmd(2 * b0, b3), qmq(qm2(b1), b2))), qaq(qmd(-2 * cx, a3), qmd(-2 * cy, b3)));\r\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\r\n    const t2 = qaq(qaq(qaq(qmd(2 * a0, a2), qmd(2 * b0, b2)), qaq(qmq(a1, a1), qmq(b1, b1))), qaq(qmd(-2 * cx, a2), qmd(-2 * cy, b2)));\r\n    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)\r\n    const t1 = qdifq(qaq(qmd(2 * a0, a1), qmd(2 * b0, b1)), qaq(qmd(2 * cx, a1), qmd(2 * cy, b1)));\r\n    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)\r\n    const t0 = qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), // -2*(a0*cx + b0*cy)\r\n    qdifq(qaq(qaq(tp(a0, a0), tp(b0, b0)), // a0**2 + b0**2\r\n    qaq(tp(cx, cx), tp(cy, cy)) // cx**2 + cy**2\r\n    ), tp(r, r) // r**2\r\n    ));\r\n    return [t6, t5, t4, t3, t2, t1, t0];\r\n}\r\n/**\r\n * @param circle a circle\r\n * @param ps a quadratic bezier curve\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsQuadraticDd(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a2, a1, [, a0]], [b2, b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2Dd)(ps);\r\n    // a2*a2 + b2*b2\r\n    const t4 = qaq(qmq(a2, a2), qmq(b2, b2));\r\n    // 2*a1*a2 + 2*b1*b2 \r\n    const t3 = qaq(qmq(qm2(a1), a2), qmq(qm2(b1), b2));\r\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\r\n    const t2 = qaq(qaq(qaq(qmd(2 * a0, a2), qmd(2 * b0, b2)), qaq(qmq(a1, a1), qmq(b1, b1))), qaq(qmd(-2 * cx, a2), qmd(-2 * cy, b2)));\r\n    // (2*a0*a1 + 2*b0*b1) + (-2*a1*cx + -2*b1*cy)\r\n    const t1 = qaq(qaq(qmd(2 * a0, a1), qmd(2 * b0, b1)), qaq(qmd(-2 * cx, a1), qmd(-2 * cy, b1)));\r\n    // ((a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy)) + ((cx*cx + cy*cy) - r*r)\r\n    const t0 = qaq(qaq(qaq(tp(a0, a0), tp(b0, b0)), qaq(tp(-2 * a0, cx), tp(-2 * b0, cy))), qdifq(qaq(tp(cx, cx), tp(cy, cy)), tp(r, r)));\r\n    return [t4, t3, t2, t1, t0];\r\n}\r\n/**\r\n * @param circle a circle\r\n * @param ps a linear bezier curve\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsLinearDd(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a1, [, a0]], [b1, [, b0]]] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1Dd)(ps);\r\n    // a1**2 + b1**2\r\n    const t2 = qaq(qmq(a1, a1), qmq(b1, b1));\r\n    // 2*((a0*a1 + b0*b1) - (a1*cx + b1*cy))\r\n    const t1 = qm2(qdifq(qaq(qmd(a0, a1), qmd(b0, b1)), qaq(qmd(cx, a1), qmd(cy, b1))));\r\n    // ((-2*a0*cx + -2*b0*cy) + (a0*a0 + b0*b0)) + ((cx*cx + cy*cy) - r*r)\r\n    const t0 = qaq(qaq(qmn2(qaq(tp(a0, cx), tp(b0, cy))), qaq(tp(a0, a0), tp(b0, b0))), qdifq(qaq(tp(cx, cx), tp(cy, cy)), tp(r, r)));\r\n    return [t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.js?')},"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsCubicExact": () => (/* binding */ getCoeffsCubicExact),\n/* harmony export */   "getCoeffsLinearExact": () => (/* binding */ getCoeffsLinearExact),\n/* harmony export */   "getCoeffsQuadraticExact": () => (/* binding */ getCoeffsQuadraticExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\nconst tp = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.twoProduct;\r\nconst calc = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eCalculate;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.scaleExpansion;\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of a circle\r\n * and a cubic bezier curve.\r\n *\r\n * The returned polynomial degree will be 6\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n *\r\n * @param circle a circle\r\n * @param ps a cubic bezier curve\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsCubicExact(circle, ps) {\r\n    const { radius: r, center: c } = circle;\r\n    const [cx, cy] = c;\r\n    //const [[a3,a2,a1,x0], [b3,b2,b1,y0]] = toPowerBasis3Exact(ps);\r\n    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3Exact)(ps);\r\n    //const a0 = [x0];\r\n    //const b0 = [y0];\r\n    // (a3**2 + b3**2)*t**6 + \r\n    const t6 = calc([\r\n        [a3, a3],\r\n        [b3, b3]\r\n    ]);\r\n    // (2*a2*a3 + 2*b2*b3)*t**5 + \r\n    const t5 = sce(calc([\r\n        [a2, a3],\r\n        [b2, b3]\r\n    ]), 2);\r\n    // (2*a1*a3 + a2**2 + 2*b1*b3 + b2**2)*t**4 + \r\n    const t4 = calc([\r\n        [[2], a1, a3], [a2, a2], [[2], b1, b3], [b2, b2]\r\n    ]);\r\n    // (2*a0*a3 + 2*a1*a2 - 2*a3*cx + 2*b0*b3 + 2*b1*b2 - 2*b3*cy)*t**3 + \r\n    const t3 = sce(calc([\r\n        [a0, a3], [a1, a2], [[-1], a3, [cx]], [b0, b3], [b1, b2], [[-1], b3, [cy]]\r\n    ]), 2);\r\n    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + \r\n    const t2 = calc([\r\n        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]\r\n    ]);\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    const t1 = sce(calc([\r\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\r\n    ]), 2);\r\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\r\n    const t0 = calc([\r\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\r\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\r\n    ]);\r\n    return [t6, t5, t4, t3, t2, t1, t0];\r\n}\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of a circle\r\n * and a quadratic bezier curve.\r\n *\r\n * The returned polynomial degree will be 4\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * **precondition:** none\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n *\r\n * @param circle a circle\r\n * @param ps a quadratic bezier curve\r\n */\r\nfunction getCoeffsQuadraticExact(circle, ps) {\r\n    const { radius: r, center: c } = circle;\r\n    const [cx, cy] = c;\r\n    const [[a2, a1, a0], [b2, b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2Exact)(ps);\r\n    //const a0 = [x0];\r\n    //const b0 = [y0];\r\n    // (a2**2 + b2**2)*t**4 + \r\n    const t4 = calc([\r\n        [a2, a2],\r\n        [b2, b2]\r\n    ]);\r\n    // (2*a1*a2 + 2*b1*b2)*t**3 + \r\n    const t3 = sce(calc([\r\n        [a1, a2],\r\n        [b1, b2]\r\n    ]), 2);\r\n    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + \r\n    const t2 = calc([\r\n        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]\r\n    ]);\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    const t1 = sce(calc([\r\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\r\n    ]), 2);\r\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\r\n    const t0 = calc([\r\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\r\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\r\n    ]);\r\n    return [t4, t3, t2, t1, t0];\r\n}\r\n/**\r\n * Returns an error-free polynomial in 1 variable\r\n * whose roots are the parameter values of the intersection points of a circle\r\n * and a linear bezier curve (i.e. a line).\r\n *\r\n * The returned polynomial degree will be 2\r\n * (see [Bézout\'s theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * **precondition:** none\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n *\r\n * @param circle a circle\r\n * @param ps a linear bezier curve\r\n */\r\nfunction getCoeffsLinearExact(circle, ps) {\r\n    const { radius: r, center: c } = circle;\r\n    const [cx, cy] = c;\r\n    const [[a1, a0], [b1, b0]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1Exact)(ps);\r\n    //const a0 = [x0];\r\n    //const b0 = [y0];\r\n    // (a1**2 + b1**2)*t**2 +\r\n    const t2 = calc([\r\n        [a1, a1],\r\n        [b1, b1]\r\n    ]);\r\n    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + \r\n    const t1 = sce(calc([\r\n        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]\r\n    ]), 2);\r\n    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2\r\n    const t0 = calc([\r\n        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],\r\n        [tp(cx, cx)], [tp(cy, cy)], [tp(-r, r)]\r\n    ]);\r\n    return [t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/exact/get-coeffs-exact.js?')},"./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsCubicErrorCounters": () => (/* binding */ getCoeffsCubicErrorCounters),\n/* harmony export */   "getCoeffsLinearErrorCounters": () => (/* binding */ getCoeffsLinearErrorCounters),\n/* harmony export */   "getCoeffsQuadraticErrorCounters": () => (/* binding */ getCoeffsQuadraticErrorCounters)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/to-power-basis-error-counters.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js");\n\r\nconst abs = Math.abs;\r\n/**\r\n * @param circle a circle\r\n * @param ps a cubic bezier curve\r\n *\r\n * ```\r\n * // (1 x γ) the error counters for double precision!\r\n * // (6 x γγ) the error counters for double-double precision!\r\n * return [\r\n *      t6_,  // <8>\r\n *      t5_,  // <8>\r\n *      t4_,  // <9>\r\n *      t3_,  // <9>\r\n *      t2_,  // <8>\r\n *      t1_,  // <5>\r\n *      t0_   // <5>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsCubicErrorCounters(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a3_, a2_, a1_, /*0*/], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b3_, b2_, b1_, /*0*/] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis3ErrorCounters)(ps);\r\n    const p0 = ps[0];\r\n    const a0_ = abs(p0[0]);\r\n    const b0_ = abs(p0[1]);\r\n    const cx_ = abs(cx);\r\n    const cy_ = abs(cy);\r\n    // a3*a3 + b3*b3\r\n    // <8> <-- <8>(<7>(<3>a3*<3>a3) + <7>(<3>b3*<3>b3))\r\n    const t6_ = a3_ * a3_ + b3_ * b3_;\r\n    // 2*a2*a3 + 2*b2*b3\r\n    // <8> <-- 2*a2*a3 + 2*b2*b3\r\n    const t5_ = 2 * (a2_ * a3_ + b2_ * b3_);\r\n    // (2*a1*a3 + 2*b1*b3) + (a2*a2 + b2*b2)\r\n    // <9> <-- <9>(<7>(2*(<6>a1*a3 + <6>b1*b3)) + <8>(<7>a2*a2 + <7>b2*b2))\r\n    const t4_ = 2 * (a1_ * a3_ + b1_ * b3_) + (a2_ * a2_ + b2_ * b2_);\r\n    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)\r\n    // 2*(((a0*a3 + a1*a2) + (b0*b3 + b1*b2)) + (a3*cx + b3*cy))\r\n    // <9> <-- 2*<9>(<8>(<7>(<4>a0*a3 + <6>a1*a2) + <7>(<4>b0*b3 + <6>b1*b2)) + <5>(<4>(a3*cx) + <4>(b3*cy)))\r\n    const t3_ = 2 * (((a0_ * a3_ + a1_ * a2_) + (b0_ * b3_ + b1_ * b2_)) + (a3_ * cx_ + b3_ * cy_));\r\n    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)\r\n    // (2*(a0*a2 + b0*b2) + (a1*a1 + b1*b1)) + -2*(a2*cx + b2*cy)\r\n    // <8> <-- <8>(<7>(2*<5>(<4>(a0*a2) + <4>(b0*b2)) + <6>(<5>(a1*a1) + <5>(b1*b1))) + <5>(-2*(<4>(a2*cx) + <4>(b2*cy))))\r\n    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);\r\n    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)\r\n    // 2*(a0*a1 + b0*b1) - 2*(a1*cx + b1*cy);\r\n    // <5> <-- <5>(<4>(2*(<3>(a0*a1) + <3>b0*b1)) - <4>(2*(<3>(a1*cx) + <3>(b1*cy))));\r\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\r\n    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)\r\n    // <5> <--  <5>(<2>(-2*(<1>(a0*cx) + <1>(b0*cy))) + <4>(<3>(<2>(<1>(a0**2) + <1>(b0**2)) + <2>(<1>(cx**2) + <1>(cy**2))) - <1>(r**2)));\r\n    const t0_ = 2 * (a0_ * cx_ + b0_ * cy_) + (((a0_ * a0_ + b0_ * b0_) + (cx_ * cx_ + cy_ * cy_)) + r * r);\r\n    return [\r\n        t6_,\r\n        t5_,\r\n        t4_,\r\n        t3_,\r\n        t2_,\r\n        t1_,\r\n        t0_ // <5>\r\n    ];\r\n}\r\n/**\r\n * @param circle a circle\r\n * @param ps a quadratic bezier curve\r\n *\r\n * @internal\r\n *\r\n * ```\r\n * return [\r\n *      t4_,  // <6>\r\n *      t3_,  // <5>\r\n *      t2_,  // <6>\r\n *      t1_,  // <4>\r\n *      t0_   // <4>\r\n * ];\r\n * ```\r\n */\r\nfunction getCoeffsQuadraticErrorCounters(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a2_, a1_, /*0*/], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b2_, b1_, /*0*/] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis2ErrorCounters)(ps);\r\n    const p0 = ps[0];\r\n    const a0_ = abs(p0[0]);\r\n    const b0_ = abs(p0[1]);\r\n    const cx_ = abs(cx);\r\n    const cy_ = abs(cy);\r\n    // <6> <-- <6>(<5>(a2*a2) + <5>(b2*b2))\r\n    const t4_ = a2_ * a2_ + b2_ * b2_;\r\n    // 2*a1*a2 + 2*b1*b2\r\n    // <5> <-- <5>(2*(<4>(a1*a2) + <4>(b1*b2)))\r\n    const t3_ = 2 * (a1_ * a2_ + b1_ * b2_);\r\n    // <6> <-- <6>(<5>(2*<4>(<3<(a0*a2) + <3<(b0*b2)) + <4>(<3<(a1*a1) + <3<(b1*b1))) + -2*<4>(<3>(a2*cx) + <3>(b2*cy)))\r\n    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);\r\n    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1))) + -2*<3>(<2>(a1*cx) + <2>(b1*cy)))\r\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\r\n    // (a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy) + (cx*cx + cy*cy) - r*r\r\n    // <4> <-- <4>(<3>(<2>(<1>(a0*a0) + <1>(b0*b0)) + <2>(-2*(<1>(a0*cx) + <1>(b0*cy)))) + <3>(<2>(<1>(cx*cx) + <1>(cy*cy)) - <1>(r*r)))\r\n    const t0_ = ((a0_ * a0_ + b0_ * b0_) + 2 * (a0_ * cx_ + b0_ * cy_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);\r\n    return [t4_, t3_, t2_, t1_, t0_];\r\n}\r\n/**\r\n * @param circle a circle\r\n * @param ps a linear bezier curve\r\n *\r\n * @internal\r\n *\r\n * ```\r\n * return [\r\n *      t2_,  // <4>\r\n *      t1_,  // <4>\r\n *      t0_   // <4>\r\n * ];\r\n * ```\r\n */\r\nfunction getCoeffsLinearErrorCounters(circle, ps) {\r\n    const { radius: r, center: [cx, cy] } = circle;\r\n    const [[a1_, /*0*/], // <1>a1_, <0>a0_  (a0_ is just abs(a0))\r\n    [b1_, /*0*/] // <1>b1_, <0>b0_  (b0_ is just abs(b0))\r\n    ] = (0,_to_power_basis_to_power_basis_to_power_basis_error_counters_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis1ErrorCounters)(ps);\r\n    const p0 = ps[0];\r\n    const a0_ = abs(p0[0]);\r\n    const b0_ = abs(p0[1]);\r\n    const cx_ = abs(cx);\r\n    const cy_ = abs(cy);\r\n    // <4> <-- <4>(<3>(a1*a1) + <3>(b1*b1))\r\n    const t2_ = a1_ * a1_ + b1_ * b1_;\r\n    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1)) - <3>(<2>(a1*cx) + <2>(b1*cy))))\r\n    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));\r\n    // <4> <-- <4>(<3>(-2*<2>(<1>(a0*cx) + <1>(b0*cy)) + <2>(a0*a0 + b0*b0)) + <3>(<2>(cx*cx + cy*cy) - <1>(r*r)))\r\n    const t0_ = (2 * (a0_ * cx_ + b0_ * cy_) + (a0_ * a0_ + b0_ * b0_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);\r\n    return [t2_, t1_, t0_];\r\n}\r\n\r\n//# sourceMappingURL=get-circle-bezier-intersection-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bAbs": () => (/* binding */ bAbs)\n/* harmony export */ });\n/** @internal */\r\nfunction bAbs(n) {\r\n    return n < 0n ? -n : n;\r\n}\r\n\r\n//# sourceMappingURL=b-abs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bCbrt": () => (/* binding */ bCbrt)\n/* harmony export */ });\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-abs.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js");\n/* harmony import */ var _b_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-sign.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js");\n\r\n\r\nconst { round, cbrt } = Math;\r\n/**\r\n * Returns the cube root of a bigint.\r\n *\r\n * * see https://stackoverflow.com/a/53684036/2010061\r\n *\r\n * * **precondition**: the given bigint must be a perfect cube\r\n *\r\n * @internal\r\n */\r\nfunction bCbrt(n) {\r\n    const sgn = (0,_b_sign_js__WEBPACK_IMPORTED_MODULE_1__.bSign)(n);\r\n    n = (0,_b_abs_js__WEBPACK_IMPORTED_MODULE_0__.bAbs)(n);\r\n    if (n <= 1n) {\r\n        return sgn * n;\r\n    }\r\n    let x0 = BigInt(round(cbrt(Number(n))));\r\n    while (true) {\r\n        const x1 = (2n * x0 + n / (x0 * x0)) / 3n;\r\n        if (x1 === x0) {\r\n            return sgn * x0;\r\n        }\r\n        x0 = x1;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-cbrt.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bSign": () => (/* binding */ bSign)\n/* harmony export */ });\n/** @internal */\r\nfunction bSign(v) {\r\n    return v > 0n ? 1n : v < 0n ? -1n : 0n;\r\n}\r\n\r\n//# sourceMappingURL=b-sign.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sign.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bSqrt\": () => (/* binding */ bSqrt)\n/* harmony export */ });\nconst { round, sqrt } = Math;\r\n/**\r\n * Returns the square root of a bigint.\r\n *\r\n * * see https://stackoverflow.com/a/53684036/2010061\r\n *\r\n * * **precondition**: the given bigint must be a perfect square\r\n *\r\n * @internal\r\n */\r\nfunction bSqrt(v) {\r\n    if (v <= 1n) {\r\n        if (v < 0n) {\r\n            throw new Error('square root of negative numbers are not allowed');\r\n        }\r\n        return v;\r\n    }\r\n    let x0 = BigInt(round(sqrt(Number(v))));\r\n    while (true) {\r\n        const x1 = (x0 + v / x0) >> 1n;\r\n        if (x1 === x0) {\r\n            return x0;\r\n        }\r\n        x0 = x1;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-sqrt.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js?")},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bigintToExpansion": () => (/* binding */ bigintToExpansion)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst maxSafe = BigInt(2 ** 53);\r\n/**\r\n * Returns the [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansion of the given bigint.\r\n *\r\n * * it is assumed that the given bigint doesn\'t cause floating point overflow\r\n *\r\n * @internal\r\n */\r\nfunction bigintToExpansion(b) {\r\n    if (b === 0n) {\r\n        return [0];\r\n    }\r\n    const e = [];\r\n    let i = 0;\r\n    let q = b;\r\n    while (q !== 0n) {\r\n        q = b / maxSafe;\r\n        const r = b % maxSafe;\r\n        e.push(Number(r) * 2 ** (i * 53));\r\n        b = q;\r\n        i++;\r\n    }\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompress)(e);\r\n}\r\n\r\n//# sourceMappingURL=bigint-to-expansion.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calcExactCubeRoot": () => (/* binding */ calcExactCubeRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigint-to-expansion.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js");\n/* harmony import */ var _b_cbrt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./b-cbrt.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-cbrt.js");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sum-bigints.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js");\n\r\n\r\n\r\n\r\n/**\r\n * * **precondition**: the given value must be a perfect cube\r\n *\r\n * @param a the rational value for which the square root is sought given as\r\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions\r\n *\r\n * @internal\r\n */\r\nfunction calcExactCubeRoot(a) {\r\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_3__.sumBigints);\r\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.bGcdInt)(NN, DD);\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    let N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_2__.bCbrt)(NN / gcd));\r\n    let D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__.bigintToExpansion)((0,_b_cbrt_js__WEBPACK_IMPORTED_MODULE_2__.bCbrt)(DD / gcd));\r\n    return [N, D];\r\n}\r\n\r\n//# sourceMappingURL=calc-exact-cube-root.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "calcExactSquareRoot": () => (/* binding */ calcExactSquareRoot)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigint-to-expansion.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/bigint-to-expansion.js");\n/* harmony import */ var _b_sqrt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./b-sqrt.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-sqrt.js");\n/* harmony import */ var _b_abs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./b-abs.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/b-abs.js");\n/* harmony import */ var _sum_bigints_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sum-bigints.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * * **precondition**: the given value must be a perfect square\r\n *\r\n * @param a the rational value for which the square root is sought given as\r\n * `[N,D]` to represent the value `N/D` where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions\r\n *\r\n * @internal\r\n */\r\nfunction calcExactSquareRoot(a) {\r\n    const [NN, DD] = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.scaleFloatssToBigintss)(a).map(_sum_bigints_js__WEBPACK_IMPORTED_MODULE_4__.sumBigints);\r\n    const gcd = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.bGcdInt)(NN, DD);\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    let N = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_2__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_3__.bAbs)(NN / gcd)));\r\n    let D = (0,_bigint_to_expansion_js__WEBPACK_IMPORTED_MODULE_1__.bigintToExpansion)((0,_b_sqrt_js__WEBPACK_IMPORTED_MODULE_2__.bSqrt)((0,_b_abs_js__WEBPACK_IMPORTED_MODULE_3__.bAbs)(DD / gcd)));\r\n    return [N, D];\r\n}\r\n\r\n//# sourceMappingURL=calc-exact-square-root.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ensureRange": () => (/* binding */ ensureRange)\n/* harmony export */ });\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\n/**\r\n * @param t\r\n * @param min1Sign\r\n *\r\n * @internal\r\n */\r\nfunction ensureRange(t, min1Sign) {\r\n    return (min1Sign < 0\r\n        ? (t < 1 ? t : 1 - u)\r\n        : min1Sign === 0\r\n            ? 1\r\n            : (t > 1 ? t : 1 + eps));\r\n}\r\n\r\n//# sourceMappingURL=ensure-range.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "erCompare": () => (/* binding */ erCompare)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/**\r\n * Compares two expansion rationals.\r\n *\r\n * @internal\r\n */\r\nfunction erCompare(a, b) {\r\n    return ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(a[0], b[1]), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(a[1], b[0])) *\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[1]) *\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(b[1]));\r\n}\r\n\r\n//# sourceMappingURL=er-compare.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "erEstimate": () => (/* binding */ erEstimate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/**\r\n * Estimates the result of the given expansion rational.\r\n *\r\n * * the sign of the returned result is guaranteed to be correct\r\n * * the result is guaranteed accurate to within 2 ulps\r\n *\r\n * @param a\r\n *\r\n * @internal\r\n */\r\nfunction erEstimate(a) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiv)(a[0], a[1], 2));\r\n}\r\n\r\n//# sourceMappingURL=er-estimate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "erSign": () => (/* binding */ erSign)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/**\r\n * Returns the sign of the given expansion rational.\r\n *\r\n * @param a\r\n *\r\n * @internal\r\n */\r\nfunction erSign(a) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[1]);\r\n}\r\n\r\n//# sourceMappingURL=er-sign.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAB": () => (/* binding */ getAB)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _ensure_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ensure-range.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/ensure-range.js");\n/* harmony import */ var _er_estimate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./er-estimate.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-estimate.js");\n/* harmony import */ var _er_sign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./er-sign.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-sign.js");\n\r\n\r\n\r\n\r\n/** @internal */\r\nfunction getAB(getTransform) {\r\n    return (psA, psB) => {\r\n        const xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA);\r\n        const xyB = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB);\r\n        const xyAR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psA.slice().reverse());\r\n        const xyBR = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(psB.slice().reverse());\r\n        const d = getTransform(xyA, xyB);\r\n        const d_AR = getTransform(xyAR, xyB);\r\n        const d_BR = getTransform(xyA, xyBR);\r\n        const d_ARBR = getTransform(xyAR, xyBR);\r\n        // Get the *certified* sign of `tA_B0 - 1`.\r\n        const sgn_tA_B0_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_3__.erSign)(d_AR);\r\n        const sgn_tA_B1_min1 = -(0,_er_sign_js__WEBPACK_IMPORTED_MODULE_3__.erSign)(d_ARBR);\r\n        const _tA_B0 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d);\r\n        const _tA_B1 = (0,_er_estimate_js__WEBPACK_IMPORTED_MODULE_2__.erEstimate)(d_BR);\r\n        const tA_B0 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_1__.ensureRange)(_tA_B0, sgn_tA_B0_min1);\r\n        const tA_B1 = (0,_ensure_range_js__WEBPACK_IMPORTED_MODULE_1__.ensureRange)(_tA_B1, sgn_tA_B1_min1);\r\n        return [tA_B0, tA_B1];\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-ab.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAB1": () => (/* binding */ getAB1)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js");\n/* harmony import */ var _get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-1.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js");\n\r\n\r\n/** @internal */\r\nconst getAB1 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_1_js__WEBPACK_IMPORTED_MODULE_1__.getTransform1);\r\n\r\n//# sourceMappingURL=get-ab1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAB2": () => (/* binding */ getAB2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_transform_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-2.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab1.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js");\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-ab.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js");\n\r\n\r\n\r\n\r\n\r\n/** @internal */\r\nfunction getAB2(psA, psB) {\r\n    const _xyA = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasisExact)(psA);\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can\'t be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(_xyA[0][0]) === 0 ? 0 : (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(_xyA[1][0]) === 0 ? 1 : -1;\r\n    if (coord !== -1) {\r\n        const psA0c = psA[0][coord];\r\n        const psA2c = psA[2][coord];\r\n        const psB0c = psB[0][coord];\r\n        const psB2c = psB[2][coord];\r\n        return (0,_get_ab1_js__WEBPACK_IMPORTED_MODULE_3__.getAB1)([[psA0c, psA0c], [psA2c, psA2c]], [[psB0c, psB0c], [psB2c, psB2c]]);\r\n    }\r\n    return (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_4__.getAB)(_get_transform_2_js__WEBPACK_IMPORTED_MODULE_1__.getTransform2)(psA, psB);\r\n}\r\n\r\n//# sourceMappingURL=get-ab2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getAB3": () => (/* binding */ getAB3)\n/* harmony export */ });\n/* harmony import */ var _get_ab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-ab.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab.js");\n/* harmony import */ var _get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transform-3.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js");\n\r\n\r\n/** @internal */\r\nconst getAB3 = (0,_get_ab_js__WEBPACK_IMPORTED_MODULE_0__.getAB)(_get_transform_3_js__WEBPACK_IMPORTED_MODULE_1__.getTransform3);\r\n\r\n//# sourceMappingURL=get-ab3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getEndpointIntersections": () => (/* binding */ getEndpointIntersections)\n/* harmony export */ });\n/* harmony import */ var _bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bezier-bezier-intersection/x.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js");\n/* harmony import */ var _transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transformation/reduce-order-if-possible.js */ "./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js");\n/* harmony import */ var _get_ab1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-ab1.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab1.js");\n/* harmony import */ var _get_ab2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-ab2.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab2.js");\n/* harmony import */ var _get_ab3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-ab3.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-ab3.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n/* harmony import */ var _sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../sub-1-ulp.js */ "./node_modules/flo-bezier3/node/sub-1-ulp.js");\n/* harmony import */ var _add_1_ulp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../add-1-ulp.js */ "./node_modules/flo-bezier3/node/add-1-ulp.js");\n/* harmony import */ var _boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../boxes/intersect-boxes.js */ "./node_modules/flo-bezier3/node/boxes/intersect-boxes.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Returns the intersection range (given as 2 intersections (`X`s)) where the\r\n * endpoints of the two given *algebraically identical* curves\r\n * overlap (provided they overlap, else an empty array is returned).\r\n *\r\n * * **precondition:** the two given curves must be *algebraically identical*\r\n * (i.e. identical except possibly for endpoints)\r\n *\r\n * * **precondition**: not all bezier control points collinear\r\n *\r\n * @param psA an order 1,2 or 3 bezier curve\r\n * @param psB another bezier curve\r\n *\r\n * @internal but still exported for backwards compatibility\r\n */\r\nfunction getEndpointIntersections(psA, psB, orderAlreadyReduced = false) {\r\n    if (!orderAlreadyReduced) {\r\n        psA = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_1__.reduceOrderIfPossible)(psA);\r\n        psB = (0,_transformation_reduce_order_if_possible_js__WEBPACK_IMPORTED_MODULE_1__.reduceOrderIfPossible)(psB);\r\n    }\r\n    // `psB.length` should equal `psB.length` (due to precondition)\r\n    const getABs = [, , _get_ab1_js__WEBPACK_IMPORTED_MODULE_2__.getAB1, _get_ab2_js__WEBPACK_IMPORTED_MODULE_3__.getAB2, _get_ab3_js__WEBPACK_IMPORTED_MODULE_4__.getAB3];\r\n    const [tA_B0, tA_B1] = getABs[psA.length](psA, psB);\r\n    const [tB_A0, tB_A1] = getABs[psA.length](psB, psA);\r\n    //------------------------------------------------\r\n    // Perform a simple unrolled sweep line algorithm\r\n    //------------------------------------------------\r\n    const infos = [\r\n        { tA: tA_B0, tB: 0, bez: \'B\', start: true },\r\n        { tA: tA_B1, tB: 1, bez: \'B\', start: false },\r\n        { tA: 0, tB: tB_A0, bez: \'A\', start: true },\r\n        { tA: 1, tB: tB_A1, bez: \'A\', start: false }\r\n    ].sort((a, b) => a.tA - b.tA);\r\n    if (infos[1].tA === infos[2].tA) {\r\n        const info = infos[1];\r\n        const tA = info.tA; // `tA` will be either exactly `0` or exactly `1`\r\n        const tB = info.tB; // `tB` will be either exactly `0` or exactly `1`\r\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(psA, [tA, tA]);\r\n        return [{\r\n                p: box[0], kind: 4, box,\r\n                t1: tA, ri1: { tS: tA, tE: tA, multiplicity: 1 },\r\n                t2: tB, ri2: { tS: tB, tE: tB, multiplicity: 1 }\r\n            }];\r\n    }\r\n    if (infos[0].bez === infos[1].bez) {\r\n        return [];\r\n    }\r\n    const start = infos[1];\r\n    const end = infos[2];\r\n    const [tSAMin, tSAMax] = getMinMaxT(start.tA);\r\n    const [tSBMin, tSBMax] = getMinMaxT(start.tB);\r\n    const [tEAMin, tEAMax] = getMinMaxT(end.tA);\r\n    const [tEBMin, tEBMax] = getMinMaxT(end.tB);\r\n    const boxSA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(psA, [tSAMin, tSAMax]);\r\n    const boxSB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(psB, [tSBMin, tSBMax]);\r\n    const boxEA = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(psA, [tEAMin, tEAMax]);\r\n    const boxEB = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_5__.getIntervalBox)(psB, [tEBMin, tEBMax]);\r\n    const boxS = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_8__.intersectBoxes)(boxSA, boxSB);\r\n    const boxE = (0,_boxes_intersect_boxes_js__WEBPACK_IMPORTED_MODULE_8__.intersectBoxes)(boxEA, boxEB);\r\n    const riSA = { tS: tSAMin, tE: tSAMax, multiplicity: 1 };\r\n    const riSB = { tS: tSBMin, tE: tSBMax, multiplicity: 1 };\r\n    const riEA = { tS: tEAMin, tE: tEAMax, multiplicity: 1 };\r\n    const riEB = { tS: tEBMin, tE: tEBMax, multiplicity: 1 };\r\n    return [\r\n        {\r\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_0__.getPFromBox)(boxS), kind: 5, box: boxS,\r\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(riSA), ri1: riSA,\r\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(riSB), ri2: riSB\r\n        }, {\r\n            p: (0,_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_0__.getPFromBox)(boxE), kind: 5, box: boxE,\r\n            t1: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(riEA), ri1: riEA,\r\n            t2: (0,flo_poly__WEBPACK_IMPORTED_MODULE_9__.mid)(riEB), ri2: riEB\r\n        }\r\n    ];\r\n}\r\n/** @internal */\r\nfunction sub2Ulp(v) {\r\n    return (0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_6__.sub1Ulp)((0,_sub_1_ulp_js__WEBPACK_IMPORTED_MODULE_6__.sub1Ulp)(v));\r\n}\r\n/** @internal */\r\nfunction add2Ulp(v) {\r\n    return (0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_7__.add1Ulp)((0,_add_1_ulp_js__WEBPACK_IMPORTED_MODULE_7__.add1Ulp)(v));\r\n}\r\n/** @internal */\r\nfunction getMinMaxT(t) {\r\n    if (t === 0 || t === 1) {\r\n        return [t, t];\r\n    }\r\n    const tMin = sub2Ulp(t);\r\n    const tMax = add2Ulp(t);\r\n    return [tMin, tMax];\r\n}\r\n\r\n//# sourceMappingURL=get-endpoint-intersections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-endpoint-intersections.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getTransform1": () => (/* binding */ getTransform1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/** @internal */\r\nfunction getTransform1(_xyA, _xyB) {\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can\'t be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(_xyA[0][0]) === 0 ? 1 : 0;\r\n    const xyA = _xyA[coord];\r\n    const xyB = _xyB[coord];\r\n    return getTransformedTs1(xyA, xyB);\r\n}\r\n/**\r\n * Given two algebraically identical bezier curves (but with possibly different\r\n * endpoints) return the transformation parameters (the `c` and `d` in\r\n * `t = cx + d`) for transforming the second curve into the first so that it has\r\n * exactly the same control points but such that the parameter `t` values run\r\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\r\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\r\n *\r\n * * **precondition**: the given pair of bezier curves must be algebraically\r\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\r\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\r\n *\r\n * * **precondition**: the given pair of bezier curves are in lowest possible\r\n * order\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs1(A, B) {\r\n    const [p1, p0] = A;\r\n    const [, r0] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r1 = c*p1       => c = r1/p1\r\n    // (2)   r0 = d*p1 + p0  => d = (r0 - p0)/p1\r\n    //---------------\r\n    // Calculate `d`\r\n    //---------------\r\n    // (1)   d = (r0 - p0)/p1\r\n    // the *exact* `d` is given as the rational number `N/D`\r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    return [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(r0, p0), p1];\r\n}\r\n\r\n//# sourceMappingURL=get-transform-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-1.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getTransform2": () => (/* binding */ getTransform2)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _er_compare_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./er-compare.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/er-compare.js");\n/* harmony import */ var _calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calc-exact-square-root.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-square-root.js");\n\r\n\r\n\r\n/** @internal */\r\nfunction getTransform2(xyA, xyB) {\r\n    const [D1x, D2x] = getTransformedTs2(xyA[0], xyB[0]);\r\n    const [D1y, D2y] = getTransformedTs2(xyA[1], xyB[1]);\r\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_1__.erCompare)(D1x, D1y) === 0 ||\r\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_1__.erCompare)(D1x, D2y) === 0) {\r\n        return D1x;\r\n    }\r\n    if ((0,_er_compare_js__WEBPACK_IMPORTED_MODULE_1__.erCompare)(D2x, D1y) === 0 ||\r\n        (0,_er_compare_js__WEBPACK_IMPORTED_MODULE_1__.erCompare)(D2x, D2y) === 0) {\r\n        return D2x;\r\n    }\r\n    throw new Error(\'An unexpected error occured.\');\r\n}\r\n/**\r\n * @param A A coordinate (x or y) of a bezier curve in power basis\r\n * @param B A coordinate (x or y) of another bezier curve in power basis\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs2(A, B) {\r\n    const [p2, p1] = A;\r\n    const [r2, r1] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r2 = cc*p2\r\n    // (2)   r1 = c*p1 + 2*c*d*p2\r\n    // (3)   r0 = dd*p2 + d*p1 + p0\r\n    // Note that since `r2,r1,r0,p2,p1,p0` are rational we must have \r\n    // (non-trivially) that `c` is rational and thus `d` also rational.\r\n    //-----------------------------------\r\n    // Calculate `c` *exactly* using (1)\r\n    //-----------------------------------\r\n    // the *exact* positive root `c` is given as the rational number `N/D` \r\n    // where `N` and `D` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) expansions\r\n    const [N, D] = (0,_calc_exact_square_root_js__WEBPACK_IMPORTED_MODULE_2__.calcExactSquareRoot)([r2, p2]);\r\n    //-----------------------------------\r\n    // Calculate `d` *exactly* using (2)\r\n    //-----------------------------------\r\n    // (2)   r1 = c*p1 + 2*c*d*p2  =>\r\n    //       r1 = c*(p1 + 2*d*p2)  =>\r\n    // dA = (r1/c - p1)/(2*p2)\r\n    //    = r1/(c*2*p2) - c*p1/(c*2*p2)\r\n    //    = (r1 - c*p1)/(c*2*p2)\r\n    //    = (r1 - N*p1/D)/(N*2*p2/D)\r\n    //    = (D*r1 - N*p1)/(N*2*p2)\r\n    // dB = (r1/(-c) - p1)/(2*p2)\r\n    //    = r1/(-c*2*p2) - c*p1/(c*2*p2)\r\n    //    = (-r1 - c*p1)/(c*2*p2)\r\n    //    = (-r1 - N*p1/D)/(N*2*p2/D)\r\n    //    = (-r1*D - N*p1)/(N*2*p2)\r\n    return [\r\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(r1, D), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2)(p2))],\r\n        [(0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(r1, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf)(D)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(p1, N)), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(N, (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2)(p2))]\r\n    ].sort(_er_compare_js__WEBPACK_IMPORTED_MODULE_1__.erCompare);\r\n}\r\n\r\n//# sourceMappingURL=get-transform-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-2.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getTransform3": () => (/* binding */ getTransform3)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-exact-cube-root.js */ "./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/calc-exact-cube-root.js");\n\r\n\r\n/** @internal */\r\nfunction getTransform3(xyA, xyB) {\r\n    // Both `_xyB[0][0]` and `_xyB[1][0]` can\'t be zero else we would have had\r\n    // a lower order bezier curve. Also, if `_xyB[0][0]` is zero \r\n    // then `_xyA[0][0]` will also be zero (and same with the y coordinate)\r\n    const coord = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(xyA[0][0]) === 0 ? 1 : 0;\r\n    const xyA_ = xyA[coord];\r\n    const xyB_ = xyB[coord];\r\n    return getTransformedTs3(xyA_, xyB_);\r\n}\r\n/**\r\n * Given two algebraically identical bezier curves (but with possibly different\r\n * endpoints) return the transformation parameters (the `c` and `d` in\r\n * `t = cx + d`) for transforming the second curve into the first so that it has\r\n * exactly the same control points but such that the parameter `t` values run\r\n * from `t0` to `t1` where `t0` and `t1` can be obtained via `t0 = -d/c`\r\n * and `t1 = (1 - d)/c` (or in reverse: `t0_ = d` and `t1_ = c + d`).\r\n *\r\n * * **precondition**: the given pair of bezier curves must be algebraically\r\n * identical, e.g. `ps = [[1,1],[2,2],[3,2],[3,-1]]`\r\n * and `ps_ = [[-1,-21],[-3.25,-29.25],[-6.625,-40.3125],[-11.546875,-55.03125]]`\r\n *\r\n * * **precondition**: the given pair of bezier curves are in lowest possible\r\n * order\r\n *\r\n * @internal\r\n */\r\nfunction getTransformedTs3(A, B) {\r\n    const [p3, p2] = A;\r\n    const [r3, r2] = B;\r\n    // The (over-determined) set of equations used to solve `c` and `d`\r\n    // (1)   r3 = p3*ccc\r\n    // (2)   r2 = 3*cc*p3*d + cc*p2\r\n    // (3)   r1 = 3*c*p3*dd + 2*c*p2*d + c*p1\r\n    // (4)   r0 = p3*ddd + p2*dd + p1*d + p0\r\n    //-------------------------\r\n    // Calculate `c` *exactly*\r\n    //-------------------------\r\n    const C = (0,_calc_exact_cube_root_js__WEBPACK_IMPORTED_MODULE_1__.calcExactCubeRoot)([r3, p3]);\r\n    //-------------------------\r\n    // Calculate `d` *exactly*\r\n    //-------------------------\r\n    // (2)   3*cc*p3*d + cc*p2 = r2\r\n    //  =>   d = (r2/cc - p2)/(3*p3)\r\n    const NN = eSquare(C[0]);\r\n    return [\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(r2, eSquare(C[1])), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(p2, NN)),\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2)(3, p3), NN)\r\n    ];\r\n}\r\n/** @internal */\r\nfunction eSquare(v) {\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult)(v, v);\r\n}\r\n\r\n//# sourceMappingURL=get-transform-3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/get-transform-3.js?')},"./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sumBigints": () => (/* binding */ sumBigints)\n/* harmony export */ });\n/** @internal */\r\nfunction sumBigints(vs) {\r\n    let total = 0n;\r\n    for (let i = 0; i < vs.length; i++) {\r\n        total += vs[i];\r\n    }\r\n    return total;\r\n}\r\n\r\n//# sourceMappingURL=sum-bigints.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/get-endpoint-intersections/sum-bigints.js?')},"./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierSelfIntersection": () => (/* binding */ bezierSelfIntersection)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var _get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coefficients/double/get-coeffs-bez3-with-running-error.js */ "./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js");\n/* harmony import */ var _get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coefficients/exact/get-coeffs-bez3-exact.js */ "./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n\r\n\r\n\r\n\r\n\r\nconst edif = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_1__.twoDiff;\r\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_1__.twoSum;\r\nconst qno = double_double__WEBPACK_IMPORTED_MODULE_1__.ddNegativeOf;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddAddDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultBy2;\r\nconst qdivq = double_double__WEBPACK_IMPORTED_MODULE_1__.ddDivDd;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\nconst eps = Number.EPSILON;\r\nconst eps2 = 2 * eps;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γ"])(1);\r\n/**\r\n * Returns the unique self-intersection parameter `t` values of the given\r\n * bezier curve if they exist, else return `[]` (see also the `inRange`\r\n * parameter below).\r\n *\r\n * * only cubic (or higher order) bezier curves can have unique self-intersections\r\n * * this algorithm is mathematically guaranteed accurate to within an absolute\r\n * error of `4 * Number.EPSILON` for the returned `t` values satisfying `|t| <= 1`\r\n * or a relative error of the same `4 * Number.EPSILON` otherwise.\r\n * * **special case:** a cusp is considered a degenerate self-intersection and\r\n * the (duplicate) `t` values will be returned\r\n *\r\n * @param ps a bezier curve given as an array of its control points\r\n * @param inRange if `inRange === true` (the default) then return the two `t`\r\n * parameter values only if both are in [0,1] else return `[]`.\r\n * If `inRange === false` then return the (0,1 or 2) `t` values in `[0,1]` even\r\n * if only one is in that range.\r\n *\r\n * @doc mdx\r\n */\r\nfunction bezierSelfIntersection(ps, inRange = true) {\r\n    if (ps.length < 4) {\r\n        // lines and quadratics don\'t have uniqure self-intersections.\r\n        return [];\r\n    }\r\n    // First get fast naively calculated coefficients\r\n    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = (0,_get_coefficients_double_get_coeffs_bez3_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBez3WithRunningError)(ps);\r\n    // if error in `a` cannot discern it from zero\r\n    if (abs(a) <= a_) {\r\n        // it is rare to get here \r\n        // check for sure if a === 0 exactly\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        //const a3 = (x3 - x0) + 3*(x1 - x2);\r\n        //const a2 = (x2 + x0) - 2*x1;\r\n        //const b3 = (y3 - y0) + 3*(y1 - y2);\r\n        //const b2 = (y2 + y0) - 2*y1;\r\n        const a3 = fes(td(x3, x0), sce(3, (td(x1, x2))));\r\n        const a2 = ge(ts(x2, x0), -2 * x1);\r\n        const b3 = fes(td(y3, y0), sce(3, (td(y1, y2))));\r\n        const b2 = ge(ts(y2, y0), -2 * y1);\r\n        const a2b3 = epr(a2, b3);\r\n        const a3b2 = epr(a3, b2);\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)(a2b3, a3b2) === 0) {\r\n            // a === 0 => no roots possible! (also b === 0 always if a === 0)\r\n            // This type of curve is usually shaped like an S where both \r\n            // extreme curvatures are identical...\r\n            // ...this is an explicit cubic curve!\r\n            return [];\r\n        }\r\n    }\r\n    // `Discr` = discriminant = b^2 - 4ac\r\n    // calculate `Discr` and its absolute error Discr_\r\n    const bb = b * b;\r\n    const bb_ = 2 * b_ * abs(b) + γ1 * bb; // the error in b**2\r\n    const ac4 = 4 * a * c;\r\n    const ac4_ = 4 * (a_ * abs(c) + abs(a) * c_) + γ1 * abs(ac4);\r\n    const Discr = bb - ac4;\r\n    const Discr_ = bb_ + ac4_ + γ1 * abs(Discr);\r\n    // if the discriminant is smaller than negative the error bound then\r\n    // certainly there are no roots, i.e. no cusp and no self-intersections\r\n    if (Discr < -Discr_) {\r\n        // discriminant is definitely negative\r\n        return [];\r\n    }\r\n    // if the discriminant is definitely positive\r\n    if (Discr > Discr_) {\r\n        // calculate roots naively as a fast pre-filter\r\n        const { est: D, err: D_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_1__.sqrtWithErr)(Discr, Discr_);\r\n        let q1;\r\n        if (b >= 0) {\r\n            // const r1 = (-b - D) / 2*a;\r\n            // const r2 = (2*c) / (-b - D);\r\n            q1 = -b - D;\r\n        }\r\n        else {\r\n            // const r2 = (-b + D) / 2*a;\r\n            // const r1 = (2*c) / (-b + D);\r\n            q1 = -b + D;\r\n        }\r\n        const q1_ = b_ + D_ + γ1 * abs(q1);\r\n        const { est: r1, err: r1_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_1__.divWithErr)(q1, 2 * a, q1_, 2 * a_);\r\n        const { est: r2, err: r2_ } = (0,double_double__WEBPACK_IMPORTED_MODULE_1__.divWithErr)(2 * c, q1, 2 * c_, q1_);\r\n        // the actual \'filter\' follows\r\n        if (inRange) {\r\n            // IF at least one root is not in [0,1]\r\n            // THEN no self-intersection (in [0,1])\r\n            if (r1 + r1_ < 0 || r1 - r1_ > 1 ||\r\n                r2 + r2_ < 0 || r2 - r2_ > 1) {\r\n                return [];\r\n            }\r\n        }\r\n        else {\r\n            // IF both roots not in [0,1] \r\n            // THEN no self-intersection (in [0,1])\r\n            if ((r1 + r1_ < 0 || r1 - r1_ > 1) &&\r\n                (r2 + r2_ < 0 || r2 - r2_ > 1)) {\r\n                return [];\r\n            }\r\n        }\r\n    }\r\n    // we need to check exactly - (a !== 0) at this point - tested for earlier\r\n    let [A, B, C] = (0,_get_coefficients_exact_get_coeffs_bez3_exact_js__WEBPACK_IMPORTED_MODULE_3__.getCoeffsBez3Exact)(ps);\r\n    // exact - Discr = b^2 - 4ac\r\n    const eDiscr = edif(epr(B, B), sce(4, epr(A, C)));\r\n    const sgnDiscr = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(eDiscr);\r\n    if (sgnDiscr < 0) {\r\n        // sgn < 0 => no real roots => no cusp or double point for t in [0,1]\r\n        return [];\r\n    }\r\n    if (sgnDiscr > 0) {\r\n        const D = (0,double_double__WEBPACK_IMPORTED_MODULE_1__.ddSqrt)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(eDiscr));\r\n        A = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(A);\r\n        B = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(B);\r\n        C = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(C);\r\n        let nBD;\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(B) >= 0) {\r\n            nBD = qno(qaq(B, D));\r\n            //t1 = (-B - D) / (2*A);\r\n            //t2 = (2*C) / (-B - D);\r\n        }\r\n        else {\r\n            nBD = qaq(qno(B), D);\r\n            //t1 = (2*C) / (-B + D);\r\n            //t2 = (-B + D) / (2*A);\r\n        }\r\n        let t1 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(qdivq(nBD, qm2(A))); // max 1 ulps out\r\n        let t2 = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(qdivq(qm2(C), nBD)); // max 1 ulps out\r\n        if (inRange) {\r\n            // if any root is outside the range => no double point for t in [0,1]\r\n            if (t1 < -eps2 || t1 > 1 + eps2 ||\r\n                t2 < -eps2 || t2 > 1 + eps2) {\r\n                return [];\r\n            }\r\n        }\r\n        else {\r\n            // if both roots are outside the range => no double point for t in [0,1]\r\n            if ((t1 < -eps2 || t1 > 1 + eps2) &&\r\n                (t2 < -eps2 || t2 > 1 + eps2)) {\r\n                return [];\r\n            }\r\n        }\r\n        // coerce to 0/1\r\n        //t1 = (t1 >= -eps4 && t1 < 0)\r\n        //    ? 0\r\n        //    : (t1 > 1 && t1 <= 1 + eps4) ? 1 : t1;\r\n        //t2 = (t2 >= -eps4 && t2 < 0)\r\n        //    ? 0\r\n        //    : (t2 > 1 && t2 <= 1 + eps4) ? 1 : t2;\r\n        [t1, t2] = t1 < t2 ? [t1, t2] : [t2, t1];\r\n        return t1 >= 0 - eps2 && t1 <= 1 + eps2\r\n            ? t2 >= 0 - eps2 && t2 <= 1 + eps2\r\n                ? [t1, t2]\r\n                : [t1]\r\n            : t2 >= 0 - eps2 && t2 <= 1 + eps2\r\n                ? [t2]\r\n                : [];\r\n    }\r\n    // sign === 0 => cusp\r\n    // set t = b/d = b/-2a\r\n    const d = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultByNeg2)(A);\r\n    const sgnB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(B);\r\n    const sgnD = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(d);\r\n    // if result is negative the cusp is outside the bezier endpoints\r\n    const sgn_ = sgnB * sgnD;\r\n    if (sgn_ < 0) {\r\n        return [];\r\n    }\r\n    // if result is > 1 the cusp is outside the bezier endpoints\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(B), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(d)) > 0) {\r\n        return [];\r\n    }\r\n    const qB = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(B);\r\n    const qd = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd)(d);\r\n    const qt = qdivq(qB, qd);\r\n    const t = qt[1] + qt[0];\r\n    return [t, t];\r\n}\r\n\r\n//# sourceMappingURL=bezier-self-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/self-intersection/bezier-self-intersection.js?')},"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3WithRunningError": () => (/* binding */ getCoeffsBez3WithRunningError)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js");\n\r\n\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γ"])(1);\r\n/**\r\n * Returns a polynomial in 1 variable (including coefficientwise error bound)\r\n * whose roots are the parameter values of the self-intersection points of the\r\n * given cubic bezier curve.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of double\r\n * precision floating point numbers from highest to lowest power,\r\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double precision and this is\r\n * reflected in the error bound\r\n * * the error bound returned need **not** be scaled before use\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve.\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3WithRunningError(ps) {\r\n    const { coeffs: [[a3, a2, a1], [b3, b2, b1]], errorBound: [[a3_, a2_], [b3_, b2_]] } = (0,_to_power_basis_to_power_basis_double_to_power_basis_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3WithRunningError)(ps);\r\n    const _a3 = abs(a3);\r\n    const _a2 = abs(a2);\r\n    const _a1 = abs(a1);\r\n    const _b3 = abs(b3);\r\n    const _b2 = abs(b2);\r\n    const _b1 = abs(b1);\r\n    const a2b3 = a2 * b3;\r\n    const a3b2 = a3 * b2;\r\n    const a3b1 = a3 * b1;\r\n    const a1b3 = a1 * b3;\r\n    const a2b1 = a2 * b1;\r\n    const a1b2 = a1 * b2;\r\n    // Note: a variable prepended with and underscore is an absolute value,\r\n    // postpended with an underscore denotes an absolute error (before \r\n    // multiplication by the round-off unit `u`) - both underscores present \r\n    // means it is both an absolute value and a round-off error.\r\n    const _a2b3 = abs(a2b3);\r\n    const _a3b2 = abs(a3b2);\r\n    const _a3b1 = abs(a3b1);\r\n    const _a1b3 = abs(a1b3);\r\n    const _a2b1 = abs(a2b1);\r\n    const _a1b2 = abs(a1b2);\r\n    const a2b3_ = a2_ * _b3 + _a2 * b3_ + _a2b3;\r\n    const a3b2_ = a3_ * _b2 + _a3 * b2_ + _a3b2;\r\n    const a3b1_ = a3_ * _b1 + _a3b1;\r\n    const a1b3_ = _a1 * b3_ + _a1b3;\r\n    const a2b1_ = a2_ * _b1 + _a2b1;\r\n    const a1b2_ = _a1 * b2_ + _a1b2;\r\n    const f4 = a2b3 - a3b2;\r\n    const _f4 = abs(f4);\r\n    const f4_ = a2b3_ + a3b2_ + _f4;\r\n    const f5 = a1b3 - a3b1;\r\n    const _f5 = abs(f5);\r\n    const f5_ = a1b3_ + a3b1_ + _f5;\r\n    const f6 = a2b1 - a1b2;\r\n    const _f6 = abs(f6);\r\n    const f6_ = a2b1_ + a1b2_ + _f6;\r\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    //const u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2\r\n    //const u2 = (a2b3 - a3b2)*(a2b3 - a3b2)\r\n    const u2 = f4 * f4;\r\n    const u2_ = 2 * f4_ * _f4 + abs(u2);\r\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    //const u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2\r\n    //const u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)\r\n    //const u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);\r\n    const u1 = f4 * f5;\r\n    const u1_ = f4_ * _f5 + _f4 * f5_ + abs(u1);\r\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    //const u0 = \r\n    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +\r\n    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;\r\n    //const u0 = \r\n    //       f6*f4 + \r\n    //       (a1b3 - a3b1)*(a1b3 - a3b1);\r\n    //const u0 = f6*f4 + f5*f5;\r\n    const g7 = f6 * f4;\r\n    const g7_ = f6_ * _f4 + _f6 * f4_ + abs(g7);\r\n    const g9 = f5 * f5;\r\n    const g9_ = 2 * _f5 * f5_ + abs(g9);\r\n    const u0 = g7 + g9;\r\n    const u0_ = g7_ + g9_ + abs(u0);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return {\r\n        coeffs: [u2, u1, u0],\r\n        errBound: [u2_, u1_, u0_].map(c => γ1 * c)\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.js?')},"./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCoeffsBez3Exact": () => (/* binding */ getCoeffsBez3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\n/**\r\n * Returns an error-free polynomial in 1 variable whose roots are the parameter\r\n * values of the self-intersection points of the given cubic bezier curve.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * the returned polynomial coefficients are exact (i.e. error-free)\r\n * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)\r\n *\r\n * @param ps a cubic bezier curve.\r\n *\r\n * @internal\r\n */\r\nfunction getCoeffsBez3Exact(ps) {\r\n    const [[a3, a2, a1], [b3, b2, b1]] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps);\r\n    const a2b3 = epr(a2, b3);\r\n    const a3b2 = epr(a3, b2);\r\n    const a3b1 = epr(a3, b1);\r\n    const a1b3 = epr(a1, b3);\r\n    const a2b1 = epr(a2, b1);\r\n    const a1b2 = epr(a1, b2);\r\n    const f4 = ediff(a2b3, a3b2);\r\n    const f5 = ediff(a1b3, a3b1);\r\n    const f6 = ediff(a2b1, a1b2);\r\n    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2\r\n    const u2 = epr(f4, f4);\r\n    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3\r\n    const u1 = epr(f4, f5);\r\n    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2\r\n    const g7 = epr(f4, f6);\r\n    const g9 = epr(f5, f5);\r\n    const u0 = fes(g7, g9);\r\n    // Solve: u2*t**2 + u1*t + u0 = 0\r\n    return [u2, u1, u0];\r\n}\r\n\r\n//# sourceMappingURL=get-coeffs-bez3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "curvature": () => (/* binding */ curvature),\n/* harmony export */   "κ": () => (/* binding */ κ)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js");\n\r\n\r\n\r\n/**\r\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\r\n * curve at a specific given parameter value `t`.\r\n *\r\n * * returns `Number.NaN` at a cusp - this can be tested for with `Number.isNaN`\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the curvature should be evaluated\r\n *\r\n * @doc mdx\r\n */\r\nfunction curvature(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\r\n    const [ddX, ddY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis_2ndDerivative)(ps);\r\n    const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(dX, t);\r\n    const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(dY, t);\r\n    const ddx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(ddX, t);\r\n    const ddy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(ddY, t);\r\n    const a = dx * ddy - dy * ddx;\r\n    const b = Math.sqrt((dx * dx + dy * dy) ** 3);\r\n    return a / b;\r\n}\r\n/**\r\n * Alias for [[κ]].\r\n *\r\n * Returns the curvature `κ` of the given linear, quadratic or cubic bezier\r\n * curve at a specific given parameter value `t`.\r\n *\r\n * * **alias**: [[curvature]]\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the curvature should be evaluated\r\n *\r\n * @doc\r\n */\r\nconst κ = curvature;\r\n\r\n//# sourceMappingURL=curvature.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/curvature.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/ds.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ds": () => (/* binding */ ds)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns `ds` (the length differential) for a linear, quadratic or cubic\r\n * bezier curve.\r\n *\r\n * * this function is curried\r\n *\r\n * @param ps an order 1, 2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value\r\n *\r\n * @internal\r\n */\r\nfunction ds(ps) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    return function (t) {\r\n        const dx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t);\r\n        const dy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t);\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=ds.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/ds.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate2ndDerivativeAt0\": () => (/* binding */ evaluate2ndDerivativeAt0)\n/* harmony export */ });\n/**\r\n * Returns the result, `[x,y]`, of evaluating the 2nd derivative of a linear,\r\n * quadratic or cubic bezier curve's power basis at `t === 0`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction evaluate2ndDerivativeAt0(ps) {\r\n    // Bitlength: If the coordinates of the control points are bit-aligned then the\r\n    // * max bitlength (incl bit shift) increase === 5 (for cubics)\r\n    // * max bitlength (incl bit shift) increase === 3 (for quadratics)\r\n    // * max bitlength (incl bit shift) increase === 0 (for lines)\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            6 * ((x2 + x0) - 2 * x1),\r\n            6 * ((y2 + y0) - 2 * y1)\r\n        ]; // max bitlength increase 5\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * ((x2 + x0) - 2 * x1),\r\n            2 * ((y2 + y0) - 2 * y1)\r\n        ]; // max bitlength increase 3\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3');\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative-at-0.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-0.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate2ndDerivativeAt1\": () => (/* binding */ evaluate2ndDerivativeAt1)\n/* harmony export */ });\n/**\r\n * Returns the result, `[x,y]`, of evaluating the 2nd derivative of a linear,\r\n * quadratic or cubic bezier curve's power basis at `t === 1`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction evaluate2ndDerivativeAt1(ps) {\r\n    // Bitlength: If the coordinates of the control points are bit-aligned then the\r\n    // * max bitlength (incl bit shift) increase === 5 (for cubics)\r\n    // * max bitlength (incl bit shift) increase === 3 (for quadratics)\r\n    // * max bitlength (incl bit shift) increase === 0 (for lines)\r\n    if (ps.length === 4) {\r\n        const [, [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * ((x3 + x1) - 2 * x2),\r\n            6 * ((y3 + y1) - 2 * y2),\r\n        ]; // max bitlength increase 5\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            2 * ((x2 + x0) - 2 * x1),\r\n            2 * ((y2 + y0) - 2 * y1), // t^0\r\n        ]; // max bitlength increase 3\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [0, 0]; // max bitlength increase 0\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3');\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative-at-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative-at-1.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluate2ndDerivative": () => (/* binding */ evaluate2ndDerivative)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns the `[x,y]` value of the twice differentiated (with respect to `t`)\r\n * bezier curve\'s power basis when evaluated at `t`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps a cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the t parameter\r\n *\r\n * @doc mdx\r\n */\r\nfunction evaluate2ndDerivative(ps, t) {\r\n    const [ddPsX, ddPsY] = (0,_to_power_basis_to_power_basis_2nd_derivative_double_to_power_basis_2nd_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_2ndDerivative)(ps);\r\n    return [\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(ddPsX, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(ddPsY, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/double/evaluate-2nd-derivative.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluate2ndDerivativeAt0Exact": () => (/* binding */ evaluate2ndDerivativeAt0Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\n/**\r\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\r\n * linear, quadratic or cubic bezier curve\'s power basis at `t === 0`.\r\n *\r\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction evaluate2ndDerivativeAt0Exact(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            sce(6, ge(ts(x2, x0), -2 * x1)),\r\n            sce(6, ge(ts(y2, y0), -2 * y1))\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\r\n            ge(ts(2 * y2, 2 * y0), -4 * y1)\r\n        ];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3\');\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative-at-0-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-0-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluate2ndDerivativeAt1Exact": () => (/* binding */ evaluate2ndDerivativeAt1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\n/**\r\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\r\n * linear, quadratic or cubic bezier curve\'s power basis at `t === 1`.\r\n *\r\n * @param ps An order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction evaluate2ndDerivativeAt1Exact(ps) {\r\n    if (ps.length === 4) {\r\n        const [, [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            sce(6, ge(ts(x3, x1), -2 * x2)),\r\n            sce(6, ge(ts(y3, y1), -2 * y2))\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\r\n            ge(ts(2 * y2, 2 * y0), -4 * y1)\r\n        ];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3\');\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative-at-1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-at-1-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluate2ndDerivativeExact": () => (/* binding */ evaluate2ndDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns the *exact* result, `[x,y]`, of evaluating the 2nd derivative of a\r\n * linear, quadratic or cubic bezier curve\'s power basis at `t`.\r\n *\r\n * @param ps a cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the t parameter\r\n *\r\n * @doc mdx\r\n */\r\nfunction evaluate2ndDerivativeExact(ps, t) {\r\n    const [ddPsX, ddPsY] = (0,_to_power_basis_to_power_basis_2nd_derivative_exact_to_power_basis_2nd_derivative_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_2ndDerivativeExact)(ps);\r\n    return [(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(ddPsX, t), (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(ddPsY, t)];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-2nd-derivative-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate-2nd-derivative/exact/evaluate-2nd-derivative-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalDeCasteljauDd": () => (/* binding */ evalDeCasteljauDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\r\n/**\r\n * Returns the resulting point (in double-double precision) of evaluating the\r\n * given bezier curve at the given parameter `t` (given as a double-double\r\n * precision floating point number).\r\n *\r\n * * uses [De Casteljau\'s algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * with intermediate calculations done in double-double precision floating point\r\n * arithmetic.\r\n *\r\n * * to get an absolute error bound on the result call [[evalDeCasteljauError]]\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated (given in\r\n * double-double precision)\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljauDd(ps, t) {\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        return ps[0].map(c => [c]);\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        return ps[ps.length - 1].map(c => [c]);\r\n    }\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const a01 = qad(qmq(td(x1, x0), t), x0);\r\n        const a11 = qad(qmq(td(x2, x1), t), x1);\r\n        const a21 = qad(qmq(td(x3, x2), t), x2);\r\n        const a02 = qaq(a01, qmq(qdq(a11, a01), t));\r\n        const a12 = qaq(a11, qmq(qdq(a21, a11), t));\r\n        const x = qaq(a02, qmq(qdq(a12, a02), t));\r\n        const b01 = qad(qmq(td(y1, y0), t), y0);\r\n        const b11 = qad(qmq(td(y2, y1), t), y1);\r\n        const b21 = qad(qmq(td(y3, y2), t), y2);\r\n        const b02 = qaq(b01, qmq(qdq(b11, b01), t));\r\n        const b12 = qaq(b11, qmq(qdq(b21, b11), t));\r\n        const y = qaq(b02, qmq(qdq(b12, b02), t));\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const a01 = qaq([0, x0], qmq(td(x1, x0), t));\r\n        const a11 = qaq([0, x1], qmq(td(x2, x1), t));\r\n        const x = qaq(a01, qmq(qdq(a11, a01), t));\r\n        const b01 = qaq([0, y0], qmq(td(y1, y0), t));\r\n        const b11 = qaq([0, y1], qmq(td(y2, y1), t));\r\n        const y = qaq(b01, qmq(qdq(b11, b01), t));\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const x = qad(qmq(td(x1, x0), t), x0);\r\n        const y = qad(qmq(td(y1, y0), t), y0);\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 1) {\r\n        const [x, y] = ps[0];\r\n        return [[0, x], [0, y]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalDeCasteljauWithErrDd": () => (/* binding */ evalDeCasteljauWithErrDd)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eval-de-casteljau-error.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js");\n/* harmony import */ var _eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eval-de-casteljau-dd.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-dd.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst evalDeCasteljauDd = _eval_de_casteljau_dd_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljauDd;\r\nconst evalDeCasteljauError = _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauError;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__["γγ"])(3);\r\n/**\r\n * Returns the resulting point (in double-double precision) of evaluating the\r\n * given bezier curve at the given parameter `t` (including a coordinate-wise\r\n * error bound).\r\n *\r\n * * uses [De Casteljau\'s algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * in double-double precision floating point arithmetic.\r\n *\r\n * The resulting point is returned as `{ p: number[][], pE: number[] }`,\r\n * where `p` is the point `[x,y]` (with `x` and `y` in double-double precision)\r\n * and `pE` is the corresponding coordinate-wise absolute error bound of the\r\n * calculation.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljauWithErrDd(ps, t) {\r\n    const p = evalDeCasteljauDd(ps, t);\r\n    const pE = evalDeCasteljauError(ps, t);\r\n    if (ps.length === 4) {\r\n        return { p, pE: pE.map(e => 2 * 9 * γγ3 * e) };\r\n    }\r\n    if (ps.length === 3) {\r\n        return { p, pE: pE.map(e => 2 * 6 * γγ3 * e) };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { p, pE: pE.map(e => 2 * 3 * γγ3 * e) };\r\n    }\r\n    if (ps.length === 1) {\r\n        return { p: [ps[0]], pE: [0, 0] };\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-with-err-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double-double/eval-de-casteljau-with-err-dd.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalDeCasteljauWithErr": () => (/* binding */ evalDeCasteljauWithErr)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eval-de-casteljau-error.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js");\n/* harmony import */ var _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst evalDeCasteljau = _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau;\r\nconst evalDeCasteljauError = _eval_de_casteljau_error_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauError;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_2__["γ"])(1);\r\n/**\r\n * Returns the resulting point of evaluating the given bezier curve at the given\r\n * parameter `t` including a coordinate-wise error bound.\r\n *\r\n * * uses [De Casteljau\'s algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * in double precision floating point arithmetic\r\n *\r\n * The resulting point is returned as `{ p: number[], pE: number[] }`,\r\n * where `p` is the point `[x,y]` and `pE` is the corresponding coordinate-wise\r\n * absolute error bound of the calculation.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljauWithErr(ps, t) {\r\n    const p = evalDeCasteljau(ps, t);\r\n    const pE = evalDeCasteljauError(ps, [0, t]);\r\n    if (ps.length === 4) {\r\n        return { p, pE: pE.map(e => 9 * γ1 * e) };\r\n    }\r\n    if (ps.length === 3) {\r\n        return { p, pE: pE.map(e => 6 * γ1 * e) };\r\n    }\r\n    if (ps.length === 2) {\r\n        return { p, pE: pE.map(e => 3 * γ1 * e) };\r\n    }\r\n    if (ps.length === 1) {\r\n        return { p: ps[0], pE: [0, 0] };\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-with-err.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau-with-err.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evalDeCasteljau\": () => (/* binding */ evalDeCasteljau)\n/* harmony export */ });\n/**\r\n * Returns the resulting point of evaluating the given bezier curve at the\r\n * given parameter `t`.\r\n *\r\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\r\n * in double precision floating point arithmetic\r\n *\r\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\r\n * double precision floating point numbers.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n **/\r\nfunction evalDeCasteljau(ps, t) {\r\n    if (t === 0) {\r\n        return ps[0];\r\n    }\r\n    else if (t === 1) {\r\n        return ps[ps.length - 1];\r\n    }\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const a01 = x0 + (x1 - x0) * t;\r\n        const a11 = x1 + (x2 - x1) * t;\r\n        const a21 = x2 + (x3 - x2) * t;\r\n        const a02 = a01 + (a11 - a01) * t;\r\n        const a12 = a11 + (a21 - a11) * t;\r\n        const x = a02 + (a12 - a02) * t;\r\n        const b01 = y0 + (y1 - y0) * t;\r\n        const b11 = y1 + (y2 - y1) * t;\r\n        const b21 = y2 + (y3 - y2) * t;\r\n        const b02 = b01 + (b11 - b01) * t;\r\n        const b12 = b11 + (b21 - b11) * t;\r\n        const y = b02 + (b12 - b02) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const a01 = x0 + (x1 - x0) * t;\r\n        const a11 = x1 + (x2 - x1) * t;\r\n        const x = a01 + (a11 - a01) * t;\r\n        const b01 = y0 + (y1 - y0) * t;\r\n        const b11 = y1 + (y2 - y1) * t;\r\n        const y = b01 + (b11 - b01) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const x = x0 + (x1 - x0) * t;\r\n        const y = y0 + (y1 - y0) * t;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 1) {\r\n        return ps[0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluate": () => (/* binding */ evaluate)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/double/to-power-basis.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns the resulting point of evaluating the given bezier curve at the\r\n * given parameter `t`.\r\n *\r\n * * uses power bases conversion and subsequently [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n * to evaluate the polynomial in double precision floating point arithmetic.\r\n *\r\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\r\n * double precision floating point numbers.\r\n *\r\n * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated\r\n *\r\n * @doc mdx\r\n */\r\nfunction evaluate(ps, t) {\r\n    const len = ps.length;\r\n    if (t === 0) {\r\n        return ps[0];\r\n    }\r\n    if (t === 1) {\r\n        return ps[len - 1];\r\n    }\r\n    const [X, Y] = (0,_to_power_basis_to_power_basis_double_to_power_basis_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\r\n    return [\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(X, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(Y, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=evaluate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/evaluate.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evalDeCasteljauError\": () => (/* binding */ evalDeCasteljauError)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when evaluating the given bezier curve at the parameter `t`\r\n * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm).\r\n *\r\n * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (2*γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n * The `T` in the error counter formula is the input error given as an error\r\n * counter on `t`. For example, if the exact `t` (let's call it `te`) is bounded\r\n * by `(|t| - 5u) < |te| < (|t| + 5u)` where `u === Number.EPSILON/2` then `T`\r\n * should be given as `5`. If `t` is exact then `T` is zero.\r\n *\r\n * ```\r\n * // for cubic bezier curves\r\n * return [\r\n * \tx_,  // <E> === 3T + 9\r\n * \ty_   // <E> === 3T + 9\r\n * ];\r\n * // for quadratic bezier curves\r\n * return [\r\n * \tx_,  // <E> === 2T + 6\r\n * \ty_   // <E> === 2T + 6\r\n * ];\r\n * // for linear bezier curves (i.e. lines)\r\n * return [\r\n * \tx_,  // <E> === T + 3\r\n * \ty_   // <E> === T + 3\r\n * ];\r\n * ```\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the bezier should be evaluated (given in\r\n * double-double precision)\r\n *\r\n * @example\r\n * ```typescript\r\n * const ps = [[1.1,1.1],[2.3,2.3],[0.7,2.1],[3.11,-1.27]];  // some cubic bezier curve\r\n * const t = [0,0.1];  // some `t` in double-double precision, i.e. `t` equals `0.1`\r\n * const r = evalDeCasteljau(ps, t[1]) //=> [1.3828099999999999, 1.41623]\r\n * let error = evalDeCasteljauError(ps,t); //=> [2.32521, 2.3695700000000004]\r\n * const γ1 = 1*(Number.EPSILON)/(1-1*(Number.EPSILON));  // this is the error constant for double precision\r\n * error = error.map(c => γ1*c); //=> [5.163003358177322e-16, 5.261502344922066e-16]\r\n * // so, for instance, the *real* x coordinate of the point, i.e. `r[0]`, is somewhere between\r\n * // `1.3828099999999999 - 5.163003358177322e-16` and `1.3828099999999999 + 5.163003358177322e-16`, i.e.\r\n * // `1.3828099999999994 < r[0] < 1.3828100000000003`\r\n * ```\r\n *\r\n * @internal\r\n **/\r\nfunction evalDeCasteljauError(ps, t) {\r\n    if (t[0] === 0 && t[1] === 0) {\r\n        return [0, 0]; // No error\r\n    }\r\n    else if (t[0] === 0 && t[1] === 1) {\r\n        return [0, 0]; // No error\r\n    }\r\n    const t_ = abs(t[1]); // <T>\r\n    // <M> --\x3e the cost of multiplication === <1> except for `qmq` in which\r\n    // case it is <2>. One might as well just double the error in the end for\r\n    // double-double precision calculations (thus losing 1 bit) and take \r\n    // <M> === 1 always. This simplifies the calculation a bit.\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        const _x0 = abs(x0); // <0>\r\n        const _y0 = abs(y0); // <0>\r\n        const _x1 = abs(x1); // <0>\r\n        const _y1 = abs(y1); // <0>\r\n        const _x2 = abs(x2); // <0>\r\n        const _y2 = abs(y2); // <0>\r\n        const _x3 = abs(x3); // <0>\r\n        const _y3 = abs(y3); // <0>\r\n        // a01<T+3> <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const a01_ = _x0 + (_x1 + _x0) * t_;\r\n        // a11<T+3> <-- <T+3>(x1 + <1>(<0>(x2 + x1)*<T>t));\r\n        const a11_ = _x1 + (_x2 + _x1) * t_;\r\n        // a21<T+3> <-- <T+3>(x2 + <1>(<0>(x3 + x2)*<T>t));\r\n        const a21_ = _x2 + (_x3 + _x2) * t_;\r\n        // a02<2T+6> <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\r\n        const a02_ = a01_ + (a11_ + a01_) * t_;\r\n        // a12<2T+6> <-- <2T+6>(<T+3>a11 + <2T+5>(<T+4>(<T+3>a21 + <T+3>a11)*<T>t));\r\n        const a12_ = a11_ + (a21_ + a11_) * t_;\r\n        // x<3T+9> <-- <3T+9>(<2T+6>a02 + <3T+8>(<2T+7>(<2T+6>a12 + <2T+6>a02)*<T>t));\r\n        const x_ = a02_ + (a12_ + a02_) * t_;\r\n        const b01_ = _y0 + (_y1 + _y0) * t_;\r\n        const b11_ = _y1 + (_y2 + _y1) * t_;\r\n        const b21_ = _y2 + (_y3 + _y2) * t_;\r\n        const b02_ = b01_ + (b11_ + b01_) * t_;\r\n        const b12_ = b11_ + (b21_ + b11_) * t_;\r\n        const y_ = b02_ + (b12_ + b02_) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        const _x0 = abs(x0);\r\n        const _y0 = abs(y0);\r\n        const _x1 = abs(x1);\r\n        const _y1 = abs(y1);\r\n        const _x2 = abs(x2);\r\n        const _y2 = abs(y2);\r\n        // <T+3>a01 <-- <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const a01_ = _x0 + (_x1 + _x0) * t_;\r\n        // <T+3>a11 <-- <T+3>(x1 + <T+2>(<1>(x2 + x1)*<T>t));\r\n        const a11_ = _x1 + (_x2 + _x1) * t_;\r\n        // <2T+6>x <-- <2T+6>(<T+3>a01 + <2T+5>(<T+4>(<T+3>a11 + <T+3>a01)*<T>t));\r\n        const x_ = a01_ + (a11_ + a01_) * t_;\r\n        const b01_ = _y0 + (_y1 + _y0) * t_;\r\n        const b11_ = _y1 + (_y2 + _y1) * t_;\r\n        const y_ = b01_ + (b11_ + b01_) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        const _x0 = abs(x0);\r\n        const _y0 = abs(y0);\r\n        const _x1 = abs(x1);\r\n        const _y1 = abs(y1);\r\n        // <T+3>x = <T+3>(x0 + <T+2>(<1>(x1 + x0)*<T>t));\r\n        const x_ = _x0 + (_x1 + _x0) * t_;\r\n        const y_ = _y0 + (_y1 + _y0) * t_;\r\n        return [x_, y_];\r\n    }\r\n    if (ps.length === 1) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=eval-de-casteljau-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/eval-de-casteljau-error.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateExact": () => (/* binding */ evaluateExact)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns the *exact* resulting point of evaluating the given bezier curve at\r\n * the given `t` parameter.\r\n *\r\n * * the result is returned as `[x,y]`, where `x` and `y` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t\r\n *\r\n * @doc mdx\r\n */\r\nfunction evaluateExact(ps, t) {\r\n    if (t === 0) {\r\n        return [[ps[0][0]], [ps[0][1]]];\r\n    }\r\n    if (t === 1) {\r\n        return [[ps[ps.length - 1][0]], [ps[ps.length - 1][1]]];\r\n    }\r\n    const [X, Y] = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasisExact)(ps);\r\n    return [\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(X, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.eHorner)(Y, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/exact/evaluate-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "normal": () => (/* binding */ normal)\n/* harmony export */ });\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns a normal vector (not necessarily of unit length) of a bezier curve\r\n * at a specific given parameter value `t` by simply taking the `tangent` at\r\n * that point and rotating it by 90 degrees.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps a linear, quadratic or cubic bezier curve given by its ordered\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the parameter value where the normal should be evaluated\r\n *\r\n * @doc mdx\r\n */\r\nfunction normal(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n    return [\r\n        -(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dY, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(dX, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=normal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/normal/normal.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tangentAt0\": () => (/* binding */ tangentAt0)\n/* harmony export */ });\n/**\r\n * Returns the tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at `t === 0`, i.e.\r\n * returns the result, `[x,y]`, of evaluating the derivative of a linear,\r\n * quadratic or cubic bezier curve's power basis at `t === 0`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction tangentAt0(ps) {\r\n    // Bitlength: If the coordinates of the control points are grid-aligned then\r\n    // * max bitlength (incl bit shift) increase === 3 (for cubics)\r\n    // * max bitlength (incl bit shift) increase === 2 (for quadratics)\r\n    // * max bitlength (incl bit shift) increase === 1 (for lines)\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            3 * (x1 - x0),\r\n            3 * (y1 - y0)\r\n        ]; // max bitlength increase 3\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            2 * (x1 - x0),\r\n            2 * (y1 - y0),\r\n        ]; // max bitlength increase 2\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0,\r\n        ]; // max bitlength increase 1\r\n    }\r\n    if (ps.length === 1) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=tangent-at-0.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-0.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tangentAt1\": () => (/* binding */ tangentAt1)\n/* harmony export */ });\n/**\r\n * Returns the tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at `t === 1`, i.e.\r\n * Returns the result, `[x,y]`, of evaluating the derivative of a linear,\r\n * quadratic or cubic bezier curve's power basis at `t === 1`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction tangentAt1(ps) {\r\n    // Bitlength: If the coordinates of the control points are grid-aligned then\r\n    // * max bitlength (incl bit shift) increase === 3 (for cubics)\r\n    // * max bitlength (incl bit shift) increase === 2 (for quadratics)\r\n    // * max bitlength (incl bit shift) increase === 1 (for lines)\r\n    if (ps.length === 4) {\r\n        const [x2, y2] = ps[2];\r\n        const [x3, y3] = ps[3];\r\n        return [\r\n            3 * (x3 - x2),\r\n            3 * (y3 - y2),\r\n        ]; // max bitlength increase 3\r\n    }\r\n    if (ps.length === 3) {\r\n        const [x1, y1] = ps[1];\r\n        const [x2, y2] = ps[2];\r\n        return [\r\n            2 * (x2 - x1),\r\n            2 * (y2 - y1),\r\n        ]; // max bitlength increase 2\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            x1 - x0,\r\n            y1 - y0\r\n        ]; // max bitlength increase 1\r\n    }\r\n    if (ps.length === 1) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=tangent-at-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent-at-1.js?")},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tangent": () => (/* binding */ tangent)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js");\n\r\n\r\n/**\r\n * Returns the tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at a specific given parameter value `t`, i.e.\r\n * returns the `[x,y]` value of the once differentiated (with respect to `t`)\r\n * bezier curve\'s power basis when evaluated at `t`.\r\n *\r\n * * uses double precision calculations internally\r\n *\r\n * @param ps a linear, quadratic or cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the t parameter\r\n *\r\n * @doc mdx\r\n */\r\nfunction tangent(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_double_to_power_basis_1st_derivative_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivative)(ps);\r\n    return [\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(dX, t),\r\n        (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.Horner)(dY, t)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=tangent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/double/tangent.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tangentAt0Exact": () => (/* binding */ tangentAt0Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\n/**\r\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at `t === 0`, i.e.\r\n * returns the result, `[x,y]`, of evaluating the derivative of a linear,\r\n * quadratic or cubic bezier curve\'s power basis at `t === 0`.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction tangentAt0Exact(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            sce(3, td(x1, x0)),\r\n            sce(3, td(y1, y0))\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            td(2 * x1, 2 * x0),\r\n            td(2 * y1, 2 * y0),\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            td(x1, x0),\r\n            td(y1, y0),\r\n        ];\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=tangent-at-0-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-0-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tangentAt1Exact": () => (/* binding */ tangentAt1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\n/**\r\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at `t === 1`, i.e.\r\n * returns the exact result (`[x,y]`) of evaluating the derivative of a linear,\r\n * quadratic or cubic bezier curve\'s power basis at `t === 1`.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction tangentAt1Exact(ps) {\r\n    if (ps.length === 4) {\r\n        const [x2, y2] = ps[2];\r\n        const [x3, y3] = ps[3];\r\n        return [\r\n            sce(3, td(x3, x2)),\r\n            sce(3, td(y3, y2))\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [x1, y1] = ps[1];\r\n        const [x2, y2] = ps[2];\r\n        return [\r\n            td(2 * x2, 2 * x1),\r\n            td(2 * y2, 2 * y1),\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            td(x1, x0),\r\n            td(y1, y0),\r\n        ];\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=tangent-at-1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-at-1-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tangentExact": () => (/* binding */ tangentExact)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js");\n\r\n\r\n/**\r\n * Returns the *exact* tangent vector (not necessarily of unit length) of an\r\n * order 0,1,2 or 3 bezier curve at a specific parameter `t`, i.e.\r\n * returns the `[x,y]` value of the once differentiated (with respect to `t`)\r\n * bezier curve\'s power basis when evaluated at `t`.\r\n *\r\n * @param ps a linear, quadratic or cubic bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param t the t parameter\r\n *\r\n * @doc\r\n */\r\nfunction tangentExact(ps, t) {\r\n    const [dX, dY] = (0,_to_power_basis_to_power_basis_1st_derivative_exact_to_power_basis_1st_derivative_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis_1stDerivativeExact)(ps);\r\n    return [(0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.eHorner)(dX, t), (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.eHorner)(dY, t)];\r\n}\r\n\r\n//# sourceMappingURL=tangent-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-at-t/tangent/exact/tangent-exact.js?')},"./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getTAtLength": () => (/* binding */ getTAtLength)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global-properties/length/length.js */ "./node_modules/flo-bezier3/node/global-properties/length/length.js");\n\r\n\r\n/**\r\n * Returns the `t` parameter value where the given bezier curve reaches the\r\n * given length `s` starting from `t = 0` and clipping at `t = 1.125`.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param s the length\r\n *\r\n * @doc mdx\r\n */\r\nfunction getTAtLength(ps, s) {\r\n    if (s === 0) {\r\n        return 0;\r\n    }\r\n    const lenAtT = (t) => (0,_global_properties_length_length_js__WEBPACK_IMPORTED_MODULE_1__.length)([0, t], ps);\r\n    return (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.brent)(t => (lenAtT(t) - s), 0, 1.125);\r\n}\r\n\r\n//# sourceMappingURL=get-t-at-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-to-t/get-t-at-length.js?')},"./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "tFromXY": () => (/* binding */ tFromXY)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/exact/to-power-basis-exact.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../to-power-basis/to-power-basis/double-double/to-power-basis-dd.js */ "./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js");\n\r\n\r\n\r\n\r\n\r\n\r\nconst twoDiff = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.twoDiff;\r\nconst { min, max } = Math;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γγ"])(3);\r\n/**\r\n * Performs certified inversion, i.e. returns the `t` parameter value\r\n * interval(s) for the given `x` and `y` coordinates on the specified bezier\r\n * curve.\r\n *\r\n * * Only `t` values in `[0,1]` are returned.\r\n *\r\n * * see also [[closestPointOnBezier]] and [[closestPointOnBezierCertified]]\r\n *\r\n * **precondition**: `p` must be *exactly* on the curve for the result to be\r\n * certified\r\n *\r\n * * **certified** here means no `t` value can be missed but (in rare cases)\r\n * an extra 1 or 2 `t`s could be returned (e.g. for self-overlapping curves\r\n * and when the point is exactly on the point of self-intersection of the curve)\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\nfunction tFromXY(ps, p) {\r\n    if (ps.length === 4) {\r\n        return tFromXY3(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return tFromXY2(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return tFromXY1(ps, p);\r\n    }\r\n    if (ps.length === 1) {\r\n        const p1 = ps[0];\r\n        if (p1[0] === p[0] && p1[1] === p[1]) {\r\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\r\n        }\r\n        return [];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction tFromXY3(ps, p) {\r\n    const x = p[0];\r\n    const y = p[1];\r\n    // get power basis representation in double-double precision including error\r\n    // bound\r\n    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis3DdWithRunningError)(ps);\r\n    // pop the constant term off `x(t)`\r\n    const txDd = _polyDdX.pop()[1];\r\n    // subtract the x coordinate of the point\r\n    const polyDdX = [..._polyDdX, twoDiff(txDd, x)];\r\n    // pop the constant term off `y(t)`\r\n    const tyDd = _polyDdY.pop()[1];\r\n    // subtract the y coordinate of the point\r\n    const polyDdY = [..._polyDdY, twoDiff(tyDd, y)];\r\n    let pExactXY = undefined;\r\n    const getPExactX = () => {\r\n        if (pExactXY === undefined) {\r\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps);\r\n        }\r\n        const _pExactX = pExactXY[0].slice(); // x coordinate\r\n        // pop the constant term off `x(t)`\r\n        const tx = _pExactX.pop();\r\n        const pExactX = [..._pExactX, twoDiff(tx[0], x)];\r\n        return pExactX;\r\n    };\r\n    const getPExactY = () => {\r\n        if (pExactXY === undefined) {\r\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis3Exact)(ps);\r\n        }\r\n        const _pExactY = pExactXY[1].slice(); // y coordinate\r\n        // pop the constant term off `y(t)`\r\n        const ty = _pExactY.pop();\r\n        const pExactY = [..._pExactY, twoDiff(ty[0], y)];\r\n        return pExactY;\r\n    };\r\n    // max 3 roots\r\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyDdX, 0, 1, polyX_.map(c => γγ3 * c), getPExactX, true);\r\n    // const xrsExp = xrs!.map(xr => refineK1(xr, getPExactX()));\r\n    // max 3 roots\r\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyDdY, 0, 1, polyY_.map(c => γγ3 * c), getPExactY, true);\r\n    if (xrs === undefined) {\r\n        // the `x` value of the point is on the curve for all `t` values\r\n        // the curve must be a \'line\' (can also be degenerate quadratic, etc.)\r\n        if (yrs === undefined) {\r\n            // the `y` value of the point is on the curve for all `t` values\r\n            // the curve must be a point\r\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\r\n        }\r\n        return yrs; //.map(r => [r.tS, r.tE]);\r\n    }\r\n    if (yrs === undefined) {\r\n        // the `y` value of the point is on the curve for all `t` values\r\n        // the curve must be a \'line\' (can also be degenerate quadratic, etc.)        \r\n        return xrs;\r\n    }\r\n    // check for `t` value overlap \r\n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (at point of \r\n    // self-intersection), 3 overlaps (for self-overlapping curve (that looks \r\n    // like a line))\r\n    // at this point `xrs !== undefined` and `yrs !== undefined`\r\n    let ris = [];\r\n    for (let i = 0; i < xrs.length; i++) {\r\n        let xr = xrs[i];\r\n        for (let j = 0; j < yrs.length; j++) {\r\n            let yr = yrs[j];\r\n            let r = combineRoots(xr, yr);\r\n            if (r !== undefined) {\r\n                ris.push(r);\r\n            }\r\n        }\r\n    }\r\n    return ris;\r\n}\r\n/** @internal */\r\nfunction tFromXY2(ps, p) {\r\n    const x = p[0];\r\n    const y = p[1];\r\n    // get power basis representation in double-double precision including error\r\n    // bound\r\n    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.toPowerBasis2DdWithRunningError)(ps);\r\n    // pop the constant term off `x(t)`\r\n    const txDd = _polyDdX.pop()[1];\r\n    // subtract the x coordinate of the point\r\n    const polyDdX = [..._polyDdX, twoDiff(txDd, x)];\r\n    // pop the constant term off `y(t)`\r\n    const tyDd = _polyDdY.pop()[1];\r\n    // subtract the y coordinate of the point\r\n    const polyDdY = [..._polyDdY, twoDiff(tyDd, y)];\r\n    let pExactXY = undefined;\r\n    const getPExactX = () => {\r\n        if (pExactXY === undefined) {\r\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps);\r\n        }\r\n        const _pExactX = pExactXY[0]; // x coordinate\r\n        // pop the constant term off `x(t)`\r\n        const tx = _pExactX.pop()[0];\r\n        const pExactX = [..._pExactX, twoDiff(tx, x)];\r\n        return pExactX;\r\n    };\r\n    const getPExactY = () => {\r\n        if (pExactXY === undefined) {\r\n            pExactXY = (0,_to_power_basis_to_power_basis_exact_to_power_basis_exact_js__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis2Exact)(ps);\r\n        }\r\n        const _pExactY = pExactXY[1]; // y coordinate\r\n        // pop the constant term off `y(t)`\r\n        const ty = _pExactY.pop()[0];\r\n        const pExactY = [..._pExactY, twoDiff(ty, y)];\r\n        return pExactY;\r\n    };\r\n    // max 2 roots\r\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyDdX, 0, 1, polyX_.map(c => γγ3 * c), getPExactX, true);\r\n    // max 2 roots\r\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyDdY, 0, 1, polyY_.map(c => γγ3 * c), getPExactY, true);\r\n    if (xrs === undefined) {\r\n        // the `x` value of the point is on the curve for all `t` values\r\n        // the curve must be a \'line\'\r\n        if (yrs === undefined) {\r\n            // the `y` value of the point is on the curve for all `t` values\r\n            // the curve must be a point\r\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\r\n        }\r\n        return yrs;\r\n    }\r\n    if (yrs === undefined) {\r\n        // the `y` value of the point is on the curve for all `t` values\r\n        // the curve must be a \'line\'\r\n        return xrs;\r\n    }\r\n    // check for `t` value overlap \r\n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for \r\n    // self-overlapping curve (that looks like a line))\r\n    // at this point `xrs !== undefined` and `yrs !== undefined`\r\n    let ris = [];\r\n    for (let i = 0; i < xrs.length; i++) {\r\n        let xr = xrs[i];\r\n        for (let j = 0; j < yrs.length; j++) {\r\n            let yr = yrs[j];\r\n            let r = combineRoots(xr, yr);\r\n            if (r !== undefined) {\r\n                ris.push(r);\r\n            }\r\n        }\r\n    }\r\n    return ris;\r\n}\r\n/** @internal */\r\nfunction tFromXY1(ps, p) {\r\n    const x = p[0];\r\n    const y = p[1];\r\n    // get power basis representation in double-double precision including error\r\n    // bound\r\n    const [_polyDdX, _polyDdY] = (0,_to_power_basis_to_power_basis_double_double_to_power_basis_dd_js__WEBPACK_IMPORTED_MODULE_5__.toPowerBasis1Dd)(ps);\r\n    // pop the constant term off `x(t)`\r\n    const txDd = _polyDdX.pop()[1];\r\n    // subtract the x coordinate of the point\r\n    const polyExactX = [..._polyDdX, twoDiff(txDd, x)];\r\n    // pop the constant term off `y(t)`\r\n    const tyDd = _polyDdY.pop()[1];\r\n    // subtract the y coordinate of the point\r\n    const polyExactY = [..._polyDdY, twoDiff(tyDd, y)];\r\n    // max 1 roots\r\n    const xrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyExactX, 0, 1, undefined, undefined, true);\r\n    // max 1 roots\r\n    const yrs = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(polyExactY, 0, 1, undefined, undefined, true);\r\n    if (xrs === undefined) {\r\n        // the `x` value of the point is on the curve for all `t` values\r\n        // the curve must be a vertical line\r\n        if (yrs === undefined) {\r\n            // the `y` value of the point is on the curve for all `t` values\r\n            // the curve must be a point\r\n            return [{ tS: 0.5, tE: 0.5, multiplicity: 1 }];\r\n        }\r\n        return yrs;\r\n    }\r\n    if (yrs === undefined) {\r\n        // the `y` value of the point is on the curve for all `t` values\r\n        // the curve must be horizontal line\r\n        return xrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));\r\n    }\r\n    // check for `t` value overlap \r\n    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for \r\n    // self-overlapping curve (that looks like a line))\r\n    // at this point `xrs !== undefined` and `yrs !== undefined`\r\n    if (xrs.length === 0 || yrs.length === 0) {\r\n        return [];\r\n    }\r\n    // at this point `xrs.length === 1` and `yrs.length === 1`\r\n    const r = combineRoots(xrs[0], yrs[0]);\r\n    if (r === undefined) {\r\n        return [];\r\n    }\r\n    return [r];\r\n}\r\n/** @internal */\r\nfunction combineRoots(r, s) {\r\n    // case 1\r\n    if (r.tS <= s.tS) {\r\n        if (r.tE < s.tS) {\r\n            return undefined; // no overlap\r\n        }\r\n        return { tS: s.tS, tE: max(r.tE, s.tE), multiplicity: min(r.multiplicity, s.multiplicity) };\r\n    }\r\n    // case 2 - r.tS > s.tS\r\n    if (s.tE < r.tS) {\r\n        return undefined; // no overlap\r\n    }\r\n    return { tS: r.tS, tE: max(r.tE, s.tE), multiplicity: min(r.multiplicity, s.multiplicity) };\r\n}\r\n\r\n//# sourceMappingURL=t-from-xy.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/local-properties-to-t/t-from-xy.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "closestPointOnBezierCertified": () => (/* binding */ closestPointOnBezierCertified)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-3-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-2-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js");\n/* harmony import */ var _get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double-double/get-footpoint-poly-1-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-3-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-2-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js");\n/* harmony import */ var _get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-coeffs/exact/get-footpoint-poly-1-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js");\n/* harmony import */ var _get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-coeffs/get-closest-on-bezier-from-point-error-counters.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../global-properties/bounds/get-interval-box/get-interval-box.js */ "./node_modules/flo-bezier3/node/global-properties/bounds/get-interval-box/get-interval-box.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../intersection/bezier-bezier-intersection/x.js */ "./node_modules/flo-bezier3/node/intersection/bezier-bezier-intersection/x.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eEstimate;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_10__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eMult;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_10__.eAdd;\r\nconst eps = Number.EPSILON;\r\nconst { sqrt } = Math;\r\nconst γγ6 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_9__["γγ"])(6);\r\n/**\r\n * Returns the closest point(s) (and parameter `t` value(s)) on the given\r\n * bezier curve to the given point (with `t ∈ [0,1]`).\r\n *\r\n * * guaranteed accurate to within `4*Number.EPSILON` in the returned `t`\r\n * value(s)\r\n * * in some cases there can be more than one closest point, e.g. on the axis\r\n * of symmetry of a parabola\r\n * * the returned point(s) are objects with the following properties:\r\n *     * `p`: the best estimate point on the bezier curve (calculated from the root interval `ri`)\r\n *     * `t`: the best estimate `t` parameter value (calculated from the root interval `ri`)\r\n *     * `d`: the best estimate closest distance from the point to the bezier curve (calculated from the root interval `ri`)\r\n *     * `ri`: a root interval guaranteed to contain the actual `t` value\r\n *     * `box`: a small box guaranteed to contain the relevant point on the bezier curve\r\n *     * `dSquaredI`: a small squared distance interval guaranteed to contain the actual distance squared\r\n *        between the point and the bezier curve\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @doc\r\n */\r\nfunction closestPointOnBezierCertified(ps, p) {\r\n    const order = ps.length - 1;\r\n    let ris;\r\n    if (order === 3) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier3FromPointErrorCounters)(ps, p).map(e => 10 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_3__.getFootpointPoly3Exact)(ps, p));\r\n    }\r\n    else if (order === 2) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier2FromPointErrorCounters)(ps, p).map(e => 8 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_4__.getFootpointPoly2Exact)(ps, p));\r\n    }\r\n    else if (order === 1) {\r\n        // keep TypeScript happy; `ris` cannot be `undefined` here\r\n        ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.allRootsCertified)((0,_get_coeffs_double_double_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1Dd)(ps, p), 0, 1, (0,_get_coeffs_get_closest_on_bezier_from_point_error_counters_js__WEBPACK_IMPORTED_MODULE_6__.getClosestOnBezier1FromPointErrorCounters)(ps, p).map(e => 6 * γγ6 * e), () => (0,_get_coeffs_exact_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_5__.getFootpointPoly1Exact)(ps, p));\r\n    }\r\n    else if (order === 0) {\r\n        return [];\r\n    }\r\n    else {\r\n        throw new Error(\'The given bezier curve must be of order <= 3\');\r\n    }\r\n    ris.push({ tS: 0, tE: 0, multiplicity: 1 });\r\n    ris.push({ tS: 1, tE: 1, multiplicity: 1 });\r\n    const infos = ris.map(ri => {\r\n        const box = (0,_global_properties_bounds_get_interval_box_get_interval_box_js__WEBPACK_IMPORTED_MODULE_8__.getIntervalBox)(ps, [ri.tS, ri.tE]);\r\n        const dSquaredI = rootIntervalToDistanceSquaredInterval(box, p);\r\n        return {\r\n            p: (0,_intersection_bezier_bezier_intersection_x_js__WEBPACK_IMPORTED_MODULE_11__.getPFromBox)(box),\r\n            t: (0,flo_poly__WEBPACK_IMPORTED_MODULE_7__.mid)(ri),\r\n            d: (sqrt(dSquaredI[0]) + sqrt(dSquaredI[1])) / 2,\r\n            dSquaredI,\r\n            box,\r\n            ri\r\n        };\r\n    });\r\n    /** the minimum max interval value */\r\n    let minMax = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < infos.length; i++) {\r\n        const diMax = infos[i].dSquaredI[1];\r\n        if (diMax < minMax) {\r\n            minMax = diMax;\r\n        }\r\n    }\r\n    const closestPointInfos = [];\r\n    for (let i = 0; i < infos.length; i++) {\r\n        const info = infos[i];\r\n        if (info.dSquaredI[0] <= minMax) {\r\n            closestPointInfos.push(info);\r\n        }\r\n    }\r\n    return closestPointInfos;\r\n}\r\n/**\r\n * Returns the distance interval squared given the root interval (currently\r\n * ignoring multiplicity)\r\n *\r\n * @param box\r\n * @param p\r\n *\r\n * @internal\r\n */\r\nfunction rootIntervalToDistanceSquaredInterval(box, p) {\r\n    const bl = box[0];\r\n    const tr = box[1];\r\n    const minX = bl[0];\r\n    const minY = bl[1];\r\n    const maxX = tr[0];\r\n    const maxY = tr[1];\r\n    const x = p[0]; // <0>\r\n    const y = p[1]; // <0>\r\n    let minDSquared = Number.POSITIVE_INFINITY;\r\n    let maxDSquared = Number.NEGATIVE_INFINITY;\r\n    // for each corner of the interval box\r\n    for (const [a, b] of [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]) {\r\n        /*\r\n        // distance to 1st corner of interval box - `distance² = x² + y²`\r\n        const dc1 = (a - x)**2 + (b - y)**2;\r\n        // max absolute roundoff error of `dc1`\r\n        // <4>dc1 <-- <4>(<3>(<1>(a - x)**2) + <3>(<1>((b - y)**2))\r\n        const dc1E = 4*γ1*((a + x)**2 + (b + y)**2);\r\n        const dc1Min = dc1 - dc1E;  // distance minus max error\r\n        const dc1Max = dc1 + dc1E;  // distance plus max error\r\n        */\r\n        /** distance to 1st corner of interval box - `distance² = x² + y²` */\r\n        const ax = td(a, x);\r\n        const by = td(b, y);\r\n        const dc1Exact = eadd(emult(ax, ax), emult(by, by));\r\n        const dc1 = estimate(dc1Exact);\r\n        const dc1Min = dc1 * (1 - eps); // distance minus max error\r\n        const dc1Max = dc1 * (1 + eps); // distance plus max error\r\n        if (dc1Min <= minDSquared) {\r\n            minDSquared = dc1Min;\r\n        }\r\n        if (dc1Max >= maxDSquared) {\r\n            maxDSquared = dc1Max;\r\n        }\r\n    }\r\n    return [minDSquared, maxDSquared];\r\n}\r\n\r\n/**\r\n * Returns the closest point on the bezier to the given point - returns the point\r\n * and the t value.\r\n *\r\n * * this function also acts as an excellent inversion formula.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\n/*\r\n function closestPointOnBezierPrecise(\r\n        ps: number[][],\r\n        p: number[]): {\r\n            p: number[];\r\n            t: number;\r\n        } {\r\n\r\n    const polyE = getFootpointPolyExact(ps, p);\r\n    const polyDd = polyE.map(eToDd);\r\n    const polyErr = polyE.map((c,i) => Math.abs(eEstimate(eDiff(c,polyDd[i]))));\r\n    function getPExact() { return polyE; }\r\n\r\n    let ts = allRootsCertified(\r\n        polyDd,\r\n        0, 1,\r\n        polyErr,\r\n        getPExact\r\n    ).map(mid);\r\n\r\n    ts.push(0);\r\n    ts.push(1);\r\n\r\n    let ps_ = ts.map(t => ({ p: evaluateExact(ps, t).map(eEstimate), t }));\r\n\r\n    // Get point with minimum distance\r\n    let minD = Number.POSITIVE_INFINITY;\r\n    let minT: { p: number[], t: number } | undefined = undefined;\r\n    ps_.forEach(p_ => {\r\n        let d = squaredDistanceBetween(p_.p, p);\r\n        if (d < minD) {\r\n            minD = d;\r\n            minT = p_;\r\n        }\r\n    });\r\n\r\n    return minT!;\r\n}\r\n*/ \r\n//# sourceMappingURL=closest-point-on-bezier-certified.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier-certified.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "closestPointOnBezier": () => (/* binding */ closestPointOnBezier)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-3.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-2.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-1.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n\r\n\r\n\r\n\r\n\r\n\r\nconst sqrt = Math.sqrt;\r\n/**\r\n * Returns the closest point(s) (and parameter `t` value(s)) on the given\r\n * bezier curve to the given point (with `t ∈ [0,1]`).\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * in some cases there can be more than one closest point, e.g. on the axis\r\n * of symmetry of a parabola (in which case only one of the points are returned)\r\n * * the returned point(s) are objects with the following properties:\r\n *     * `p`: the closest point on the bezier curve\r\n *     * `t`: the parameter value of the point on the bezier curve\r\n *     * `d`: the closest distance between the point and the bezier curve\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction closestPointOnBezier(ps, p) {\r\n    let poly;\r\n    if (ps.length === 4) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3)(ps, p);\r\n    }\r\n    else if (ps.length === 3) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\r\n    }\r\n    else if (ps.length === 2) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1)(ps, p);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return { p: ps[0], t: 0, d: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.distanceBetween)(ps[0], p) };\r\n    }\r\n    else {\r\n        throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n    }\r\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRoots)(poly, 0, 1);\r\n    ts.push(0);\r\n    ts.push(1);\r\n    // Get point with minimum distance\r\n    let minDSquared = Number.POSITIVE_INFINITY;\r\n    let minP = undefined;\r\n    for (const t of ts) {\r\n        const p_ = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljau)(ps, t);\r\n        const dSquared = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.squaredDistanceBetween)(p_, p);\r\n        if (dSquared < minDSquared) {\r\n            minDSquared = dSquared;\r\n            minP = { p: p_, t, d: sqrt(dSquared) };\r\n        }\r\n    }\r\n    // keep TypeScript happy; `minP` cannot be `undefined` here\r\n    return minP;\r\n}\r\n\r\n//# sourceMappingURL=closest-point-on-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "furthestPointOnBezier": () => (/* binding */ furthestPointOnBezier)\n/* harmony export */ });\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-3.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-2.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js");\n/* harmony import */ var _get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-coeffs/double/get-footpoint-poly-1.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n\r\n\r\n\r\n\r\n\r\n\r\nconst sqrt = Math.sqrt;\r\n/**\r\n * Returns the furthest point(s) (and parameter `t` value(s)) on the given\r\n * bezier curve to the given point (with `t ∈ [0,1]`).\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * in some cases there can be more than one furthest point, e.g. on parts of\r\n * the axis of symmetry of a parabola (in which case only one of the points are returned)\r\n * * the returned point(s) are objects with the following properties:\r\n *     * `p`: the furthest point on the bezier curve\r\n *     * `t`: the parameter value of the point on the bezier curve\r\n *     * `d`: the furthest distance between the point and the bezier curve\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction furthestPointOnBezier(ps, p) {\r\n    let poly;\r\n    if (ps.length === 4) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly3)(ps, p);\r\n    }\r\n    else if (ps.length === 3) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\r\n    }\r\n    else if (ps.length === 2) {\r\n        poly = (0,_get_coeffs_double_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly1)(ps, p);\r\n    }\r\n    else if (ps.length === 1) {\r\n        return { p: ps[0], t: 0, d: (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.distanceBetween)(ps[0], p) };\r\n    }\r\n    else {\r\n        throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n    }\r\n    const ts = (0,flo_poly__WEBPACK_IMPORTED_MODULE_4__.allRoots)(poly, 0, 1);\r\n    ts.push(0);\r\n    ts.push(1);\r\n    // Get point with minimum distance\r\n    let maxDSquared = Number.NEGATIVE_INFINITY;\r\n    let maxP = undefined;\r\n    for (const t of ts) {\r\n        const p_ = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_5__.evalDeCasteljau)(ps, t);\r\n        const dSquared = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_3__.squaredDistanceBetween)(p_, p);\r\n        if (dSquared > maxDSquared) {\r\n            maxDSquared = dSquared;\r\n            maxP = { p: p_, t, d: sqrt(dSquared) };\r\n        }\r\n    }\r\n    // keep TypeScript happy; `minP` cannot be `undefined` here\r\n    return maxP;\r\n}\r\n\r\n//# sourceMappingURL=furthest-point-on-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly1Dd": () => (/* binding */ getFootpointPoly1Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmn2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultByNeg2;\r\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 1 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly1Dd(ps, p) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = x0 - x;\r\n    const xx1 = x1 - x;\r\n    const yy0 = y0 - y;\r\n    const yy1 = y1 - y;\r\n    const x00 = tp(xx0, xx0);\r\n    const x01 = tp(xx0, xx1);\r\n    const x11 = tp(xx1, xx1);\r\n    const y00 = tp(yy0, yy0);\r\n    const y01 = tp(yy0, yy1);\r\n    const y11 = tp(yy1, yy1);\r\n    const s1 = qaq(x01, y01);\r\n    const s2 = qaq(y00, x00);\r\n    //const t1 = (x11 + y11) + (s2 - 2*s1)\r\n    const t1 = qaq(qaq(x11, y11), qaq(s2, qmn2(s1)));\r\n    //const t0 = s1 - s2;\r\n    const t0 = qdifq(s1, s2);\r\n    return [t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-1-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly2Dd": () => (/* binding */ getFootpointPoly2Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qdifq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 2 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly2Dd(ps, p) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const x00 = qmq(xx0, xx0);\r\n    const x01 = qmq(xx0, xx1);\r\n    const x02 = qmq(xx0, xx2);\r\n    const x11 = qmq(xx1, xx1);\r\n    const x12 = qmq(xx1, xx2);\r\n    const x22 = qmq(xx2, xx2);\r\n    const y00 = qmq(yy0, yy0);\r\n    const y01 = qmq(yy0, yy1);\r\n    const y02 = qmq(yy0, yy2);\r\n    const y11 = qmq(yy1, yy1);\r\n    const y12 = qmq(yy1, yy2);\r\n    const y22 = qmq(yy2, yy2);\r\n    const q1 = qaq(y02, qm2(y11));\r\n    const r1 = qaq(x02, qm2(x11));\r\n    //const t3 = ((y22 + y00) + 2*q1 - 4*(y12 + y01)) + \r\n    //           ((x22 + x00) + 2*r1 - 4*(x12 + x01));\r\n    const t3 = qaq(qdifq(qaq(qaq(y22, y00), qm2(q1)), qm4(qaq(y12, y01))), qdifq(qaq(qaq(x22, x00), qm2(r1)), qm4(qaq(x12, x01))));\r\n    //const t2 = 3*(((y12 - q1) + (3*y01 - y00)) + \r\n    //              ((x12 - r1) + (3*x01 - x00)));\r\n    const t2 = qmd(3, qaq(qaq(qdifq(y12, q1), qdifq(qmd(3, y01), y00)), qaq(qdifq(x12, r1), qdifq(qmd(3, x01), x00))));\r\n    //const t1 = (q1 - 3*(2*y01 - y00)) + \r\n    //           (r1 - 3*(2*x01 - x00));\r\n    const t1 = qaq(qdifq(q1, qmd(3, qdifq(qm2(y01), y00))), qdifq(r1, qmd(3, qdifq(qm2(x01), x00))));\r\n    //const t0 = (y01 - y00) + \r\n    //           (x01 - x00);\r\n    const t0 = qaq(qdifq(y01, y00), qdifq(x01, x00));\r\n    return [t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-2-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly3Dd": () => (/* binding */ getFootpointPoly3Dd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDd;\r\nconst qm2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy2;\r\nconst qm4 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultBy4;\r\nconst qdq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\n/**\r\n * Returns the polynomial whose roots are all the `t` values on the given bezier\r\n * curve such that the line from the given point to the point on the bezier\r\n * evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly3Dd(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x); // exact\r\n    const xx1 = td(x1, x); // exact\r\n    const xx2 = td(x2, x); // exact\r\n    const xx3 = td(x3, x); // exact\r\n    const yy0 = td(y0, y); // exact\r\n    const yy1 = td(y1, y); // exact\r\n    const yy2 = td(y2, y); // exact\r\n    const yy3 = td(y3, y); // exact\r\n    const x00 = qmq(xx0, xx0);\r\n    const x01 = qmd(6, qmq(xx0, xx1));\r\n    const x02 = qmd(6, qmq(xx0, xx2));\r\n    const x03 = qm2(qmq(xx0, xx3));\r\n    const x11 = qmd(9, qmq(xx1, xx1));\r\n    const x12 = qmd(18, qmq(xx1, xx2));\r\n    const x13 = qmd(6, qmq(xx1, xx3));\r\n    const x22 = qmd(9, qmq(xx2, xx2));\r\n    const x23 = qmd(6, qmq(xx2, xx3));\r\n    const x33 = qmq(xx3, xx3);\r\n    const y00 = qmq(yy0, yy0);\r\n    const y01 = qmd(6, qmq(yy0, yy1));\r\n    const y02 = qmd(6, qmq(yy0, yy2));\r\n    const y03 = qm2(qmq(yy0, yy3));\r\n    const y11 = qmd(9, qmq(yy1, yy1));\r\n    const y12 = qmd(18, qmq(yy1, yy2));\r\n    const y13 = qmd(6, qmq(yy1, yy3));\r\n    const y22 = qmd(9, qmq(yy2, yy2));\r\n    const y23 = qmd(6, qmq(yy2, yy3));\r\n    const y33 = qmq(yy3, yy3);\r\n    const q1 = qaq(x13, x22);\r\n    const q2 = qaq(x03, x12);\r\n    const q3 = qaq(x02, x11);\r\n    const r1 = qaq(y13, y22);\r\n    const r2 = qaq(y03, y12);\r\n    const r3 = qaq(y02, y11);\r\n    // const t5 = 6*(((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) + \r\n    //               ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));\r\n    const t5 = qmd(6, qaq(qaq(qaq(qaq(qdq(x33, x23), qdq(x00, x01)), q1), qdq(q3, q2)), qaq(qaq(qaq(qdq(y33, y23), qdq(y00, y01)), r1), qdq(r3, r2))));\r\n    //const t4 = 5*((((x23 + 5*x01) + 3*q2) - 2*(q1 + 2*q3 + 3*x00)) +\r\n    //              (((y23 + 5*y01) + 3*r2) - 2*(r1 + 2*r3 + 3*y00)));\r\n    const t4 = qmd(5, qaq(qdq(qaq(qaq(x23, qmd(5, x01)), qmd(3, q2)), qm2(qaq(qaq(q1, qm2(q3)), qmd(3, x00)))), qdq(qaq(qaq(y23, qmd(5, y01)), qmd(3, r2)), qm2(qaq(qaq(r1, qm2(r3)), qmd(3, y00))))));\r\n    //const t3 = 4*(((q1 - 3*(q2 - 2*q3)) - 5*(2*x01 - 3*x00)) +\r\n    //              ((r1 - 3*(r2 - 2*r3)) - 5*(2*y01 - 3*y00)));\r\n    const t3 = qm4(qaq(qdq(qdq(q1, qmd(3, (qdq(q2, qm2(q3))))), qmd(5, qdq(qm2(x01), qmd(3, x00)))), qdq(qdq(r1, qmd(3, (qdq(r2, qm2(r3))))), qmd(5, qdq(qm2(y01), qmd(3, y00))))));\r\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\r\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\r\n    const t2 = qmd(3, qaq(qdq(q2, qm2(qdq(qm2(q3), qmd(5, qdq(x01, qm2(x00)))))), qdq(r2, qm2(qdq(qm2(r3), qmd(5, qdq(y01, qm2(y00))))))));\r\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\r\n    //              (r3 - 5*(y01 - 3*y00)));\r\n    const t1 = qm2(qaq(qdq(q3, qmd(5, (qdq(x01, qmd(3, x00))))), qdq(r3, qmd(5, (qdq(y01, qmd(3, y00)))))));\r\n    //const t0 = ((x01 - 6*x00) +\r\n    //            (y01 - 6*y00));\r\n    const t0 = qaq(qdq(x01, qmd(6, x00)), qdq(y01, qmd(6, y00)));\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-3-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPolyDd": () => (/* binding */ getFootpointPolyDd)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-1-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-1-dd.js");\n/* harmony import */ var _get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-2-dd.js");\n/* harmony import */ var _get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-3-dd.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-3-dd.js");\n\r\n\r\n\r\n/**\r\n * Returns the polynomial whose roots are all the `t` parameter values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier curve evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * intermediate calculations are done (and the final result returned in)\r\n * double-double precision\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\nfunction getFootpointPolyDd(ps, p) {\r\n    if (ps.length === 4) {\r\n        return (0,_get_footpoint_poly_3_dd_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly3Dd)(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_get_footpoint_poly_2_dd_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2Dd)(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_get_footpoint_poly_1_dd_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly1Dd)(ps, p);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order 1,2 or 3\');\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double-double/get-footpoint-poly-dd.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly1": () => (/* binding */ getFootpointPoly1)\n/* harmony export */ });\n/** @internal */\r\nfunction getFootpointPoly1(ps, p) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const [xp, yp] = p;\r\n    const xx0 = x0 - xp;\r\n    const xx1 = x1 - xp;\r\n    const yy0 = y0 - yp;\r\n    const yy1 = y1 - yp;\r\n    const x01 = xx0 * xx1;\r\n    const y01 = yy0 * yy1;\r\n    const s1 = x01 + y01;\r\n    const s2 = yy0 * yy0 + xx0 * xx0;\r\n    const t1 = (xx1 * xx1 + yy1 * yy1) + (s2 - 2 * s1);\r\n    const t0 = s1 - s2;\r\n    return [t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly2": () => (/* binding */ getFootpointPoly2)\n/* harmony export */ });\n/** @internal */\r\nfunction getFootpointPoly2(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const xp = p[0];\r\n    const yp = p[1];\r\n    const xx0 = x0 - xp;\r\n    const xx1 = x1 - xp;\r\n    const xx2 = x2 - xp;\r\n    const yy0 = y0 - yp;\r\n    const yy1 = y1 - yp;\r\n    const yy2 = y2 - yp;\r\n    const x00 = xx0 * xx0;\r\n    const x01 = xx0 * xx1;\r\n    const x02 = xx0 * xx2;\r\n    const x11 = xx1 * xx1;\r\n    const x12 = xx1 * xx2;\r\n    const x22 = xx2 * xx2;\r\n    const y00 = yy0 * yy0;\r\n    const y01 = yy0 * yy1;\r\n    const y02 = yy0 * yy2;\r\n    const y11 = yy1 * yy1;\r\n    const y12 = yy1 * yy2;\r\n    const y22 = yy2 * yy2;\r\n    const q1 = y02 + 2 * y11;\r\n    const r1 = x02 + 2 * x11;\r\n    const t3 = ((y22 + y00) + 2 * q1 - 4 * (y12 + y01)) +\r\n        ((x22 + x00) + 2 * r1 - 4 * (x12 + x01));\r\n    const t2 = 3 * (((y12 - q1) + (3 * y01 - y00)) +\r\n        ((x12 - r1) + (3 * x01 - x00)));\r\n    const t1 = (q1 - 3 * (2 * y01 - y00)) +\r\n        (r1 - 3 * (2 * x01 - x00));\r\n    const t0 = (y01 - y00) +\r\n        (x01 - x00);\r\n    return [t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly3": () => (/* binding */ getFootpointPoly3)\n/* harmony export */ });\n/** @internal */\r\nfunction getFootpointPoly3(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    const xp = p[0];\r\n    const yp = p[1];\r\n    const xx0 = x0 - xp;\r\n    const xx1 = x1 - xp;\r\n    const xx2 = x2 - xp;\r\n    const xx3 = x3 - xp;\r\n    const yy0 = y0 - yp;\r\n    const yy1 = y1 - yp;\r\n    const yy2 = y2 - yp;\r\n    const yy3 = y3 - yp;\r\n    const x00 = xx0 * xx0;\r\n    const x01 = 6 * xx0 * xx1;\r\n    const x02 = 6 * xx0 * xx2;\r\n    const x03 = 2 * xx0 * xx3;\r\n    const x11 = 9 * xx1 * xx1;\r\n    const x12 = 18 * xx1 * xx2;\r\n    const x13 = 6 * xx1 * xx3;\r\n    const x22 = 9 * xx2 * xx2;\r\n    const x23 = 6 * xx2 * xx3;\r\n    const x33 = xx3 * xx3;\r\n    const y00 = yy0 * yy0;\r\n    const y01 = 6 * yy0 * yy1;\r\n    const y02 = 6 * yy0 * yy2;\r\n    const y03 = 2 * yy0 * yy3;\r\n    const y11 = 9 * yy1 * yy1;\r\n    const y12 = 18 * yy1 * yy2;\r\n    const y13 = 6 * yy1 * yy3;\r\n    const y22 = 9 * yy2 * yy2;\r\n    const y23 = 6 * yy2 * yy3;\r\n    const y33 = yy3 * yy3;\r\n    const q1 = x13 + x22;\r\n    const q2 = x03 + x12;\r\n    const q3 = x02 + x11;\r\n    const r1 = y13 + y22;\r\n    const r2 = y03 + y12;\r\n    const r3 = y02 + y11;\r\n    const t5 = 6 * (((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) +\r\n        ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));\r\n    const t4 = 5 * ((((x23 + 5 * x01) + 3 * q2) - 2 * (q1 + 2 * q3 + 3 * x00)) +\r\n        (((y23 + 5 * y01) + 3 * r2) - 2 * (r1 + 2 * r3 + 3 * y00)));\r\n    const t3 = 4 * (((q1 - 3 * (q2 - 2 * q3)) - 5 * (2 * x01 - 3 * x00)) +\r\n        ((r1 - 3 * (r2 - 2 * r3)) - 5 * (2 * y01 - 3 * y00)));\r\n    const t2 = 3 * ((q2 - 2 * (2 * q3 - 5 * (x01 - 2 * x00))) +\r\n        (r2 - 2 * (2 * r3 - 5 * (y01 - 2 * y00))));\r\n    const t1 = 2 * ((q3 - 5 * (x01 - 3 * x00)) +\r\n        (r3 - 5 * (y01 - 3 * y00)));\r\n    const t0 = ((x01 - 6 * x00) +\r\n        (y01 - 6 * y00));\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly": () => (/* binding */ getFootpointPoly)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-1.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-1.js");\n/* harmony import */ var _get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-2.js");\n/* harmony import */ var _get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-3.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly-3.js");\n\r\n\r\n\r\n/**\r\n * Returns a polynomial in 1 variable whose roots are the parameter values of\r\n * the foot points on the given bezier curve of the given point.\r\n *\r\n * The returned polynomial coefficients are given densely as an array of\r\n * double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * * intermediate calculations are done in double precision\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control points, e.g. `[[1,2],[3,4],[5,7],[0,0]]`\r\n * @param p\r\n */\r\nfunction getFootpointPoly(ps, p) {\r\n    if (ps.length === 4) {\r\n        return (0,_get_footpoint_poly_3_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly3)(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_get_footpoint_poly_2_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2)(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_get_footpoint_poly_1_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly1)(ps, p);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order 1,2 or 3\');\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/double/get-footpoint-poly.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly1Exact": () => (/* binding */ getFootpointPoly1Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult;\r\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultByNeg2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 1 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly1Exact(ps, p) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = emult(xx0, xx1);\r\n    const x11 = emult(xx1, xx1);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = emult(yy0, yy1);\r\n    const y11 = emult(yy1, yy1);\r\n    const s1 = eadd(x01, y01);\r\n    const s2 = eadd(y00, x00);\r\n    //const t1 = x11 + y11 - 2*s1 + s2;\r\n    const t1 = eadd(eadd(x11, y11), eadd(emn2(s1), s2));\r\n    //const t0 = s1 - s2;\r\n    const t0 = ediff(s1, s2);\r\n    return [t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-1-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly2Exact": () => (/* binding */ getFootpointPoly2Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\n/**\r\n * Returns the result of multiplying a floating point expansion by 4.\r\n *\r\n * * **error free**\r\n *\r\n * * see [[Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n *\r\n * @param e a floating point expansion\r\n *\r\n * @internal\r\n */\r\nfunction em4(e) {\r\n    const e_ = [];\r\n    for (let i = 0; i < e.length; i++) {\r\n        e_.push(4 * e[i]);\r\n    }\r\n    return e_;\r\n}\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 2 curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * @internal\r\n */\r\nfunction getFootpointPoly2Exact(ps, p) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = emult(xx0, xx1);\r\n    const x02 = emult(xx0, xx2);\r\n    const x11 = emult(xx1, xx1);\r\n    const x12 = emult(xx1, xx2);\r\n    const x22 = emult(xx2, xx2);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = emult(yy0, yy1);\r\n    const y02 = emult(yy0, yy2);\r\n    const y11 = emult(yy1, yy1);\r\n    const y12 = emult(yy1, yy2);\r\n    const y22 = emult(yy2, yy2);\r\n    const q1 = eadd(y02, em2(y11));\r\n    const r1 = eadd(x02, em2(x11));\r\n    //const t3 = y22 + 2*q1 - 4*(y12 + y01) + y00 + \r\n    //           x22 + 2*r1 - 4*(x12 + x01) + x00;\r\n    const t3a = eadd(ediff(eadd(x22, em2(r1)), em4(eadd(x12, x01))), x00);\r\n    const t3b = eadd(ediff(eadd(y22, em2(q1)), em4(eadd(y12, y01))), y00);\r\n    const t3 = eadd(t3a, t3b);\r\n    //const t2 = 3*(y12 - q1 + 3*y01 - y00 + \r\n    //              x12 - r1 + 3*x01 - x00);\r\n    const t2a = eadd(ediff(x12, r1), ediff(sce(3, x01), x00));\r\n    const t2b = eadd(ediff(y12, q1), ediff(sce(3, y01), y00));\r\n    const t2 = sce(3, eadd(t2a, t2b));\r\n    //const t1 = q1 - 3*(2*y01 - y00) + \r\n    //           r1 - 3*(2*x01 - x00);\r\n    const t1a = ediff(q1, sce(3, ediff(em2(y01), y00)));\r\n    const t1b = ediff(r1, sce(3, ediff(em2(x01), x00)));\r\n    const t1 = eadd(t1a, t1b);\r\n    //const t0 = y01 - y00 + \r\n    //           x01 - x00;\r\n    const t0a = ediff(y01, y00);\r\n    const t0b = ediff(x01, x00);\r\n    const t0 = eadd(t0a, t0b);\r\n    return [t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-2-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPoly3Exact": () => (/* binding */ getFootpointPoly3Exact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst emult = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMult;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst em2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultBy2;\r\nconst emn2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eMultByNeg2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\nfunction getFootpointPoly3Exact(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    const [x, y] = p;\r\n    const xx0 = td(x0, x);\r\n    const xx1 = td(x1, x);\r\n    const xx2 = td(x2, x);\r\n    const xx3 = td(x3, x);\r\n    const yy0 = td(y0, y);\r\n    const yy1 = td(y1, y);\r\n    const yy2 = td(y2, y);\r\n    const yy3 = td(y3, y);\r\n    const x00 = emult(xx0, xx0);\r\n    const x01 = sce(6, emult(xx0, xx1));\r\n    const x02 = sce(6, emult(xx0, xx2));\r\n    const x03 = em2(emult(xx0, xx3));\r\n    const x11 = sce(9, emult(xx1, xx1));\r\n    const x12 = sce(18, emult(xx1, xx2));\r\n    const x13 = sce(6, emult(xx1, xx3));\r\n    const x22 = sce(9, emult(xx2, xx2));\r\n    const x23 = sce(6, emult(xx2, xx3));\r\n    const x33 = emult(xx3, xx3);\r\n    const y00 = emult(yy0, yy0);\r\n    const y01 = sce(6, emult(yy0, yy1));\r\n    const y02 = sce(6, emult(yy0, yy2));\r\n    const y03 = em2(emult(yy0, yy3));\r\n    const y11 = sce(9, emult(yy1, yy1));\r\n    const y12 = sce(18, emult(yy1, yy2));\r\n    const y13 = sce(6, emult(yy1, yy3));\r\n    const y22 = sce(9, emult(yy2, yy2));\r\n    const y23 = sce(6, emult(yy2, yy3));\r\n    const y33 = emult(yy3, yy3);\r\n    const q1 = eadd(x13, x22);\r\n    const q2 = eadd(x03, x12);\r\n    const q3 = eadd(x02, x11);\r\n    const r1 = eadd(y13, y22);\r\n    const r2 = eadd(y03, y12);\r\n    const r3 = eadd(y02, y11);\r\n    //const t5 = 6*((x33 - x23 + q1 - q2 + q3 - x01 + x00) + \r\n    //              (y33 - y23 + r1 - r2 + r3 - y01 + y00));\r\n    const t5a = ediff(eadd(eadd(x33, x00), eadd(q1, q3)), (eadd(eadd(q2, x23), x01)));\r\n    const t5b = ediff(eadd(eadd(y33, y00), eadd(r1, r3)), (eadd(eadd(r2, y23), y01)));\r\n    const t5 = sce(6, eadd(t5a, t5b));\r\n    //const t4 = 5*((x23 - 2*(q1 + 2*q3 + 3*x00) + 3*q2 + 5*x01) +\r\n    //              (y23 - 2*(r1 + 2*r3 + 3*y00) + 3*r2 + 5*y01));\r\n    const t4a = eadd(emn2(eadd(eadd(q1, em2(q3)), sce(3, x00))), eadd(eadd(x23, sce(3, q2)), sce(5, x01)));\r\n    const t4b = eadd(emn2(eadd(eadd(r1, em2(r3)), sce(3, y00))), eadd(eadd(y23, sce(3, r2)), sce(5, y01)));\r\n    const t4 = sce(5, eadd(t4a, t4b));\r\n    //const t3 = 4*((q1 - 3*(q2 - 2*q3) - 5*(2*x01 - 3*x00)) +\r\n    //              (r1 - 3*(r2 - 2*r3) - 5*(2*y01 - 3*y00)));\r\n    const t3a = eadd(eadd(q1, sce(3, (ediff(em2(q3), q2)))), sce(5, (ediff(sce(3, x00), em2(x01)))));\r\n    const t3b = eadd(eadd(r1, sce(3, (ediff(em2(r3), r2)))), sce(5, (ediff(sce(3, y00), em2(y01)))));\r\n    const t3 = sce(4, eadd(t3a, t3b));\r\n    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +\r\n    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));\r\n    const t2a = ediff(q2, em2(ediff(em2(q3), sce(5, (ediff(x01, em2(x00)))))));\r\n    const t2b = ediff(r2, em2(ediff(em2(r3), sce(5, (ediff(y01, em2(y00)))))));\r\n    const t2 = sce(3, eadd(t2a, t2b));\r\n    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +\r\n    //              (r3 - 5*(y01 - 3*y00)));\r\n    const t1a = ediff(q3, sce(5, (ediff(x01, sce(3, x00)))));\r\n    const t1b = ediff(r3, sce(5, (ediff(y01, sce(3, y00)))));\r\n    const t1 = em2(eadd(t1a, t1b));\r\n    //const t0 = ((x01 - 6*x00) +\r\n    //            (y01 - 6*y00));\r\n    const t0a = ediff(x01, sce(6, x00));\r\n    const t0b = ediff(y01, sce(6, y00));\r\n    const t0 = eadd(t0a, t0b);\r\n    return [t5, t4, t3, t2, t1, t0];\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-3-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getFootpointPolyExact": () => (/* binding */ getFootpointPolyExact)\n/* harmony export */ });\n/* harmony import */ var _get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-footpoint-poly-1-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-1-exact.js");\n/* harmony import */ var _get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-footpoint-poly-2-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-2-exact.js");\n/* harmony import */ var _get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-footpoint-poly-3-exact.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-3-exact.js");\n\r\n\r\n\r\n/**\r\n * Returns the *exact* polynomial whose roots are all the `t` values on the\r\n * given bezier curve such that the line from the given point to the point on\r\n * the bezier evaluated at `t` is tangent to the bezier curve at `t`.\r\n *\r\n * * The returned polynomial coefficients are given densely as an array of\r\n * [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating\r\n * point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1],[3,5],[7,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n */\r\nfunction getFootpointPolyExact(ps, p) {\r\n    if (ps.length === 4) {\r\n        return (0,_get_footpoint_poly_3_exact_js__WEBPACK_IMPORTED_MODULE_2__.getFootpointPoly3Exact)(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_get_footpoint_poly_2_exact_js__WEBPACK_IMPORTED_MODULE_1__.getFootpointPoly2Exact)(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_get_footpoint_poly_1_exact_js__WEBPACK_IMPORTED_MODULE_0__.getFootpointPoly1Exact)(ps, p);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order 1,2 or 3\');\r\n}\r\n\r\n//# sourceMappingURL=get-footpoint-poly-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/exact/get-footpoint-poly-exact.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getClosestOnBezier1FromPointErrorCounters": () => (/* binding */ getClosestOnBezier1FromPointErrorCounters),\n/* harmony export */   "getClosestOnBezier2FromPointErrorCounters": () => (/* binding */ getClosestOnBezier2FromPointErrorCounters),\n/* harmony export */   "getClosestOnBezier3FromPointErrorCounters": () => (/* binding */ getClosestOnBezier3FromPointErrorCounters)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * ```\r\n * return [\r\n *      t5_,  // <9>\r\n *      t4_,  // <10>\r\n *      t3_,  // <10>\r\n *      t2_,  // <10>\r\n *      t1_,  // <9>\r\n *      t0_   // <7>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier3FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0_ = abs(p0[0]); // <0>  (error counters)\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const x2_ = abs(p2[0]); // <0>\r\n    const y2_ = abs(p2[1]); // <0>\r\n    const x3_ = abs(p3[0]); // <0>\r\n    const y3_ = abs(p3[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);\r\n    const xx1_ = x1_ + xp_;\r\n    // <1>xx2 <-- <1>(x2 - xp);\r\n    const xx2_ = x2_ + xp_;\r\n    // <1>xx3 <-- <1>(x3 - xp);\r\n    const xx3_ = x3_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);\r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);\r\n    const yy1_ = y1_ + yp_;\r\n    // <1>yy2 <-- <1>(y2 - yp);\r\n    const yy2_ = y2_ + yp_;\r\n    // <1>yy3 <-- <1>(y3 - yp);\r\n    const yy3_ = y3_ + yp_;\r\n    // <3>x00 <-- <3>(<1>xx0*<1>xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <4>x01 <-- <4>(6 *<3>(<1>xx0*<1>xx1));\r\n    const x01_ = 6 * xx0_ * xx1_;\r\n    // <4>x02 <-- <4>(6 *<3>(<1>xx0*<1>xx2));\r\n    const x02_ = 6 * xx0_ * xx2_;\r\n    // <3>x03 <-- 2 *<3>(<1>xx0*<1>xx3);\r\n    const x03_ = 2 * xx0_ * xx3_;\r\n    // <4>x11 <-- <4>(9 *<3>(<1>xx1*<1>xx1));\r\n    const x11_ = 9 * xx1_ * xx1_;\r\n    // <4>x12 <-- <4>(18*<3>(<1>xx1*<1>xx2));\r\n    const x12_ = 18 * xx1_ * xx2_;\r\n    // <4>x13 <-- <4>(6 *<3>(<1>xx1*<1>xx3));\r\n    const x13_ = 6 * xx1_ * xx3_;\r\n    // <4>x22 <-- <4>(9 *<3>(<1>xx2*<1>xx2));\r\n    const x22_ = 9 * xx2_ * xx2_;\r\n    // <4>x23 <-- <4>(6 *<3>(<1>xx2*<1>xx3));\r\n    const x23_ = 6 * xx2_ * xx3_;\r\n    // <3>x33 <--    <3>(<1>xx3*<1>xx3);\r\n    const x33_ = xx3_ * xx3_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = 6 * yy0_ * yy1_;\r\n    const y02_ = 6 * yy0_ * yy2_;\r\n    const y03_ = 2 * yy0_ * yy3_;\r\n    const y11_ = 9 * yy1_ * yy1_;\r\n    const y12_ = 18 * yy1_ * yy2_;\r\n    const y13_ = 6 * yy1_ * yy3_;\r\n    const y22_ = 9 * yy2_ * yy2_;\r\n    const y23_ = 6 * yy2_ * yy3_;\r\n    const y33_ = yy3_ * yy3_;\r\n    // <5>q1 <-- (5>(<4>x13 + <4>x22);\r\n    const q1_ = x13_ + x22_;\r\n    // <5>q2 <-- (5>(<3>x03 + <4>x12);\r\n    const q2_ = x03_ + x12_;\r\n    // <5>q3 <-- (5>(<4>x02 + <4>x11);\r\n    const q3_ = x02_ + x11_;\r\n    const r1_ = y13_ + y22_; // <5>\r\n    const r2_ = y03_ + y12_; // <5>\r\n    const r3_ = y02_ + y11_; // <5>\r\n    // <9>t5 <-- <9>(6*<8>(<7>(<6>(<5>(<4>(x33 - x23) + <4>(x00 - x01)) + <5>q1) + <6>(q3 - q2)) + \r\n    //                     <7>(<6>(<5>(<4>(y33 - y23) + <4>(y00 - y01)) + <5>r1) + <6>(r3 - r2))));\r\n    const t5_ = 6 * (((((x33_ + x23_) + (x00_ + x01_)) + q1_) + (q3_ + q2_)) +\r\n        ((((y33_ + y23_) + (y00_ + y01_)) + r1_) + (r3_ + r2_)));\r\n    // <10>t4 <-- <10>(5*<9>(<8>(<7>(<6>(x23 + <5>(5*x01)) + <6>(3*q2)) - 2*<7>(<6>(q1 + 2*q3) + <5>(3*x00))) +\r\n    //                       <8>(<7>(<6>(y23 + <5>(5*y01)) + <6>(3*r2)) - 2*<7>(<6>(r1 + 2*r3) + <5>(3*y00)))));\r\n    const t4_ = 5 * ((((x23_ + 5 * x01_) + 3 * q2_) + 2 * (q1_ + 2 * q3_ + 3 * x00_)) +\r\n        (((y23_ + 5 * y01_) + 3 * r2_) + 2 * (r1_ + 2 * r3_ + 3 * y00_)));\r\n    // <10>t3 <-- 4*<10>(<9>(<8>(q1 - <7>(3*<6>(q2 - 2*q3))) - <7>(5*<6>(2*x01 - <5>(3*x00)))) +\r\n    //                 <9>(<8>(r1 - <7>(3*<6>(r2 - 2*r3))) - <7>(5*<6>(2*y01 - <5>(3*y00)))))\r\n    const t3_ = 4 * (((q1_ + 3 * (q2_ + 2 * q3_)) + 5 * (2 * x01_ + 3 * x00_)) +\r\n        ((r1_ + 3 * (r2_ + 2 * r3_)) + 5 * (2 * y01_ + 3 * y00_)));\r\n    // <10>t2 <-- <10>(3*<9>(<8>(q2 - 2*<7>(2*q3 - <6>(5*<5>(x01 - 2*x00)))) +\r\n    //                       <8>(r2 - 2*<7>(2*r3 - <6>(5*<5>(y01 - 2*y00))))));\r\n    const t2_ = 3 * ((q2_ + 2 * (2 * q3_ + 5 * (x01_ + 2 * x00_))) +\r\n        (r2_ + 2 * (2 * r3_ + 5 * (y01_ + 2 * y00_))));\r\n    // <9>t1 <-- 2*<9>(<8>(q3 - <7>(5*<6>(x01 - <5>(3*x00)))) +\r\n    //                 <8>(r3 - <7>(5*<6>(y01 - <5>(3*y00)))));\r\n    const t1_ = 2 * ((q3_ + 5 * (x01_ + 3 * x00_)) +\r\n        (r3_ + 5 * (y01_ + 3 * y00_)));\r\n    // <7>t0 <-- <7>(<6>(x01 - <5>(6*x00)) +\r\n    //              <6>(y01 - <5>(6*y00)));\r\n    const t0_ = ((x01_ + 6 * x00_) +\r\n        (y01_ + 6 * y00_));\r\n    return [\r\n        t5_,\r\n        t4_,\r\n        t3_,\r\n        t2_,\r\n        t1_,\r\n        t0_ // <7>\r\n    ];\r\n}\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n * ```\r\n * return [\r\n *      t3_,  // <7>\r\n *      t2_,  // <8>\r\n *      t1_,  // <7>\r\n *      t0_   // <5>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier2FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0_ = abs(p0[0]); // <0>\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const x2_ = abs(p2[0]); // <0>\r\n    const y2_ = abs(p2[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);\r\n    const xx1_ = x1_ + xp_;\r\n    // <1>xx2 <-- <1>(x2 - xp);\r\n    const xx2_ = x2_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);\r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);\r\n    const yy1_ = y1_ + yp_;\r\n    // <1>yy2 <-- <1>(y2 - yp);\r\n    const yy2_ = y2_ + yp_;\r\n    // <3>x00 <-- <3>(xx0*xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <3>x01 <-- <3>(xx0*xx1);\r\n    const x01_ = xx0_ * xx1_;\r\n    // <3>x02 <-- <3>(xx0*xx2);\r\n    const x02_ = xx0_ * xx2_;\r\n    // <3>x11 <-- <3>(xx1*xx1);\r\n    const x11_ = xx1_ * xx1_;\r\n    // <3>x12 <-- <3>(xx1*xx2);\r\n    const x12_ = xx1_ * xx2_;\r\n    // <3>x22 <-- <3>(xx2*xx2);\r\n    const x22_ = xx2_ * xx2_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = yy0_ * yy1_;\r\n    const y02_ = yy0_ * yy2_;\r\n    const y11_ = yy1_ * yy1_;\r\n    const y12_ = yy1_ * yy2_;\r\n    const y22_ = yy2_ * yy2_;\r\n    // <4>q1 <-- <4>(y02 + 2*y11);\r\n    const q1_ = y02_ + 2 * y11_;\r\n    // <4>r1 <-- <4>(x02 + 2*x11);\r\n    const r1_ = x02_ + 2 * x11_;\r\n    // <7>t3 <-- <7>(<6>(<5>(<4>(y22 + y00) + 2*q1) - 4*<4>(y12 + y01))) + \r\n    //              (<6>(<5>(<4>(x22 + x00) + 2*r1) - 4*<4>(x12 + x01)));\r\n    const t3_ = ((y22_ + y00_) + 2 * q1_ + 4 * (y12_ + y01_)) +\r\n        ((x22_ + x00_) + 2 * r1_ + 4 * (x12_ + x01_));\r\n    // <8>t2 <-- <8>(3*<7>(<6>(<5>(y12 - q1) + <5>(<4>(3*y01) - y00)) + \r\n    //                     <6>(<5>(x12 - r1) + <5>(<4>(3*x01) - x00))));\r\n    const t2_ = 3 * (((y12_ + q1_) + (3 * y01_ + y00_)) +\r\n        ((x12_ + r1_) + (3 * x01_ + x00_)));\r\n    // <7>t1 <-- <7>(<6>(<4>q1 - <5>(3*<4>(2*y01 - y00))) + \r\n    //               <6>(<4>r1 - <5>(3*<4>(2*x01 - x00))));\r\n    const t1_ = (q1_ + 3 * (2 * y01_ + y00_)) +\r\n        (r1_ + 3 * (2 * x01_ + x00_));\r\n    // <5>t0 <-- <5>(<4>(y01 - y00) + \r\n    //              <4>(x01 - x00));\r\n    const t0_ = (y01_ + y00_) +\r\n        (x01_ + x00_);\r\n    return [\r\n        t3_,\r\n        t2_,\r\n        t1_,\r\n        t0_ // <5>\r\n    ];\r\n}\r\n/**\r\n * Returns a representation of the error when calculating the polynomial whose\r\n * roots are all the `t` values on the given bezier curve such that the line\r\n * from the given point to the point on the bezier evaluated at `t` is tangent\r\n * to the bezier at `t`.\r\n *\r\n * @param ps a linear bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param p a point, e.g. `[1,2]`\r\n *\r\n * ```\r\n * return [\r\n *     t1,  // <6>\r\n *     t0   // <5>\r\n * ];\r\n * ```\r\n *\r\n * @internal\r\n */\r\nfunction getClosestOnBezier1FromPointErrorCounters(ps, p) {\r\n    //const [[x0, y0], [x1, y1]] = ps;\r\n    //const [xp, yp] = p;\r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0_ = abs(p0[0]); // <0>\r\n    const y0_ = abs(p0[1]); // <0>\r\n    const x1_ = abs(p1[0]); // <0>\r\n    const y1_ = abs(p1[1]); // <0>\r\n    const xp_ = abs(p[0]); // <0>\r\n    const yp_ = abs(p[1]); // <0>\r\n    // <1>xx0 <-- <1>(x0 - xp);\r\n    const xx0_ = x0_ + xp_;\r\n    // <1>xx1 <-- <1>(x1 - xp);    \r\n    const xx1_ = x1_ + xp_;\r\n    // <1>yy0 <-- <1>(y0 - yp);    \r\n    const yy0_ = y0_ + yp_;\r\n    // <1>yy1 <-- <1>(y1 - yp);    \r\n    const yy1_ = y1_ + yp_;\r\n    // <3>x00 <-- <3>(xx0*xx0);\r\n    const x00_ = xx0_ * xx0_;\r\n    // <3>x01 <-- <3>(xx0*xx1);\r\n    const x01_ = xx0_ * xx1_;\r\n    // <3>x11 <-- <3>(xx1*xx1);\r\n    const x11_ = xx1_ * xx1_;\r\n    const y00_ = yy0_ * yy0_;\r\n    const y01_ = yy0_ * yy1_;\r\n    const y11_ = yy1_ * yy1_;\r\n    // <4>s1 <-- <4>(x01 + y01);\r\n    const s1_ = x01_ + y01_;\r\n    // <4>s2 <-- <4>(y00 + x00);\r\n    const s2_ = y00_ + x00_;\r\n    // <6>t1 = <6>(<4>(x11 + y11) + <5>(s2 - 2*s1));\r\n    const t1 = x11_ + y11_ + 2 * s1_ + s2_;\r\n    // <5>t0 = <5>(s1 - s2);\r\n    const t0 = s1_ + s2_;\r\n    return [\r\n        t1,\r\n        t0 // <5>\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-closest-on-bezier-from-point-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/equal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "equal": () => (/* binding */ equal)\n/* harmony export */ });\n/**\r\n * Returns `true` if the two given bezier curves are exactly equal when compared\r\n * by value (deep equality), `false` otherwise\r\n *\r\n * @param ps1 an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param ps2 another bezier curve\r\n *\r\n * @doc\r\n */\r\nfunction equal(ps1, ps2) {\r\n    if (ps1 === ps2) {\r\n        return true;\r\n    }\r\n    if (ps1.length !== ps2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < ps1.length; i++) {\r\n        if (ps1[i][0] !== ps2[i][0] || ps1[i][1] !== ps2[i][1]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/equal.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInterfaceRotation": () => (/* binding */ getInterfaceRotation)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n\r\n\r\n\r\n\r\nconst tp = double_double__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\nconst ddAddDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst ddDiffDd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddDiffDd;\r\nconst { PI: 𝜋, asin, acos } = Math;\r\n/**\r\n * Returns the rotation angle (-𝜋 <= θ <= 𝜋 *guaranteed*) from some vector to\r\n * another vector considering them to both start at the same point.\r\n *\r\n * If one of the vectors is the zero vector then `0` is returned.\r\n *\r\n * It can also be imagined that the 2nd vector starts where the 1st one ends.\r\n *\r\n * Intermediate calculations are done in double precision in a numerically\r\n * stable manner.\r\n *\r\n * @param a the first 2d vector given as `[x,y]` where `x` and `y` are the\r\n * coordinates, e.g. `[2,3]`\r\n * @param b the second 2d vector\r\n */\r\nfunction getInterfaceRotation(a, b) {\r\n    if ((a[0] === 0 && a[1] === 0) ||\r\n        (b[0] === 0 && b[1] === 0)) {\r\n        return 0; // zero vector\r\n    }\r\n    const c = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(a);\r\n    const d = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_1__.toUnitVector)(b);\r\n    // let cross_ = c[0]*d[1] - c[1]*d[0];\r\n    // let dot_   = c[0]*d[0] + c[1]*d[1];\r\n    let cross_ = ddDiffDd(tp(c[0], d[1]), tp(c[1], d[0]))[1];\r\n    let dot_ = ddAddDd(tp(c[0], d[0]), tp(c[1], d[1]))[1];\r\n    // clip `dot_` and `cross_` to ensure `acos` and `asin` exists. (The -1 and\r\n    // +1 might be overstepped due to inexact calculations during the calls to\r\n    // `toUnitVector` and is not avoidable in double precision)\r\n    if (cross_ < -1) {\r\n        cross_ = -1;\r\n    }\r\n    if (cross_ > +1) {\r\n        cross_ = +1;\r\n    }\r\n    if (dot_ < -1) {\r\n        dot_ = -1;\r\n    }\r\n    if (dot_ > +1) {\r\n        dot_ = +1;\r\n    }\r\n    // if `sgn >= 0` then the dot product is numerically more stable, else\r\n    // the cross product is more stable...\r\n    // const sgn = c[0]*c[1]*d[0]*d[1];\r\n    // ...however, then `acos` and `asin` is much less stable\r\n    const θ = dot_ >= 0\r\n        ? cross_ >= 0\r\n            ? dot_ <= 0.5 ? +acos(dot_) : asin(cross_) // 1st quadrant\r\n            : dot_ <= 0.5 ? -acos(dot_) : asin(cross_) // 4th quadrant\r\n        : cross_ >= 0\r\n            ? dot_ >= -0.5 ? +acos(dot_) : +𝜋 - asin(cross_) // 2nd quadrant\r\n            : dot_ >= -0.5 ? -acos(dot_) : -𝜋 - asin(cross_); // 3rd quadrant\r\n    return θ;\r\n}\r\n\r\n//# sourceMappingURL=get-interface-rotation.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/get-interface-rotation.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getMaxHausdorff": () => (/* binding */ getMaxHausdorff)\n/* harmony export */ });\n/** @internal */\r\nfunction getMaxHausdorff(i) {\r\n    return Math.max(i.hL + i.hEL, i.hR + i.hER);\r\n}\r\n\r\n//# sourceMappingURL=get-max-hausdorff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hausdorffCompare": () => (/* binding */ hausdorffCompare)\n/* harmony export */ });\n/* harmony import */ var _get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-max-hausdorff.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js");\n\r\n/**\r\n * @param a\r\n * @param b\r\n *\r\n * @internal\r\n */\r\nfunction hausdorffCompare(a, b) {\r\n    let diff = ((0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__.getMaxHausdorff)(a) - (0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_0__.getMaxHausdorff)(b));\r\n    if (diff !== 0) {\r\n        return diff;\r\n    }\r\n    //diff = a.tS - b.tS;\r\n    //if (diff !== 0) { return diff; }\r\n    //return a.tE - b.tE;\r\n    return a.tS - b.tS;\r\n}\r\n\r\n//# sourceMappingURL=hausdorff-compare.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hausdorffDistanceOneSided": () => (/* binding */ hausdorffDistanceOneSided)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js");\n/* harmony import */ var _local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../local-properties-at-t/evaluate/double/eval-de-casteljau.js */ "./node_modules/flo-bezier3/node/local-properties-at-t/evaluate/double/eval-de-casteljau.js");\n/* harmony import */ var _closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../closest-and-furthest-point-on-bezier/closest-point-on-bezier.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/closest-point-on-bezier.js");\n/* harmony import */ var _closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/closest-and-furthest-point-on-bezier/furthest-point-on-bezier.js");\n/* harmony import */ var _error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../error-analysis/max-abs-coordinate.js */ "./node_modules/flo-bezier3/node/error-analysis/max-abs-coordinate.js");\n/* harmony import */ var _get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-max-hausdorff.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/get-max-hausdorff.js");\n/* harmony import */ var _hausdorff_compare_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hausdorff-compare.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-compare.js");\n/* harmony import */ var _heap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./heap.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/heap.js");\n/* harmony import */ var _transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transformation/split/from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @internal */\r\nconst max = Math.max;\r\n// We need to calculate `H(A,B)`, the two sided Hausdorff distance between\r\n// the bezier curves `A` and `B` which equals `max(h(A,B), h(B,A))`, where\r\n// `h(A,B)` is the one sided Hausdorff distance from `A` to `B`\r\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\r\n// where: δS = max[ (1 ≤ i ≤ M+1)(ti − ti−1) ] is the maximum distance between \r\n// two consecutive parameter values\r\n// Lemma 2.1: \r\n//   h(A,S) ≤ ωf(δS/2) and\r\n//   h(B,T) ≤ ωg(δT/2)\r\n// Theorem 2.3: (both curves discretized)\r\n//   |h(S,T) − h(A,B)| ≤ max[ h(A,S), h(B,T) ] \r\n//                     ≤ max[ ωf(δS/2), ωg(δT/2) ]\r\n//  \r\n// (only A discretized)\r\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\r\n/**\r\n * Calculates and returns an accurate approximation to the one-sided Hausdorff\r\n * distance from the bezier curve `A` to the bezier curve `B`.\r\n *\r\n * * partially based off [Computing the Hausdorff distance between two sets of parametric curves](https://www.semanticscholar.org/paper/COMPUTING-THE-HAUSDORFF-DISTANCE-BETWEEN-TWO-SETS-Kim-McLean/d2bd6529c4b118e389e1db209d8f1bf7467f9016)\r\n *\r\n * @param A a bezier curve (the \'from\' curve) given by an ordered array of its\r\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param B a bezier curve (the \'to\' curve) given by an ordered array of its\r\n * control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param tolerance optional; defaults to `Math.max(maxAbsCoordinate(A),maxAbsCoordinate(B))/1000_000`;\r\n * if the calculated absolute error bound is less than this, the result is\r\n * returned; this is *not* a hard tolerance and the bound can be less\r\n * accurate in hard cases (due to the `maxIterations` parameter). Luckily\r\n * however, specifically the lower bound will be very accurate due to\r\n * its fast convergence in such hard cases (see the paper)\r\n * @param maxIterations optional; defaults to `50`; if the desired guaranteed error bound\r\n * has not been achieved after `maxIterations` then the result will be returned\r\n *\r\n * @doc mdx\r\n */\r\nfunction hausdorffDistanceOneSided(A, B, tolerance, maxIterations = 50) {\r\n    if (A.length === 1) {\r\n        return (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, A[0]).d;\r\n    }\r\n    if (B.length === 1) {\r\n        return (0,_closest_and_furthest_point_on_bezier_furthest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_4__.furthestPointOnBezier)(A, B[0]).d;\r\n    }\r\n    if (A.length === 2 && B.length === 2) {\r\n        // Seperately handle the simple case of two lines\r\n        // Find minimum distance from endpoints of A to B:\r\n        const EA0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, A[0]).d;\r\n        const EA1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, A[A.length - 1]).d;\r\n        return EA0 > EA1 ? EA0 : EA1;\r\n    }\r\n    const l = max((0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.maxAbsCoordinate)(A), (0,_error_analysis_max_abs_coordinate_js__WEBPACK_IMPORTED_MODULE_5__.maxAbsCoordinate)(B));\r\n    tolerance = tolerance || l / 1000000;\r\n    // an array of intervals\r\n    const [eL, eR] = calcHErrorBound(A, 0, 1);\r\n    const d0 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, A[0]).d;\r\n    const d1 = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, A[A.length - 1]).d;\r\n    const initialInterval = {\r\n        tS: 0, tE: 1,\r\n        hL: d0, hR: d1, hEL: eL, hER: eR\r\n    };\r\n    const heap = new _heap_js__WEBPACK_IMPORTED_MODULE_8__.Heap(_hausdorff_compare_js__WEBPACK_IMPORTED_MODULE_7__.hausdorffCompare);\r\n    heap.insert(initialInterval);\r\n    let j = 0;\r\n    let bestHUpper = Number.POSITIVE_INFINITY;\r\n    let bestHLower = Number.NEGATIVE_INFINITY;\r\n    while (true) {\r\n        const interval = heap.heap[0]; // peek max\r\n        const { tS, tE, hL, hR } = interval;\r\n        const tM = (tS + tE) / 2;\r\n        const [ELL, ELR] = calcHErrorBound(A, tS, tM);\r\n        const [ERL, ERR] = calcHErrorBound(A, tM, tE);\r\n        //---- get hM ---------------------------\r\n        const pM = (0,_local_properties_at_t_evaluate_double_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_2__.evalDeCasteljau)(A, tM);\r\n        const pB = (0,_closest_and_furthest_point_on_bezier_closest_point_on_bezier_js__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezier)(B, pM).p;\r\n        const hM = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.distanceBetween)(pM, pB);\r\n        //---------------------------------------\r\n        const h = max(hL, hM, hR);\r\n        if (h > bestHLower) {\r\n            bestHLower = h;\r\n        }\r\n        bestHUpper = (0,_get_max_hausdorff_js__WEBPACK_IMPORTED_MODULE_6__.getMaxHausdorff)(interval);\r\n        if (bestHUpper - bestHLower < tolerance) {\r\n            // The lower bound is by far the best approximation for difficult cases (see the paper).\r\n            return bestHLower;\r\n        }\r\n        if (j++ > maxIterations) {\r\n            // The lower bound is by far the best approximation for difficult cases (see the paper).\r\n            return bestHLower;\r\n        }\r\n        const iL = { tS, tE: tM, hL, hR: hM, hEL: ELL, hER: ELR };\r\n        const iR = { tS: tM, tE, hL: hM, hR, hEL: ERL, hER: ERR };\r\n        heap.swapMax(iL);\r\n        heap.insert(iR);\r\n    }\r\n}\r\n// Let: ωf(σ) = sup{ |f(t) − f(t′)| : t, t′ ∈ [a,b] with |t − t′| ≤ σ }\r\n//\r\n// |h(S,B) − h(A,B)| ≤ ωf(δS/2)\r\n// where: δS = max_(1≤i≤M+1)[ (ti − ti−1) ] is the maximum distance between \r\n// two consecutive parameter values\r\n/**\r\n * @internal\r\n */\r\nfunction calcHErrorBound(A, tS, tE) {\r\n    // To calculate an upper bound for ωf(δS/2) we can either check the max \r\n    // absolute tangent values on curve segments or use the control point \r\n    // lengths as an upper bound.\r\n    const tM = (tE + tS) / 2; // since the formula says `δS/2` so divide by 2\r\n    const psL = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_9__.fromTo)(A, tS, tM);\r\n    const psR = (0,_transformation_split_from_to_js__WEBPACK_IMPORTED_MODULE_9__.fromTo)(A, tM, tE);\r\n    const eL = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__.controlPointLinesLength)(psL);\r\n    const eR = (0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_1__.controlPointLinesLength)(psR);\r\n    return [eL, eR];\r\n}\r\n\r\n//# sourceMappingURL=hausdorff-distance-one-sided.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hausdorffDistance": () => (/* binding */ hausdorffDistance)\n/* harmony export */ });\n/* harmony import */ var _hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hausdorff-distance-one-sided.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance-one-sided.js");\n\r\n/** @internal */\r\nconst max = Math.max;\r\n/**\r\n * Calculates and returns the (two-sided) Hausdorff distance between the bezier\r\n * curves `A` and `B` as `[min,max]` where `min` is the minimum\r\n * guaranteed and `max` is the maximum guaranteed Hausdorff distance. The `min`\r\n * value will be a *much* more accurate result in general.\r\n *\r\n * * partially based off [Computing the Hausdorff distance between two sets of parametric curves](https://www.semanticscholar.org/paper/COMPUTING-THE-HAUSDORFF-DISTANCE-BETWEEN-TWO-SETS-Kim-McLean/d2bd6529c4b118e389e1db209d8f1bf7467f9016)\r\n *\r\n * @param A a bezier curve given by an ordered array of its control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param B a bezier curve given by an ordered array of its control points e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param tolerance optional; defaults to `Math.max(maxAbsCoordinate(A),maxAbsCoordinate(B))/1000_000`;\r\n * if the calculated absolute error bound is less than this, the result is\r\n * returned; this is *not* a hard tolerance and the returned bound can be less\r\n * accurate in hard cases (due to the `maxIterations` parameter). Luckily\r\n * however, specifically the lower bound returned will be very accurate due to\r\n * its fast convergence in such hard cases (see the paper)\r\n * @param maxIterations optional; defaults to `50`; if the desired guaranteed error bound\r\n * has not been achieved after `maxIterations` then the result will be returned\r\n *\r\n * @doc mdx\r\n */\r\nfunction hausdorffDistance(A, B, tolerance, maxIterations) {\r\n    const AB = (0,_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistanceOneSided)(A, B, tolerance, maxIterations);\r\n    const BA = (0,_hausdorff_distance_one_sided_js__WEBPACK_IMPORTED_MODULE_0__.hausdorffDistanceOneSided)(B, A, tolerance, maxIterations);\r\n    return max(AB, BA);\r\n}\r\n\r\n//# sourceMappingURL=hausdorff-distance.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/hausdorff-distance.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/heap.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Heap": () => (/* binding */ Heap)\n/* harmony export */ });\n/**\r\n * see [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))\r\n *\r\n * @internal\r\n */\r\nclass Heap {\r\n    constructor(compare) {\r\n        this.compare = compare;\r\n        this.heap = [];\r\n    }\r\n    insert(t) {\r\n        const heap = this.heap;\r\n        heap.push(t);\r\n        // Swim up\r\n        let i = heap.length - 1;\r\n        while (true) {\r\n            const parentIdx = (i - 1 - (i + 1) % 2) / 2;\r\n            if (parentIdx === -1) {\r\n                return;\r\n            }\r\n            const parent = heap[parentIdx];\r\n            if (this.compare(t, parent) < 0) {\r\n                break;\r\n            }\r\n            // Swap and update indexes and variables\r\n            heap[parentIdx] = t;\r\n            heap[i] = parent;\r\n            i = parentIdx;\r\n        }\r\n    }\r\n    popMax() {\r\n        const heap = this.heap;\r\n        const maxT = heap[0];\r\n        heap[0] = heap[heap.length - 1];\r\n        heap.length--;\r\n        this.swimDown();\r\n        return maxT;\r\n    }\r\n    swimDown() {\r\n        const heap = this.heap;\r\n        const len = heap.length;\r\n        let i = 0;\r\n        // Swim down\r\n        while (true) {\r\n            const leftIdx = 2 * i + 1;\r\n            if (leftIdx >= len) {\r\n                break; // there\'s no left or right child\r\n            }\r\n            const rightIdx = 2 * i + 2;\r\n            const swapIdx = (rightIdx >= len) || (this.compare(heap[leftIdx], heap[rightIdx]) > 0)\r\n                ? leftIdx\r\n                : rightIdx;\r\n            const swapChild = heap[swapIdx];\r\n            const parent = heap[i];\r\n            if (this.compare(parent, swapChild) > 0) {\r\n                break;\r\n            }\r\n            // Swap and update indexes\r\n            heap[swapIdx] = parent;\r\n            heap[i] = swapChild;\r\n            i = swapIdx;\r\n        }\r\n    }\r\n    swapMax(t) {\r\n        this.heap[0] = t;\r\n        this.swimDown();\r\n    }\r\n    /* ignore coverage */\r\n    static getParentIdx(i) { return (i - 1 - (i + 1) % 2) / 2; }\r\n    static getLeftChild(i) { return 2 * i + 1; }\r\n    static getRightChild(i) { return 2 * i + 2; }\r\n}\r\n\r\n//# sourceMappingURL=heap.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/hausdorff-distance/heap.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isPointOnBezierExtension1": () => (/* binding */ isPointOnBezierExtension1)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form1-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form1-dd-with-running-error.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form1-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form1-exact.js");\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\n\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_2__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eEstimate;\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_2__.ddMultDd;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eToDd;\r\nconst abs = Math.abs;\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given line where\r\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an\r\n * element of `[-∞, +∞]`, `false` otherwise.\r\n *\r\n * * there are alternative implementations to this function, e.g. ccw, etc;\r\n * it is kept for symmetry with the order 2 and 3 implementations.\r\n *\r\n * @param ps a linear bezier curve (a line)\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension1(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    {\r\n        //---- pre-filter\r\n        const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = (0,_implicit_form_double_double_get_implicit_form1_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm1DdWithRunningError)(ps);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we\'re not.\r\n        // const h = vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        const _vₓ = abs(vₓ[1]);\r\n        const _vᵧ = abs(vᵧ[1]);\r\n        // we\'re multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const $vₓx = vₓ[1] * x;\r\n        const vₓx = qmq(xd, vₓ);\r\n        const _vₓx = abs($vₓx);\r\n        const vₓx_ = _vₓ * x_ + 2 * _vₓx;\r\n        const $vᵧy = vᵧ[1] * y;\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const _vᵧy = abs($vᵧy);\r\n        const vᵧy_ = _vᵧ * y_ + 2 * _vᵧy;\r\n        // group the terms to reduce error, e.g. `v` usually has the highest bitlength\r\n        //const h = (vₓx + vᵧy) + v;\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const h = qaq(q7, v);\r\n        const h_ = q7_ + v_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    {\r\n        const implictForm = (0,_implicit_form_exact_get_implicit_form1_exact_js__WEBPACK_IMPORTED_MODULE_4__.getImplicitForm1Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // both ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        const { vₓ, vᵧ, v } = implictForm;\r\n        const vₓx = epr(xe, vₓ);\r\n        const vᵧy = epr(ye, vᵧ);\r\n        // const h = vₓ*x + vᵧ*y + v;\r\n        const hh = fes(fes(vₓx, vᵧy), v);\r\n        return sign(hh) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isPointOnBezierExtension2": () => (/* binding */ isPointOnBezierExtension2)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form2.js */ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form2.js");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form2-error-counters.js */ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form2-error-counters.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form2-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form2-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form2-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form2-exact.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_5__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_5__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eToDd;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γ"])(1);\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γγ"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given quadratic bezier curve where\r\n * the parameter `t` is allowed to extend to ±infinity, i.e. `t` is an element of\r\n * `[-∞, +∞]`, `false` otherwise.\r\n *\r\n * @param ps a quadratic bezier curve\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension2(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    //---- first pre-filter\r\n    {\r\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form2_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm2)(ps);\r\n        const { vₓₓ_, // <5>\r\n        vₓᵧ_, // <5>\r\n        vᵧᵧ_, // <5>\r\n        vₓ_, // <8>\r\n        vᵧ_, // <8>\r\n        v_ // <10>\r\n         } = (0,_implicit_form_get_error_counters_get_implicit_form2_error_counters_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm2ErrorCounters)(ps);\r\n        // In the below a a postfix underscore means \r\n        // an error bound (>= absolute value)\r\n        // `h` (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we\'re not.\r\n        // In the below, if x is given as a double then the error counter on\r\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\r\n        // error counter with a <D> so that for a point with double precion \r\n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\r\n        // `0` if we have only double precision coordinates, `1` otherwise\r\n        const D = isDouble ? 0 : 1;\r\n        const x_ = abs(x); // <D>x\r\n        const y_ = abs(y); // <D>y\r\n        const xx_ = x_ * x_; // <2D+1>xx\r\n        const xy_ = x_ * y_; // <2D+1>xy\r\n        const yy_ = y_ * y_; // <2D+1>yy\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        const h = (((vₓₓ * x * x + vₓᵧ * x * y) +\r\n            vᵧᵧ * y * y) +\r\n            (vₓ * x + vᵧ * y)) +\r\n            v;\r\n        // <D+12>h <-- <D+12>(<D+11>(<2D+9>(<2D+8> + <2D+7>) + <D+10>) + <10>);\r\n        const h_ = ((\r\n        // <2D+8>(<2D+7>(<5>vₓₓ*<2D+1>(xx)) + <2D+7>(<5>vₓᵧ*<2D+1>(xy)))\r\n        (vₓₓ_ * xx_ + vₓᵧ_ * xy_) +\r\n            // <2D+7>(<5>vᵧᵧ*<2D+1>(xy))\r\n            vᵧᵧ_ * yy_) + (\r\n        // <D+10>(<D+9>(<8>vₓ*<D>x) + <D+9>(<8>vᵧ*<D>y))\r\n        vₓ_ * x_ + vᵧ_ * y_)) +\r\n            // <10>v\r\n            v_;\r\n        // if the error is not too high too discern h away from zero\r\n        if ((D + 12) * γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - const\'s try double-double precision\r\n    {\r\n        const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form2_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm2DdWithRunningError)(ps);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we\'re not.\r\n        // const h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        // we\'re multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const xx = qmq(xd, xd);\r\n        const _xx = xx[1];\r\n        const xx_ = 2 * (_x * x_ + _xx);\r\n        const yy = qmq(yd, yd);\r\n        const _yy = yy[1];\r\n        const yy_ = 2 * (_y * y_ + _yy);\r\n        const xy = qmq(xd, yd);\r\n        const _xy = abs(xy[1]);\r\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\r\n        const vₓₓxx = qmq(vₓₓ, xx);\r\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\r\n        const vₓᵧxy = qmq(vₓᵧ, xy);\r\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\r\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\r\n        const vₓx = qmq(xd, vₓ);\r\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //const h = \r\n        //    (\r\n        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + \r\n        //      (vₓx + vᵧy)\r\n        //    ) + \r\n        //    v;\r\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        const q5 = qaq(q4, vᵧᵧyy);\r\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const q8 = qaq(q5, q7);\r\n        const q8_ = q5_ + q7_ + abs(q8[1]);\r\n        const h = qaq(q8, v);\r\n        const h_ = q8_ + v_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - let\'s go exact\r\n    {\r\n        let implictForm = (0,_implicit_form_exact_get_implicit_form2_exact_js__WEBPACK_IMPORTED_MODULE_3__.getImplicitForm2Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // all ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        if (!implictForm.hasOwnProperty(\'vₓₓ\')) {\r\n            implictForm.vₓₓ = [0];\r\n            implictForm.vₓᵧ = [0];\r\n            implictForm.vᵧᵧ = [0];\r\n        }\r\n        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\r\n        // h (say height) is the the result of evaluating the implicit equation; \r\n        // if it is 0 we are on the curve, else we\'re not.\r\n        // const h =\r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const h = fes(fes(fes(epr(vₓₓ, epr(xe, xe)), epr(vₓᵧ, epr(xe, ye))), epr(vᵧᵧ, epr(ye, ye))), fes(fes(epr(xe, vₓ), epr(ye, vᵧ)), v));\r\n        return sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isPointOnBezierExtension3": () => (/* binding */ isPointOnBezierExtension3)\n/* harmony export */ });\n/* harmony import */ var _implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../implicit-form/double/get-implicit-form3.js */ "./node_modules/flo-bezier3/node/implicit-form/double/get-implicit-form3.js");\n/* harmony import */ var _implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../implicit-form/get-error-counters/get-implicit-form3-error-counters.js */ "./node_modules/flo-bezier3/node/implicit-form/get-error-counters/get-implicit-form3-error-counters.js");\n/* harmony import */ var _implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../implicit-form/double-double/get-implicit-form3-dd-with-running-error.js */ "./node_modules/flo-bezier3/node/implicit-form/double-double/get-implicit-form3-dd-with-running-error.js");\n/* harmony import */ var _implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../implicit-form/exact/get-implicit-form3-exact.js */ "./node_modules/flo-bezier3/node/implicit-form/exact/get-implicit-form3-exact.js");\n/* harmony import */ var _error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/error-analysis.js */ "./node_modules/flo-bezier3/node/error-analysis/error-analysis.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\n\r\n\r\nconst qmq = double_double__WEBPACK_IMPORTED_MODULE_5__.ddMultDd;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_5__.ddAddDd;\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.expansionProduct;\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.fastExpansionSum;\r\nconst sign = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eEstimate;\r\nconst etodd = big_float_ts__WEBPACK_IMPORTED_MODULE_6__.eToDd;\r\nconst abs = Math.abs;\r\nconst γ1 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γ"])(1);\r\nconst γγ3 = (0,_error_analysis_error_analysis_js__WEBPACK_IMPORTED_MODULE_4__["γγ"])(3);\r\n/**\r\n * Returns `true` if the given point is on the given cubic bezier curve where\r\n * the parameter, `t`, is allowed to extend to `±∞`, i.e. if `t ∈ (-∞, +∞)`,\r\n * `false` otherwise.\r\n *\r\n * @param ps a cubic bezier curve\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n *\r\n * @internal\r\n */\r\nfunction isPointOnBezierExtension3(ps, p) {\r\n    const [xe, ye] = p;\r\n    const lenX = xe.length;\r\n    const lenY = ye.length;\r\n    const x = xe[lenX - 1]; // get higest order double\r\n    const y = ye[lenY - 1]; // ...\r\n    const isDouble = (lenX === 1 && lenY === 1);\r\n    //---- first pre-filter\r\n    {\r\n        // The below takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = (0,_implicit_form_double_get_implicit_form3_js__WEBPACK_IMPORTED_MODULE_0__.getImplicitForm3)(ps);\r\n        const { vₓₓₓ_, // <11>\r\n        vₓₓᵧ_, // <12>\r\n        vₓᵧᵧ_, // <12>\r\n        vᵧᵧᵧ_, // <11>\r\n        vₓₓ_, // <19>\r\n        vₓᵧ_, // <18>\r\n        vᵧᵧ_, // <19>\r\n        vₓ_, // <22>\r\n        vᵧ_, // <22>\r\n        v_ // <24>\r\n         } = (0,_implicit_form_get_error_counters_get_implicit_form3_error_counters_js__WEBPACK_IMPORTED_MODULE_1__.getImplicitForm3ErrorCounters)(ps);\r\n        // In the below a a postfix underscore means \r\n        // an error bound (>= absolute value)\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we\'re not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        // const h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        const xx = x * x;\r\n        const yy = y * y;\r\n        const h = (((vₓₓₓ * (xx * x) + vₓₓᵧ * (xx * y)) +\r\n            (vₓᵧᵧ * (x * yy) + vᵧᵧᵧ * (yy * y))) +\r\n            ((vₓₓ * xx + vₓᵧ * (x * y)) + vᵧᵧ * yy)) +\r\n            ((vₓ * x + vᵧ * y) +\r\n                v);\r\n        //-------------------\r\n        // Error calculation\r\n        //-------------------\r\n        // In the below, if x is given as a double then the error counter on\r\n        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the\r\n        // error counter with a <D> so that for a point with double precion \r\n        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.\r\n        // `0` if we have only double precision coordinates, `1` otherwise\r\n        const D = isDouble ? 0 : 1;\r\n        const x_ = abs(x); // <D>x\r\n        const y_ = abs(y); // <D>y\r\n        const xx_ = x_ * x_; // <2D+1>xx\r\n        const xy_ = x_ * y_; // <2D+1>xy\r\n        const yy_ = y_ * y_; // <2D+1>yy\r\n        // <D+26>h <-- <D+26>(<2D+24>(<3D+17>(<3D+16> + <3D+16>) + <2D+23>) + <D+25>(<D+24> + <24>))\r\n        const h_ = (\r\n        // <3D+16> <-- <3D+16>((<3D+14>(<11>vₓₓₓ*<3D+2>(xx*x)) + <3D+15>(<12>vₓₓᵧ*<3D+2>(xx*y)))) +\r\n        (vₓₓₓ_ * (xx_ * x_) + vₓₓᵧ_ * (xx_ * y_)) +\r\n            // <3D+16> <-- <3D+16>((<3D+15>(<12>vₓᵧᵧ*<3D+2>(x*yy)) + <3D+14>(<11>vᵧᵧᵧ*<3D+2>(yy*y)))) +\r\n            (vₓᵧᵧ_ * (x_ * yy_) + vᵧᵧᵧ_ * (yy_ * y_)) +\r\n            // <2D+23> <-- <2D+23>(<2D+22>(<2D+21>(<19>vₓₓ*<2D+1>xx) + <2D+20>(<18>vₓᵧ*<2D+1>(x*y))) + <2D+20>(<18>vᵧᵧ*<2D+1>yy))\r\n            ((vₓₓ_ * xx_ + vₓᵧ_ * (xy_)) + vᵧᵧ_ * yy_)) +\r\n            (\r\n            // <24> <-- <D+24>(<D+23>(<22>vₓ*<D>x) + <D+23>(<22>vᵧ*<D>y))\r\n            (vₓ_ * x_ + vᵧ_ * y_) +\r\n                // <24>\r\n                v_);\r\n        // if the error is not too high too discern `h` away from zero\r\n        if ((D + 26) * γ1 * h_ < abs(h)) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error too high - let\'s try double-double precision\r\n    {\r\n        // The below takes about 15 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = (0,_implicit_form_double_double_get_implicit_form3_dd_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.getImplicitForm3DdWithRunningError)(ps);\r\n        const _vₓₓₓ = abs(vₓₓₓ[1]);\r\n        const _vₓₓᵧ = abs(vₓₓᵧ[1]);\r\n        const _vₓᵧᵧ = abs(vₓᵧᵧ[1]);\r\n        const _vᵧᵧᵧ = abs(vᵧᵧᵧ[1]);\r\n        // In the below a prefix underscore on a variable means absolute value, \r\n        // a postfix underscore means error bound (before multiplication by gamma).\r\n        // h (say height) is the the result of evaluating the implicit equation; if\r\n        // it is 0 we are on the curve, else we\'re not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xd = etodd(xe);\r\n        const yd = etodd(ye);\r\n        const _x = abs(x);\r\n        const _y = abs(y);\r\n        // we\'re multiplying by `γγ3` at the end but the error `x_` is only `γγ1`\r\n        // and hence we need to divide the error by 3.\r\n        const x_ = _x / 3;\r\n        const y_ = _y / 3;\r\n        const xx = qmq(xd, xd);\r\n        const _xx = xx[1];\r\n        const xx_ = 2 * (_x * x_ + _xx);\r\n        const xxx = qmq(xd, xx);\r\n        const _xxx = abs(xxx[1]);\r\n        const xxx_ = _x * xx_ + x_ * _xx + 2 * _xxx;\r\n        const yy = qmq(yd, yd);\r\n        const _yy = yy[1];\r\n        const yy_ = 2 * (_y * y_ + _yy);\r\n        const yyy = qmq(yd, yy);\r\n        const _yyy = abs(yyy[1]);\r\n        const yyy_ = _y * yy_ + y_ * _yy + 2 * _yyy;\r\n        const xxy = qmq(yd, xx);\r\n        const _xxy = abs(xxy[1]);\r\n        const xxy_ = _y * xx_ + y_ * _xx + 2 * _xxy;\r\n        const xyy = qmq(xd, yy);\r\n        const _xyy = abs(xyy[1]);\r\n        const xyy_ = _x * yy_ + x_ * _yy + 2 * _xyy;\r\n        const xy = qmq(xd, yd);\r\n        const _xy = abs(xy[1]);\r\n        const xy_ = _x * y_ + x_ * _y + 2 * _xy;\r\n        const vₓₓₓxxx = qmq(vₓₓₓ, xxx);\r\n        const vₓₓₓxxx_ = _vₓₓₓ * xxx_ + vₓₓₓ_ * _xxx + 2 * abs(vₓₓₓxxx[1]);\r\n        const vₓₓᵧxxy = qmq(vₓₓᵧ, xxy);\r\n        const vₓₓᵧxxy_ = _vₓₓᵧ * xxy_ + vₓₓᵧ_ * _xxy + 2 * abs(vₓₓᵧxxy[1]);\r\n        const vₓᵧᵧxyy = qmq(vₓᵧᵧ, xyy);\r\n        const vₓᵧᵧxyy_ = _vₓᵧᵧ * xyy_ + vₓᵧᵧ_ * _xyy + 2 * abs(vₓᵧᵧxyy[1]);\r\n        const vᵧᵧᵧyyy = qmq(vᵧᵧᵧ, yyy);\r\n        const vᵧᵧᵧyyy_ = _vᵧᵧᵧ * yyy_ + vᵧᵧᵧ_ * _yyy + 2 * abs(vᵧᵧᵧyyy[1]);\r\n        const vₓₓxx = qmq(vₓₓ, xx);\r\n        const vₓₓxx_ = abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * abs(vₓₓxx[1]);\r\n        const vₓᵧxy = qmq(vₓᵧ, xy);\r\n        const vₓᵧxy_ = abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * abs(vₓᵧxy[1]);\r\n        const vᵧᵧyy = qmq(vᵧᵧ, yy);\r\n        const vᵧᵧyy_ = abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * abs(vᵧᵧyy[1]);\r\n        const vₓx = qmq(xd, vₓ);\r\n        const vₓx_ = abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * abs(vₓx[1]);\r\n        const vᵧy = qmq(yd, vᵧ);\r\n        const vᵧy_ = abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * abs(vᵧy[1]);\r\n        // group the terms to reduce error, e.g. v usually has the highest bitlength\r\n        //const h = \r\n        //    (\r\n        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + \r\n        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)\r\n        //    ) + \r\n        //    (\r\n        //        (vₓx + vᵧy) + \r\n        //        v\r\n        //    );\r\n        const q1 = qaq(vₓₓₓxxx, vₓₓᵧxxy);\r\n        const q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + abs(q1[1]);\r\n        const q2 = qaq(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        const q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + abs(q2[1]);\r\n        const q3 = qaq(q1, q2);\r\n        const q3_ = q1_ + q2_ + abs(q3[1]);\r\n        const q4 = qaq(vₓₓxx, vₓᵧxy);\r\n        const q4_ = vₓₓxx_ + vₓᵧxy_ + abs(q4[1]);\r\n        const q5 = qaq(q4, vᵧᵧyy);\r\n        const q5_ = q4_ + vᵧᵧyy_ + abs(q5[1]);\r\n        const q6 = qaq(q3, q5);\r\n        const q6_ = q3_ + q5_ + abs(q6[1]);\r\n        const q7 = qaq(vₓx, vᵧy);\r\n        const q7_ = vₓx_ + vᵧy_ + abs(q7[1]);\r\n        const q8 = qaq(q7, v);\r\n        const q8_ = q7_ + v_ + abs(q8[1]);\r\n        const h = qaq(q6, q8);\r\n        const h_ = q6_ + q8_ + abs(h[1]);\r\n        // if the error is not too high too discern h away from zero\r\n        if (γγ3 * h_ < abs(estimate(h))) {\r\n            return false; // <-- prefilter applied\r\n        }\r\n    }\r\n    // error still too high - const\'s go exact\r\n    {\r\n        // The below takes about 155 micro-seconds on a 1st gen i7 and Chrome 79\r\n        const implictForm = (0,_implicit_form_exact_get_implicit_form3_exact_js__WEBPACK_IMPORTED_MODULE_3__.getImplicitForm3Exact)(ps);\r\n        if (implictForm === undefined) {\r\n            // all ps are the same point\r\n            return isDouble && x === ps[0][0] && y === ps[0][1];\r\n        }\r\n        if (!implictForm.hasOwnProperty(\'vₓₓₓ\')) {\r\n            implictForm.vₓₓₓ = [0];\r\n            implictForm.vₓₓᵧ = [0];\r\n            implictForm.vₓᵧᵧ = [0];\r\n            implictForm.vᵧᵧᵧ = [0];\r\n        }\r\n        if (!implictForm.hasOwnProperty(\'vₓₓ\')) {\r\n            implictForm.vₓₓ = [0];\r\n            implictForm.vₓᵧ = [0];\r\n            implictForm.vᵧᵧ = [0];\r\n        }\r\n        let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;\r\n        // `h` (say height) is the the result of evaluating the implicit \r\n        // equation; if it is 0 we are on the curve, else we\'re not.\r\n        // const h =\r\n        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + \r\n        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;\r\n        const xx = epr(xe, xe); // <= error free\r\n        const xxx = epr(xe, xx);\r\n        const yy = epr(ye, ye); // <= error free\r\n        const yyy = epr(ye, yy);\r\n        const xxy = epr(ye, xx);\r\n        const xyy = epr(xe, yy);\r\n        const xy = epr(xe, ye); // <= error free\r\n        const vₓₓₓxxx = epr(vₓₓₓ, xxx);\r\n        const vₓₓᵧxxy = epr(vₓₓᵧ, xxy);\r\n        const vₓᵧᵧxyy = epr(vₓᵧᵧ, xyy);\r\n        const vᵧᵧᵧyyy = epr(vᵧᵧᵧ, yyy);\r\n        const vₓₓxx = epr(vₓₓ, xx);\r\n        const vₓᵧxy = epr(vₓᵧ, xy);\r\n        const vᵧᵧyy = epr(vᵧᵧ, yy);\r\n        const vₓx = epr(xe, vₓ);\r\n        const vᵧy = epr(ye, vᵧ);\r\n        const q1 = fes(vₓₓₓxxx, vₓₓᵧxxy);\r\n        const q2 = fes(vₓᵧᵧxyy, vᵧᵧᵧyyy);\r\n        const q3 = fes(q1, q2);\r\n        const q4 = fes(vₓₓxx, vₓᵧxy);\r\n        const q5 = fes(q4, vᵧᵧyy);\r\n        const q6 = fes(q3, q5);\r\n        const q7 = fes(vₓx, vᵧy);\r\n        const q8 = fes(q7, v);\r\n        const h = fes(q6, q8);\r\n        return sign(h) === 0; // <= calculation was exact\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension-3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js?')},"./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isPointOnBezierExtension": () => (/* binding */ isPointOnBezierExtension)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-point-on-bezier-extension-1.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.js");\n/* harmony import */ var _is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-point-on-bezier-extension-2.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.js");\n/* harmony import */ var _is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-point-on-bezier-extension-3.js */ "./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns `true` if the given point is on the given bezier curve where the\r\n * parameter `t` is allowed to extend to ±∞, i.e. `t` is an element of\r\n * `(-∞, +∞)`, `false` otherwise.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n * @param p a point with coordinates given as [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)\r\n * expansions; if only double precision coordinates need to be provided then\r\n * wrap them in a one element array, e.g. for a point with `x` and `y` coordinates\r\n * of `1` and `2` set `p === [[1],[2]]`.\r\n */\r\nfunction isPointOnBezierExtension(ps, p) {\r\n    if (ps.length === 4) {\r\n        return (0,_is_point_on_bezier_extension_3_js__WEBPACK_IMPORTED_MODULE_3__.isPointOnBezierExtension3)(ps, p);\r\n    }\r\n    if (ps.length === 3) {\r\n        return (0,_is_point_on_bezier_extension_2_js__WEBPACK_IMPORTED_MODULE_2__.isPointOnBezierExtension2)(ps, p);\r\n    }\r\n    if (ps.length === 2) {\r\n        return (0,_is_point_on_bezier_extension_1_js__WEBPACK_IMPORTED_MODULE_1__.isPointOnBezierExtension1)(ps, p);\r\n    }\r\n    if (ps.length === 1) {\r\n        const x = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompress)(p[0]);\r\n        const y = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompress)(p[1]);\r\n        return (x.length === 1 && y.length === 1 &&\r\n            x[0] === ps[0][0] && y[0] === ps[0][1]);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3\');\r\n}\r\n\r\n//# sourceMappingURL=is-point-on-bezier-extension.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.js?')},"./node_modules/flo-bezier3/node/sub-1-ulp.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sub1Ulp": () => (/* binding */ sub1Ulp)\n/* harmony export */ });\nconst { EPSILON: eps } = Number;\r\nconst u = eps / 2;\r\nconst es = (eps ** 2) / 2;\r\nconst ups = u + es;\r\n/**\r\n * Subtract one unit in the last place (ulp) from the given number\r\n *\r\n * * subnormal numbers (and 0) are returned unaltered\r\n * @internal\r\n */\r\nfunction sub1Ulp(n) {\r\n    return n > 0 ? n - n * ups : n + n * ups;\r\n}\r\n\r\n//# sourceMappingURL=sub-1-ulp.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/sub-1-ulp.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_1stDerivativeDd": () => (/* binding */ toPowerBasis_1stDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_0__.twoSum; // error -> 0\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\r\n/**\r\n * Returns the derivative of the power basis representation of a bezier\r\n * curve of order cubic or less (with intermediate calculations done in\r\n * double-double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_1stDerivativeDd(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3_1stDerivativeDd(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2_1stDerivativeDd(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1_1stDerivativeDd(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[[0, 0]], [[0, 0]]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3_1stDerivativeDd(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            qmd(3, qaq(td(x3, x0), qmd(3, td(x1, x2)))),\r\n            qmd(6, qad(ts(x2, x0), -2 * x1)),\r\n            qmd(3, td(x1, x0))\r\n        ], [\r\n            qmd(3, qaq(td(y3, y0), qmd(3, td(y1, y2)))),\r\n            qmd(6, qad(ts(y2, y0), -2 * y1)),\r\n            qmd(3, td(y1, y0))\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2_1stDerivativeDd(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            qad(ts(2 * x2, 2 * x0), -4 * x1),\r\n            td(2 * x1, 2 * x0),\r\n        ], [\r\n            qad(ts(2 * y2, 2 * y0), -4 * y1),\r\n            td(2 * y1, 2 * y0),\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1_1stDerivativeDd(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            td(x1, x0),\r\n        ], [\r\n            td(y1, y0),\r\n        ]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-1st-derivative-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double-double/to-power-basis-1st-derivative-dd.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toPowerBasis_1stDerivative\": () => (/* binding */ toPowerBasis_1stDerivative)\n/* harmony export */ });\n/**\r\n * Returns the derivative of the power basis representation of a\r\n * bezier curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_1stDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1_1stDerivative(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            3 * ((x3 - x0) + 3 * (x1 - x2)),\r\n            6 * ((x2 + x0) - 2 * x1),\r\n            3 * (x1 - x0)\r\n        ], [\r\n            3 * ((y3 - y0) + 3 * (y1 - y2)),\r\n            6 * ((y2 + y0) - 2 * y1),\r\n            3 * (y1 - y0)\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            2 * ((x2 + x0) - 2 * x1),\r\n            2 * (x1 - x0)\r\n        ], [\r\n            2 * ((y2 + y0) - 2 * y1),\r\n            2 * (y1 - y0)\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1_1stDerivative(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            x1 - x0\r\n        ], [\r\n            y1 - y0\r\n        ]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-1st-derivative.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/double/to-power-basis-1st-derivative.js?")},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_1stDerivativeExact": () => (/* binding */ toPowerBasis_1stDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\n/**\r\n * Returns the *exact* derivative of the power basis representation of a\r\n * bezier curve of order cubic or less.\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\r\n * expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_1stDerivativeExact(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3_1stDerivativeExact(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2_1stDerivativeExact(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1_1stDerivativeExact(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[[0]], [[0]]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3_1stDerivativeExact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            sce(3, eadd(td(x3, x0), sce(3, td(x1, x2)))),\r\n            sce(6, ge(ts(x2, x0), -2 * x1)),\r\n            sce(3, td(x1, x0))\r\n        ], [\r\n            sce(3, eadd(td(y3, y0), sce(3, td(y1, y2)))),\r\n            sce(6, ge(ts(y2, y0), -2 * y1)),\r\n            sce(3, td(y1, y0))\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2_1stDerivativeExact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            ge(ts(2 * x2, 2 * x0), -4 * x1),\r\n            td(2 * x1, 2 * x0),\r\n        ], [\r\n            ge(ts(2 * y2, 2 * y0), -4 * y1),\r\n            td(2 * y1, 2 * y0),\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1_1stDerivativeExact(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            td(x1, x0),\r\n        ], [\r\n            td(y1, y0),\r\n        ]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-1st-derivative-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/exact/to-power-basis-1st-derivative-exact.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toPowerBasis_1stDerivativeErrorCounters\": () => (/* binding */ toPowerBasis_1stDerivativeErrorCounters)\n/* harmony export */ });\n// For double precision the error bound === γ * <counter> * `error_`\r\n// For double-double precision the error bound === γγ3 * <counter> * `error_`\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the derivative of the power basis\r\n * representation of a bezier curve of order <= 3 (using\r\n * e.g. `toPowerBasis_1stDerivative` or `toPowerBasis_1stDerivativeDd`).\r\n *\r\n * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * The `D` in the error counter formula is zero for double precision and 1 for\r\n * double-double precision.\r\n *\r\n * ```\r\n * // for cubic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tX2,  // <E> === D+3 (D = 0 for double, 1 for double-double precision)\r\n * \t\tX1,  // <E> === D+2\r\n * \t\tX0   // <E> === D+3\r\n * \t],\r\n * \t[\r\n * \t\tY2,  // <E> === D+3\r\n * \t\tY1,  // <E> === D+2\r\n * \t\tY0   // <E> === D+3\r\n * \t]\r\n * ]\r\n *\r\n * // for quadratic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tX1,  // <E> === D+1 (D = 0 for double, 1 for double-double precision)\r\n * \t\tX0   // <E> === D\r\n * \t],\r\n * \t[\r\n * \t\tY1,  // <E> === D+1\r\n * \t\tY0   // <E> === D\r\n * \t]\r\n * ];\r\n *\r\n * // for linear bezier curves (i.e. lines)\r\n * return [\r\n * \t[\r\n * \t\tX0_  // <E> === D (D = 0 for double, 1 for double-double precision)\r\n * \t],\r\n * \t[\r\n * \t\tY0_  // <E> === D\r\n * \t]\r\n * ];\r\n * ```\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction toPowerBasis_1stDerivativeErrorCounters(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3_1stDerivativeErrorCounters(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2_1stDerivativeErrorCounters(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1_1stDerivativeErrorCounters(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1_1stDerivativeErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // If intermediate calculations are done in double precision then:\r\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\r\n    return [\r\n        [\r\n            // <D> <= <D>(<0>x1 - <0>x0)\r\n            _x1 + _x0, // <D>\r\n        ], [\r\n            _y1 + _y0, // <D>\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2_1stDerivativeErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    // If intermediate calculations are done in double precision then:\r\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\r\n    return [\r\n        [\r\n            2 * ((_x2 + _x0) + 2 * _x1),\r\n            2 * (_x1 + _x0) // <D> <-- 2*<D>(x1 - x0)\r\n        ], [\r\n            2 * ((_y2 + _y0) + 2 * _y1),\r\n            2 * (_y1 + _y0)\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3_1stDerivativeErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _x3 = abs(x3);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _y3 = abs(y3);\r\n    // If intermediate calculations are done in double precision then:\r\n    // `<D> === <1>` else if double-double precision then `<D> === <0>`.\r\n    return [\r\n        [\r\n            // <D+3> <-- <D+3>(3*(<D+2>(<D>(x3 - x0) + <D+1>(3*<D>(x1 - x2)))))\r\n            3 * ((_x3 + _x0) + 3 * (_x1 + _x2)),\r\n            // <D+2> <-- <D+2>(6*<D+1>(<D>(x2 + x0) - 2*x1))\r\n            6 * ((_x2 + _x0) + 2 * _x1),\r\n            // <D+1> <-- <D+1>(3*<D>(x1 - x0))\r\n            3 * (_x1 + _x0)\r\n        ], [\r\n            3 * ((_y3 + _y0) + 3 * (_y1 + _y2)),\r\n            6 * ((_y2 + _y0) + 2 * _y1),\r\n            3 * (_y1 + _y0)\r\n        ]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-1st-derivative-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-1st-derivative/to-power-basis-1st-derivative-error-counters.js?")},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_2ndDerivativeDd": () => (/* binding */ toPowerBasis_2ndDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble;\r\n/**\r\n * Returns the 2nd derivative of the power basis representation of a bezier\r\n * curve of order cubic or less (with intermediate calculations done in\r\n * double-double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_2ndDerivativeDd(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                qmd(6, (qaq(td(x3, x0), qmd(3, (td(x1, x2)))))),\r\n                qmd(6, (qad(td(x2, 2 * x1), x0)))\r\n            ], [\r\n                qmd(6, (qaq(td(y3, y0), qmd(3, (td(y1, y2)))))),\r\n                qmd(6, (qad(td(y2, 2 * y1), y0)))\r\n            ]];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                qad(td(2 * x2, 4 * x1), 2 * x0)\r\n            ], [\r\n                qad(td(2 * y2, 4 * y1), 2 * y0)\r\n            ]];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[[0]], [[0]]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-2nd-derivative-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double-double/to-power-basis-2nd-derivative-dd.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toPowerBasis_2ndDerivative\": () => (/* binding */ toPowerBasis_2ndDerivative)\n/* harmony export */ });\n/**\r\n * Returns the 2nd derivative of the power basis representation of a\r\n * bezier curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_2ndDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                6 * ((x3 - x0) + 3 * (x1 - x2)),\r\n                6 * ((x2 + x0) - 2 * x1)\r\n            ], [\r\n                6 * ((y3 - y0) + 3 * (y1 - y2)),\r\n                6 * ((y2 + y0) - 2 * y1)\r\n            ]];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                2 * (x2 - 2 * x1 + x0)\r\n            ], [\r\n                2 * (y2 - 2 * y1 + y0)\r\n            ]];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-2nd-derivative.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/double/to-power-basis-2nd-derivative.js?")},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_2ndDerivativeExact": () => (/* binding */ toPowerBasis_2ndDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\n/**\r\n * Returns the *exact* 2nd derivative of the power basis representation of a\r\n * bezier curve of order cubic or less.\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\r\n * expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_2ndDerivativeExact(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [[\r\n                sce(6, (eadd(td(x3, x0), sce(3, (td(x1, x2)))))),\r\n                sce(6, (ge(td(x2, 2 * x1), x0)))\r\n            ], [\r\n                sce(6, (eadd(td(y3, y0), sce(3, (td(y1, y2)))))),\r\n                sce(6, (ge(td(y2, 2 * y1), y0)))\r\n            ]];\r\n    }\r\n    if (ps.length === 3) {\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [[\r\n                ge(td(2 * x2, 4 * x1), 2 * x0)\r\n            ], [\r\n                ge(td(2 * y2, 4 * y1), 2 * y0)\r\n            ]];\r\n    }\r\n    if (ps.length <= 2) {\r\n        return [[[0]], [[0]]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-2nd-derivative-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-2nd-derivative/exact/to-power-basis-2nd-derivative-exact.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_3rdDerivativeDd": () => (/* binding */ toPowerBasis_3rdDerivativeDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\n/**\r\n * Returns the 3rd derivative of the power basis representation of a bezier\r\n * curve of order cubic or less (with intermediate calculations done in\r\n * double-double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are in double-double precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_3rdDerivativeDd(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            qmd(6, qaq(td(x3, x0), qmd(3, td(x1, x2)))),\r\n            qmd(6, qaq(td(y3, y0), qmd(3, td(y1, y2))))\r\n        ];\r\n    }\r\n    if (ps.length <= 3) {\r\n        return [[0, 0], [0, 0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], \r\n    // then max(dddx)(t) <= 48*X for all t.\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-3rd-derivative-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double-double/to-power-basis-3rd-derivative-dd.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toPowerBasis_3rdDerivative\": () => (/* binding */ toPowerBasis_3rdDerivative)\n/* harmony export */ });\n/**\r\n * Returns the 3rd derivative of the power basis representation of a bezier\r\n * curve of order cubic or less (with intermediate calculations done in\r\n * double precision).\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_3rdDerivative(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            6 * ((x3 - x0) + 3 * (x1 - x2)),\r\n            6 * ((y3 - y0) + 3 * (y1 - y2))\r\n        ];\r\n    }\r\n    if (ps.length <= 3) {\r\n        return [0, 0];\r\n    }\r\n    throw new Error('The given bezier curve must be of order <= 3.');\r\n    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], \r\n    // then max(dddx)(t) <= 48*X for all t.\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-3rd-derivative.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/double/to-power-basis-3rd-derivative.js?")},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis_3rdDerivativeExact": () => (/* binding */ toPowerBasis_3rdDerivativeExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst eadd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\n/**\r\n * Returns the *exact* 3rd derivative of the power basis representation of a\r\n * bezier curve of order cubic or less.\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\r\n * expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis_3rdDerivativeExact(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            sce(6, eadd(td(x3, x0), sce(3, td(x1, x2)))),\r\n            sce(6, eadd(td(y3, y0), sce(3, td(y1, y2))))\r\n        ];\r\n    }\r\n    else if (ps.length <= 3) {\r\n        return [[0], [0]];\r\n    }\r\n    // Note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], then\r\n    // max(dddx)(t) <= 48*X for all t.\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-3rd-derivative-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis-3rd-derivative/exact/to-power-basis-3rd-derivative-exact.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis1DdWithRunningError": () => (/* binding */ toPowerBasis1DdWithRunningError),\n/* harmony export */   "toPowerBasis2DdWithRunningError": () => (/* binding */ toPowerBasis2DdWithRunningError),\n/* harmony export */   "toPowerBasis3DdWithRunningError": () => (/* binding */ toPowerBasis3DdWithRunningError),\n/* harmony export */   "toPowerBasisDdWithRunningError": () => (/* binding */ toPowerBasisDdWithRunningError)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\r\nconst abs = Math.abs;\r\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less including a coefficient-wise absolute error bound that need to be multiplied\r\n * by `γγ(3)`\r\n *\r\n * * intermediate calculations done in double-double precision\r\n * * the error bound need to be multiplied by `γγ(3) === 3.697785493223493e-32` before use\r\n * * returns the power basis x and y coordinate polynomials from highest power\r\n * to lowest, e.g. if `x(t) = at^3 + bt^2 + ct + d`\r\n * and `y(t) = et^3 + ft^2 + gt + h` then the result is returned\r\n * as `[[a,b,c,d],[e,f,g,h]]`, where the `a,b,c,...` are in double-double\r\n * precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisDdWithRunningError(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3DdWithRunningError(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2DdWithRunningError(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return {\r\n            coeffs: toPowerBasis1DdWithRunningError(ps),\r\n            errorBound: [[0, 0], [0, 0]]\r\n        };\r\n    }\r\n    if (ps.length === 1) {\r\n        return {\r\n            coeffs: toPowerBasis0DdWithRunningError(ps),\r\n            errorBound: [[0], [0]]\r\n        };\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= cubic.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // ----------------------------\r\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\r\n    // ----------------------------\r\n    const xa = td(x3, x0); // error free\r\n    const xb = td(x1, x2); // error free\r\n    const $xc = 3 * (x1 - x2);\r\n    const xc = qmd(3, xb);\r\n    const _xc_ = abs($xc);\r\n    const xx3 = qaq(xa, xc);\r\n    const xx3_ = _xc_ + abs(x3 - x0 + $xc);\r\n    // ----------------------------\r\n    // xx2 = 3*(x2 - 2*x1 + x0)\r\n    // ----------------------------\r\n    const xd = td(x2, 2 * x1); // error free\r\n    const xe = qad(xd, x0);\r\n    const _xe_ = abs(x2 - 2 * x1 + x0);\r\n    const xx2 = qmd(3, xe);\r\n    //const xx2_ = 3*_xe_ + 3*_xe_;\r\n    const xx2_ = 6 * _xe_;\r\n    // ----------------------------\r\n    // xx1 = 3*(x1 - x0)\r\n    // ----------------------------\r\n    const xg = td(x1, x0); // error free\r\n    const xx1 = qmd(3, xg);\r\n    const xx1_ = abs(3 * (x1 - x0));\r\n    // ----------------------------\r\n    // yy3 = y3 + 3*(y1 - y2) - y0\r\n    // ----------------------------\r\n    const ya = td(y3, y0); // error free\r\n    const yb = td(y1, y2); // error free\r\n    const $yc = 3 * (y1 - y2);\r\n    const yc = qmd(3, yb);\r\n    const _yc_ = abs($yc);\r\n    const yy3 = qaq(ya, yc);\r\n    const yy3_ = _yc_ + abs(y3 - y0 + $yc);\r\n    // ----------------------------\r\n    // yy2 = 3*(y2 - 2*y1 + y0)\r\n    // ----------------------------\r\n    const yd = td(y2, 2 * y1); // error free\r\n    const ye = qad(yd, y0);\r\n    const _ye_ = abs(y2 - 2 * y1 + y0);\r\n    const yy2 = qmd(3, ye);\r\n    //const yy2_ = 3*_ye_ + 3*_ye_;\r\n    const yy2_ = 6 * _ye_;\r\n    // ----------------------------\r\n    // yy1 = 3*(y1 - y0)\r\n    // ----------------------------\r\n    const yg = td(y1, y0); // error free\r\n    const yy1 = qmd(3, yg);\r\n    const yy1_ = abs(3 * (y1 - y0));\r\n    return {\r\n        coeffs: [[xx3, xx2, xx1, [0, x0]], [yy3, yy2, yy1, [0, y0]]],\r\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // ---------------------\r\n    // xx2 = x2 - 2*x1 + x0\r\n    // ---------------------\r\n    const $a = x2 - 2 * x1;\r\n    const a = td(x2, 2 * x1); // error free\r\n    const xx2 = qad(a, x0);\r\n    const xx2_ = abs($a + x0);\r\n    // ---------------------\r\n    // xx1 = 2*(x1 - x0)\r\n    // ---------------------\r\n    const xx1 = td(2 * x1, 2 * x0); // error free\r\n    // ---------------------\r\n    // yy2 = y2 - 2*y1 + y0\r\n    // ---------------------\r\n    const $b = y2 - 2 * y1;\r\n    const b = td(y2, 2 * y1); // error free\r\n    const yy2 = qad(b, y0);\r\n    const yy2_ = abs($b + y0);\r\n    // ---------------------\r\n    // yy1 = 2*(y1 - y0)\r\n    // ---------------------\r\n    const yy1 = td(2 * y1, 2 * y0); // error free\r\n    return {\r\n        coeffs: [[xx2, xx1, [0, x0]], [yy2, yy1, [0, y0]]],\r\n        errorBound: [[xx2_, 0, 0], [yy2_, 0, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1DdWithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            td(x1, x0),\r\n            [0, x0]\r\n        ], [\r\n            td(y1, y0),\r\n            [0, y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0DdWithRunningError(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[[0, x0]], [[0, y0]]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-dd-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd-with-running-error.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis0Dd": () => (/* binding */ toPowerBasis0Dd),\n/* harmony export */   "toPowerBasis1Dd": () => (/* binding */ toPowerBasis1Dd),\n/* harmony export */   "toPowerBasis2Dd": () => (/* binding */ toPowerBasis2Dd),\n/* harmony export */   "toPowerBasis3Dd": () => (/* binding */ toPowerBasis3Dd),\n/* harmony export */   "toPowerBasisDd": () => (/* binding */ toPowerBasisDd)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = double_double__WEBPACK_IMPORTED_MODULE_0__.twoDiff; // error -> 0\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2; // error -> 3*u²\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\nconst qad = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDouble; // error -> 2*u²\r\nconst ts = double_double__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less.\r\n *\r\n * * intermediate calculations are done in double-double precision\r\n * * returns the power basis x and y coordinate polynomials from highest power\r\n * to lowest, e.g. if `x(t) = at^3 + bt^2 + ct + d`\r\n * and `y(t) = et^3 + ft^2 + gt + h` then the result is returned\r\n * as `[[a,b,c,d],[e,f,g,h]]`, where the `a,b,c,...` are in double-double\r\n * precision\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisDd(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3Dd(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2Dd(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1Dd(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0Dd(ps);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= cubic.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3Dd(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // ----------------------------\r\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\r\n    // ----------------------------\r\n    const xx3 = qaq(td(x3, x0), qmd(3, td(x1, x2)));\r\n    // ----------------------------\r\n    // xx2 = 3*((x2 + x0) - 2*x1)\r\n    // ----------------------------\r\n    const xx2 = qmd(3, qad(ts(x2, x0), -2 * x1));\r\n    // ----------------------------\r\n    // xx1 = 3*(x1 - x0)\r\n    // ----------------------------\r\n    const xx1 = qmd(3, td(x1, x0));\r\n    // ----------------------------\r\n    // yy3 = (y3 - y0) + 3*(y1 - y2)\r\n    // ----------------------------\r\n    const yy3 = qaq(td(y3, y0), qmd(3, td(y1, y2)));\r\n    // ----------------------------\r\n    // yy2 = 3*((y2 + y0) - 2*y1)\r\n    // ----------------------------\r\n    const yy2 = qmd(3, qad(ts(y2, y0), -2 * y1));\r\n    // ----------------------------\r\n    // yy1 = 3*(y1 - y0)\r\n    // ----------------------------\r\n    const yy1 = qmd(3, td(y1, y0));\r\n    return [[xx3, xx2, xx1, [0, x0]], [yy3, yy2, yy1, [0, y0]]];\r\n}\r\n/**\r\n * Only the quadratic monomial coefficient has an error, the others are exact.\r\n *\r\n * @internal\r\n */\r\nfunction toPowerBasis2Dd(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // ---------------------\r\n    // xx2 = x2 + x0 - 2*x1\r\n    // ---------------------\r\n    const xx2 = qad(ts(x2, x0), -2 * x1);\r\n    // ---------------------\r\n    // xx1 = 2*(x1 - x0)\r\n    // ---------------------\r\n    const xx1 = td(2 * x1, 2 * x0); // error free\r\n    // ---------------------\r\n    // yy2 = y2 + y0 - 2*y1\r\n    // ---------------------\r\n    const yy2 = qad(ts(y2, y0), -2 * y1);\r\n    // ---------------------\r\n    // yy1 = 2*(y1 - y0)\r\n    // ---------------------\r\n    const yy1 = td(2 * y1, 2 * y0); // error free\r\n    return [[xx2, xx1, [0, x0]], [yy2, yy1, [0, y0]]];\r\n}\r\n/**\r\n * Exact for any bitlength.\r\n *\r\n * @internal\r\n */\r\nfunction toPowerBasis1Dd(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            td(x1, x0),\r\n            [0, x0]\r\n        ], [\r\n            td(y1, y0),\r\n            [0, y0]\r\n        ]];\r\n}\r\n/**\r\n * Exact for any bitlength.\r\n *\r\n * @internal\r\n */\r\nfunction toPowerBasis0Dd(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[[0, x0]], [[0, y0]]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-dd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double-double/to-power-basis-dd.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis1WithRunningError": () => (/* binding */ toPowerBasis1WithRunningError),\n/* harmony export */   "toPowerBasis2WithRunningError": () => (/* binding */ toPowerBasis2WithRunningError),\n/* harmony export */   "toPowerBasis3WithRunningError": () => (/* binding */ toPowerBasis3WithRunningError),\n/* harmony export */   "toPowerBasisWithRunningError": () => (/* binding */ toPowerBasisWithRunningError)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less including a coefficient-wise absolute error bound.\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * the error bound need to be multiplied by `γ(1) === u/(1-u)`\r\n * where `u = Number.EPSILON/2` before use\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisWithRunningError(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3WithRunningError(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2WithRunningError(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1WithRunningError(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0WithRunningError(ps);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    // ----------------------------\r\n    // xx3 = (x3 - x0) + 3*(x1 - x2)\r\n    // ----------------------------\r\n    const xa = x3 - x0;\r\n    const _xa_ = abs(xa);\r\n    const xb = x1 - x2;\r\n    const _xb_ = abs(xb);\r\n    const xc = 3 * xb;\r\n    const xc_ = 6 * _xb_; // === 3*_xb_ + 3*abs(xc)\r\n    const xx3 = xa + xc;\r\n    const xx3_ = _xa_ + xc_ + abs(xx3);\r\n    // ----------------------------\r\n    // xx2 = 3*((x2 + x0) - 2*x1)\r\n    // ----------------------------\r\n    const xd = x2 + x0;\r\n    const _xd_ = abs(xd);\r\n    const xe = xd - 2 * x1;\r\n    const _xe_ = _xd_ + abs(xe);\r\n    const xx2 = 3 * xe;\r\n    const xx2_ = 6 * _xe_; // 3*_xe_ + abs(xx2)\r\n    // ----------------------------\r\n    // xx1 = 3*(x1 - x0)\r\n    // ----------------------------\r\n    const xg = x1 - x0;\r\n    const _xg_ = abs(xg);\r\n    const xx1 = 3 * xg;\r\n    const xx1_ = 6 * _xg_; // 3*_xg_ + abs(3*xg)\r\n    // ------------------------------\r\n    // yy3 = (y3 - y0) + 3*(y1 - y2)\r\n    // ------------------------------\r\n    const ya = y3 - y0;\r\n    const _ya_ = abs(ya);\r\n    const yb = y1 - y2;\r\n    const _yb_ = abs(yb);\r\n    const yc = 3 * yb;\r\n    const yc_ = 6 * _yb_; // === 3*_yb_ + 3*abs(yc)\r\n    const yy3 = ya + yc;\r\n    const yy3_ = _ya_ + yc_ + abs(yy3);\r\n    // ----------------------------\r\n    // yy2 = 3*((y2 + y0) - 2*y1)\r\n    // ----------------------------\r\n    const yd = y2 + y0;\r\n    const _yd_ = abs(yd);\r\n    const ye = yd - 2 * y1;\r\n    const _ye_ = _yd_ + abs(ye);\r\n    const yy2 = 3 * ye;\r\n    const yy2_ = 6 * _ye_; // 3*_ye_ + abs(yy2)\r\n    // ----------------------------\r\n    // yy1 = 3*(y1 - y0)\r\n    // ----------------------------\r\n    const yg = y1 - y0;\r\n    const _yg_ = abs(yg);\r\n    const yy1 = 3 * yg;\r\n    const yy1_ = 6 * _yg_; // 3*_yg_ + abs(3*yg)\r\n    return {\r\n        coeffs: [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]],\r\n        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    // ---------------------\r\n    // xx2 = (x2 + x0) - 2*x1\r\n    // ---------------------\r\n    const xa = x2 + x0;\r\n    const _xa_ = abs(xa);\r\n    const xx2 = xa - 2 * x1;\r\n    const xx2_ = _xa_ + abs(xx2);\r\n    // ---------------------\r\n    // xx1 = 2*(x1 - x0)\r\n    // ---------------------\r\n    const xx1 = 2 * (x1 - x0);\r\n    const xx1_ = abs(xx1);\r\n    // ---------------------\r\n    // yy2 = (y2 + y0) - 2*y1\r\n    // ---------------------\r\n    const ya = y2 + y0;\r\n    const _ya_ = abs(ya);\r\n    const yy2 = ya - 2 * y1;\r\n    const yy2_ = _ya_ + abs(yy2);\r\n    // ---------------------\r\n    // yy1 = 2*(y1 - y0)\r\n    // ---------------------\r\n    const yy1 = 2 * (y1 - y0);\r\n    const yy1_ = abs(yy1);\r\n    return {\r\n        coeffs: [[xx2, xx1, x0], [yy2, yy1, y0]],\r\n        errorBound: [[xx2_, xx1_, 0], [yy2_, yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1WithRunningError(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const xx1 = x1 - x0;\r\n    const xx1_ = abs(xx1);\r\n    const yy1 = y1 - y0;\r\n    const yy1_ = abs(yy1);\r\n    return {\r\n        coeffs: [[xx1, x0], [yy1, y0]],\r\n        errorBound: [[xx1_, 0], [yy1_, 0]]\r\n    };\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0WithRunningError(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return {\r\n        coeffs: [[x0], [y0]],\r\n        errorBound: [[0], [0]]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis-with-running-error.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis": () => (/* binding */ toPowerBasis),\n/* harmony export */   "toPowerBasis0": () => (/* binding */ toPowerBasis0),\n/* harmony export */   "toPowerBasis1": () => (/* binding */ toPowerBasis1),\n/* harmony export */   "toPowerBasis2": () => (/* binding */ toPowerBasis2),\n/* harmony export */   "toPowerBasis3": () => (/* binding */ toPowerBasis3)\n/* harmony export */ });\n/**\r\n * Returns the power basis representation of a bezier curve of order cubic or\r\n * less.\r\n *\r\n * * intermediate calculations are done in double precision\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasis(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0(ps);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            (x3 - x0) + 3 * (x1 - x2),\r\n            3 * ((x2 + x0) - 2 * x1),\r\n            3 * (x1 - x0),\r\n            x0\r\n        ], [\r\n            (y3 - y0) + 3 * (y1 - y2),\r\n            3 * ((y2 + y0) - 2 * y1),\r\n            3 * (y1 - y0),\r\n            y0\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            (x2 + x0) - 2 * x1,\r\n            2 * (x1 - x0),\r\n            x0\r\n        ], [\r\n            (y2 + y0) - 2 * y1,\r\n            2 * (y1 - y0),\r\n            y0\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            x1 - x0,\r\n            x0,\r\n        ], [\r\n            y1 - y0,\r\n            y0,\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[x0], [y0]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/double/to-power-basis.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis0Exact": () => (/* binding */ toPowerBasis0Exact),\n/* harmony export */   "toPowerBasis1Exact": () => (/* binding */ toPowerBasis1Exact),\n/* harmony export */   "toPowerBasis2Exact": () => (/* binding */ toPowerBasis2Exact),\n/* harmony export */   "toPowerBasis3Exact": () => (/* binding */ toPowerBasis3Exact),\n/* harmony export */   "toPowerBasisExact": () => (/* binding */ toPowerBasisExact)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\nconst ge = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.growExpansion;\r\nconst eAdd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAdd;\r\n/**\r\n * Returns the *exact* power basis representation of a bezier curve of order\r\n * cubic or less.\r\n *\r\n * * returns the resulting power basis x and y coordinate polynomials from\r\n * highest power to lowest, e.g. if `x(t) = at^2 + bt + c`\r\n * and `y(t) = dt^2 + et + f` then  the result is returned\r\n * as `[[a,b,c],[d,e,f]]`, where the `a,b,c,...` are [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf) floating point\r\n * expansions\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toPowerBasisExact(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3Exact(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2Exact(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1Exact(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return toPowerBasis0Exact(ps);\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= cubic.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3Exact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    return [[\r\n            // (x3 - x0) + 3*(x1 - x2)\r\n            eAdd(td(x3, x0), sce(3, td(x1, x2))),\r\n            // OR\r\n            // (x3 - x0) - (2*x2 + x2) + (2*x1 + x1)\r\n            //eAdd(eAdd(td(x3,x0), ts(-2*x2, -x2)), ts(2*x1, x1))\r\n            // 3*((x2 + x0) - 2*x1)\r\n            sce(3, ge(ts(x2, x0), -2 * x1)),\r\n            // 3*(x1 - x0)\r\n            sce(3, td(x1, x0)),\r\n            // x0\r\n            [x0]\r\n        ], [\r\n            //ge(ge(sce(3, td(y1, y2)), y3), -y0),\r\n            eAdd(td(y3, y0), sce(3, td(y1, y2))),\r\n            //sce(3, ge(td(y2, 2*y1), y0)),\r\n            sce(3, ge(ts(y2, y0), -2 * y1)),\r\n            sce(3, td(y1, y0)),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2Exact(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [[\r\n            // x2 - 2*x1 + x0\r\n            ge(ts(x2, x0), -2 * x1),\r\n            // 2*(x1 - x0)\r\n            td(2 * x1, 2 * x0),\r\n            //x0\r\n            [x0]\r\n        ], [\r\n            ge(ts(y2, y0), -2 * y1),\r\n            td(2 * y1, 2 * y0),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1Exact(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [[\r\n            //x1 - x0,\r\n            td(x1, x0),\r\n            //x0\r\n            [x0]\r\n        ], [\r\n            td(y1, y0),\r\n            [y0]\r\n        ]];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis0Exact(ps) {\r\n    const [[x0, y0]] = ps;\r\n    return [[[x0]], [[y0]]];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-exact.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/exact/to-power-basis-exact.js?')},"./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toPowerBasis1ErrorCounters": () => (/* binding */ toPowerBasis1ErrorCounters),\n/* harmony export */   "toPowerBasis2ErrorCounters": () => (/* binding */ toPowerBasis2ErrorCounters),\n/* harmony export */   "toPowerBasis3ErrorCounters": () => (/* binding */ toPowerBasis3ErrorCounters),\n/* harmony export */   "toPowerBasisErrorCounters": () => (/* binding */ toPowerBasisErrorCounters)\n/* harmony export */ });\n// Note: \r\n// Error counters of double-double will actually be slightly less but\r\n// we can use this for both double and double-double precision.\r\n// For double precision the error bound === γ * <counter> * `error_`\r\n// For double-double precision the error bound === γγ3 * <counter> * `error_`\r\nconst abs = Math.abs;\r\n/**\r\n * Returns a representation of the error (from which an absolute error bound\r\n * can be calculated) when calculating the power basis representation of a\r\n * bezier curve of order <= 3 (using e.g. `toPowerBasis` or `toPowerBasisDd`).\r\n *\r\n * The returned error representation needs to be multiplied with\r\n * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)\r\n * and an appropriate error function, `γ`, depending on the precision used (e.g. double\r\n * or double-double). This is explained in more detail below. See\r\n * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n * p. 68 near the bottom.\r\n *\r\n * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,\r\n *  1973. xiii+441 pp. ISBN 0-12-670350-7\r\n *\r\n * The absolute erros below can be calculated as follows (where `<E>` are the\r\n * error counters as indicated in the comments of the return value below):\r\n *  * double precision: `<E> * (γ(1)) * result_`\r\n *  * double-double precision: `<E> * (γγ(3)) * result_`\r\n *\r\n * where [[γ]] and [[γγ]] are the usual error functions with `γ(1) === 1.1102230246251568e-16`\r\n * and `γγ(3) === 3.697785493223493e-32`.\r\n *\r\n * ```\r\n * // for cubic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tx3,  // <E> === 3\r\n * \t\tx2,  // <E> === 3\r\n * \t\tx1,  // <E> === 2\r\n * \t\t0,\r\n * \t],\r\n * \t[\r\n * \t\ty3,  // <E> === 3\r\n * \t\ty2,  // <E> === 3\r\n * \t\ty1,  // <E> === 2\r\n * \t\t0,\r\n * \t]\r\n * ]\r\n *\r\n * // for quadratic bezier curves\r\n * return [\r\n * \t[\r\n * \t\tx2,  // <E> === 2\r\n * \t\tx1,  // <E> === 1\r\n * \t\t0,\r\n * \t],\r\n * \t[\r\n * \t\ty2,  // <E> === 2\r\n * \t\ty1,  // <E> === 1\r\n * \t\t0,\r\n * \t]\r\n * ];\r\n *\r\n * // for linear bezier curves (i.e. lines)\r\n * return [\r\n * \t[\r\n * \t\tx1_,  // <E> === 1\r\n * \t\tx0_   // <E> === 0\r\n * \t],\r\n * \t[\r\n * \t\ty1_,  // <E> === 1\r\n * \t\ty0_   // <E> === 0\r\n * \t]\r\n * ];\r\n * ```\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given by an ordered array of its\r\n * control points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction toPowerBasisErrorCounters(ps) {\r\n    if (ps.length === 4) {\r\n        return toPowerBasis3ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 3) {\r\n        return toPowerBasis2ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 2) {\r\n        return toPowerBasis1ErrorCounters(ps);\r\n    }\r\n    if (ps.length === 1) {\r\n        return [[0], [0]];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n/** @internal */\r\nfunction toPowerBasis1ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    return [\r\n        [\r\n            _x1 + _x0,\r\n            0,\r\n        ], [\r\n            _y1 + _y0,\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis2ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    return [\r\n        [\r\n            _x2 + _x0 + 2 * _x1,\r\n            2 * (_x1 + _x0),\r\n            0,\r\n        ], [\r\n            _y2 + _y0 + 2 * _y1,\r\n            2 * (_y1 + _y0),\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n/** @internal */\r\nfunction toPowerBasis3ErrorCounters(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _x3 = abs(x3);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _y3 = abs(y3);\r\n    return [\r\n        [\r\n            _x3 + _x0 + 3 * (_x1 + _x2),\r\n            3 * (_x2 + _x0 + 2 * _x1),\r\n            3 * (_x1 + _x0),\r\n            0,\r\n        ], [\r\n            _y3 + _y0 + 3 * (_y1 + _y2),\r\n            3 * (_y2 + _y0 + 2 * _y1),\r\n            3 * (_y1 + _y0),\r\n            0,\r\n        ]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=to-power-basis-error-counters.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/to-power-basis/to-power-basis/to-power-basis-error-counters.js?')},"./node_modules/flo-bezier3/node/transformation/clone.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "clone": () => (/* binding */ clone)\n/* harmony export */ });\n/**\r\n * Returns a clone of the given cubic bezier (with a different reference).\r\n *\r\n * @param ps a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction clone(ps) {\r\n    const ps_ = [];\r\n    for (let i = 0; i < ps.length; i++) {\r\n        const p = ps[i];\r\n        ps_.push([p[0], p[1]]);\r\n    }\r\n    return ps_;\r\n}\r\n\r\n//# sourceMappingURL=clone.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/clone.js?')},"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cubicToHybridQuadratic\": () => (/* binding */ cubicToHybridQuadratic)\n/* harmony export */ });\n/**\r\n * Returns the hybrid quadratic version of the given cubic bezier. For a\r\n * definition of hybrid quadratic bezier curves please see\r\n * this [article](http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd)\r\n *\r\n * * returns an array of three quadratic bezier points where the\r\n * middle point is a 'hybrid' point represented as a line (itself represented\r\n * by two points (a linear bezier curve)) that can be evaluated at a different\r\n * `t` value (call it `th`). If evaluated at the same t value the result is the\r\n * same as evaluating the original cubic bezier at `t`.\r\n *\r\n * * the length of the linear bezier curve mentioned above is a measure of how\r\n * closely the cubic can be represented as a quadratic bezier curve.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction cubicToHybridQuadratic(ps) {\r\n    if (ps.length === 4) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [\r\n                [(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],\r\n                [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]\r\n            ],\r\n            [x3, y3]\r\n        ];\r\n    }\r\n    throw new Error('The given bezier curve must be a cubic');\r\n}\r\n\r\n//# sourceMappingURL=cubic-to-hybrid-quadratic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-hybrid-quadratic.js?")},"./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cubicToQuadratic": () => (/* binding */ cubicToQuadratic)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below to improve performance with bundlers❗ The assignee is a getter❗ The assigned is a pure function❗\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\nconst ediff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst esign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst estimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\r\nconst ts = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\n/**\r\n * Returns a quadratic approximation to the given cubic bezier curve.\r\n *\r\n * * the initial and final control points of the resulting bezier coincide with\r\n * that of the curve being approximated\r\n *\r\n * * if `preserveTangents` is `true` and the cubic\'s initial and final tangents\r\n * are parallel (and not coincident) then `undefined` is returned\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param preserveTangents optional; defaults to `false`; if `true` then the approximation\r\n * must also preserve the tangents of the cubic at the initial and final control\r\n * points\r\n *\r\n * @doc mdx\r\n */\r\nfunction cubicToQuadratic(ps, preserveTangents = false) {\r\n    // Note: if cubic is really a quad then\r\n    //   x3 + 3*(x1 - x2) === x0 && \r\n    //   y3 + 3*(y1 - y2) === y0\r\n    // Take the midpoint of the moving line of the hybrid quadratic version of \r\n    // the cubic as the new quadratic\'s middle control point.\r\n    if (!preserveTangents) {\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [x0, y0],\r\n            [\r\n                // [\r\n                //   (3*(x1 + x2) - (x0 + x3)) / 4, \r\n                //   (3*(y1 + y2) - (y0 + y3)) / 4\r\n                // ]\r\n                estimate(ediff(sce(ts(x1 / 4, x2 / 4), 3), ts(x0 / 4, x3 / 4))),\r\n                estimate(ediff(sce(ts(y1 / 4, y2 / 4), 3), ts(y0 / 4, y3 / 4)))\r\n            ],\r\n            [x3, y3]\r\n        ];\r\n    }\r\n    // At this point: `preserveTangents === true`\r\n    const [p0, p1, p2, p3] = ps;\r\n    const l1 = [p0, p1];\r\n    const l2 = [p3, p2];\r\n    const pM = llIntersection(l1, l2);\r\n    if (pM === undefined) {\r\n        return undefined;\r\n        //return [\r\n        //    p0,\r\n        //    [(p0[0] + p3[0])/2, (p0[1] + p3[1])/2],\r\n        //    p3\r\n        //];\r\n    }\r\n    return [p0, pM, p3];\r\n}\r\n/**\r\n * Returns the point of intersection of the given two lines or `undefined` if\r\n * the lines are parallel.\r\n *\r\n * * returns `undefined` *iff* the lines are *exactly* parallel\r\n *\r\n * @param l1\r\n * @param l2\r\n *\r\n * @internal\r\n */\r\nfunction llIntersection(l1, l2) {\r\n    const [[x1, y1], [x2, y2]] = l1;\r\n    const [[x3, y3], [x4, y4]] = l2;\r\n    const x1_ = td(x2, x1);\r\n    const y1_ = td(y2, y1);\r\n    const x2_ = td(x4, x3);\r\n    const y2_ = td(y4, y3);\r\n    const denom = ediff(epr(x2_, y1_), epr(y2_, x1_));\r\n    if (esign(denom) === 0) {\r\n        // definitely parallel\r\n        return undefined;\r\n    }\r\n    const x3_ = td(x3, x1);\r\n    const y3_ = td(y3, y1);\r\n    const b = ediff(epr(y3_, x1_), epr(x3_, y1_));\r\n    const bb = estimate(b) / estimate(denom);\r\n    return [\r\n        x3 + bb * estimate(x2_),\r\n        y3 + bb * estimate(y2_)\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=cubic-to-quadratic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js?')},"./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lineToCubic": () => (/* binding */ lineToCubic)\n/* harmony export */ });\n/**\r\n * Returns a cubic bezier from the given line with evenly spaced control points.\r\n *\r\n * @param ps a 2d line represented by two points\r\n *\r\n * @doc mdx\r\n */\r\nfunction lineToCubic(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    const xInterval = (x1 - x0) / 3;\r\n    const yInterval = (y1 - y0) / 3;\r\n    return [\r\n        [x0, y0],\r\n        [x0 + xInterval, y0 + yInterval],\r\n        [x0 + xInterval * 2, y0 + yInterval * 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=line-to-cubic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js?')},"./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lineToQuadratic": () => (/* binding */ lineToQuadratic)\n/* harmony export */ });\n/**\r\n * Returns a quadratic bezier from the given line with evenly spaced control points.\r\n *\r\n * @param ps a 2d line represented by two points, e.g. `[[1,2],[3,4]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction lineToQuadratic(ps) {\r\n    const [[x0, y0], [x1, y1]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [(x0 + x1) / 2, (y0 + y1) / 2],\r\n        [x1, y1]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=line-to-quadratic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-quadratic.js?')},"./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "quadraticToCubic": () => (/* binding */ quadraticToCubic)\n/* harmony export */ });\n/**\r\n * Returns the cubic version of the given quadratic bezier curve (by degree\r\n * elevation).\r\n *\r\n * * quadratic bezier curves can always be represented exactly by cubics - the\r\n * converse is false\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction quadraticToCubic(ps) {\r\n    const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    return [\r\n        [x0, y0],\r\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\r\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\r\n        [x2, y2]\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=quadratic-to-cubic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js?')},"./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toCubic": () => (/* binding */ toCubic)\n/* harmony export */ });\n/* harmony import */ var _line_to_cubic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line-to-cubic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/line-to-cubic.js");\n/* harmony import */ var _quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quadratic-to-cubic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/quadratic-to-cubic.js");\n\r\n\r\n/**\r\n * Returns a cubic bezier curve that is equivalent to the given linear or\r\n * quadratic bezier curve.\r\n *\r\n * Cubics are just returned unaltered.\r\n *\r\n * This function simply uses `lineToCubic` or `quadraticToCubic` internally.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction toCubic(ps) {\r\n    if (ps.length === 4) { // Cubic\r\n        return ps;\r\n    }\r\n    if (ps.length === 3) { // Quadratic\r\n        return (0,_quadratic_to_cubic_js__WEBPACK_IMPORTED_MODULE_1__.quadraticToCubic)(ps);\r\n    }\r\n    if (ps.length === 2) { // Linear\r\n        return (0,_line_to_cubic_js__WEBPACK_IMPORTED_MODULE_0__.lineToCubic)(ps);\r\n    }\r\n    if (ps.length === 1) { // Point\r\n        const p = ps[0];\r\n        return [p, p, p, p];\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=to-cubic.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/degree-or-type/to-cubic.js?')},"./node_modules/flo-bezier3/node/transformation/get-hodograph.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getHodograph\": () => (/* binding */ getHodograph)\n/* harmony export */ });\n/**\r\n * Returns the hodograph of the given bezier curve.\r\n *\r\n * @param ps an order 1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction getHodograph(ps) {\r\n    // * **bitlength**: If the coordinates of the control points are bit-aligned then\r\n    // * max bitlength increase === 3, max shift === 3 (for cubics)\r\n    // * max bitlength increase === 1, max shift === 2 (for quadratics)\r\n    // * max bitlength increase === 1, max shift === 1 (for lines)\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        return [\r\n            [3 * (x1 - x0), 3 * (y1 - y0)],\r\n            [3 * (x2 - x1), 3 * (y2 - y1)],\r\n            [3 * (x3 - x2), 3 * (y3 - y2)]\r\n        ];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        return [\r\n            [2 * (x1 - x0), 2 * (y1 - y0)],\r\n            [2 * (x2 - x1), 2 * (y2 - y1)]\r\n        ];\r\n    }\r\n    if (ps.length === 2) {\r\n        // a line\r\n        const [[x0, y0], [x1, y1]] = ps;\r\n        return [\r\n            [x1 - x0, y1 - y0]\r\n        ];\r\n    }\r\n    throw new Error('The given bezier curve must be of order 1, 2 or 3.');\r\n}\r\n\r\n//# sourceMappingURL=get-hodograph.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/get-hodograph.js?")},"./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reduceOrderIfPossible": () => (/* binding */ reduceOrderIfPossible)\n/* harmony export */ });\n/* harmony import */ var _global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global-properties/classification/is-cubic-really-quad.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-cubic-really-quad.js");\n/* harmony import */ var _degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./degree-or-type/cubic-to-quadratic.js */ "./node_modules/flo-bezier3/node/transformation/degree-or-type/cubic-to-quadratic.js");\n/* harmony import */ var _global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global-properties/classification/is-quad-really-line.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-quad-really-line.js");\n/* harmony import */ var _global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global-properties/classification/is-really-point.js */ "./node_modules/flo-bezier3/node/global-properties/classification/is-really-point.js");\n\r\n\r\n\r\n\r\n/**\r\n * Returns a reduced order version of the given bezier curve *if* it can be\r\n * represented as such without loss.\r\n *\r\n * Crucially, the reduced order bezier will have exactly the same `t` values\r\n * at specific `x` and `y` coordinates as the original.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc mdx\r\n */\r\nfunction reduceOrderIfPossible(ps) {\r\n    if (ps.length === 4 && (0,_global_properties_classification_is_cubic_really_quad_js__WEBPACK_IMPORTED_MODULE_0__.isCubicReallyQuad)(ps)) {\r\n        ps = (0,_degree_or_type_cubic_to_quadratic_js__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(ps);\r\n    }\r\n    if (ps.length === 3 && (0,_global_properties_classification_is_quad_really_line_js__WEBPACK_IMPORTED_MODULE_2__.isQuadReallyLine)(ps)) {\r\n        ps = [ps[0], ps[2]];\r\n    }\r\n    if (ps.length === 2 && (0,_global_properties_classification_is_really_point_js__WEBPACK_IMPORTED_MODULE_3__.isReallyPoint)(ps)) {\r\n        ps = [ps[0]];\r\n    }\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=reduce-order-if-possible.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/reduce-order-if-possible.js?')},"./node_modules/flo-bezier3/node/transformation/reverse.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reverse": () => (/* binding */ reverse)\n/* harmony export */ });\n/**\r\n * Returns the given points (e.g. bezier curve) in reverse order.\r\n *\r\n * Implementation details:\r\n * ```\r\n * const reverse = ps => ps.slice().reverse()\r\n * ```\r\n *\r\n * @param ps a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction reverse(ps) {\r\n    return ps.slice().reverse();\r\n}\r\n\r\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/reverse.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromToInclErrorBound": () => (/* binding */ fromToInclErrorBound)\n/* harmony export */ });\n/* harmony import */ var _from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to/from-to-3-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js");\n/* harmony import */ var _from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to-2-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js");\n/* harmony import */ var _from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to-1-incl-error-bound.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js");\n\r\n\r\n\r\nconst fromTo3 = _from_to_from_to_3_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3InclErrorBound;\r\nconst fromTo2 = _from_to_from_to_2_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2InclErrorBound;\r\nconst fromTo1 = _from_to_from_to_1_incl_error_bound_js__WEBPACK_IMPORTED_MODULE_2__.fromTo1InclErrorBound;\r\n/**\r\n * Returns a bezier curve, `ps`, that starts and ends at the given `t` parameters\r\n * (starting at `tS` and ending at `tE`) including a matching coordinate-wise\r\n * error bound, `_ps`, that needs to be multiplied by `3u`, `5u` or `8u` (for\r\n * lines, quadratic or cubic bezier curves respectively) before use,\r\n * where `u === Number.EPSILON/2`.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @doc mdx\r\n */\r\nfunction fromToInclErrorBound(ps, tS, tE) {\r\n    if (ps.length === 4) {\r\n        return fromTo3(ps, tS, tE);\r\n    }\r\n    if (ps.length === 3) {\r\n        return fromTo2(ps, tS, tE);\r\n    }\r\n    if (ps.length === 2) {\r\n        return fromTo1(ps, tS, tE);\r\n    }\r\n    if (ps.length === 1) {\r\n        return { ps, _ps: [[0]] };\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=from-to-incl-error-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to-incl-error-bound.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo": () => (/* binding */ fromTo)\n/* harmony export */ });\n/* harmony import */ var _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to/from-to-3.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js");\n/* harmony import */ var _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to-2.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js");\n/* harmony import */ var _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to-1.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js");\n\r\n\r\n\r\nconst fromTo3 = _from_to_from_to_3_js__WEBPACK_IMPORTED_MODULE_0__.fromTo3;\r\nconst fromTo2 = _from_to_from_to_2_js__WEBPACK_IMPORTED_MODULE_1__.fromTo2;\r\nconst fromTo1 = _from_to_from_to_1_js__WEBPACK_IMPORTED_MODULE_2__.fromTo1;\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @doc mdx\r\n */\r\nfunction fromTo(ps, tS, tE) {\r\n    if (ps.length === 4) {\r\n        return fromTo3(ps, tS, tE);\r\n    }\r\n    if (ps.length === 3) {\r\n        return fromTo2(ps, tS, tE);\r\n    }\r\n    if (ps.length === 2) {\r\n        return fromTo1(ps, tS, tE);\r\n    }\r\n    if (ps.length === 1) {\r\n        return ps;\r\n    }\r\n    throw new Error(\'The given bezier curve must be of order <= 3.\');\r\n}\r\n\r\n//# sourceMappingURL=from-to.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo1InclErrorBound": () => (/* binding */ fromTo1InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `3u` before use,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a linear bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo1InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft1(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight1(ps, tS);\r\n    }\r\n    return splitAtBoth1(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given `t` parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `3u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psR = [\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0],\r\n        [x1,\r\n            y1] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx0 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\r\n    const _xx0 = _t * (_x1 + _x0) + _x0;\r\n    const _yy0 = _t * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [3*u*_xx0, 3*u*_yy0],\r\n    //    [0, 0]\r\n    //];\r\n    const psR_ = [\r\n        [_xx0, _yy0],\r\n        [0, 0]\r\n    ];\r\n    return {\r\n        ps: psR,\r\n        _ps: psR_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter including an error bound (that needs to be multiplied by `3u`,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact \r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psL = [\r\n        [x0,\r\n            y0],\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx1 <= <3>(<2>(t*<1>(x1 - x0)) + x0)\r\n    const _xx1 = _t * (_x1 + _x0) + _x0;\r\n    const _yy1 = _t * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psL_ = [\r\n    //    [0, 0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //];\r\n    const psL_ = [\r\n        [0, 0],\r\n        [_xx1, _yy1],\r\n    ];\r\n    return {\r\n        ps: psL,\r\n        _ps: psL_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `3u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth1(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const psB = [\r\n        [tS * (x1 - x0) + x0,\r\n            tS * (y1 - y0) + y0],\r\n        [tE * (x1 - x0) + x0,\r\n            tE * (y1 - y0) + y0] // yy1\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    // <3>xx0 <= <3>(<2>(tS*<1>(x1 - x0)) + x0)\r\n    const _xx0 = _tS * (_x1 + _x0) + _x0;\r\n    // <3>xx1\r\n    const _xx1 = _tE * (_x1 + _x0) + _x0;\r\n    const _yy0 = _tS * (_y1 + _y0) + _y0;\r\n    const _yy1 = _tE * (_y1 + _y0) + _y0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [3*u*_xx0, 3*u*_yy0],\r\n    //    [0, 0]\r\n    //];\r\n    const psB_ = [\r\n        [_xx0, _yy0],\r\n        [_xx1, _yy1]\r\n    ];\r\n    return {\r\n        ps: psB,\r\n        _ps: psB_\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-1-incl-error-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1-incl-error-bound.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo1": () => (/* binding */ fromTo1)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo1(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft1(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight1(ps, tS);\r\n    }\r\n    return splitAtBoth1(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given `t` parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0],\r\n        [x1,\r\n            y1] // yy1\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft1(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [x0,\r\n            y0],\r\n        [t * (x1 - x0) + x0,\r\n            t * (y1 - y0) + y0] // yy1\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a lineer bezier curve (a line) given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth1(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    // --------------------------------------------------------\r\n    return [\r\n        [tS * (x1 - x0) + x0,\r\n            tS * (y1 - y0) + y0],\r\n        [tE * (x1 - x0) + x0,\r\n            tE * (y1 - y0) + y0] // yy1\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=from-to-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-1.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo2InclErrorBound": () => (/* binding */ fromTo2InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `5u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo2InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft2(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight2(ps, tS);\r\n    }\r\n    return splitAtBoth2(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `5u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const psR = [\r\n        [tt * (xA + xB) - (2 * t * xA - x0),\r\n            tt * (yA + yB) - (2 * t * yA - y0)],\r\n        [t * xB + x1,\r\n            t * yB + y1],\r\n        [x2,\r\n            y2] // yy2\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xB = _x2 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yB = _y2 + _y1;\r\n    // <5>xx0 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>xB)) - <3>(<2>(2*t*<1>xA) - x0))\r\n    const _xx0 = tt * (_xA + _xB) + (2 * _t * _xA + _x0);\r\n    // <3>xx1 <= <3>(<2>(t*<1>xB) + x1)\r\n    const _xx1 = _t * _xB + _x1;\r\n    const _yy0 = tt * (_yA + _yB) + (2 * _t * _yA + _y0);\r\n    const _yy1 = 0;\r\n    /** the coordinate-wise error bound */\r\n    //const psR_ = [\r\n    //    [5*u*_xx0, 5*u*_yy0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //    [0, 0]\r\n    //];\r\n    const psR_ = [\r\n        [_xx0, _yy0],\r\n        [_xx1, _yy1],\r\n        [0, 0]\r\n    ];\r\n    return {\r\n        ps: psR,\r\n        _ps: psR_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter including an error bound (that needs to be multiplied by `5u`,\r\n * where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact \r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)\r\n    const xA = x0 - x1; // <1>xA\r\n    const yA = y0 - y1;\r\n    const psL = [\r\n        [x0,\r\n            y0],\r\n        [-t * xA + x0,\r\n            -t * yA + y0],\r\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\r\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\r\n    ];\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    // <3>xx1 <= <3>(<2>(-t*<1>xA) + x0)\r\n    const _xx1 = _t * _xA + _x0;\r\n    // <5>xx2 <= <5>(<4>(<1>tt*<2>(<1>xA + <1>(x2 - x1))) - <3>(<2>(2*t*<1>xA) - x0))\r\n    const _xx2 = tt * (_xA + (_x2 + _x1)) + (2 * _t * _xA + _x0);\r\n    const _yy1 = _t * _yA + _y0;\r\n    const _yy2 = tt * (_yA + (_y2 + _y1)) + (2 * _t * _yA + _y0);\r\n    /** the coordinate-wise error bound */\r\n    //const psL_ = [\r\n    //    [0, 0],\r\n    //    [3*u*_xx1, 3*u*_yy1],\r\n    //    [5*u*_xx2, 5*u*_yy2],\r\n    //];\r\n    const psL_ = [\r\n        [0, 0],\r\n        [_xx1, _yy1],\r\n        [_xx2, _yy2]\r\n    ];\r\n    return {\r\n        ps: psL,\r\n        _ps: psL_\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `5u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth2(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0]; // exact\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\r\n    const ttE = tE * tE; // ...\r\n    const tStE = tS * tE; // <1>tStE\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const xC = xA + xB; // <2>xC\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = yA + yB;\r\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\r\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\r\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\r\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\r\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\r\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _tStE = abs(tStE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xC = _xA + _x2 + _x1;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yC = _yA + _y2 + _y1;\r\n    // <5>xx0 = <5>(<4>(<1>ttS*<2>xC) - <3>(<2>(2*tS*<1>xA) - x0))\r\n    const _xx0 = ttS * _xC + (2 * _tS * _xA + _x0);\r\n    // <5>xx1 = <5>(<4>(<1>tStE*<2>xC) - <4>((<3>(<1>xA*<1>(tE + tS)) - x0)))\r\n    const _xx1 = _tStE * _xC + (_xA * (_tE + _tS) + _x0);\r\n    // <5>xx2 = <5>(<4>(<1>ttE*<2>xC) - <3>(<2>(2*tE*<1>xA) - x0))\r\n    const _xx2 = ttE * _xC + (2 * _tE * _xA + _x0);\r\n    const _yy0 = ttS * _yC + (2 * _tS * _yA + _y0);\r\n    const _yy1 = _tStE * yC + (_yA * (_tE + _tS) + _y0);\r\n    const _yy2 = ttE * _yC + (2 * _tE * _yA + _y0);\r\n    return {\r\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2]],\r\n        //ps_: [\r\n        //    [5*u*_xx0, 5*u*_yy0],\r\n        //    [5*u*_xx1, 5*u*_yy1],\r\n        //    [5*u*_xx2, 5*u*_yy2]\r\n        //]\r\n        _ps: [\r\n            [_xx0, _yy0],\r\n            [_xx1, _yy1],\r\n            [_xx2, _yy2]\r\n        ]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-2-incl-error-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2-incl-error-bound.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo2": () => (/* binding */ fromTo2)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo2(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft2(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight2(ps, tS);\r\n    }\r\n    return splitAtBoth2(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const tt = t * t;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    return [\r\n        [tt * (xA + xB) - (2 * t * xA - x0),\r\n            tt * (yA + yB) - (2 * t * yA - y0)],\r\n        [t * xB + x1,\r\n            t * yB + y1],\r\n        [x2,\r\n            y2] // yy2\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\r\n * parameter.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft2(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const tt = t * t;\r\n    const xA = x0 - x1;\r\n    const yA = y0 - y1;\r\n    return [\r\n        [x0,\r\n            y0],\r\n        [-t * xA + x0,\r\n            -t * yA + y0],\r\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0),\r\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\r\n    ];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a quadratic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth2(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    // --------------------------------------------------------\r\n    const ttS = tS * tS;\r\n    const ttE = tE * tE;\r\n    const tStE = tS * tE;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const xC = xA + xB;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = yA + yB;\r\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\r\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\r\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\r\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\r\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\r\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\r\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2]];\r\n}\r\n\r\n//# sourceMappingURL=from-to-2.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-2.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo3InclErrorBound": () => (/* binding */ fromTo3InclErrorBound)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/** error free error bounds */\r\nconst psErrorFree = [[0, 0], [0, 0], [0, 0], [0, 0]];\r\n/**\r\n * Returns a bezier curve that starts and ends at the given t parameters\r\n * including an error bound (that needs to be multiplied by `9u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo3InclErrorBound(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return { ps, _ps: psErrorFree };\r\n        }\r\n        return splitLeft3(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight3(ps, tS);\r\n    }\r\n    return splitAtBoth3(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1` including an error bound (that needs to be multiplied\r\n * by `9u`, where `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x00 = abs(x00);\r\n    const _x10 = abs(x10);\r\n    const _x20 = abs(x20);\r\n    const _x30 = abs(x30);\r\n    const _y00 = abs(y00);\r\n    const _y10 = abs(y10);\r\n    const _y20 = abs(y20);\r\n    const _y30 = abs(y30);\r\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\r\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\r\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\r\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\r\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\r\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\r\n    const _y01 = _y00 + _t * (_y00 + _y10);\r\n    const _y11 = _y10 + _t * (_y10 + _y20);\r\n    const _y21 = _y20 + _t * (_y20 + _y30);\r\n    const _y02 = _y01 + _t * (_y01 + _y11);\r\n    const _y12 = _y11 + _t * (_y11 + _y21);\r\n    const _y03 = _y02 + _t * (_y02 + _y12);\r\n    return {\r\n        ps: [[x03, y03], [x12, y12], [x21, y21], [x30, y30]],\r\n        _ps: [\r\n            // the coordinate-wise error bounds\r\n            [_x03, _y03],\r\n            [_x12, _y12],\r\n            [_x21, _y21],\r\n            [0, 0] // [0, 0],\r\n        ]\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\r\n * parameter including an error bound (that needs to be multiplied by `9u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    // -----------------------\r\n    // Calculate error bounds\r\n    // -----------------------\r\n    const _t = abs(t);\r\n    const _x00 = abs(x00);\r\n    const _x10 = abs(x10);\r\n    const _x20 = abs(x20);\r\n    const _x30 = abs(x30);\r\n    const _y00 = abs(y00);\r\n    const _y10 = abs(y10);\r\n    const _y20 = abs(y20);\r\n    const _y30 = abs(y30);\r\n    const _x01 = _x00 + _t * (_x00 + _x10); // <3>x01 = <3>(x00 - <2>(t*<1>(x00 - x10)))\r\n    const _x11 = _x10 + _t * (_x10 + _x20); // <3>x11\r\n    const _x21 = _x20 + _t * (_x20 + _x30); // <3>x21\r\n    const _x02 = _x01 + _t * (_x01 + _x11); // <6>x02 = <6>(x01 - <5>(t*<4>(<3>x01 - <3>x11)))\r\n    const _x12 = _x11 + _t * (_x11 + _x21); // <6>x12\r\n    const _x03 = _x02 + _t * (_x02 + _x12); // <9>x03 = <9>(x02 - <8>(t*<7>(<6>x02 - <6>x12)))\r\n    const _y01 = _y00 + _t * (_y00 + _y10);\r\n    const _y11 = _y10 + _t * (_y10 + _y20);\r\n    const _y21 = _y20 + _t * (_y20 + _y30);\r\n    const _y02 = _y01 + _t * (_y01 + _y11);\r\n    const _y12 = _y11 + _t * (_y11 + _y21);\r\n    const _y03 = _y02 + _t * (_y02 + _y12);\r\n    return {\r\n        ps: [[x00, y00], [x01, y01], [x02, y02], [x03, y03]],\r\n        _ps: [\r\n            // the coordinate-wise error bounds\r\n            [0, 0],\r\n            [_x01, _y01],\r\n            [_x02, _y02],\r\n            [_x03, _y03] // [9*u*_x03, 9*u*_y03]\r\n        ]\r\n    };\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters\r\n * including an error bound (that needs to be multiplied by `8u`, where\r\n * `u === Number.EPSILON/2`).\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth3(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1]; // exact\r\n    const p2 = ps[2];\r\n    const p3 = ps[3]; // exact\r\n    const x0 = p0[0];\r\n    const y0 = p0[1]; // exact\r\n    const x1 = p1[0];\r\n    const y1 = p1[1]; // exact\r\n    const x2 = p2[0];\r\n    const y2 = p2[1]; // exact\r\n    const x3 = p3[0];\r\n    const y3 = p3[1]; // exact\r\n    // --------------------------------------------------------\r\n    // error bound using counters <k>:\r\n    // counter rules:\r\n    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)\r\n    //   2. <k>a<l>b = <k + l + 1>ab\r\n    //   3. fl(a) === <1>a\r\n    const ttS = tS * tS; // <1>ttS  <= <0>tS<0>tS   (by counter rule 2)\r\n    const tttS = tS * ttS; // <2>tttS <= <0>tS<1>ttS  (again by counter rule 2)\r\n    const ttE = tE * tE; // ...\r\n    const tttE = tE * ttE; // ...\r\n    const tStE = tS * tE; // <1>tStE\r\n    const xA = x0 - x1; // <1>xA\r\n    const xB = x2 - x1; // <1>xB\r\n    const xC = x3 - x0; // <1>xC\r\n    const xD = xA + xB; // <2>xD\r\n    const tSxA = tS * xA; // <2>tSxA\r\n    const tExA = tE * xA; // <2>tExA\r\n    const xC3xB = xC - 3 * xB; // <3>xC3xB = <3>(<1>xC - <2>(3*<1>xB))\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = y3 - y0;\r\n    const yD = yA + yB;\r\n    const tSyA = tS * yA;\r\n    const tEyA = tE * yA;\r\n    const yC3yB = yC - 3 * yB;\r\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\r\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\r\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\r\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\r\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\r\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\r\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\r\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\r\n    // ----------------------------------------------\r\n    // Calculate error bounds\r\n    // ----------------------------------------------\r\n    const _tS = abs(tS);\r\n    const _tE = abs(tE);\r\n    const _tStE = abs(tStE);\r\n    const _tttS = abs(tttS);\r\n    const _tttE = abs(tttE);\r\n    const _x0 = abs(x0);\r\n    const _x1 = abs(x1);\r\n    const _x2 = abs(x2);\r\n    const _xA = _x0 + _x1;\r\n    const _xB = _x2 + _x1;\r\n    const _xD = _xA + _xB;\r\n    const _tSxA = _tS * _xA;\r\n    const _tExA = _tE * _xA;\r\n    const _xC3xB = abs(xC) + 3 * _xB;\r\n    const _y0 = abs(y0);\r\n    const _y1 = abs(y1);\r\n    const _y2 = abs(y2);\r\n    const _yA = _y0 + _y1;\r\n    const _yB = _y2 + _y1;\r\n    const _yD = _yA + _yB;\r\n    const _tSyA = _tS * _yA;\r\n    const _tEyA = _tE * _yA;\r\n    const _yC3yB = abs(yC) + 3 * _yB;\r\n    // <8>xx0 = <8>(<6>(<2>tttS*<3>xC3xB) + <7>(<6>(<1>(3*tS)*(<4>(<3>(tS*<2>xD) - <1>xA))) + x0));\r\n    const _xx0 = _tttS * _xC3xB + (3 * _tS * (_tS * _xD + _xA) + _x0);\r\n    // <7>xx1 = <7>(<6>(<1>tStE*<5>(<4>(tS*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttS*<2>xD) + x0) - <3>(<2>tExA + <2>(2*tSxA))));\r\n    const _xx1 = _tStE * (_tS * _xC3xB + 2 * _xD) + ((ttS * _xD + _x0) + (_tExA + 2 * _tSxA));\r\n    // <7>xx2 = <7>(<6>(<1>tStE*<5>(<4>(tE*<3>xC3xB) + <2>(2*xD))) + <6>(<5>(<4>(<1>ttE*<2>xD) + x0) - <3>(<2>(2*tExA) + <2>tSxA)));\r\n    const _xx2 = _tStE * (_tE * _xC3xB + 2 * _xD) + ((ttE * _xD + _x0) + (2 * _tExA + _tSxA));\r\n    // <8>xx3 = <8>(<6>(<2>tttE*<3>xC3xB) + <7>(<6>(<1>(3*tE)*(<4>(<3>(tE*<2>xD) - <1>xA))) + x0));\r\n    const _xx3 = _tttE * _xC3xB + (3 * _tE * (_tE * _xD + _xA) + _x0);\r\n    const _yy0 = _tttS * _yC3yB + (3 * _tS * (_tS * _yD + _yA) + _y0);\r\n    const _yy1 = _tStE * (_tS * _yC3yB + 2 * _yD) + ((ttS * _yD + _y0) + (_tEyA + 2 * _tSyA));\r\n    const _yy2 = _tStE * (_tE * _yC3yB + 2 * _yD) + ((ttE * _yD + _y0) + (2 * _tEyA + _tSyA));\r\n    const _yy3 = _tttE * _yC3yB + (3 * _tE * (_tE * _yD + _yA) + _y0);\r\n    return {\r\n        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]],\r\n        _ps: [\r\n            [_xx0, _yy0],\r\n            [_xx1, _yy1],\r\n            [_xx2, _yy2],\r\n            [_xx3, _yy3] // [8*u*_xx3, 8*u*_yy3]\r\n        ]\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=from-to-3-incl-error-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3-incl-error-bound.js?')},"./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromTo3": () => (/* binding */ fromTo3)\n/* harmony export */ });\n/**\r\n * Returns a bezier curve that starts and ends at the given t parameters.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction fromTo3(ps, tS, tE) {\r\n    if (tS === 0) {\r\n        if (tE === 1) {\r\n            return ps;\r\n        }\r\n        return splitLeft3(ps, tE);\r\n    }\r\n    if (tE === 1) {\r\n        return splitRight3(ps, tS);\r\n    }\r\n    return splitAtBoth3(ps, tS, tE);\r\n}\r\n/**\r\n * Returns a bezier curve that starts at the given t parameter and ends\r\n * at `t === 1`.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should start\r\n *\r\n * @internal\r\n */\r\nfunction splitRight3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    return [[x03, y03], [x12, y12], [x21, y21], [x30, y30]];\r\n}\r\n/**\r\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\r\n * parameter.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param t the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitLeft3(ps, t) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x00 = p0[0];\r\n    const y00 = p0[1];\r\n    const x10 = p1[0];\r\n    const y10 = p1[1];\r\n    const x20 = p2[0];\r\n    const y20 = p2[1];\r\n    const x30 = p3[0];\r\n    const y30 = p3[1];\r\n    // --------------------------------------------------------\r\n    const x01 = x00 - t * (x00 - x10);\r\n    const x11 = x10 - t * (x10 - x20);\r\n    const x21 = x20 - t * (x20 - x30);\r\n    const x02 = x01 - t * (x01 - x11);\r\n    const x12 = x11 - t * (x11 - x21);\r\n    const x03 = x02 - t * (x02 - x12);\r\n    const y01 = y00 - t * (y00 - y10);\r\n    const y11 = y10 - t * (y10 - y20);\r\n    const y21 = y20 - t * (y20 - y30);\r\n    const y02 = y01 - t * (y01 - y11);\r\n    const y12 = y11 - t * (y11 - y21);\r\n    const y03 = y02 - t * (y02 - y12);\r\n    return [[x00, y00], [x01, y01], [x02, y02], [x03, y03]];\r\n}\r\n/**\r\n * Returns a bezier curve that starts and ends at the given `t` parameters.\r\n *\r\n * @param ps a cubic bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param tS the `t` parameter where the resultant bezier should start\r\n * @param tE the `t` parameter where the resultant bezier should end\r\n *\r\n * @internal\r\n */\r\nfunction splitAtBoth3(ps, tS, tE) {\r\n    // --------------------------------------------------------\r\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \r\n    const p0 = ps[0];\r\n    const p1 = ps[1];\r\n    const p2 = ps[2];\r\n    const p3 = ps[3];\r\n    const x0 = p0[0];\r\n    const y0 = p0[1];\r\n    const x1 = p1[0];\r\n    const y1 = p1[1];\r\n    const x2 = p2[0];\r\n    const y2 = p2[1];\r\n    const x3 = p3[0];\r\n    const y3 = p3[1];\r\n    // --------------------------------------------------------\r\n    const ttS = tS * tS;\r\n    const tttS = tS * ttS;\r\n    const ttE = tE * tE;\r\n    const tttE = tE * ttE;\r\n    const tStE = tS * tE;\r\n    const xA = x0 - x1;\r\n    const xB = x2 - x1;\r\n    const xC = x3 - x0;\r\n    const xD = xA + xB;\r\n    const tSxA = tS * xA;\r\n    const tExA = tE * xA;\r\n    const xC3xB = xC - 3 * xB;\r\n    const yA = y0 - y1;\r\n    const yB = y2 - y1;\r\n    const yC = y3 - y0;\r\n    const yD = yA + yB;\r\n    const tSyA = tS * yA;\r\n    const tEyA = tE * yA;\r\n    const yC3yB = yC - 3 * yB;\r\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\r\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\r\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\r\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\r\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\r\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\r\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\r\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\r\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]];\r\n}\r\n\r\n//# sourceMappingURL=from-to-3.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/from-to/from-to-3.js?')},"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "splitByCurvatureAndLength": () => (/* binding */ splitByCurvatureAndLength)\n/* harmony export */ });\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js");\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global-properties/curviness.js */ "./node_modules/flo-bezier3/node/global-properties/curviness.js");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\n\r\n/**\r\n * Split the given bezier curve into pieces (given as an array of parameter\r\n * `t` values) such that each piece is flat within a given tolerance (where\r\n * curvature is measured by the `curviness` function).\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param maxCurviness optional; defaults to `0.4 radians`; maximum curviness\r\n * (must be > 0) as calculated using\r\n * the `curviness` function (that measures the total angle in radians formed\r\n * by the vectors formed by the ordered control points)\r\n * @param maxLength optional; defaults to `10`; maximum allowed length of any returned piece\r\n * @param minTSpan optional; defaults to `2**-16`; the minimum `t` span that can\r\n * be returned for a bezier piece; necessary for cubics otherwise a curve with a\r\n * cusp would cause an infinite loop\r\n *\r\n * @doc mdx\r\n */\r\nfunction splitByCurvatureAndLength(ps, maxCurviness = 0.4, maxLength = 10, minTSpan = 2 ** -16) {\r\n    const ts = [0, 1]; // include endpoints\r\n    const tStack = [[0, 1]];\r\n    while (tStack.length) {\r\n        const ts_ = tStack.pop();\r\n        if (ts_[1] - ts_[0] <= minTSpan) {\r\n            continue;\r\n        }\r\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_2__.fromTo)(ps, ts_[0], ts_[1]);\r\n        if ((0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(ps_) > maxLength ||\r\n            (0,_global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_1__.curviness)(ps_) > maxCurviness) {\r\n            const t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\n\r\n//# sourceMappingURL=split-by-curvature-and-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/split-by-curvature-and-length.js?')},"./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "splitByCurvature": () => (/* binding */ splitByCurvature)\n/* harmony export */ });\n/* harmony import */ var _global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global-properties/curviness.js */ "./node_modules/flo-bezier3/node/global-properties/curviness.js");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\n/**\r\n * Split the order 0,1,2 or 3 bezier curve into pieces (given as an array of\r\n * parameter `t` values) such that each piece is flat within a given tolerance\r\n * given by the `curviness` function.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param maxCurviness optional; defaults to `0.4 radians`; maximum curviness\r\n * (must be > 0) as calculated using\r\n * the `curviness` function (which measures the total angle in radians formed\r\n * by the vectors formed by the ordered control points);\r\n * @param minTSpan optional; defaults to `2**-16`; the minimum `t` span that\r\n * can be returned for a bezier piece; necessary for cubics otherwise a curve\r\n * with a cusp would cause an infinite loop\r\n *\r\n * @doc mdx\r\n */\r\nfunction splitByCurvature(ps, maxCurviness = 0.4, minTSpan = 2 ** -16) {\r\n    const ts = [0, 1]; // include endpoints\r\n    const tStack = [[0, 1]];\r\n    while (tStack.length) {\r\n        const ts_ = tStack.pop();\r\n        if (ts_[1] - ts_[0] <= minTSpan) {\r\n            continue;\r\n        }\r\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, ts_[0], ts_[1]);\r\n        const curviness_ = (0,_global_properties_curviness_js__WEBPACK_IMPORTED_MODULE_0__.curviness)(ps_);\r\n        if (curviness_ > maxCurviness) {\r\n            const t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\n\r\n//# sourceMappingURL=split-by-curvature.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/split-by-curvature.js?')},"./node_modules/flo-bezier3/node/transformation/split/split-by-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "splitByLength": () => (/* binding */ splitByLength)\n/* harmony export */ });\n/* harmony import */ var _global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global-properties/length/control-point-lines-length.js */ "./node_modules/flo-bezier3/node/global-properties/length/control-point-lines-length.js");\n/* harmony import */ var _from_to_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to.js */ "./node_modules/flo-bezier3/node/transformation/split/from-to.js");\n\r\n\r\n/**\r\n * Split the given bezier curve into pieces (given as an array of parameter\r\n * `t` values) such that the longest curve length is guaranteed to be lower than\r\n * the given max length.\r\n *\r\n * @param ps an order 0,1,2 or 3 bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\r\n * @param maxLength\r\n *\r\n * @doc mdx\r\n */\r\nfunction splitByLength(ps, maxLength) {\r\n    const ts = [0, 1]; // include endpoints\r\n    const tStack = [[0, 1]];\r\n    while (tStack.length) {\r\n        const ts_ = tStack.pop();\r\n        const ps_ = (0,_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, ts_[0], ts_[1]);\r\n        if ((0,_global_properties_length_control_point_lines_length_js__WEBPACK_IMPORTED_MODULE_0__.controlPointLinesLength)(ps_) > maxLength) {\r\n            const t = (ts_[0] + ts_[1]) / 2;\r\n            tStack.push([ts_[0], t]);\r\n            tStack.push([t, ts_[1]]);\r\n            ts.push(t);\r\n        }\r\n    }\r\n    ts.sort((a, b) => a - b);\r\n    return ts;\r\n}\r\n\r\n//# sourceMappingURL=split-by-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/split/split-by-length.js?')},"./node_modules/flo-bezier3/node/transformation/to-string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toString\": () => (/* binding */ toString)\n/* harmony export */ });\n/**\r\n * Returns a 'human readable' string representation of the given bezier curve.\r\n *\r\n * @param ps a bezier curve given as an ordered array of its\r\n * control point coordinates, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\r\n *\r\n * @doc\r\n */\r\nfunction toString(ps) {\r\n    return `[${ps.map(p => `[${p.join(',')}]`).join(',')}]`;\r\n}\r\n\r\n//# sourceMappingURL=to-string.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-bezier3/node/transformation/to-string.js?")},"./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "areContainersIntersecting": () => (/* binding */ areContainersIntersecting)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n\r\nfunction areContainersIntersecting(container1, container2) {\r\n    return (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.areBoxesIntersecting)(true, container1.box, container2.box);\r\n}\r\n\r\n//# sourceMappingURL=are-containers-intersecting.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js?')},"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getContainerInOuts": () => (/* binding */ getContainerInOuts)\n/* harmony export */ });\n/* harmony import */ var _get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-in-outs-via-sides/get-in-outs-via-sides.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js");\n/* harmony import */ var _get_in_outs_via_crossing_get_in_outs_via_crossing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-in-outs-via-crossing/get-in-outs-via-crossing.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js");\n\r\n\r\n/**\r\n * * **warning** ioIdx will be modified by this function\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getContainerInOuts(container, ioIdx) {\r\n    // We check one _X_ for each curve with an intersection within this container\r\n    let xs = container.xs;\r\n    // Check nature of Xs. If Xs is the very common case where two curves cross\r\n    // we can use a faster check. Also in the bit less common case where all\r\n    // curves are joining at an interface we can do a fast ccw (the ccw part\r\n    // has not been implemented yet).\r\n    if (xs.length === 2) {\r\n        if (xs[0].x.kind === 1 && xs[1].x.kind === 1 &&\r\n            xs[0].x.ri.multiplicity % 2 === 1 && xs[1].x.ri.multiplicity % 2 === 1) {\r\n            return (0,_get_in_outs_via_crossing_get_in_outs_via_crossing_js__WEBPACK_IMPORTED_MODULE_1__.getInOutsViaCrossing)(container, ioIdx);\r\n        }\r\n    }\r\n    return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_0__.getInOutsViaSides)(container, ioIdx);\r\n}\r\n\r\n//# sourceMappingURL=get-container-in-outs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js?')},"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInOutsViaCrossing": () => (/* binding */ getInOutsViaCrossing)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-in-outs-via-sides/get-in-outs-via-sides.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js");\n\r\n\r\n\r\n/**\r\n * Returns the incoming / outgoing curves (as InOuts) for the given container.\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getInOutsViaCrossing(container, ioIdx) {\r\n    let xs = container.xs;\r\n    let inOuts = [];\r\n    let x1 = xs[0];\r\n    let x2 = xs[1];\r\n    let ps1 = x1.curve.ps;\r\n    let ps2 = x2.curve.ps;\r\n    let p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(ps1, x1.x.ri.tS);\r\n    let t1S = x1.x.ri.tS;\r\n    let t1E = x1.x.ri.tE;\r\n    let t2S = x2.x.ri.tS;\r\n    let t2E = x2.x.ri.tE;\r\n    let v1s;\r\n    let v2s;\r\n    if (ps1.length === 4 || ps1.length === 3) {\r\n        // cubic => hodograph is a parabola\r\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\r\n        let h1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps1); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\r\n        v1s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(h1, [t1S, t1E]);\r\n    }\r\n    else /*if (ps1.length === 2)*/ {\r\n        // line => hodograph is a fixed point\r\n        v1s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps1); // <= 52 bit-aligned => exact\r\n    }\r\n    if (ps2.length === 4 || ps2.length === 3) {\r\n        // cubic => hodograph is a parabola\r\n        // quadratic => hodograph is a line (we still get the box, but in future maybe we can do better)\r\n        let h2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps2); // <= cubic: 50 bit-aligned => exact, quadratic: 52 bit-aligned => exact\r\n        v2s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getIntervalBox)(h2, [t2S, t2E]);\r\n    }\r\n    else /*if (ps2.length === 2)*/ {\r\n        // line => hodograph is a fixed point\r\n        v2s = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.getHodograph)(ps2); // <= 52 bit-aligned => exact\r\n    }\r\n    // possible configurations: (up to cyclic permutation)\r\n    // config1: i1 o2 o1 i2 ==== i2 i1 o2 o1 ==== etc.\r\n    // config2: i1 i2 o1 o2 ==== o2 i1 i2 o1 ==== etc.\r\n    let cSign = undefined;\r\n    // TODO - investigate faster method by finding and using the 2 extreme points only\r\n    for (let i = 0; i < v1s.length; i++) {\r\n        for (let j = 0; j < v2s.length; j++) {\r\n            // we use orient2d below since it is completely robust (cross is not)\r\n            //let c = Math.sign(cross(v1s[i],v2s[j]));\r\n            let c = Math.sign((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(v1s[i], v2s[j], [0, 0]));\r\n            if (c === 0) {\r\n                // too close to call \r\n                // use a more accurate but slower method\r\n                return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_2__.getInOutsViaSides)(container, ioIdx);\r\n            }\r\n            if (cSign === undefined) {\r\n                cSign = c;\r\n                continue;\r\n            }\r\n            if (cSign !== c) {\r\n                // conflicting results\r\n                // use a more accurate but slower method\r\n                return (0,_get_in_outs_via_sides_get_in_outs_via_sides_js__WEBPACK_IMPORTED_MODULE_2__.getInOutsViaSides)(container, ioIdx);\r\n            }\r\n        }\r\n    }\r\n    let config1 = cSign > 0;\r\n    if (config1) {\r\n        // config1 (the 1st of the 2 possible configurations)\r\n        inOuts.push({ dir: -1, p, _x_: x1, container });\r\n        inOuts.push({ dir: +1, p, _x_: x2, container });\r\n        inOuts.push({ dir: +1, p, _x_: x1, container });\r\n        inOuts.push({ dir: -1, p, _x_: x2, container });\r\n        x1.in_ = inOuts[0];\r\n        x2.in_ = inOuts[3];\r\n    }\r\n    else {\r\n        // config2 (the 2nd of the 2 possible configurations)\r\n        inOuts.push({ dir: -1, p, _x_: x1, container });\r\n        inOuts.push({ dir: -1, p, _x_: x2, container });\r\n        inOuts.push({ dir: +1, p, _x_: x1, container });\r\n        inOuts.push({ dir: +1, p, _x_: x2, container });\r\n        x1.in_ = inOuts[0];\r\n        x2.in_ = inOuts[1];\r\n    }\r\n    return { inOuts, ioIdx };\r\n}\r\n\r\n//# sourceMappingURL=get-in-outs-via-crossing.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-crossing/get-in-outs-via-crossing.js?')},"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compareOrderedInOut\": () => (/* binding */ compareOrderedInOut)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\r\n\r\nconst abs = Math.abs;\r\n// TODO - memoize (probably at some deeper level)\r\n/**\r\n *\r\n * @param inOutA\r\n * @param inOutB\r\n */\r\nfunction compareOrderedInOut(inOutA, inOutB) {\r\n    // First compare side indexes - side indexes are the coursest ordering\r\n    let res = inOutA.side - inOutB.side;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Could not resolve by side indexes (they are the same)\r\n    // Compare by side t values\r\n    let xA = inOutA.sideX;\r\n    let xB = inOutB.sideX;\r\n    res = xA.ri.tS - xB.ri.tS;\r\n    let errBound = 2 * 4 * Number.EPSILON; // is factor of 2 necessary\r\n    if (abs(res) >= errBound) {\r\n        return res;\r\n    }\r\n    // At this point we zoom in once more (compensated once) to add an \r\n    // additional 49 bits accuracy\r\n    // TODO - first check if they are in the same k family - this will speed\r\n    // up the algorithm in those cases.\r\n    if (!xA.compensated) { // else the root is already compensated once\r\n        xA.compensated = 1; // compensate once - in future we can compensate more times if necessary\r\n        // there should be only 1 root in the 4u interval\r\n        // TODO - getPExact called too often - cache it!\r\n        xA.riExp = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.refineK1)(xA.ri, xA.getPExact())[0];\r\n    }\r\n    if (!xB.compensated) { // else the root is already compensated once\r\n        xB.compensated = 1; // compensate once - in future we can compensate more times if necessary\r\n        // there should be only 1 root in the 4u interval\r\n        // TODO - getPExact called too often - cache it!\r\n        xB.riExp = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.refineK1)(xB.ri, xB.getPExact())[0];\r\n    }\r\n    //console.log('compensated')\r\n    //console.log('xA', expEst(xA.riExp.tS), ' - ', expEst(xA.riExp.tE));\r\n    //console.log('xB', expEst(xB.riExp.tS), ' - ', expEst(xB.riExp.tE));\r\n    res = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eCompare)(xA.riExp.tS, xB.riExp.tS);\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // At this stage it is either the same curve (mathematically if endpoints\r\n    // and direction is ignored) or even the once compenensated roots cannot be\r\n    // resolved. In future we can cascade compensations to ensure resolution\r\n    // but we are already about a quadrillionth of a quadrillionth of a unit\r\n    // accurate at this stage.\r\n    res = inOutB.inOut.dir - inOutA.inOut.dir;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // At this stage they are both in or both out\r\n    // We reverse sort the ins in comparison to the outs\r\n    return inOutA.inOut.dir === 1\r\n        ? inOutA.inOut.idx - inOutB.inOut.idx\r\n        : inOutB.inOut.idx - inOutA.inOut.idx;\r\n}\r\n/** temp for testing */\r\n//function expEst(t: number[]) {\r\n//    return estimate(t.slice(0, t.length-1));\r\n//}\r\n\r\n//# sourceMappingURL=compare-in-out.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js?")},"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInOutsViaSides": () => (/* binding */ getInOutsViaSides)\n/* harmony export */ });\n/* harmony import */ var _get_x_in_outs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-x-in-outs.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js");\n/* harmony import */ var _compare_in_out_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compare-in-out.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/compare-in-out.js");\n\r\n\r\n/**\r\n * Returns the incoming / outgoing curves (as InOuts) for the given container\r\n * using an extremely small rectangle around the intersections.\r\n * * **warning** ioIdx will be modified by this function\r\n * @param container\r\n * @param ioIdx\r\n */\r\nfunction getInOutsViaSides(container, ioIdx) {\r\n    // We check one _X_ for each curve with an intersection within this container\r\n    let xs_ = container.xs;\r\n    //console.log(container.xs);\r\n    let inOuts = [];\r\n    // get a map from each Curve to each _X_ of this container\r\n    let xMap = new Map();\r\n    for (let x of xs_) {\r\n        let curve = x.curve;\r\n        let xs = xMap.get(curve);\r\n        if (!xs) {\r\n            xMap.set(curve, [x]);\r\n        }\r\n        else {\r\n            xs.push(x);\r\n        }\r\n    }\r\n    let getXInOuts_ = (0,_get_x_in_outs_js__WEBPACK_IMPORTED_MODULE_0__.getXInOuts)(container);\r\n    for (let entry of xMap) {\r\n        let [curve, xs] = entry;\r\n        let ins;\r\n        let outs;\r\n        ({ ins, outs, ioIdx } = getXInOuts_(curve, xs, ioIdx));\r\n        inOuts.push(...ins);\r\n        inOuts.push(...outs);\r\n    }\r\n    inOuts.sort(_compare_in_out_js__WEBPACK_IMPORTED_MODULE_1__.compareOrderedInOut);\r\n    return { inOuts: inOuts.map(inOut => inOut.inOut), ioIdx };\r\n}\r\n\r\n//# sourceMappingURL=get-in-outs-via-sides.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-in-outs-via-sides.js?')},"./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getXInOuts": () => (/* binding */ getXInOuts)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../sweep-line/are-boxes-intersecting.js */ "./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js");\n\r\n\r\n\r\n\r\nfunction midBox(_x_) {\r\n    return [\r\n        (_x_.x.box[0][0] + _x_.x.box[1][0]) / 2,\r\n        (_x_.x.box[0][1] + _x_.x.box[1][1]) / 2\r\n    ];\r\n}\r\n/**\r\n * * **warning** modifies container.xs[i].in_\r\n * @param container\r\n */\r\nfunction getXInOuts(container) {\r\n    let [[left, top], [right, bottom]] = container.box;\r\n    let sides = [\r\n        [[right, top], [left, top]],\r\n        [[left, top], [left, bottom]],\r\n        [[left, bottom], [right, bottom]],\r\n        [[right, bottom], [right, top]]\r\n    ];\r\n    return (curve, xs_, ioIdx) => {\r\n        // At this point all xs belong to the same curve and container.\r\n        // For each of the four sides get the t values closest to the \r\n        // intersection t.\r\n        let ps = curve.ps;\r\n        let xs = xs_.slice();\r\n        for (let i = 0; i < sides.length; i++) {\r\n            let xs_ = getTs(ps, sides[i]);\r\n            for (let { psX, sideX } of xs_) {\r\n                xs.push({\r\n                    x: psX,\r\n                    side: i,\r\n                    sideX,\r\n                    curve: undefined, // unused\r\n                });\r\n            }\r\n        }\r\n        //---- resolve in-outs\r\n        // the sort below should always resolve if the container dimension is\r\n        // \'large enough\', where large enough is based on the maximum value that\r\n        // the tangent magnitude of a curve can attain (no need to resort to \r\n        // compensated intervals)\r\n        xs.sort((xA, xB) => xA.x.ri.tS - xB.x.ri.tS);\r\n        let ins = [];\r\n        let outs = [];\r\n        let prevX = undefined;\r\n        /** true if the prevX was a proper X, false if it was a SideX */\r\n        let prevWasX = undefined;\r\n        for (let x of xs) {\r\n            if (x.side !== undefined) {\r\n                // it is a sideX\r\n                if (prevWasX === true) {\r\n                    //console.log(midBox(x))\r\n                    outs.push({\r\n                        inOut: {\r\n                            dir: +1,\r\n                            p: midBox(x),\r\n                            _x_: prevX,\r\n                            container,\r\n                            idx: ++ioIdx\r\n                        },\r\n                        side: x.side,\r\n                        sideX: x.sideX\r\n                    });\r\n                }\r\n                prevWasX = false;\r\n            }\r\n            else {\r\n                // it is a proper X\r\n                if (prevWasX === false) {\r\n                    ins.push({\r\n                        inOut: {\r\n                            dir: -1,\r\n                            p: midBox(prevX),\r\n                            _x_: x,\r\n                            container,\r\n                            idx: ++ioIdx\r\n                        },\r\n                        side: prevX.side,\r\n                        sideX: prevX.sideX\r\n                    });\r\n                    x.in_ = ins[ins.length - 1].inOut;\r\n                }\r\n                prevWasX = true;\r\n            }\r\n            prevX = x;\r\n        }\r\n        return { ins, outs, ioIdx };\r\n    };\r\n}\r\n/**\r\n * Get zero times compensated roots and exact coefficents\r\n */\r\nfunction getXs0(ps1, ps2) {\r\n    // let _coeffs = getIntersectionCoeffs(ps1, ps2);\r\n    let _coeffs = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getCoeffsBezBez)(ps1, ps2);\r\n    if (_coeffs === undefined) {\r\n        return undefined;\r\n    }\r\n    let { coeffs, errBound, getPExact } = _coeffs;\r\n    let ris = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.allRootsCertified)(coeffs, 0, 1, errBound, getPExact);\r\n    if (ris.length === 0) {\r\n        return undefined;\r\n    }\r\n    return { ris: ris.map(flo_poly__WEBPACK_IMPORTED_MODULE_1__.rootIntervalToExp), getPExact };\r\n}\r\nfunction rootIntervalToDouble(ri) {\r\n    return {\r\n        tS: (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(ri.tS),\r\n        tE: (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(ri.tE),\r\n        multiplicity: ri.multiplicity\r\n    };\r\n}\r\n/**\r\n * Robustly get matching intersections of ps (a bezier) that matches those of\r\n * side. ps and side can actually be any order 1, 2 or 3 bezier curve.\r\n * * **precondition** RootInterval[] contains no multiple roots\r\n * @param ps\r\n * @param side\r\n * @param risSide_\r\n */\r\nfunction getTs(ps, side) {\r\n    let xs0Side = getXs0(ps, side);\r\n    if (xs0Side === undefined) {\r\n        return [];\r\n    }\r\n    let { ris: risSide, getPExact: getPExactSide } = xs0Side;\r\n    //let exactSide = getPExactSide();\r\n    let exactSide = undefined; // lazy loaded\r\n    let getPExactSide_ = () => {\r\n        exactSide = exactSide || getPExactSide();\r\n        return exactSide;\r\n    };\r\n    let xs0Ps = getXs0(side, ps);\r\n    if (xs0Ps === undefined) {\r\n        return [];\r\n    }\r\n    let { ris: risPs, getPExact: getPExactPs } = xs0Ps;\r\n    //let exactPs = getPExactPs();\r\n    let exactPs = undefined; // lazy loaded\r\n    let getPExactPs_ = () => {\r\n        exactPs = exactPs || getPExactPs();\r\n        return exactPs;\r\n    };\r\n    //---- Make sure no boxesPs overlap. \r\n    // If any two boxes do operlap we cannot match the t value of a ps box to \r\n    // that of a side box, else we can definitively match them.\r\n    // Note: multiplicity > 1 intersections will result in an infinite loop. \r\n    // It is assumed (as a precondition) the code is such that a multiple \r\n    // intersection is node possible here\r\n    let maxIter;\r\n    // currently we only go up to once compensated (double-double precision roots)\r\n    maxIter = 1;\r\n    /** number of compensations for ps */\r\n    let cPs = 0;\r\n    let boxesPs = undefined;\r\n    loop: while ( true && cPs < maxIter) {\r\n        // update boxes to new tighter versions\r\n        boxesPs = risPs.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getIntervalBoxDd)(ps, [ri.tS, ri.tE]));\r\n        for (let i = 0; i < risPs.length; i++) {\r\n            let boxPsI = boxesPs[i];\r\n            for (let j = i + 1; j < risPs.length; j++) {\r\n                let boxPsJ = boxesPs[j];\r\n                if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersectingDd)(true)(boxPsI, boxPsJ)) {\r\n                    let _risPs = [];\r\n                    for (let riPs of risPs) {\r\n                        // TODO - below we\'re converting riPs (using getXs0) to RootIntervalExp and below back to \r\n                        // RootInterval again - not necessary - fix\r\n                        _risPs.push(...(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.refineK1)({ tS: riPs.tS[1], tE: riPs.tE[1], multiplicity: riPs.multiplicity }, getPExactPs_()));\r\n                    }\r\n                    risPs = _risPs;\r\n                    cPs++;\r\n                    continue loop;\r\n                }\r\n            }\r\n        }\r\n        break loop;\r\n    }\r\n    //---- Make sure no boxesSides overlap - this should be rare as we are \r\n    // already roughly once compensated on that (due to small length of the sides).\r\n    // currently we only go up to once compensated (quad precision roots)\r\n    maxIter = 1;\r\n    /** number of compensations for sides */\r\n    let cSide = 0;\r\n    let boxesSide = undefined;\r\n    loop: while ( true && cSide < maxIter) {\r\n        boxesSide = risSide.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_2__.getIntervalBoxDd)(side, [ri.tS, ri.tE]));\r\n        for (let i = 0; i < risSide.length; i++) {\r\n            let boxSideI = boxesSide[i];\r\n            for (let j = i + 1; j < risSide.length; j++) {\r\n                let boxSideJ = boxesSide[j];\r\n                if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersectingDd)(true)(boxSideI, boxSideJ)) {\r\n                    let _risSide = [];\r\n                    for (let riSide of risSide) {\r\n                        _risSide.push(...(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.refineK1)({ tS: riSide.tS[1], tE: riSide.tE[1], multiplicity: riSide.multiplicity }, getPExactSide_()));\r\n                    }\r\n                    risSide = _risSide;\r\n                    cSide++;\r\n                    continue loop;\r\n                }\r\n            }\r\n        }\r\n        break loop;\r\n    }\r\n    let xPairs = [];\r\n    for (let i = 0; i < risPs.length; i++) {\r\n        let boxPs = boxesPs[i];\r\n        for (let j = 0; j < risSide.length; j++) {\r\n            let boxSide = boxesSide[j];\r\n            // TODO - investigate if below commented code would improve algorithm\r\n            //let box = intersectBoxes(boxPs,boxSide);\r\n            //if (box !== undefined) {\r\n            if ((0,_sweep_line_are_boxes_intersecting_js__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersectingDd)(true)(boxPs, boxSide)) {\r\n                let psX = {\r\n                    compensated: cPs,\r\n                    ri: rootIntervalToDouble(risPs[i]),\r\n                    riExp: cPs ? risPs[i] : undefined,\r\n                    getPExact: cPs ? undefined : getPExactPs,\r\n                    kind: 1,\r\n                    box: boxExpToBox(boxPs)\r\n                };\r\n                let sideX = {\r\n                    compensated: cSide,\r\n                    ri: rootIntervalToDouble(risSide[j]),\r\n                    riExp: cSide ? risSide[j] : undefined,\r\n                    getPExact: cSide ? undefined : getPExactSide,\r\n                    kind: 1,\r\n                    box: boxExpToBox(boxSide)\r\n                };\r\n                xPairs.push({ psX, sideX });\r\n            }\r\n        }\r\n    }\r\n    return xPairs;\r\n}\r\n/**\r\n * Converts a box with expansion coordinates into one with double coordinates.\r\n */\r\nfunction boxExpToBox(boxExp) {\r\n    return boxExp.map(p => p.map(big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate));\r\n}\r\n\r\n//# sourceMappingURL=get-x-in-outs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-in-outs-via-sides/get-x-in-outs.js?')},"./node_modules/flo-boolean/node/calc-containers/get-containers.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getContainers": () => (/* binding */ getContainers)\n/* harmony export */ });\n/* harmony import */ var _are_containers_intersecting_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./are-containers-intersecting.js */ "./node_modules/flo-boolean/node/calc-containers/are-containers-intersecting.js");\n/* harmony import */ var _graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/get-connected-components.js */ "./node_modules/flo-boolean/node/graph/get-connected-components.js");\n/* harmony import */ var _get_isolated_containers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-isolated-containers.js */ "./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js");\n/* harmony import */ var _merge_containers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge-containers.js */ "./node_modules/flo-boolean/node/calc-containers/merge-containers.js");\n/* harmony import */ var _get_container_in_outs_get_container_in_outs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-container-in-outs/get-container-in-outs.js */ "./node_modules/flo-boolean/node/calc-containers/get-container-in-outs/get-container-in-outs.js");\n/* harmony import */ var _get_critical_points_get_intersections_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../get-critical-points/get-intersections.js */ "./node_modules/flo-boolean/node/get-critical-points/get-intersections.js");\n/* harmony import */ var _get_critical_points_set_intersection_next_values_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../get-critical-points/set-intersection-next-values.js */ "./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js");\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sweep-line/sweep-line.js */ "./node_modules/flo-boolean/node/sweep-line/sweep-line.js");\n/* harmony import */ var _get_critical_points_get_self_intersections_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../get-critical-points/get-self-intersections.js */ "./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js");\n/* harmony import */ var _get_critical_points_get_interface_intersections_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../get-critical-points/get-interface-intersections.js */ "./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js");\n/* harmony import */ var _get_critical_points_get_extremes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../get-critical-points/get-extremes.js */ "./node_modules/flo-boolean/node/get-critical-points/get-extremes.js");\n/* harmony import */ var _send_containers_to_grid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./send-containers-to-grid.js */ "./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param containerDim\r\n */\r\nfunction getContainers(loops, containerDim, expMax) {\r\n    //let t0 = performance.now();\r\n    let xs1 = (0,_get_critical_points_get_intersections_js__WEBPACK_IMPORTED_MODULE_5__.getIntersections)(loops, expMax);\r\n    //let t1 = performance.now();\r\n    //console.log("intersections took " + ((t1 - t0)).toFixed(3) + " milliseconds.");\r\n    let xs2 = (0,_get_critical_points_get_self_intersections_js__WEBPACK_IMPORTED_MODULE_8__.getSelfIntersections)(loops);\r\n    let xs3 = (0,_get_critical_points_get_interface_intersections_js__WEBPACK_IMPORTED_MODULE_9__.getInterfaceIntersections)(loops);\r\n    let { extremes, xs: xs4 } = (0,_get_critical_points_get_extremes_js__WEBPACK_IMPORTED_MODULE_10__.getExtremes)(loops);\r\n    let xPairs = [...xs1, ...xs2, ...xs3, ...xs4];\r\n    //console.log(\'general  \', xs1);\r\n    //console.log(\'self     \', xs2);\r\n    //console.log(\'interface\', xs3);\r\n    //console.log(\'topmost  \', xs4);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        for (let xPair of xs1) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        for (let xPair of xs2) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        // TODO - are interface intersections really necessary?\r\n        for (let xPair of xs3) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n        for (let xPair of xs4) {\r\n            _debug_.generated.elems.intersection.push(...xPair);\r\n        }\r\n    }\r\n    // initialize the containers with one of the one-sided intersections\r\n    // console.log(xPairs)\r\n    let containers = xPairs.map(xPair => ({\r\n        xs: xPair,\r\n        box: [\r\n            // TODO xs[0].box -> combine xs[0] and xs[1] boxes\r\n            [xPair[0].x.box[0][0] - containerDim, xPair[0].x.box[0][1] - containerDim],\r\n            [xPair[0].x.box[1][0] + containerDim, xPair[0].x.box[1][1] + containerDim]\r\n        ],\r\n        inOuts: undefined // to be set later\r\n    }));\r\n    // iterate, combining containers that overlap on each iteration \r\n    while (true) {\r\n        /** container intersections as an array of Container pairs */\r\n        let is = (0,_sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_7__.sweepLine)(containers, getLeftMost, getRightMost, _are_containers_intersecting_js__WEBPACK_IMPORTED_MODULE_0__.areContainersIntersecting);\r\n        // if there are no more intersections between containers we\'re done\r\n        if (!is.length) {\r\n            break;\r\n        }\r\n        let graph = new Map();\r\n        (0,_graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_1__.addEdges)(graph, is);\r\n        let connectedContainers = (0,_graph_get_connected_components_js__WEBPACK_IMPORTED_MODULE_1__.getConnectedComponents)(graph);\r\n        let isolatedContainers = (0,_get_isolated_containers_js__WEBPACK_IMPORTED_MODULE_2__.getIsolatedComponents)(containers, connectedContainers);\r\n        containers = [\r\n            ...(0,_merge_containers_js__WEBPACK_IMPORTED_MODULE_3__.mergeContainers)(connectedContainers),\r\n            ...isolatedContainers\r\n        ];\r\n    }\r\n    containers = filterContainers(containers);\r\n    containers = (0,_send_containers_to_grid_js__WEBPACK_IMPORTED_MODULE_11__.sendContainersToGrid)(containers, expMax, containerDim);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        _debug_.generated.elems.container = containers;\r\n    }\r\n    // Add the other half of the intersections too - all intersections has \r\n    // exactly one opposite curve intersection (t values come in pairs)\r\n    // Also, set inOuts on each container, and debugging idx\r\n    let ioIdx = 0;\r\n    //containers.reverse();  // TODO - REMOVE THIS LINE !!! <---\r\n    for (let container of containers) {\r\n        for (let x of container.xs) {\r\n            x.container = container;\r\n        }\r\n        let inOuts;\r\n        ({ inOuts, ioIdx } = (0,_get_container_in_outs_get_container_in_outs_js__WEBPACK_IMPORTED_MODULE_4__.getContainerInOuts)(container, ioIdx));\r\n        container.inOuts = inOuts;\r\n    }\r\n    // remove xs not belonging to a container (caused by filterContainers)\r\n    xPairs = xPairs.filter(x => x[0].container);\r\n    (0,_get_critical_points_set_intersection_next_values_js__WEBPACK_IMPORTED_MODULE_6__.setIntersectionNextValues)(xPairs);\r\n    // Connect container ins and outs\r\n    for (let container of containers) {\r\n        for (let out of container.inOuts) {\r\n            if (out.dir === -1) {\r\n                continue;\r\n            }\r\n            let _x_ = out._x_;\r\n            // move to next \'in\' _X_\r\n            while (true) {\r\n                _x_ = _x_.next;\r\n                if (_x_.in_) {\r\n                    break;\r\n                }\r\n            }\r\n            out.next = _x_.in_;\r\n            out.idx = out.next.idx;\r\n        }\r\n    }\r\n    // set next and prev around container for each inout for each container\r\n    for (let container of containers) {\r\n        let inOuts = container.inOuts;\r\n        let prevInOut = inOuts[inOuts.length - 1];\r\n        for (let i = 0; i < inOuts.length; i++) {\r\n            let inOut = inOuts[i];\r\n            inOut.prevAround = prevInOut;\r\n            prevInOut.nextAround = inOut;\r\n            prevInOut = inOut;\r\n        }\r\n    }\r\n    return { extremes, containers };\r\n}\r\n/**\r\n * Returns the containers that is the given containers filtered so that those\r\n * having only interface intersections or only a single (giben as a pair) even\r\n * multiple intersection are not included.\r\n * @param containers\r\n */\r\nfunction filterContainers(containers) {\r\n    let containers_ = containers.filter(container => {\r\n        let xs = container.xs;\r\n        if (container.xs.length === 2) {\r\n            let _x_ = xs[0];\r\n            if (_x_.x.kind === 1 && _x_.x.ri.multiplicity % 2 === 0) {\r\n                // multiple even intersection - exclude\r\n                return false;\r\n            }\r\n        }\r\n        for (let x of container.xs) {\r\n            if (x.x.kind !== 4) {\r\n                // include container if any _X_ is not an interface\r\n                return true;\r\n            }\r\n        }\r\n        return false; // exclude container\r\n    });\r\n    return containers_;\r\n}\r\nfunction getLeftMost(container) {\r\n    return container.box[0][0];\r\n}\r\nfunction getRightMost(container) {\r\n    return container.box[1][0];\r\n}\r\n\r\n//# sourceMappingURL=get-containers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-containers.js?')},"./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getIsolatedComponents": () => (/* binding */ getIsolatedComponents)\n/* harmony export */ });\n/**\r\n * @param containers all containers\r\n * @param connectedContainers\r\n */\r\nfunction getIsolatedComponents(containers, connectedContainers) {\r\n    let connectedContainers_ = new Set();\r\n    for (let cs of connectedContainers) {\r\n        for (let c of cs) {\r\n            connectedContainers_.add(c);\r\n        }\r\n    }\r\n    let res = [];\r\n    for (let i = 0; i < containers.length; i++) {\r\n        let container = containers[i];\r\n        if (!connectedContainers_.has(container)) {\r\n            res.push(container);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=get-isolated-containers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/get-isolated-containers.js?')},"./node_modules/flo-boolean/node/calc-containers/merge-containers.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mergeContainers": () => (/* binding */ mergeContainers)\n/* harmony export */ });\nfunction mergeContainers(ccs) {\r\n    let containers = [];\r\n    for (let cc of ccs) {\r\n        let minLeft = Number.POSITIVE_INFINITY;\r\n        let minTop = Number.POSITIVE_INFINITY;\r\n        let maxRight = Number.NEGATIVE_INFINITY;\r\n        let maxBottom = Number.NEGATIVE_INFINITY;\r\n        let xs = [];\r\n        for (let c of cc) {\r\n            let [[left, top], [right, bottom]] = c.box;\r\n            if (left < minLeft) {\r\n                minLeft = left;\r\n            }\r\n            if (top < minTop) {\r\n                minTop = top;\r\n            }\r\n            if (right > maxRight) {\r\n                maxRight = right;\r\n            }\r\n            if (bottom > maxBottom) {\r\n                maxBottom = bottom;\r\n            }\r\n            xs.push(...c.xs);\r\n        }\r\n        // console.log(minLeft)\r\n        let container = {\r\n            box: [[minLeft, minTop], [maxRight, maxBottom]],\r\n            xs: xs,\r\n            inOuts: undefined\r\n        };\r\n        containers.push(container);\r\n    }\r\n    return containers;\r\n}\r\n\r\n//# sourceMappingURL=merge-containers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/merge-containers.js?')},"./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sendContainersToGrid": () => (/* binding */ sendContainersToGrid)\n/* harmony export */ });\n/* harmony import */ var _loop_normalize_to_grid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/normalize/to-grid.js */ "./node_modules/flo-boolean/node/loop/normalize/to-grid.js");\n\r\n/**\r\n * Returns the containers from the given containers by sending their boxes to a\r\n * grid with a smaller bitlength.\r\n * @param containers\r\n * @param expMax\r\n * @param containerDim\r\n */\r\nfunction sendContainersToGrid(containers, expMax, containerDim) {\r\n    /**\r\n     * The exponent difference between expMax and the distance of critical\r\n     * points from the sides of the containers. This value cannot be higher\r\n     * than ⌈sqrt(n)⌉ where n is the number of intersections in a container.\r\n     * Assume n < 100 - this is a (mild) limitation of the algorithm\r\n     */\r\n    let expContainer = Math.log2(containerDim);\r\n    let expContainerAdj = expContainer - 3; // 2**-3 === 1/8 of container\r\n    let containers_ = containers.map(container => {\r\n        let box = container.box;\r\n        box = box.map(p => p.map(c => {\r\n            return (0,_loop_normalize_to_grid_js__WEBPACK_IMPORTED_MODULE_0__.toGrid)(c, expMax, expMax - expContainerAdj);\r\n        }));\r\n        return { ...container, box };\r\n    });\r\n    return containers_;\r\n}\r\n\r\n//# sourceMappingURL=send-containers-to-grid.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-containers/send-containers-to-grid.js?')},"./node_modules/flo-boolean/node/calc-paths/complete-loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "completeLoop": () => (/* binding */ completeLoop)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _get_next_exit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-next-exit.js */ "./node_modules/flo-boolean/node/calc-paths/get-next-exit.js");\n/* harmony import */ var _get_beziers_to_next_container_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-beziers-to-next-container.js */ "./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js");\n\r\n\r\n\r\n\r\n/**\r\n * Completes a loop for a specific intersection point entry curve.\r\n * @param expMax\r\n * @param takenOuts\r\n * @param out\r\n */\r\nfunction completeLoop(expMax, takenOuts, out) {\r\n    let additionalOutsToCheck = [];\r\n    let beziers = [];\r\n    // Move immediately to the outgoing start of the loop\r\n    let out_ = out;\r\n    let additionalBezier;\r\n    let ii = 0; // TODO - remove\r\n    do {\r\n        takenOuts.add(out_); // Mark this intersection as taken\r\n        let { beziers: additionalBeziers, in_, inBez } = (0,_get_beziers_to_next_container_js__WEBPACK_IMPORTED_MODULE_3__.getBeziersToNextContainer)(expMax, out_);\r\n        // TODO - it will probably better to remove additionalBeziers and just\r\n        // connect the endpoints of adjacent beziers - even if we had near\r\n        // exact coordinates (think quad or better precision) of intersections\r\n        // they are still not returned as algebraic numbers so we can never have\r\n        // a perfect algorithm anyway without returning algebraic numbers as \r\n        // intersection coordinates, hence we might as well remove \r\n        // additionalBeziers whose length is about a trillionth of the max\r\n        // coordinate of loops\r\n        beziers.push(...additionalBeziers);\r\n        ({ out_, additionalBezier } = (0,_get_next_exit_js__WEBPACK_IMPORTED_MODULE_2__.getNextExit)(expMax, in_, out, additionalOutsToCheck, takenOuts));\r\n        if (additionalBezier) {\r\n            let t = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.closestPointOnBezierCertified)(inBez, additionalBezier[0])[0].ri);\r\n            let inBez_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.fromTo)(inBez, 0, t);\r\n            beziers.push(inBez_);\r\n            beziers.push(additionalBezier);\r\n        }\r\n        else {\r\n            beziers.push(inBez);\r\n        }\r\n    } while (out_ !== out /* && ii++ < 100*/);\r\n    return { beziers, additionalOutsToCheck };\r\n}\r\n\r\n//# sourceMappingURL=complete-loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/complete-loop.js?')},"./node_modules/flo-boolean/node/calc-paths/complete-path.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "completePath": () => (/* binding */ completePath)\n/* harmony export */ });\n/* harmony import */ var _complete_loop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complete-loop.js */ "./node_modules/flo-boolean/node/calc-paths/complete-loop.js");\n\r\n/**\r\n * Completes the path of a disjoint set of loops, i.e. this function is called\r\n * for each disjoint set of paths.\r\n * @param intersections\r\n * @param takenLoops\r\n * @param parent\r\n * @param loop\r\n */\r\nfunction completePath(expMax, initialOut, takenLoops, takenOuts) {\r\n    let outStack = [initialOut];\r\n    while (outStack.length) {\r\n        let out = outStack.pop();\r\n        takenLoops.add(out._x_.curve.loop);\r\n        if (takenOuts.has(out)) {\r\n            continue;\r\n        }\r\n        out.children = new Set();\r\n        let { beziers, additionalOutsToCheck } = (0,_complete_loop_js__WEBPACK_IMPORTED_MODULE_0__.completeLoop)(expMax, takenOuts, out);\r\n        out.beziers = beziers;\r\n        out.parent.children = out.parent.children || new Set();\r\n        out.parent.children.add(out);\r\n        outStack.push(...additionalOutsToCheck);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=complete-path.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/complete-path.js?')},"./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBeziersToNextContainer": () => (/* binding */ getBeziersToNextContainer)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _container_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container.js */ "./node_modules/flo-boolean/node/container.js");\n\r\n\r\n\r\nfunction getBeziersToNextContainer(expMax, out) {\r\n    let in_ = out.next;\r\n    let endCurve = in_._x_.curve;\r\n    let endT = in_._x_.x.ri.tS;\r\n    let curCurve = out._x_.curve;\r\n    let curT = out._x_.x.ri.tS;\r\n    if (!(0,_container_js__WEBPACK_IMPORTED_MODULE_2__.containerIsBasic)(expMax, out.container)) {\r\n        // we must clip the outgoing curve\r\n        curT = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.closestPointOnBezierCertified)(curCurve.ps, out.p)[0].ri);\r\n    }\r\n    let beziers = [];\r\n    let inBez;\r\n    while (true) {\r\n        if (curCurve === endCurve &&\r\n            (curT < endT || (curT === endT && beziers.length))) {\r\n            inBez = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.fromTo)(curCurve.ps, curT, endT);\r\n            return { beziers, in_, inBez };\r\n        }\r\n        else {\r\n            let ps = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.fromTo)(curCurve.ps, curT, 1);\r\n            beziers.push(ps);\r\n        }\r\n        curT = 0;\r\n        curCurve = curCurve.next;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=get-beziers-to-next-container.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/get-beziers-to-next-container.js?')},"./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopsFromTree": () => (/* binding */ getLoopsFromTree)\n/* harmony export */ });\n/**\r\n * Returns an array of LoopTrees from the given LoopTree where each returned\r\n * LoopTree is one of the nodes of the tree. Nodes with winding number absolute\r\n * value > 1 are not returned.\r\n * @param root\r\n */\r\nfunction getLoopsFromTree(root) {\r\n    let trees = [root];\r\n    let stack = Array.from(root.children);\r\n    while (stack.length) {\r\n        let tree = stack.pop();\r\n        if (tree.windingNum === 0) {\r\n            trees.push(tree);\r\n        }\r\n        for (let child of tree.children) {\r\n            stack.push(child);\r\n        }\r\n    }\r\n    return trees;\r\n}\r\n\r\n//# sourceMappingURL=get-loops-from-tree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js?')},"./node_modules/flo-boolean/node/calc-paths/get-next-exit.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getNextExit": () => (/* binding */ getNextExit)\n/* harmony export */ });\n/* harmony import */ var _container_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container.js */ "./node_modules/flo-boolean/node/container.js");\n\r\n/**\r\n *\r\n * @param in_ the in for which the next exit should be found\r\n * @param additionalOutsToCheck\r\n */\r\nfunction getNextExit(expMax, in_, originalOut, additionalOutsToCheck, takenOuts) {\r\n    let markOutForChecking_ = markOutForChecking(originalOut, takenOuts, additionalOutsToCheck);\r\n    let additionalBezier = undefined;\r\n    let fromCount = 0;\r\n    let toCount = 1;\r\n    let next = in_;\r\n    let outToUse = undefined;\r\n    do {\r\n        next = originalOut.orientation === +1\r\n            ? next.nextAround\r\n            : next.prevAround;\r\n        if (next === in_) {\r\n            break;\r\n        }\r\n        fromCount = toCount;\r\n        toCount = toCount - next.dir;\r\n        if (next.dir === -1) {\r\n            continue;\r\n        }\r\n        if (!outToUse) {\r\n            // we are still rotating on the inside of the loop\r\n            if (toCount === 0) {\r\n                outToUse = next;\r\n            }\r\n            else if (toCount === 1) {\r\n                // the outermost inner loop must have the same orientation\r\n                markOutForChecking_(next, +1, originalOut);\r\n            }\r\n        }\r\n        else {\r\n            // else we are rotating on the outside of the loop\r\n            if (fromCount === 1 && toCount === 0) {\r\n                markOutForChecking_(next, +1, originalOut.parent);\r\n            }\r\n            else if (fromCount === 0 && toCount === -1) {\r\n                markOutForChecking_(next, -1, originalOut.parent);\r\n            }\r\n        }\r\n    } while (true);\r\n    if (!(0,_container_js__WEBPACK_IMPORTED_MODULE_0__.containerIsBasic)(expMax, in_.container)) {\r\n        // if there is multiple intersection pairs then add an additional bezier\r\n        additionalBezier = [in_.p, outToUse.p];\r\n    }\r\n    return { out_: outToUse, additionalBezier };\r\n}\r\nfunction markOutForChecking(originalOut, takenOuts, additionalOutsToCheck) {\r\n    return (out, parity, parent) => {\r\n        if (!takenOuts.has(out) && !out.orientation) {\r\n            out.orientation = parity * originalOut.orientation;\r\n            out.parent = parent;\r\n            out.windingNum = parent.windingNum + out.orientation;\r\n            additionalOutsToCheck.push(out);\r\n        }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=get-next-exit.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/get-next-exit.js?')},"./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOutermostInAndOut\": () => (/* binding */ getOutermostInAndOut)\n/* harmony export */ });\n/**\r\n * Get initial an intersection for the given loop. The loop must be such that\r\n * an extreme point on the loop forms part of an outermost loop that is outside\r\n * all other component loops that is formed by this loop and all other loops it\r\n * may intersect. This extreme point is guaranteed by the initial ordering of\r\n * the loops by their minimum y value.\r\n * @param loop\r\n * @param parent\r\n */\r\nfunction getOutermostInAndOut(container) {\r\n    let inOuts = container.inOuts;\r\n    let firstInOut = inOuts[0];\r\n    let lastInOut = inOuts[inOuts.length - 1];\r\n    // set 'loop' direction\r\n    if (firstInOut.dir === 1) {\r\n        firstInOut.orientation = -1; // anti-clockwise\r\n        return firstInOut;\r\n    }\r\n    else {\r\n        lastInOut.orientation = +1;\r\n        return lastInOut;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=get-outermost-in-and-out.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js?")},"./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getTightestContainingLoop": () => (/* binding */ getTightestContainingLoop)\n/* harmony export */ });\n/* harmony import */ var _is_loop_in_loop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-loop-in-loop.js */ "./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js");\n\r\n/**\r\n * @param root\r\n * @param loop\r\n */\r\nfunction getTightestContainingLoop(root, loop) {\r\n    let containingLoop = undefined;\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let inOut = stack.pop();\r\n        f(inOut);\r\n    }\r\n    return containingLoop;\r\n    function f(parent) {\r\n        if (parent === root || (0,_is_loop_in_loop_js__WEBPACK_IMPORTED_MODULE_0__.isLoopInLoop)(loop.beziers, parent.beziers)) {\r\n            containingLoop = parent;\r\n            for (let child of parent.children) {\r\n                stack.push(child);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=get-tightest-containing-loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js?')},"./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isLoopInLoop\": () => (/* binding */ isLoopInLoop)\n/* harmony export */ });\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-poly */ \"./node_modules/flo-poly/node/index.js\");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ \"./node_modules/flo-vector2d/node/index.js\");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../get-bounding-box-.js */ \"./node_modules/flo-boolean/node/get-bounding-box-.js\");\n/* harmony import */ var _get_bounds_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../get-bounds-.js */ \"./node_modules/flo-boolean/node/get-bounds-.js\");\n\r\n\r\n\r\n\r\n\r\n// TODO - remove delta by basing isLoopInLoop on a solid numerical analytic \r\n// basis - isLoopInLoop is the only sub-algorithm left having a DELTA.\r\nconst DELTA = 1e-6;\r\n/**\r\n * Returns true if the first loop is wholly contained within the second loop's\r\n * boundary.\r\n *\r\n * Precondition: the loop is either wholly contained inside the loop or is wholly outside.\r\n * @param loop1\r\n * @param loop2\r\n */\r\nfunction isLoopInLoop(loop1, loop2) {\r\n    let i = 0;\r\n    let seed = 1231; // Just some value\r\n    do {\r\n        i++;\r\n        // This gets us a predictable random number between 0 and 1;\r\n        let rand1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.flatCoefficients)(1, 0, 1, seed);\r\n        let t = rand1.p[0];\r\n        seed = rand1.seed; // Get next seed.\r\n        // This gets us a predictable random number roughly between 0 and the \r\n        // number of curves in the loop.\r\n        let curveCount = loop1.length;\r\n        let rand2 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.flatCoefficients)(1, 0, curveCount, seed);\r\n        let idx = Math.floor(rand2.p[0]);\r\n        seed = rand2.seed; // Get next seed.\r\n        let ps = loop1[idx];\r\n        let p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(ps, t);\r\n        let res = f(loop1, loop2, p);\r\n        if (res !== undefined) {\r\n            return res;\r\n        }\r\n    } while (i < 100);\r\n    return undefined; // There's no chance we'll get up to this point.\r\n    function f(loop1, loop2, p) {\r\n        if (isLoopNotInLoop(loop1, loop2)) {\r\n            return false;\r\n        }\r\n        let count = getAxisAlignedRayLoopIntersections(loop2, p, 'left');\r\n        if (count !== undefined) {\r\n            return count % 2 !== 0;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns true if the first loop is not wholly within the second. The converse\r\n * is not necessarily true. It is assumed the loops don't intersect.\r\n * @param loops\r\n */\r\nfunction isLoopNotInLoop(loop1, loop2) {\r\n    let boundss = [loop1, loop2].map(getLoopBounds);\r\n    return (boundss[0].minX < boundss[1].minX ||\r\n        boundss[0].maxX > boundss[1].maxX ||\r\n        boundss[0].minY < boundss[1].minY ||\r\n        boundss[0].maxY > boundss[1].maxY);\r\n}\r\nfunction getLoopBounds(pss) {\r\n    let bounds = pss.map(ps => (0,_get_bounds_js__WEBPACK_IMPORTED_MODULE_4__.getBounds_)(ps));\r\n    return {\r\n        minX: Math.min(...bounds.map(bound => bound.box[0][0])),\r\n        maxX: Math.max(...bounds.map(bound => bound.box[1][0])),\r\n        minY: Math.min(...bounds.map(bound => bound.box[0][1])),\r\n        maxY: Math.max(...bounds.map(bound => bound.box[1][1])),\r\n    };\r\n}\r\n/**\r\n * @param p The point where the horizontal ray starts\r\n * @param toLeft The ray to the left of this point (else right)\r\n * @param loop A loop of curves\r\n *\r\n * @internal\r\n */\r\nfunction getAxisAlignedRayLoopIntersections(loop, p, dir) {\r\n    let [x, y] = p;\r\n    let count = 0;\r\n    for (let i = 0; i < loop.length; i++) {\r\n        let ps = loop[i];\r\n        //------------------------------------------------------/\r\n        //---- Check if ray intersects bezier bounding box -----/\r\n        //------------------------------------------------------/\r\n        let [[minX, minY], [maxX, maxY]] = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_3__.getBoundingBox_)(ps);\r\n        let notIntersecting = ((dir === 'left' || dir === 'right') && (minY > y || maxY < y)) ||\r\n            ((dir === 'up' || dir === 'down') && (minX > x || maxX < x));\r\n        notIntersecting = notIntersecting ||\r\n            (dir === 'left' && minX > x) || (dir === 'right' && maxX < x) ||\r\n            (dir === 'down' && minY > y) || (dir === 'up' && maxY < y);\r\n        if (notIntersecting) {\r\n            continue;\r\n        } // No intersection with bezier\r\n        //------------------------------------------------------/\r\n        //----------- Get intersection ts on bezier ------------/\r\n        //------------------------------------------------------/\r\n        // Get the bezier's x-coordinate power representation.\r\n        let ts = [];\r\n        let f;\r\n        let offset;\r\n        let axis;\r\n        let dirIsDecreasing = (dir === 'left' || dir === 'up');\r\n        if (dir === 'left' || dir === 'right') {\r\n            //f = getY;\r\n            f = (ps) => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis)(ps)[1];\r\n            offset = [0, -y];\r\n            axis = 0;\r\n        }\r\n        else {\r\n            //f = getX;\r\n            f = (ps) => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.toPowerBasis)(ps)[0];\r\n            offset = [-x, 0];\r\n            axis = 1;\r\n        }\r\n        //let translatedPs = translate(offset, ps);\r\n        let translatedPs = ps.map((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.translate)(offset));\r\n        let poly = f(translatedPs);\r\n        //let ev = evalDeCasteljau(translatedPs);\r\n        let ts_ = (0,flo_poly__WEBPACK_IMPORTED_MODULE_0__.allRoots)(poly, 0 - DELTA, 1 + DELTA);\r\n        for (let i = 0; i < ts_.length; i++) {\r\n            let t = ts_[i];\r\n            if (Math.abs(t) < DELTA || Math.abs(t - 1) < DELTA) {\r\n                // We don't know the exact number of intersections due to\r\n                // floating point arithmetic. \r\n                return undefined;\r\n            }\r\n            //let p_ = ev(t);\r\n            let p_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(translatedPs, t);\r\n            if ((dirIsDecreasing && p[axis] >= p_[axis]) ||\r\n                (!dirIsDecreasing && p[axis] <= p_[axis])) {\r\n                ts.push(t);\r\n            }\r\n        }\r\n        //------------------------------------------------------/\r\n        //----- Check if line is tangent to intersections ------/\r\n        //------------------------------------------------------/\r\n        // We only care if there were 1 or 3 intersections.\r\n        if (ts.length === 1 || ts.length === 3) {\r\n            for (let t of ts) {\r\n                let tan = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.toUnitVector)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.tangent)(ps, t));\r\n                if (((dir === 'left' || dir === 'right') && Math.abs(tan[1]) < DELTA) ||\r\n                    ((dir === 'down' || dir === 'up') && Math.abs(tan[0]) < DELTA)) {\r\n                    // We don't know the exact number of intersections due to\r\n                    // floating point arithmetic\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        count += ts.length;\r\n    }\r\n    return count;\r\n}\r\n\r\n//# sourceMappingURL=is-loop-in-loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/is-loop-in-loop.js?")},"./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "orderLoopAscendingByMinY": () => (/* binding */ orderLoopAscendingByMinY)\n/* harmony export */ });\n/* harmony import */ var _get_bounds_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../get-bounds-.js */ "./node_modules/flo-boolean/node/get-bounds-.js");\n\r\n/**\r\n * Returns < 0 if loopA\'s topmost point is higher (i.e. smaller) than that of\r\n * loopB. Using this function in a sort will sort from highest topmost (smallest\r\n * y) point loops to lowest in a left-handed coordinate system.\r\n * @param loopA\r\n * @param loopB\r\n */\r\nfunction orderLoopAscendingByMinY(loopA, loopB) {\r\n    return getMinY(loopA) - getMinY(loopB);\r\n}\r\nfunction getMinY(pss) {\r\n    let minY = Number.POSITIVE_INFINITY;\r\n    for (let ps of pss) {\r\n        let y = (0,_get_bounds_js__WEBPACK_IMPORTED_MODULE_0__.getBounds_)(ps).box[0][1];\r\n        if (y < minY) {\r\n            minY = y;\r\n        }\r\n    }\r\n    return minY;\r\n}\r\n\r\n//# sourceMappingURL=order-loop-ascending-by-min-y.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js?')},"./node_modules/flo-boolean/node/calc-paths/simplify-paths.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "simplifyPaths": () => (/* binding */ simplifyPaths)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _complete_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complete-path.js */ "./node_modules/flo-boolean/node/calc-paths/complete-path.js");\n/* harmony import */ var _get_tightest_containing_loop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-tightest-containing-loop.js */ "./node_modules/flo-boolean/node/calc-paths/get-tightest-containing-loop.js");\n/* harmony import */ var _order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order-loop-ascending-by-min-y.js */ "./node_modules/flo-boolean/node/calc-paths/order-loop-ascending-by-min-y.js");\n/* harmony import */ var _split_loop_trees_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./split-loop-trees.js */ "./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js");\n/* harmony import */ var _get_loops_from_tree_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./get-loops-from-tree.js */ "./node_modules/flo-boolean/node/calc-paths/get-loops-from-tree.js");\n/* harmony import */ var _calc_containers_get_containers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../calc-containers/get-containers.js */ "./node_modules/flo-boolean/node/calc-containers/get-containers.js");\n/* harmony import */ var _get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./get-outermost-in-and-out.js */ "./node_modules/flo-boolean/node/calc-paths/get-outermost-in-and-out.js");\n/* harmony import */ var _loop_reverse_orientation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../loop/reverse-orientation.js */ "./node_modules/flo-boolean/node/loop/reverse-orientation.js");\n/* harmony import */ var _loop_loop_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../loop/loop.js */ "./node_modules/flo-boolean/node/loop/loop.js");\n/* harmony import */ var _loop_normalize_normalize_loop_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../loop/normalize/normalize-loop.js */ "./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js");\n/* harmony import */ var _loop_normalize_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../loop/normalize/get-max-coordinate.js */ "./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js");\n/* harmony import */ var _loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loop/get-loop-area.js */ "./node_modules/flo-boolean/node/loop/get-loop-area.js");\n/* harmony import */ var _svg_loops_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../svg/loops-to-svg-path-str.js */ "./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../get-bounding-box-.js */ "./node_modules/flo-boolean/node/get-bounding-box-.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Uses the algorithm of Lavanya Subramaniam: PARTITION OF A NON-SIMPLE POLYGON\r\n * INTO SIMPLE POLYGONS;\r\n *\r\n * see http://www.cis.southalabama.edu/~hain/general/Theses/Subramaniam_thesis.pdf\r\n * but modified to use bezier curves (as opposed to polygons) and to additionally\r\n * take care of paths with multiple subpaths, i.e. such as disjoint nested paths.\r\n *\r\n * Also takes care of all special cases.\r\n *\r\n * @param loops an array of possibly intersecting paths\r\n * @param maxCoordinate optional - if not provided, it will be calculated - a\r\n * wrong value could cause the algorithm to fail\r\n */\r\nfunction simplifyPaths(bezierLoops, maxCoordinate) {\r\n    let timingStart;\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        timingStart = performance.now();\r\n    }\r\n    /**\r\n     * All bezier coordinates will be truncated to this (bit-aligned) bitlength.\r\n     * Higher bitlengths would increase the running time of the algorithm\r\n     * considerably.\r\n     */\r\n    let maxBitLength = 46;\r\n    maxCoordinate = maxCoordinate || (0,_loop_normalize_get_max_coordinate_js__WEBPACK_IMPORTED_MODULE_11__.getMaxCoordinate)(bezierLoops);\r\n    /** The exponent, e, such that 2**e >= all bezier coordinate points. */\r\n    let expMax = Math.ceil(Math.log2(maxCoordinate));\r\n    let gridSpacing = 2 ** expMax * 2 ** (-maxBitLength);\r\n    /**\r\n     * A size (based on the max value of the tangent) for the containers holding\r\n     * critical points.\r\n     */\r\n    const containerSizeMultiplier = 2 ** 4;\r\n    //const containerSizeMultiplier = 2**39;\r\n    let containerDim = gridSpacing * containerSizeMultiplier;\r\n    bezierLoops = (0,_loop_normalize_normalize_loop_js__WEBPACK_IMPORTED_MODULE_10__.normalizeLoops)(bezierLoops, maxBitLength, expMax, false, true);\r\n    addDebugInfo1(bezierLoops);\r\n    bezierLoops.sort(_order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_3__.orderLoopAscendingByMinY);\r\n    // console.log(bezierLoops);\r\n    let loops = bezierLoops.map((loop, i) => (0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_9__.loopFromBeziers)(loop, i));\r\n    let { extremes } = (0,_calc_containers_get_containers_js__WEBPACK_IMPORTED_MODULE_6__.getContainers)(loops, containerDim, expMax);\r\n    let root = createRootInOut();\r\n    let takenLoops = new Set();\r\n    let takenOuts = new Set(); // Taken intersections\r\n    // throw \'a\';\r\n    // debugger;\r\n    for (let loop of loops) {\r\n        if (takenLoops.has(loop)) {\r\n            continue;\r\n        }\r\n        takenLoops.add(loop);\r\n        let parent = (0,_get_tightest_containing_loop_js__WEBPACK_IMPORTED_MODULE_2__.getTightestContainingLoop)(root, loop);\r\n        let container = extremes.get(loop)[0].container;\r\n        if (!container.inOuts.length) {\r\n            continue;\r\n        }\r\n        let initialOut = (0,_get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_7__.getOutermostInAndOut)(container);\r\n        // Each loop generated will give rise to one componentLoop. \r\n        initialOut.parent = parent;\r\n        initialOut.windingNum = parent.windingNum + initialOut.orientation;\r\n        initialOut.children = new Set();\r\n        (0,_complete_path_js__WEBPACK_IMPORTED_MODULE_1__.completePath)(expMax, (0,_get_outermost_in_and_out_js__WEBPACK_IMPORTED_MODULE_7__.getOutermostInAndOut)(container), takenLoops, takenOuts);\r\n    }\r\n    let loopTrees = (0,_split_loop_trees_js__WEBPACK_IMPORTED_MODULE_4__.splitLoopTrees)(root);\r\n    let outSets = loopTrees.map(_get_loops_from_tree_js__WEBPACK_IMPORTED_MODULE_5__.getLoopsFromTree);\r\n    let loopss = outSets.map(outSet => outSet.map(out => loopFromOut(out, outSet[0].orientation)));\r\n    /**\r\n     * Arbitrarily choose min. loop area to be equal to one square pixel on a\r\n     * 4096 x 4096 grid.\r\n     */\r\n    let minLoopArea = (2 ** expMax * 2 ** (-12)) ** 2;\r\n    let loopss_ = [];\r\n    for (let i = 0; i < loopss.length; i++) {\r\n        let loops = loopss[i].filter((loop) => Math.abs((0,_loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_12__.getLoopArea)(loop)) > minLoopArea);\r\n        if (loops.length) {\r\n            loops.sort((loopA, loopB) => {\r\n                return (0,_order_loop_ascending_by_min_y_js__WEBPACK_IMPORTED_MODULE_3__.orderLoopAscendingByMinY)(loopA.beziers, loopB.beziers);\r\n            });\r\n            loopss_.push(loops);\r\n        }\r\n    }\r\n    addDebugInfo2(loopss_);\r\n    if (typeof _debug_ !== \'undefined\') {\r\n        const timing = _debug_.generated.timing;\r\n        timing.simplifyPaths = performance.now() - timingStart;\r\n    }\r\n    return loopss_;\r\n}\r\nfunction loopFromOut(out, orientation) {\r\n    let loop = orientation < 0\r\n        ? (0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_9__.loopFromBeziers)(out.beziers)\r\n        : (0,_loop_reverse_orientation_js__WEBPACK_IMPORTED_MODULE_8__.reverseOrientation)((0,_loop_loop_js__WEBPACK_IMPORTED_MODULE_9__.loopFromBeziers)(out.beziers));\r\n    return loop;\r\n}\r\nfunction addDebugInfo2(loopss) {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    for (let loops of loopss) {\r\n        _debug_.generated.elems.loop.push(...loops);\r\n        _debug_.generated.elems.loops.push(loops);\r\n        //console.log(loopsToSvgPathStr(loops.map(loop => loop.beziers)));\r\n    }\r\n}\r\nfunction addDebugInfo1(loops) {\r\n    if (typeof _debug_ === \'undefined\') {\r\n        return;\r\n    }\r\n    // Modifies the displayed SVG to reflect changes caused by `normalizeLoops`.\r\n    if (typeof document !== \'undefined\') {\r\n        let pathStr = (0,_svg_loops_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_13__.loopsToSvgPathStr)(loops);\r\n        let $svg = document.getElementsByClassName(\'shape\')[0];\r\n        $svg.setAttributeNS(null, \'d\', pathStr);\r\n    }\r\n    for (let loop of loops) {\r\n        _debug_.generated.elems.loopPre.push(...loops);\r\n        _debug_.generated.elems.loopsPre.push(loops);\r\n        for (let ps of loop) {\r\n            let lbb = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_14__.getBoundingBox_)(ps);\r\n            let tbb = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingBoxTight)(ps);\r\n            let bhull = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingHull)(ps);\r\n            _debug_.generated.elems.bezier_.push(ps);\r\n            _debug_.generated.elems.looseBoundingBox_.push(lbb);\r\n            _debug_.generated.elems.tightBoundingBox_.push(tbb);\r\n            _debug_.generated.elems.boundingHull_.push(bhull);\r\n        }\r\n    }\r\n}\r\nfunction createRootInOut() {\r\n    return {\r\n        dir: undefined,\r\n        idx: 0,\r\n        parent: undefined,\r\n        children: new Set(),\r\n        windingNum: 0,\r\n        p: undefined,\r\n        _x_: undefined,\r\n        container: undefined\r\n    };\r\n}\r\n\r\n// TODO - Handle case where bezier tangentially touches container edge. \r\n// Simply move the container boundary 1/8th or 1/16th inward and try again. \r\n// This case is truly extremely rare and not hard to fix completely.\r\n//# sourceMappingURL=simplify-paths.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/simplify-paths.js?')},"./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "splitLoopTrees": () => (/* binding */ splitLoopTrees)\n/* harmony export */ });\n/**\r\n * Take the forest of trees, create a new root making it a tree and snip\r\n * branches such that each branch determines a new set of loops each\r\n * representing an individual independent shape (possibly with holes).\r\n * @param root\r\n */\r\nfunction splitLoopTrees(root) {\r\n    let iLoopTrees = [];\r\n    let stack = [root];\r\n    while (stack.length) {\r\n        let tree = stack.pop();\r\n        tree.children = tree.children || new Set();\r\n        for (let child of tree.children) {\r\n            if (tree.windingNum === 0) {\r\n                iLoopTrees.push(child);\r\n            }\r\n            stack.push(child);\r\n        }\r\n        if (tree.windingNum === 0) {\r\n            tree.children = new Set(); // Make it a leaf\r\n        }\r\n    }\r\n    return iLoopTrees;\r\n}\r\n\r\n//# sourceMappingURL=split-loop-trees.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/calc-paths/split-loop-trees.js?')},"./node_modules/flo-boolean/node/container.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "containerIsBasic": () => (/* binding */ containerIsBasic)\n/* harmony export */ });\n/**\r\n * Returns true if the container is basic, i.e. contains only 1 interface\r\n * intersection or contains only 1 general, extreme or loop intersection\r\n * (not cusp, or endpoint overlap), false otherwise.\r\n *\r\n * @param container\r\n */\r\nfunction containerIsBasic(expMax, container) {\r\n    let xs = container.xs;\r\n    if (xs.length <= 2) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n//# sourceMappingURL=container.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/container.js?')},"./node_modules/flo-boolean/node/debug/debug.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enableDebugForBooleanOp": () => (/* binding */ enableDebugForBooleanOp)\n/* harmony export */ });\n/* harmony import */ var _draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-elem/draw-elem.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js");\n\r\n/**\r\n * Returns a new debug object by spreading boolean operation debug information\r\n * onto the given (possibly undefined) debug object.\r\n * @param debug a (possibly undefined) debug object\r\n */\r\nfunction enableDebugForBooleanOp(debugOn) {\r\n    if (!debugOn) {\r\n        window._debug_ = undefined;\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = {\r\n        ...debug,\r\n        generated: {\r\n            ...(!debug ? {} : !debug.generated ? {} : debug.generated),\r\n            elems: {\r\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.elems ? {} : debug.generated.elems),\r\n                minY: [],\r\n                loop: [],\r\n                loopPre: [],\r\n                loopsPre: [],\r\n                loops: [],\r\n                intersection: [],\r\n                container: [],\r\n                bezier_: [],\r\n                looseBoundingBox_: [],\r\n                tightBoundingBox_: [],\r\n                boundingHull_: [],\r\n            },\r\n            timing: {\r\n                ...(!debug ? {} : !debug.generated ? {} : !debug.generated.timing ? {} : debug.generated.timing),\r\n                normalize: 0,\r\n                simplifyPaths: 0,\r\n            }\r\n        },\r\n        fs: {\r\n            ...(!debug ? {} : !debug.fs ? {} : debug.fs),\r\n            drawElem: {\r\n                ...(!debug ? {} : !debug.fs ? {} : !debug.fs.drawElem ? {} : debug.fs.drawElem),\r\n                ..._draw_elem_draw_elem_js__WEBPACK_IMPORTED_MODULE_0__.drawElemFunctions\r\n            }\r\n        }\r\n    };\r\n    window._debug_ = debug;\r\n}\r\n\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/debug.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/default-class.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_CLASS\": () => (/* binding */ DEFAULT_CLASS)\n/* harmony export */ });\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\n\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/default-class.js?")},"./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawBoundingHull": () => (/* binding */ drawBoundingHull)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-boolean/node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction drawBoundingHull(g, hull, classes = \'thin5 black nofill\', delay = 0) {\r\n    let $polygon = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, hull, classes, delay);\r\n    return $polygon;\r\n}\r\n\r\n//# sourceMappingURL=draw-bounding-hull.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawCirclePercent": () => (/* binding */ drawCirclePercent)\n/* harmony export */ });\nfunction drawCirclePercent(g, center, radiusPercent, classes) {\r\n    const XMLNS = \'http://www.w3.org/2000/svg\';\r\n    let $circle = document.createElementNS(XMLNS, \'circle\');\r\n    $circle.setAttributeNS(null, "cx", center[0].toString());\r\n    $circle.setAttributeNS(null, "cy", center[1].toString());\r\n    $circle.setAttributeNS(null, "r", radiusPercent.toString() + \'%\');\r\n    $circle.setAttributeNS(null, "class", classes);\r\n    g.appendChild($circle);\r\n    return $circle;\r\n}\r\n\r\n//# sourceMappingURL=draw-circle-percent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawContainer\": () => (/* binding */ drawContainer)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/index.js\");\n\r\nfunction drawContainer(g, container, classes, delay = 0) {\r\n    let rect = container.box;\r\n    let xs = container.xs;\r\n    let scale = 0.025;\r\n    // intersections\r\n    let $circles = [];\r\n    for (let i = 0; i < xs.length; i++) {\r\n        let x = xs[i];\r\n        $circles.push(...flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.circle(g, { center: x.x.box[0], radius: scale }, 'thin2 red nofill', delay));\r\n    }\r\n    // text showing intersection ordering\r\n    let $texts = [];\r\n    let inOuts = container.inOuts;\r\n    for (let i = 0; i < inOuts.length; i++) {\r\n        let inOut = inOuts[i];\r\n        // console.log(inOut)\r\n        let C = 3;\r\n        let p = inOut.p.slice();\r\n        //if (inOut.order) {\r\n        //    if (inOut.order[0] === 3) { p[0] += C; }\r\n        //    if (inOut.order[0] === 0) { p[1] -= C; }\r\n        //    if (inOut.order[0] === 1) { p[0] -= 2*C; }\r\n        //    if (inOut.order[0] === 2) { p[1] += 2*C; }\r\n        //}\r\n        let color = inOut.dir === -1 ? 'red' : 'blue';\r\n        //let size = scale * (inOut.dir === -1 ? 0.75 : 1);\r\n        let size = scale * (inOut.dir === -1 ? 0.5 : 0.5);\r\n        //$texts.push(...drawFs.text(g, p, i.toString(), 4, color, delay));\r\n        $circles.push(...flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.dot(g, inOut.p, size, `thin2 ${color}`, delay));\r\n    }\r\n    // container rect\r\n    let $outline = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.rect(g, rect, 'thin2 blue nofill', delay);\r\n    return [...$outline, ...$circles, ...$texts];\r\n}\r\n\r\n//# sourceMappingURL=draw-container.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js?")},"./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawElemFunctions": () => (/* binding */ drawElemFunctions)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-boolean/node_modules/flo-draw/node/index.js");\n/* harmony import */ var _draw_min_y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw-min-y.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js");\n/* harmony import */ var _draw_loop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw-loop.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js");\n/* harmony import */ var _draw_loops_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draw-loops.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js");\n/* harmony import */ var _draw_intersection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw-intersection.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js");\n/* harmony import */ var _draw_container_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./draw-container.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-container.js");\n/* harmony import */ var _draw_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./draw-loose-bounding-box.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js");\n/* harmony import */ var _draw_tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./draw-tight-bounding-box.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js");\n/* harmony import */ var _draw_bounding_hull_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./draw-bounding-hull.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-bounding-hull.js");\n/* harmony import */ var _draw_loop_pre_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./draw-loop-pre.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loop-pre.js");\n/* harmony import */ var _draw_loops_pre_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./draw-loops-pre.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loops-pre.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst drawElemFunctions = {\r\n    minY: _draw_min_y_js__WEBPACK_IMPORTED_MODULE_1__.drawMinY,\r\n    loop: _draw_loop_js__WEBPACK_IMPORTED_MODULE_2__.drawLoop,\r\n    loopPre: _draw_loop_pre_js__WEBPACK_IMPORTED_MODULE_9__.drawLoopPre,\r\n    loopsPre: _draw_loops_pre_js__WEBPACK_IMPORTED_MODULE_10__.drawLoopsPre,\r\n    loops: _draw_loops_js__WEBPACK_IMPORTED_MODULE_3__.drawLoops,\r\n    intersection: _draw_intersection_js__WEBPACK_IMPORTED_MODULE_4__.drawIntersection,\r\n    container: _draw_container_js__WEBPACK_IMPORTED_MODULE_5__.drawContainer,\r\n    bezier_: flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.bezier,\r\n    looseBoundingBox_: _draw_loose_bounding_box_js__WEBPACK_IMPORTED_MODULE_6__.drawLooseBoundingBox,\r\n    tightBoundingBox_: _draw_tight_bounding_box_js__WEBPACK_IMPORTED_MODULE_7__.drawTightBoundingBox,\r\n    boundingHull_: _draw_bounding_hull_js__WEBPACK_IMPORTED_MODULE_8__.drawBoundingHull,\r\n};\r\n\r\n//# sourceMappingURL=draw-elem.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-elem.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawIntersection": () => (/* binding */ drawIntersection)\n/* harmony export */ });\n/* harmony import */ var _draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-circle-percent.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-circle-percent.js");\n\r\nfunction drawIntersection(g, x) {\r\n    return [(0,_draw_circle_percent_js__WEBPACK_IMPORTED_MODULE_0__.drawCirclePercent)(g, x.x.box[0], 0.7, \'purple thin5 nofill\')];\r\n}\r\n\r\n//# sourceMappingURL=draw-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-intersection.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-loop-pre.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawLoopPre\": () => (/* binding */ drawLoopPre)\n/* harmony export */ });\n/* harmony import */ var _draw_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-shape.js */ \"./node_modules/flo-boolean/node/debug/draw-elem/draw-shape.js\");\n\r\nfunction drawLoopPre(g, loop) {\r\n    //let centroid = getLoopCentroid(loop);\r\n    //let area     = getLoopArea(loop);\r\n    //let bounds   = simplifyBounds(getLoopBounds(loop));\r\n    //drawFs.crossHair(g, centroid, 'thin10 red nofill', 1, 0);\r\n    return (0,_draw_shape_js__WEBPACK_IMPORTED_MODULE_0__.drawShape)(g, loop, 'red thin10 fill30', undefined);\r\n}\r\n\r\n//# sourceMappingURL=draw-loop-pre.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-loop-pre.js?")},"./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawLoop": () => (/* binding */ drawLoop)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-boolean/node_modules/flo-draw/node/index.js");\n/* harmony import */ var _loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../loop/get-loop-area.js */ "./node_modules/flo-boolean/node/loop/get-loop-area.js");\n/* harmony import */ var _loop_get_loop_centroid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../loop/get-loop-centroid.js */ "./node_modules/flo-boolean/node/loop/get-loop-centroid.js");\n/* harmony import */ var _loop_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../loop/get-loop-bounds.js */ "./node_modules/flo-boolean/node/loop/get-loop-bounds.js");\n/* harmony import */ var _loop_simplify_bounds_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../loop/simplify-bounds.js */ "./node_modules/flo-boolean/node/loop/simplify-bounds.js");\n/* harmony import */ var _draw_shape_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./draw-shape.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-shape.js");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction drawLoop(g, loop) {\r\n    let centroid = (0,_loop_get_loop_centroid_js__WEBPACK_IMPORTED_MODULE_2__.getLoopCentroid)(loop);\r\n    let area = (0,_loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_1__.getLoopArea)(loop);\r\n    let bounds = (0,_loop_simplify_bounds_js__WEBPACK_IMPORTED_MODULE_4__.simplifyBounds)((0,_loop_get_loop_bounds_js__WEBPACK_IMPORTED_MODULE_3__.getLoopBounds)(loop));\r\n    flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.crossHair(g, centroid, \'thin10 red nofill\', 1, 0);\r\n    return (0,_draw_shape_js__WEBPACK_IMPORTED_MODULE_5__.drawShape)(g, loop.curves.map(curve => curve.ps), \'red thin10 fill30\', undefined);\r\n}\r\n\r\n//# sourceMappingURL=draw-loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-loops-pre.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawLoopsPre": () => (/* binding */ drawLoopsPre)\n/* harmony export */ });\n/* harmony import */ var _draw_loop_pre_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-loop-pre.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loop-pre.js");\n\r\nfunction drawLoopsPre(g, loops) {\r\n    const $svgs = [];\r\n    for (let loop of loops) {\r\n        $svgs.push(...(0,_draw_loop_pre_js__WEBPACK_IMPORTED_MODULE_0__.drawLoopPre)(g, loop));\r\n    }\r\n    return $svgs;\r\n}\r\n\r\n//# sourceMappingURL=draw-loops-pre.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-loops-pre.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawLoops": () => (/* binding */ drawLoops)\n/* harmony export */ });\n/* harmony import */ var _draw_loop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-loop.js */ "./node_modules/flo-boolean/node/debug/draw-elem/draw-loop.js");\n\r\nfunction drawLoops(g, loops) {\r\n    const $svgs = [];\r\n    for (let loop of loops) {\r\n        $svgs.push(...(0,_draw_loop_js__WEBPACK_IMPORTED_MODULE_0__.drawLoop)(g, loop));\r\n    }\r\n    return $svgs;\r\n}\r\n\r\n//# sourceMappingURL=draw-loops.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-loops.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawLooseBoundingBox": () => (/* binding */ drawLooseBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-boolean/node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction drawLooseBoundingBox(g, box, classes = \'thin5 brown nofill\', delay = 0) {\r\n    let [[x0, y0], [x1, y1]] = box;\r\n    box = [[x0, y0], [x1, y0], [x1, y1], [x0, y1]];\r\n    let $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, classes, delay);\r\n    return $box;\r\n}\r\n\r\n//# sourceMappingURL=draw-loose-bounding-box.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-loose-bounding-box.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawMinY\": () => (/* binding */ drawMinY)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ \"./node_modules/flo-bezier3/node/index.js\");\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-draw */ \"./node_modules/flo-boolean/node_modules/flo-draw/node/index.js\");\n\r\n\r\nfunction drawMinY(g, pos) {\r\n    let p = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(pos.curve.ps, pos.t);\r\n    let ps = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toCubic)(pos.curve.ps);\r\n    //console.log('x: ', getX(ps));\r\n    //console.log('y: ', getY(ps));\r\n    //console.log('t: ', pos.t);\r\n    let $elems = flo_draw__WEBPACK_IMPORTED_MODULE_1__.drawFs.crossHair(g, p, 'red thin10 nofill');\r\n    return $elems;\r\n}\r\n\r\n//# sourceMappingURL=draw-min-y.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-min-y.js?")},"./node_modules/flo-boolean/node/debug/draw-elem/draw-shape.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawShape": () => (/* binding */ drawShape)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-boolean/node/debug/draw-elem/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-boolean/node/debug/draw-elem/xmlns.js");\n/* harmony import */ var _svg_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../svg/beziers-to-svg-path-str.js */ "./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js");\n\r\n\r\n\r\n// TODO - move to flo-draw\r\n/**\r\n * Draws an SVG shape\r\n * @param g\r\n * @param shape the shape specified as an array of bezier curves\r\n *\r\n * * the last point does not have to be specified\r\n *\r\n * @param class_\r\n * @param delay\r\n */\r\nfunction drawShape(g, beziers, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'path\');\r\n    let d = (0,_svg_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_2__.beziersToSvgPathStr)(beziers);\r\n    $path.setAttributeNS(null, "d", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=draw-shape.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-shape.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawTightBoundingBox": () => (/* binding */ drawTightBoundingBox)\n/* harmony export */ });\n/* harmony import */ var flo_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-draw */ "./node_modules/flo-boolean/node_modules/flo-draw/node/index.js");\n\r\n/** @hidden */\r\nfunction drawTightBoundingBox(g, box, classes = \'thin5 pinker nofill\', delay = 0) {\r\n    let $box = flo_draw__WEBPACK_IMPORTED_MODULE_0__.drawFs.polygon(g, box, classes, delay);\r\n    return $box;\r\n}\r\n\r\n//# sourceMappingURL=draw-tight-bounding-box.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/draw-tight-bounding-box.js?')},"./node_modules/flo-boolean/node/debug/draw-elem/xmlns.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XMLNS\": () => (/* binding */ XMLNS)\n/* harmony export */ });\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\n\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/debug/draw-elem/xmlns.js?")},"./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doConvexPolygonsIntersect": () => (/* binding */ doConvexPolygonsIntersect)\n/* harmony export */ });\n/**\r\n * Adapted from https://stackoverflow.com/a/12414951/2010061.\r\n * Returns true if there is any intersection between the 2 polygons, false otherwise\r\n * Uses the Separating Axis Theorem.\r\n *\r\n * @param polygonA an array of connected points that form a closed polygon\r\n * @param polygonB an array of connected points that form a closed polygon\r\n * @param closed set to false to compare open polygons (not containing their\r\n * boundary) or true to compare closed polygons\r\n */\r\nfunction doConvexPolygonsIntersect(polygonA, polygonB, closed) {\r\n    // for each polygon, look at each edge of the polygon, and determine if \r\n    // it separates the two shapes\r\n    for (let polygon of [polygonA, polygonB]) {\r\n        let len = polygon.length;\r\n        for (let i = 1; i < len + 1; i++) {\r\n            // grab 2 consecutive vertices to create an edge\r\n            let p1 = polygon[i - 1];\r\n            let p2 = polygon[i % len];\r\n            // find the vector perpendicular to this edge\r\n            let normal = [p2[1] - p1[1], p1[0] - p2[0]];\r\n            let minA = Number.POSITIVE_INFINITY;\r\n            let maxA = Number.NEGATIVE_INFINITY;\r\n            // for each vertex in the first shape, project it onto the line \r\n            // perpendicular to the edge and keep track of the min and max of \r\n            // these values\r\n            for (let k = 0; k < polygonA.length; k++) {\r\n                let projected = normal[0] * polygonA[k][0] +\r\n                    normal[1] * polygonA[k][1];\r\n                if (projected < minA) {\r\n                    minA = projected;\r\n                }\r\n                if (projected > maxA) {\r\n                    maxA = projected;\r\n                }\r\n            }\r\n            // for each vertex in the second shape, project it onto the line \r\n            // perpendicular to the edge and keep track of the min and max of \r\n            // these values\r\n            let minB = Number.POSITIVE_INFINITY;\r\n            let maxB = Number.NEGATIVE_INFINITY;\r\n            for (let k = 0; k < polygonB.length; k++) {\r\n                let projected = normal[0] * polygonB[k][0] +\r\n                    normal[1] * polygonB[k][1];\r\n                if (projected < minB) {\r\n                    minB = projected;\r\n                }\r\n                if (projected > maxB) {\r\n                    maxB = projected;\r\n                }\r\n            }\r\n            // if there is no overlap between the projections, the edge we are \r\n            // looking at separates the two polygons, and we know there is no \r\n            // overlap\r\n            if (closed) {\r\n                if (maxA < minB || maxB < minA) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!closed) {\r\n                if (maxA <= minB || maxB <= minA) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=do-convex-polygons-intersect.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js?')},"./node_modules/flo-boolean/node/get-bounding-box-.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBoundingBox_": () => (/* binding */ getBoundingBox_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n\r\n\r\nconst getBoundingBox_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBoundingBox);\r\n\r\n//# sourceMappingURL=get-bounding-box-.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-bounding-box-.js?')},"./node_modules/flo-boolean/node/get-bounds-.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBounds_": () => (/* binding */ getBounds_)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n\r\n\r\nconst getBounds_ = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getBounds);\r\n\r\n//# sourceMappingURL=get-bounds-.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-bounds-.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getCurvesIntersections": () => (/* binding */ getCurvesIntersections)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _get_other_t_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get-other-t.js */ "./node_modules/flo-boolean/node/get-critical-points/get-other-t.js");\n/* harmony import */ var _geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometry/do-convex-polygons-intersect.js */ "./node_modules/flo-boolean/node/geometry/do-convex-polygons-intersect.js");\n/* harmony import */ var _get_intersection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-intersection.js */ "./node_modules/flo-boolean/node/get-critical-points/get-intersection.js");\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./make-simple-x.js */ "./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../get-bounding-box-.js */ "./node_modules/flo-boolean/node/get-bounding-box-.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Returns the pairs of intersection `t` values between the curves. Interface\r\n * intersections may not be returned - they should already be caught.\r\n *\r\n * @param curveA\r\n * @param curveB\r\n */\r\nfunction getCurvesIntersections(expMax) {\r\n    return (curveA, curveB) => {\r\n        let psA = curveA.ps;\r\n        let psB = curveB.ps;\r\n        if (psA.length === 2 && psB.length === 2) {\r\n            return getLineLineIntersections(curveA, curveB, expMax);\r\n        }\r\n        if (curveA.next === curveB || curveB.next === curveA) {\r\n            // curves are connected at endpoints\r\n            // closed bounding boxes are guaranteed to intersect - don\'t check\r\n            // check open bounding boxes\r\n            let aabbsIntersectOpen = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersecting)(false, (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psA), (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psB));\r\n            if (!aabbsIntersectOpen) {\r\n                return checkEndpoints(curveA, curveB);\r\n            }\r\n            // check open bounding hulls\r\n            let bbHullA = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.getBoundingHull)(psA);\r\n            let bbHullB = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.getBoundingHull)(psB);\r\n            let hullsIntersectOpen = (0,_geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_5__.doConvexPolygonsIntersect)(bbHullA, bbHullB, false);\r\n            if (!hullsIntersectOpen) {\r\n                return checkEndpoints(curveA, curveB);\r\n            }\r\n            // neither aabbs nor hulls can split the curves\r\n            return curveB.next === curveA\r\n                ? (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_6__.getIntersection)(curveB, curveA, expMax, true) // B--\x3eA\r\n                : (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_6__.getIntersection)(curveA, curveB, expMax, true); // A--\x3eB\r\n        }\r\n        // curves are not connected at endpoints\r\n        // check closed bounding boxes\r\n        let possiblyIntersecting = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersecting)(true, (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psA), (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psB));\r\n        if (!possiblyIntersecting) {\r\n            return undefined;\r\n        }\r\n        // check closed bounding hulls\r\n        let bbHullA = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.getBoundingHull)(psA);\r\n        let bbHullB = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.getBoundingHull)(psB);\r\n        possiblyIntersecting = (0,_geometry_do_convex_polygons_intersect_js__WEBPACK_IMPORTED_MODULE_5__.doConvexPolygonsIntersect)(bbHullA, bbHullB, true);\r\n        if (!possiblyIntersecting) {\r\n            return undefined;\r\n        }\r\n        return (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_6__.getIntersection)(curveA, curveB, expMax, false);\r\n    };\r\n}\r\n/**\r\n * Returns an un-ordered pair of intersections (excluding interface intersections,\r\n * in which case `undefined` is returned) between curveA and curveB.\r\n *\r\n * * **precondition:** curveA.next === curveB || curveB.next === curveA\r\n * * **precondition:** every intersection will be at an endpoint of at least\r\n * one of the curves\r\n *\r\n * @param curveA\r\n * @param curveB\r\n */\r\nfunction checkEndpoints(curveA, curveB) {\r\n    if (curveB.next === curveA) {\r\n        if (curveA.next === curveB) {\r\n            // if this is a very simple loop with only 2 beziers in it\r\n            return undefined;\r\n        }\r\n        // else swap the curves to make the algorithm simpler\r\n        [curveA, curveB] = [curveB, curveA];\r\n    }\r\n    // At this point A--\x3eB (curveA\'s next === curveB)\r\n    // There is thus an intersection at curveA(t=1) and curveB(t=0)\r\n    let psA = curveA.ps;\r\n    let psB = curveB.ps;\r\n    // Is last point (i.e. at `t` === 1) of curveB on curveA?\r\n    // if (isPointOnBezierExtension(psA, psB[psB.length-1])) {\r\n    if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.isPointOnBezierExtension)(psA, psB[psB.length - 1].map(c => [c]))) {\r\n        // Check if they are in same k family (this *is* necessary for two curves\r\n        // in same k-family joined end to end, e.g. ---A---\x3e|---B---\x3e in which\r\n        // case ...)\r\n        let xPairs = (0,_get_other_t_js__WEBPACK_IMPORTED_MODULE_4__.getOtherTs)(psA, psB, [(0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.createRootExact)(1)]);\r\n        if (xPairs === undefined || xPairs.length === 0) {\r\n            return undefined;\r\n        }\r\n        let xPair = xPairs[0];\r\n        return [[\r\n                { x: xPair[0], curve: curveA },\r\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__.makeSimpleX)(1, curveB, 1)\r\n            ]];\r\n    }\r\n}\r\nfunction getLineLineIntersections(curveA, curveB, expMax) {\r\n    let psA = curveA.ps;\r\n    let psB = curveB.ps;\r\n    let bbA = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psA);\r\n    let bbB = (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_8__.getBoundingBox_)(psB);\r\n    if (curveA.next !== curveB && curveB.next !== curveA) {\r\n        // the two lines are not connected at their endpoints\r\n        if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersecting)(true, bbA, bbB)) {\r\n            let xs = (0,_get_intersection_js__WEBPACK_IMPORTED_MODULE_6__.getIntersection)(curveA, curveB, expMax, false);\r\n            return xs.length ? xs : undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    // the two lines are connected at their endpoints\r\n    let swap = curveB.next === curveA;\r\n    if (swap) {\r\n        [curveA, curveB] = [curveB, curveA];\r\n        [psA, psB] = [psB, psA];\r\n    }\r\n    let orientation = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(psA[0], psA[1], psB[1]);\r\n    if (orientation !== 0) {\r\n        // they cannot intersect\r\n        return undefined;\r\n    }\r\n    // they are in the same k family - they can either go in the\r\n    // same direction or go back on top of each other\r\n    // if going in same direction\r\n    if (!(0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.areBoxesIntersecting)(false, bbA, bbB)) {\r\n        // they cannot intersect\r\n        return undefined;\r\n    }\r\n    // it is a line going back on itself \r\n    // - return endpoint intersections\r\n    let lenCurve1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.squaredDistanceBetween)(psA[0], psA[1]);\r\n    let lenCurve2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_2__.squaredDistanceBetween)(psB[0], psB[1]);\r\n    let tPair;\r\n    if (lenCurve1 > lenCurve2) {\r\n        // tPair = [inversion01Precise(psA, psB[1]), 1];\r\n        const t0 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezierCertified)(psA, psB[1])[0].ri);\r\n        tPair = [t0, 1];\r\n    }\r\n    else {\r\n        // tPair = [0, inversion01Precise(psB, psA[0])];\r\n        const t1 = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.mid)((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_3__.closestPointOnBezierCertified)(psB, psA[0])[0].ri);\r\n        tPair = [0, t1];\r\n    }\r\n    return [[\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__.makeSimpleX)(1, curveA, 5),\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__.makeSimpleX)(0, curveB, 5), // exact overlap endpoint\r\n        ], [\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__.makeSimpleX)(tPair[0], curveA, 5),\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_7__.makeSimpleX)(tPair[1], curveB, 5) // exact overlap endpoint\r\n        ]];\r\n}\r\n\r\n//# sourceMappingURL=get-curves-intersections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-extreme.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getExtreme": () => (/* binding */ getExtreme)\n/* harmony export */ });\n/* harmony import */ var _loop_get_min_y_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loop/get-min-y.js */ "./node_modules/flo-boolean/node/loop/get-min-y.js");\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./make-simple-x.js */ "./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js");\n\r\n\r\n/**\r\n * Get an extreme point (point with minimum y value) of the given loop.\r\n * @param loop\r\n */\r\nfunction getExtreme(loop) {\r\n    let { curve, y } = (0,_loop_get_min_y_js__WEBPACK_IMPORTED_MODULE_0__.getMinY)(loop);\r\n    let ts = y.ts;\r\n    if (ts[0] <= 0) {\r\n        return [\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(0, curve, 0),\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(1, curve.prev, 0) // extreme\r\n        ];\r\n    }\r\n    if (ts[1] >= 1) {\r\n        return [\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(1, curve, 0),\r\n            (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_1__.makeSimpleX)(0, curve.next, 0) // extreme\r\n        ];\r\n    }\r\n    return [\r\n        // TODO - should multiplicity be undefined in these cases?\r\n        // TODO - do we need 2 intersections???\r\n        {\r\n            x: {\r\n                ri: { tS: ts[0], tE: ts[1], multiplicity: 1 },\r\n                kind: 0,\r\n                box: y.box\r\n            },\r\n            curve\r\n        },\r\n        {\r\n            x: {\r\n                ri: { tS: ts[0], tE: ts[1], multiplicity: 1 },\r\n                kind: 0,\r\n                box: y.box\r\n            },\r\n            curve\r\n        } // extreme\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=get-extreme.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-extreme.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-extremes.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getExtremes": () => (/* binding */ getExtremes)\n/* harmony export */ });\n/* harmony import */ var _get_extreme_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-extreme.js */ "./node_modules/flo-boolean/node/get-critical-points/get-extreme.js");\n\r\n// TODO - include all interface points close to the extreme - they are the only\r\n// important interface points - or are they??\r\n/**\r\n *\r\n * @param loops\r\n */\r\nfunction getExtremes(loops) {\r\n    let extremes = new Map();\r\n    let xs = [];\r\n    for (let loop of loops) {\r\n        let xPair = (0,_get_extreme_js__WEBPACK_IMPORTED_MODULE_0__.getExtreme)(loop);\r\n        xs.push(xPair);\r\n        extremes.set(loop, xPair);\r\n    }\r\n    return { extremes, xs };\r\n}\r\n\r\n//# sourceMappingURL=get-extremes.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-extremes.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getInterfaceIntersections": () => (/* binding */ getInterfaceIntersections)\n/* harmony export */ });\n/* harmony import */ var _make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make-simple-x.js */ "./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js");\n\r\nfunction getInterfaceIntersections(loops) {\r\n    /** all one-sided Xs from */\r\n    let xs = [];\r\n    // Get interface points\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            xs.push([\r\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__.makeSimpleX)(1, curve, 4),\r\n                (0,_make_simple_x_js__WEBPACK_IMPORTED_MODULE_0__.makeSimpleX)(0, curve.next, 4), // interface\r\n            ]);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\n\r\n//# sourceMappingURL=get-interface-intersections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-interface-intersections.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getIntersection": () => (/* binding */ getIntersection)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _get_other_t_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-other-t.js */ "./node_modules/flo-boolean/node/get-critical-points/get-other-t.js");\n\r\n\r\n/**\r\n *\r\n * @param curveA\r\n * @param curveB\r\n * @param expMax\r\n * @param isANextB is curveB the next curve after curveA, i.e. is A\'s next B\r\n */\r\nfunction getIntersection(curveA, curveB, expMax, isANextB) {\r\n    let ps1 = curveA.ps;\r\n    let ps2 = curveB.ps;\r\n    let xs = [];\r\n    let ris2 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierBezierIntersectionBoundless)(ps1, ps2);\r\n    if (ris2 === undefined) {\r\n        // the curves have an infinte number of intersections\r\n        // some reasonable error bound -> to be fine-tuned, but cannot\r\n        // break the algorithm (unless its too small), only make it run slower.\r\n        let errBound = 2 ** (expMax - 47);\r\n        let xPairs = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getEndpointIntersections)(ps1, ps2);\r\n        for (let xPair of xPairs) {\r\n            let p1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps1, xPair.ri1.tS);\r\n            let box = [\r\n                [p1[0] - errBound, p1[1] - errBound],\r\n                [p1[0] + errBound, p1[1] + errBound],\r\n            ];\r\n            let ri1 = { x: { ri: xPair.ri1, kind: 5, box }, curve: curveA }; // exact overlap endpoint\r\n            let ri2 = { x: { ri: xPair.ri2, kind: 5, box }, curve: curveB }; // exact overlap endpoint\r\n            xs.push([ri1, ri2]);\r\n        }\r\n        return xs;\r\n    }\r\n    if (isANextB) {\r\n        // we are not interested in zero t values (they are interface points)\r\n        ris2 = ris2.filter(t => t.tS > 0);\r\n    }\r\n    if (ris2.length === 0) {\r\n        return [];\r\n    }\r\n    let xPairs = (0,_get_other_t_js__WEBPACK_IMPORTED_MODULE_1__.getOtherTs)(ps1, ps2, ris2);\r\n    if (xPairs === undefined || xPairs.length === 0) {\r\n        return [];\r\n    }\r\n    for (let xPair of xPairs) {\r\n        let x1 = { x: xPair[0], curve: curveA };\r\n        let x2 = { x: xPair[1], curve: curveB };\r\n        xs.push([x1, x2]);\r\n    }\r\n    return xs;\r\n}\r\n\r\n//# sourceMappingURL=get-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-intersection.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-intersections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getIntersections": () => (/* binding */ getIntersections)\n/* harmony export */ });\n/* harmony import */ var _sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sweep-line/sweep-line.js */ "./node_modules/flo-boolean/node/sweep-line/sweep-line.js");\n/* harmony import */ var _get_curves_intersections_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-curves-intersections.js */ "./node_modules/flo-boolean/node/get-critical-points/get-curves-intersections.js");\n/* harmony import */ var _get_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-bounding-box-.js */ "./node_modules/flo-boolean/node/get-bounding-box-.js");\n\r\n\r\n\r\n/**\r\n * Find and return all one-sided intersections on all given loops as a map from\r\n * each curve to an array of intersections on the curve, ordered by t value.\r\n * @param loops\r\n */\r\nfunction getIntersections(loops, expMax) {\r\n    let curves = [];\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            curves.push(curve);\r\n        }\r\n    }\r\n    ;\r\n    // Filter curves so that we eliminate those that can definitely not intersect\r\n    let _xs = (0,_sweep_line_sweep_line_js__WEBPACK_IMPORTED_MODULE_0__.sweepLine)(curves, curve => (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.getBoundingBox_)(curve.ps)[0][0], curve => (0,_get_bounding_box_js__WEBPACK_IMPORTED_MODULE_2__.getBoundingBox_)(curve.ps)[1][0], (0,_get_curves_intersections_js__WEBPACK_IMPORTED_MODULE_1__.getCurvesIntersections)(expMax));\r\n    let xs = [];\r\n    for (let _x of _xs) {\r\n        for (let x of _x.u) {\r\n            xs.push(x);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\n\r\n//# sourceMappingURL=get-intersections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-intersections.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-other-t.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getOtherTs": () => (/* binding */ getOtherTs)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n\r\n// TODO - could this come from flo-bezier3\r\nfunction getOtherTs(ps1, ps2, ts2) {\r\n    if (ts2 === undefined) {\r\n        // infinite number of intersections\r\n        return undefined;\r\n    }\r\n    if (ts2.length === 0) {\r\n        return [];\r\n    }\r\n    let ts1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierBezierIntersectionBoundless)(ps2, ps1);\r\n    if (ts1 === undefined) {\r\n        // infinite number of intersections\r\n        return undefined;\r\n    }\r\n    if (ts1.length === 0) {\r\n        return [];\r\n    }\r\n    let is1 = ts1.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getIntervalBox)(ps1, [ri.tS, ri.tE]));\r\n    let is2 = ts2.map(ri => (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getIntervalBox)(ps2, [ri.tS, ri.tE]));\r\n    let xPairs = [];\r\n    for (let i = 0; i < ts1.length; i++) {\r\n        let box1 = is1[i];\r\n        for (let j = 0; j < ts2.length; j++) {\r\n            let box2 = is2[j];\r\n            let box = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.intersectBoxes)(box1, box2);\r\n            if (box !== undefined) {\r\n                // TODO important - combine boxes to make sense, i.e. combine better\r\n                // e.g. two odd multiplicity boxes should combine to a single even, etc. etc.\r\n                let x1 = { ri: ts1[i], box, kind: 1 };\r\n                let x2 = { ri: ts2[j], box, kind: 1 };\r\n                xPairs.push([x1, x2]);\r\n            }\r\n        }\r\n    }\r\n    return xPairs;\r\n}\r\n\r\n//# sourceMappingURL=get-other-t.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-other-t.js?')},"./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getSelfIntersections": () => (/* binding */ getSelfIntersections)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n\r\nconst eps = Number.EPSILON;\r\n/**\r\n * @param loops\r\n */\r\nfunction getSelfIntersections(loops) {\r\n    let xs = [];\r\n    for (let loop of loops) {\r\n        for (let curve of loop.curves) {\r\n            let ps = curve.ps;\r\n            let ts = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.bezierSelfIntersection)(ps);\r\n            // if (ts === undefined) { continue; }  // there is no self-intersection\r\n            if (ts.length === 0) {\r\n                continue;\r\n            }\r\n            // if a cusp (or extremely close to it)\r\n            let kind = ts[0] === ts[1]\r\n                ? 3 /*cusp*/\r\n                : 2 /*self-intersection*/;\r\n            // TODO - fix box - must combine 2 boxes and bezierSelfIntersection must return intervals\r\n            let t0S = ts[0] - eps;\r\n            let t0E = ts[0] + eps;\r\n            let t1S = ts[1] - eps;\r\n            let t1E = ts[1] + eps;\r\n            let box0 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getIntervalBox)(ps, [t0S, t0E]); // ts are within 1 upls accurate\r\n            let box1 = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getIntervalBox)(ps, [t1S, t1E]); // ts are within 1 upls accurate\r\n            xs.push([\r\n                // TODO - multiplicity relevant??\r\n                { x: { ri: { tS: t0S, tE: t0E, multiplicity: 1 }, box: box0, kind }, curve },\r\n                { x: { ri: { tS: t1S, tE: t1E, multiplicity: 1 }, box: box1, kind }, curve }\r\n            ]);\r\n        }\r\n    }\r\n    return xs;\r\n}\r\n\r\n//# sourceMappingURL=get-self-intersections.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/get-self-intersections.js?')},"./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "makeSimpleX": () => (/* binding */ makeSimpleX)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n\r\n/**\r\n *\r\n * @param t\r\n * @param curve\r\n * @param kind\r\n */\r\nfunction makeSimpleX(t, curve, kind) {\r\n    let ps = curve.ps;\r\n    if (t === 0) {\r\n        // we have the exact point\r\n        let pS = ps[0];\r\n        let box = [ps[0], ps[0]];\r\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n    }\r\n    else if (t === 1) {\r\n        // we have the exact point\r\n        let pE = ps[ps.length - 1];\r\n        let box = [pE, pE];\r\n        return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n    }\r\n    // there will be some error in calculating the point\r\n    let { p, pE } = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljauWithErr)(ps, t);\r\n    let box = [\r\n        [p[0] - pE[0], p[1] - pE[1]],\r\n        [p[0] + pE[0], p[1] + pE[1]]\r\n    ];\r\n    return { x: { ri: { tS: t, tE: t, multiplicity: 1 }, box, kind }, curve };\r\n}\r\n\r\n//# sourceMappingURL=make-simple-x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/make-simple-x.js?')},"./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "setIntersectionNextValues": () => (/* binding */ setIntersectionNextValues)\n/* harmony export */ });\n/**\r\n * Set each intersection on the given original loop\'s next and prev value\r\n * @param loops\r\n * @param xMap\r\n */\r\nfunction setIntersectionNextValues(xPairs) {\r\n    let xsByLoop = new Map();\r\n    for (let xPair of xPairs) {\r\n        for (let x_ of xPair) {\r\n            let loop = x_.curve.loop;\r\n            let xs_ = xsByLoop.get(loop) || [];\r\n            if (!xs_.length) {\r\n                xsByLoop.set(loop, xs_);\r\n            }\r\n            xs_.push(x_);\r\n        }\r\n    }\r\n    for (let item of xsByLoop) {\r\n        let xs = item[1];\r\n        if (!xs || !xs.length) {\r\n            continue;\r\n        }\r\n        xs.sort((xA, xB) => {\r\n            let res = xA.curve.idx - xB.curve.idx;\r\n            if (res !== 0) {\r\n                return res;\r\n            }\r\n            res = xA.x.ri.tS - xB.x.ri.tS;\r\n            if (res !== 0) {\r\n                return res;\r\n            }\r\n            return xA.in_ ? -1 : +1;\r\n        });\r\n        for (let i = 1; i < xs.length; i++) {\r\n            xs[i - 1].next = xs[i];\r\n        }\r\n        xs[xs.length - 1].next = xs[0];\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=set-intersection-next-values.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/get-critical-points/set-intersection-next-values.js?')},"./node_modules/flo-boolean/node/graph/get-connected-components.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "addEdge": () => (/* binding */ addEdge),\n/* harmony export */   "addEdges": () => (/* binding */ addEdges),\n/* harmony export */   "getConnectedComponents": () => (/* binding */ getConnectedComponents)\n/* harmony export */ });\nfunction addEdges(graph, edges) {\r\n    for (let i = 0; i < edges.length; i++) {\r\n        let edge = edges[i];\r\n        addEdge(graph, [edge.a, edge.b]);\r\n    }\r\n}\r\n/**\r\n * Adds an edge to an undirected graph.\r\n */\r\nfunction addEdge(graph, vertices) {\r\n    let [src, dest] = vertices;\r\n    let srcList = graph.get(src);\r\n    if (!srcList) {\r\n        srcList = [];\r\n        graph.set(src, srcList);\r\n    }\r\n    let destList = graph.get(dest);\r\n    if (!destList) {\r\n        destList = [];\r\n        graph.set(dest, destList);\r\n    }\r\n    srcList.push(dest);\r\n    destList.push(src);\r\n}\r\nfunction DFSUtil(graph, v, visited, component) {\r\n    // Mark the current node as visited and print it \r\n    visited.add(v);\r\n    component.push(v);\r\n    // Recur for all the vertices adjacent to this vertex \r\n    let list = graph.get(v);\r\n    for (let i = 0; i < list.length; i++) {\r\n        let x = list[i];\r\n        if (!visited.has(x)) {\r\n            DFSUtil(graph, x, visited, component);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns connected components for the given undirected graph\r\n */\r\nfunction getConnectedComponents(graph) {\r\n    // Mark all the vertices as not visited \r\n    let components = [];\r\n    let visited = new Set();\r\n    for (let item of graph) {\r\n        let node = item[0];\r\n        if (!visited.has(node)) {\r\n            // print all reachable vertices from v \r\n            components.push([]);\r\n            DFSUtil(graph, node, visited, components[components.length - 1]);\r\n        }\r\n    }\r\n    return components;\r\n}\r\n\r\n//# sourceMappingURL=get-connected-components.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/graph/get-connected-components.js?')},"./node_modules/flo-boolean/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "beziersToSvgPathStr": () => (/* reexport safe */ _svg_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_4__.beziersToSvgPathStr),\n/* harmony export */   "enableDebugForBooleanOp": () => (/* reexport safe */ _debug_debug_js__WEBPACK_IMPORTED_MODULE_2__.enableDebugForBooleanOp),\n/* harmony export */   "getLoopArea": () => (/* reexport safe */ _loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_1__.getLoopArea),\n/* harmony export */   "getLoopCentroid": () => (/* reexport safe */ _loop_get_loop_centroid_js__WEBPACK_IMPORTED_MODULE_6__.getLoopCentroid),\n/* harmony export */   "getPathsFromStr": () => (/* reexport safe */ _svg_get_paths_from_str_js__WEBPACK_IMPORTED_MODULE_3__.getPathsFromStr),\n/* harmony export */   "loopFromBeziers": () => (/* reexport safe */ _loop_loop_js__WEBPACK_IMPORTED_MODULE_5__.loopFromBeziers),\n/* harmony export */   "simplifyPaths": () => (/* reexport safe */ _calc_paths_simplify_paths_js__WEBPACK_IMPORTED_MODULE_0__.simplifyPaths)\n/* harmony export */ });\n/* harmony import */ var _calc_paths_simplify_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc-paths/simplify-paths.js */ "./node_modules/flo-boolean/node/calc-paths/simplify-paths.js");\n/* harmony import */ var _loop_get_loop_area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop/get-loop-area.js */ "./node_modules/flo-boolean/node/loop/get-loop-area.js");\n/* harmony import */ var _debug_debug_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug/debug.js */ "./node_modules/flo-boolean/node/debug/debug.js");\n/* harmony import */ var _svg_get_paths_from_str_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svg/get-paths-from-str.js */ "./node_modules/flo-boolean/node/svg/get-paths-from-str.js");\n/* harmony import */ var _svg_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./svg/beziers-to-svg-path-str.js */ "./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js");\n/* harmony import */ var _loop_loop_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loop/loop.js */ "./node_modules/flo-boolean/node/loop/loop.js");\n/* harmony import */ var _loop_get_loop_centroid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loop/get-loop-centroid.js */ "./node_modules/flo-boolean/node/loop/get-loop-centroid.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/index.js?')},"./node_modules/flo-boolean/node/loop/get-loop-area.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopArea": () => (/* binding */ getLoopArea)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n\r\n\r\n/**\r\n * Returns the area of the given Loop.\r\n * * see e.g. https://mathinsight.org/greens_theorem_find_area\r\n */\r\nfunction getLoopArea(loop) {\r\n    let totalArea = 0;\r\n    for (const curve of loop.curves) {\r\n        const ps = curve.ps;\r\n        const [x, y] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\r\n        const [dx, dy] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n        const xdy = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)(x, dy);\r\n        const ydx = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.negate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)(y, dx));\r\n        const poly = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.add)(xdy, ydx), 0);\r\n        const area = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(poly, 1);\r\n        totalArea += area;\r\n    }\r\n    return -totalArea / 2;\r\n}\r\n\r\n//# sourceMappingURL=get-loop-area.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/get-loop-area.js?')},"./node_modules/flo-boolean/node/loop/get-loop-bounds.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopBounds": () => (/* binding */ getLoopBounds)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n/* harmony import */ var _point_on_shape_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point-on-shape/point-on-shape.js */ "./node_modules/flo-boolean/node/point-on-shape/point-on-shape.js");\n/* harmony import */ var _get_bounds_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../get-bounds-.js */ "./node_modules/flo-boolean/node/get-bounds-.js");\n\r\n\r\n\r\nconst INF = Number.POSITIVE_INFINITY;\r\n/**\r\n * Returns the bounds of the given loop - used in tests only.\r\n */\r\nlet getLoopBounds = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)(function (loop) {\r\n    let extremes = [\r\n        [\r\n            { bezier: undefined, t: undefined, val: INF },\r\n            { bezier: undefined, t: undefined, val: INF }\r\n        ],\r\n        [\r\n            { bezier: undefined, t: undefined, val: -INF },\r\n            { bezier: undefined, t: undefined, val: -INF }\r\n        ]\r\n    ];\r\n    loop.curves.forEach(function (curve) {\r\n        let ps = curve.ps;\r\n        let bounds = (0,_get_bounds_js__WEBPACK_IMPORTED_MODULE_2__.getBounds_)(ps);\r\n        {\r\n            {\r\n                let v = bounds.box[0][0];\r\n                let x = extremes[0][0].val;\r\n                if (v < x || (v === x && bounds.ts[0][0] > extremes[0][0].t)) {\r\n                    extremes[0][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[0][1];\r\n                let x = extremes[0][1].val;\r\n                if (v < x || (v === x && bounds.ts[0][1] > extremes[0][1].t)) {\r\n                    extremes[0][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[0][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        {\r\n            {\r\n                let v = bounds.box[1][0];\r\n                let x = extremes[1][0].val;\r\n                if (v > x || (v === x && bounds.ts[1][0] > extremes[1][0].t)) {\r\n                    extremes[1][0] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][0],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n            {\r\n                let v = bounds.box[1][1];\r\n                let x = extremes[1][1].val;\r\n                if (v > x || (v === x && bounds.ts[1][1] > extremes[1][1].t)) {\r\n                    extremes[1][1] = {\r\n                        bezier: curve,\r\n                        t: bounds.ts[1][1],\r\n                        val: v\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        minX: new _point_on_shape_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(extremes[0][0].bezier, extremes[0][0].t),\r\n        minY: new _point_on_shape_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(extremes[0][1].bezier, extremes[0][1].t),\r\n        maxX: new _point_on_shape_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(extremes[1][0].bezier, extremes[1][0].t),\r\n        maxY: new _point_on_shape_point_on_shape_js__WEBPACK_IMPORTED_MODULE_1__.PointOnShape(extremes[1][1].bezier, extremes[1][1].t)\r\n    };\r\n});\r\n\r\n//# sourceMappingURL=get-loop-bounds.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/get-loop-bounds.js?')},"./node_modules/flo-boolean/node/loop/get-loop-centroid.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getLoopCentroid": () => (/* binding */ getLoopCentroid)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-poly */ "./node_modules/flo-poly/node/index.js");\n/* harmony import */ var _get_loop_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-loop-area.js */ "./node_modules/flo-boolean/node/loop/get-loop-area.js");\n\r\n\r\n\r\n/**\r\n * Returns the approximate centroid of the given loop\r\n *\r\n * * **precondition**: loop must be a jordan curve (i.e. closed and simple)\r\n *\r\n * see https://sites.math.washington.edu/~king/coursedir/m324a10/as/centroid-green.pdf\r\n */\r\nfunction getLoopCentroid(loop) {\r\n    let A = (0,_get_loop_area_js__WEBPACK_IMPORTED_MODULE_2__.getLoopArea)(loop);\r\n    let cx = 0;\r\n    let cy = 0;\r\n    for (let curve of loop.curves) {\r\n        let ps = curve.ps;\r\n        let [x, y] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis)(ps);\r\n        let [dx, dy] = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.toPowerBasis_1stDerivative)(ps);\r\n        const polyX = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)(x, x), dy), 0);\r\n        const polyY = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.integrate)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)((0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.multiply)(y, y), dx), 0);\r\n        let _x = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(polyX, 1);\r\n        let _y = (0,flo_poly__WEBPACK_IMPORTED_MODULE_1__.Horner)(polyY, 1);\r\n        cx += _x;\r\n        cy += _y;\r\n    }\r\n    let a = 1 / (2 * A);\r\n    return [-a * cx, a * cy];\r\n}\r\n\r\n//# sourceMappingURL=get-loop-centroid.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/get-loop-centroid.js?')},"./node_modules/flo-boolean/node/loop/get-min-y.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getMinY": () => (/* binding */ getMinY)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n\r\n\r\n/**\r\n *\r\n */\r\nlet getMinY = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(function getMinY(loop) {\r\n    let curves = loop.curves;\r\n    let bestY = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getYBoundsTight)(curves[0].ps).minY;\r\n    let bestCurve = curves[0];\r\n    for (let i = 1; i < curves.length; i++) {\r\n        let ps = loop.curves[i].ps;\r\n        let minY = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.getYBoundsTight)(ps).minY;\r\n        let v = minY.box[0][1];\r\n        let x = bestY.box[0][1];\r\n        if (v < x || (v === x && minY.ts[0] > bestY.ts[0])) {\r\n            bestY = minY;\r\n            bestCurve = loop.curves[i];\r\n        }\r\n    }\r\n    return { curve: bestCurve, y: bestY };\r\n});\r\n\r\n//# sourceMappingURL=get-min-y.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/get-min-y.js?')},"./node_modules/flo-boolean/node/loop/loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "loopFromBeziers": () => (/* binding */ loopFromBeziers)\n/* harmony export */ });\nfunction isPoint(ps) {\r\n    if (ps.length === 2) {\r\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] // p[0] === p[1]\r\n        );\r\n    }\r\n    if (ps.length === 3) {\r\n        return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\r\n            ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] // p[1] === p[2]\r\n        );\r\n    }\r\n    return (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1] && // p[0] === p[1]\r\n        ps[1][1] === ps[2][1] && ps[1][1] === ps[2][1] && // p[1] === p[2]\r\n        ps[2][1] === ps[3][1] && ps[2][1] === ps[3][1] // p[2] === p[3]\r\n    );\r\n}\r\n/**\r\n * @param beziers A pre-ordered array of bezier curves to add initially.\r\n */\r\nfunction loopFromBeziers(beziers = [], idx) {\r\n    let curves = [];\r\n    let loop = { beziers, curves, idx };\r\n    if (!beziers.length) {\r\n        return loop;\r\n    }\r\n    let prev = undefined;\r\n    let j = 0;\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        if (isPoint(beziers[i])) {\r\n            continue;\r\n        }\r\n        let curve = {\r\n            loop,\r\n            ps: beziers[i],\r\n            prev: prev,\r\n            next: undefined,\r\n            idx: j\r\n        };\r\n        if (prev) {\r\n            prev.next = curve;\r\n        }\r\n        prev = curve;\r\n        curves.push(curve);\r\n        j++;\r\n    }\r\n    // close loop\r\n    let lastCurve = curves[curves.length - 1];\r\n    curves[0].prev = lastCurve;\r\n    lastCurve.next = curves[0];\r\n    // TODO - remove this eventually\r\n    lastCurve.ps[lastCurve.ps.length - 1] = curves[0].ps[0];\r\n    return loop;\r\n}\r\n\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/loop.js?')},"./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "areAllPointsDifferent": () => (/* binding */ areAllPointsDifferent)\n/* harmony export */ });\n/**\r\n * Returns true if all points in the given array are different, false otherwise.\r\n * @param ps An array of points.\r\n */\r\nfunction areAllPointsDifferent(ps) {\r\n    for (let i = 0; i < ps.length - 1; i++) {\r\n        for (let j = i + 1; j < ps.length; j++) {\r\n            if (ps[i][0] === ps[j][0] && ps[i][1] === ps[j][1]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=are-all-points-different.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js?')},"./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fixBezierByPointSpacing": () => (/* binding */ fixBezierByPointSpacing)\n/* harmony export */ });\n/* harmony import */ var flo_vector2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-vector2d */ "./node_modules/flo-vector2d/node/index.js");\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _are_all_points_different_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./are-all-points-different.js */ "./node_modules/flo-boolean/node/loop/normalize/are-all-points-different.js");\n\r\n// import { lengthSquaredUpperBound, isLine, isCubicReallyQuad, toQuadraticFromCubic } from "flo-bezier3";\r\n\r\n\r\n/**\r\n * Returns the same bezier if its points are well-spaced, e.g. all points not\r\n * coincident, etc., else fix it, if possible, and return the fixed bezier,\r\n * else return undefined.\r\n * @param ps A bezier\r\n */\r\nfunction fixBezierByPointSpacing(ps, gridSpacing, sendToGrid) {\r\n    // Early filter - if all points coincide, we\'re done - degenerate to point\r\n    if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.isReallyPoint)(ps)) {\r\n        return undefined; // Cannot fix\r\n    }\r\n    if (ps.length === 2) {\r\n        // obviously no need to fix a line (that is not degenerate to a point)\r\n        return ps;\r\n    }\r\n    if (ps.length === 3) {\r\n        // Early filter - if no points coincide, we\'re done - well spaced\r\n        if ((0,_are_all_points_different_js__WEBPACK_IMPORTED_MODULE_2__.areAllPointsDifferent)(ps)) {\r\n            // but if it s a line masquerading as a quadratic or cubic bezier\r\n            // then make it line\r\n            // return isLine(ps) ? [ps[0], ps[2]] : ps;\r\n            return (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.isCollinear)(ps) ? [ps[0], ps[2]] : ps;\r\n        }\r\n        // Is the quadratic bezier overlapping onto itself? \r\n        if (arePsEqual(ps[0], ps[2])) {\r\n            // a quadratic with equal endpoints (and not degenerate to a point)\r\n            // The overlap is of no consequence to the algorithm so make it a\r\n            // line\r\n            return [ps[0], ps[1]];\r\n        }\r\n        // At this point not all points same and not all points different and \r\n        // not endpoints coincide, so either:\r\n        // * point 0 and 1 coincide\r\n        // * point 1 and 2 coincide\r\n        // but in that case we simply have a line\r\n        return [ps[0], ps[2]];\r\n    }\r\n    // ---- at this point we must have a cubic\r\n    // Early filter - if no points coincide, we\'re done - well spaced\r\n    if ((0,_are_all_points_different_js__WEBPACK_IMPORTED_MODULE_2__.areAllPointsDifferent)(ps)) {\r\n        return checkCubicForLineOrQuad(ps);\r\n    }\r\n    if (arePsEqual(ps[0], ps[3])) {\r\n        // we should simply handle this case for cubics - lines and quadratics \r\n        // degenerate into a point and a self-overlapping curve respectively.\r\n        if (arePsEqual(ps[1], ps[2])) {\r\n            // it is a cubic degenerated to a line\r\n            return [ps[0], ps[2]];\r\n        }\r\n        // no need to fix anything - it is a loop - it cannot be a line or a\r\n        // quadratic (they don\'t make loops)\r\n        return ps;\r\n    }\r\n    // At this point, either:\r\n    // * point 0, 1 and 2 coincide\r\n    // * point 1, 2 and 3 coincide\r\n    // * points 0,1 AND points 2,3 coincide\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If point 0, 1 and 2 coincide OR point 1, 2 and 3 coincide OR\r\n    // points 0,1 AND points 2,3 coincide we have a line\r\n    if ((arePsEqual(ps[0], ps[1]) &&\r\n        arePsEqual(ps[1], ps[2])) ||\r\n        (arePsEqual(ps[1], ps[2]) &&\r\n            arePsEqual(ps[2], ps[3])) ||\r\n        (arePsEqual(ps[0], ps[1]) &&\r\n            arePsEqual(ps[2], ps[3]))) {\r\n        // Check if first and last point are sufficiently far apart to split\r\n        // the bezier into a line so that all points differ.\r\n        if (ps[0][0] - ps[3][0] > (3 + 1) * gridSpacing ||\r\n            ps[0][1] - ps[3][1] > (3 + 1) * gridSpacing) {\r\n            return [ps[0], ps[ps.length - 1]];\r\n        }\r\n        else {\r\n            // Points are not sufficiently far apart to resolve onto grid -\r\n            // cannot fix it - it is basically a point.\r\n            return undefined;\r\n        }\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 0 and point 2 coincides        \r\n    // * only point 1 and point 2 coincides\r\n    // * only point 1 and point 3 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // If points 0,2 OR points 1,3 OR points 1,2 coincide we\'re done - they\r\n    // are not problematic\r\n    if (arePsEqual(ps[0], ps[2]) ||\r\n        arePsEqual(ps[1], ps[3]) ||\r\n        arePsEqual(ps[1], ps[2])) {\r\n        // these kinds of cubics cannot be quadratics and the case for a line\r\n        // has already been checked - we\'re done\r\n        return ps;\r\n    }\r\n    // At this point, either:\r\n    // * only point 0 and point 1 coincides\r\n    // * only point 2 and point 3 coincides\r\n    // it is a cubic with a cusp at an endpoint - these are fine for our\r\n    // algorithm but lets move them a little apart for later alogorithms \r\n    // operating on our returned result.\r\n    if (arePsEqual(ps[0], ps[1])) {\r\n        // Move point 1 towards point 2 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn\'t affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(ps[1], ps[2]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[2],\r\n                ps[2],\r\n                ps[3]\r\n            ]; // cannot be a line or quad\r\n        }\r\n        else {\r\n            let v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toLength)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[1], ps[2]), 2 * gridSpacing);\r\n            let p1 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(ps[1], v);\r\n            return checkCubicForLineOrQuad([\r\n                ps[0],\r\n                sendToGrid(p1),\r\n                ps[2],\r\n                ps[3]\r\n            ]);\r\n        }\r\n    }\r\n    if (arePsEqual(ps[2], ps[3])) {\r\n        // Move point 2 towards point 1 without surpassing it and ensuring it\r\n        // will be on a new grid point\r\n        // If squared distance between the points < 4 * gridSpacing just \r\n        // move them onto each other - this shouldn\'t affect the overall \r\n        // accuracy of the algorithm and it ensures the move > gridSpacing.\r\n        if ((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween)(ps[2], ps[1]) < 4 * gridSpacing) {\r\n            return [\r\n                ps[0],\r\n                ps[1],\r\n                ps[1],\r\n                ps[3]\r\n            ]; // cannot be a line or quad\r\n        }\r\n        else {\r\n            let v = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.toLength)((0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.fromTo)(ps[2], ps[1]), 2 * gridSpacing);\r\n            let p2 = (0,flo_vector2d__WEBPACK_IMPORTED_MODULE_0__.translate)(ps[2], v);\r\n            return checkCubicForLineOrQuad([\r\n                ps[0],\r\n                ps[1],\r\n                sendToGrid(p2),\r\n                ps[3]\r\n            ]);\r\n        }\r\n    }\r\n}\r\nfunction checkCubicForLineOrQuad(ps) {\r\n    // return isLine(ps)\r\n    return (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.isCollinear)(ps)\r\n        ? [ps[0], ps[3]]\r\n        : (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.isCubicReallyQuad)(ps)\r\n            ? (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_1__.cubicToQuadratic)(ps)\r\n            : ps;\r\n}\r\n/** Returns true if the points are the same */\r\nfunction arePsEqual(p1, p2) {\r\n    return p1[0] === p2[0] && p1[1] === p2[1];\r\n}\r\n\r\n//# sourceMappingURL=fix-bezier-by-point-spacing.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js?')},"./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fixBeziers": () => (/* binding */ fixBeziers)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _to_grid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./to-grid.js */ "./node_modules/flo-boolean/node/loop/normalize/to-grid.js");\n/* harmony import */ var _fix_bezier_by_point_spacing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fix-bezier-by-point-spacing.js */ "./node_modules/flo-boolean/node/loop/normalize/fix-bezier-by-point-spacing.js");\n\r\n\r\n\r\nfunction sendToGrid(expMax, maxBitLength) {\r\n    return (p) => [\r\n        (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_1__.toGrid)(p[0], expMax, maxBitLength),\r\n        (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_1__.toGrid)(p[1], expMax, maxBitLength)\r\n    ];\r\n}\r\nfunction sendToGridNoop(p) { return p; }\r\n/**\r\n * Returns the grid-aligned loop derived from the given input loop.\r\n *\r\n * Also ensures that:\r\n * * All points are coerced onto a grid.\r\n * * All bezier points of a single curve are seperated.\r\n * @param expMax The exponent, e, such that 2^e > all bezier coordinate points.\r\n * @param maxBitLength\r\n */\r\nfunction fixBeziers(expMax, maxBitLength, doSendToGrid = true) {\r\n    /** The actual control point grid spacing */\r\n    let gridSpacing = 2 ** expMax * 2 ** (-maxBitLength);\r\n    let sendToGrid_ = doSendToGrid\r\n        ? sendToGrid(expMax, maxBitLength)\r\n        : sendToGridNoop;\r\n    return (loop) => {\r\n        let newPss = [];\r\n        for (let i = 0; i < loop.length; i++) {\r\n            let ps = loop[i].slice();\r\n            // Get endpoint of last good bezier or else the original start point\r\n            let len = newPss.length;\r\n            let prevGoodBezier = newPss[len - 1];\r\n            let prevGoodBezierEndpoint = prevGoodBezier\r\n                ? prevGoodBezier[prevGoodBezier.length - 1]\r\n                : sendToGrid_(loop[0][0]); // Bit-align original start point\r\n            // Set the start point to the previous good bezier\'s endpoint\r\n            ps[0] = prevGoodBezierEndpoint;\r\n            // Align to grid before doing any further checks\r\n            ps = ps.map(p => sendToGrid_(p));\r\n            // Check if ps degenerates into a self-overlapping line\r\n            if ((0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.isSelfOverlapping)(ps)) {\r\n                // Change into a line with endponts that of the original bezier\r\n                ps = [ps[0], ps[ps.length - 1]];\r\n            }\r\n            ps = (0,_fix_bezier_by_point_spacing_js__WEBPACK_IMPORTED_MODULE_2__.fixBezierByPointSpacing)(ps, gridSpacing, sendToGrid_);\r\n            if (ps !== undefined) {\r\n                newPss.push(ps);\r\n            }\r\n        }\r\n        let len = newPss.length;\r\n        if (!len) {\r\n            return [];\r\n        }\r\n        // Connect the last bezier end-point to the first bezier start-point.\r\n        let ps = newPss[len - 1];\r\n        ps[ps.length - 1] = newPss[0][0];\r\n        return newPss;\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=fix-beziers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js?')},"./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getMaxCoordinate": () => (/* binding */ getMaxCoordinate)\n/* harmony export */ });\n/* harmony import */ var flo_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-memoize */ "./node_modules/flo-memoize/node/index.js");\n\r\n/**\r\n * Returns the maximum control point coordinate value (x or y) within any loop.\r\n * @param loops The array of loops\r\n */\r\nlet getMaxCoordinate = (0,flo_memoize__WEBPACK_IMPORTED_MODULE_0__.memoize)((loops) => {\r\n    let max = 0;\r\n    for (let loop of loops) {\r\n        for (let ps of loop) {\r\n            for (let p of ps) {\r\n                for (let c of p) {\r\n                    let c_ = Math.abs(c);\r\n                    if (c_ > max) {\r\n                        max = c_;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return max;\r\n});\r\n\r\n//# sourceMappingURL=get-max-coordinate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/get-max-coordinate.js?')},"./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "normalizeLoops": () => (/* binding */ normalizeLoops)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _fix_beziers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fix-beziers.js */ "./node_modules/flo-boolean/node/loop/normalize/fix-beziers.js");\n/* harmony import */ var _to_grid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-grid.js */ "./node_modules/flo-boolean/node/loop/normalize/to-grid.js");\n\r\n\r\n\r\n/**\r\n * Returns new loops from the given loops by aligning the 53-bit double\r\n * precision coordinates to 46-bit coordinates. This speeds up the algorithm\r\n * considerably.\r\n *\r\n * The following guarantees are put in place for the returned loops:\r\n * * All points are coerced onto a grid. In other words, such that the\r\n *   significand of all coordinates are reduced to a specified number of bits\r\n *   and the significant bits of all points \'overlap\'.\r\n *\r\n * * No curves are disguised as higher order curves (this includes the case\r\n *   that no bezier is of zero length and the case where there are an infinite\r\n *   number of self-intersections). The curves are simply deflated exactly.\r\n *\r\n * * No cusps (this includes the case that all bezier end-points of each curve\r\n *   are seperated. (this prevents infinite curvature at the endpoints, etc).\r\n *   (this condition is not necessary for this algorithm but may help algorithms\r\n *    down the line that needs such guarantees)\r\n * @param bezierLoops\r\n * @param maxBitLength\r\n * @param expMax\r\n * @param doScramble\r\n * @param doSendToGrid\r\n */\r\nfunction normalizeLoops(bezierLoops, maxBitLength, expMax, doScramble = false, doSendToGrid = true) {\r\n    let fixBeziers_ = (0,_fix_beziers_js__WEBPACK_IMPORTED_MODULE_1__.fixBeziers)(expMax, maxBitLength, doSendToGrid);\r\n    let loops = bezierLoops.slice();\r\n    // just for testing purposes\r\n    loops = doScramble ? scrambleLoops(loops, maxBitLength, expMax, 1) : loops;\r\n    loops = loops.map(fixBeziers_);\r\n    loops = loops.filter(loop => loop.length > 0);\r\n    return loops;\r\n}\r\n/** Just for testing purposes - not used in the actual algorithm */\r\nfunction scrambleLoops(loops, maxBitLength, expMax, mult = 0.02) {\r\n    let loops_ = [];\r\n    for (let loop of loops) {\r\n        let loop_ = [];\r\n        for (let bez of loop) {\r\n            let bez_ = bez.map(v => v.map(c => {\r\n                let c_ = 0;\r\n                let ii = 0;\r\n                let bl = 0;\r\n                let mblc;\r\n                let mbl = 0;\r\n                while (true) {\r\n                    if (++ii > 10) {\r\n                        break;\r\n                    }\r\n                    c_ = (c + Math.random()) * (1 + ((Math.random() - 0.7) * mult));\r\n                    c_ = (0,_to_grid_js__WEBPACK_IMPORTED_MODULE_2__.toGrid)(c_, expMax, maxBitLength);\r\n                    let bl = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength)(c_);\r\n                    if (bl > mbl) {\r\n                        mbl = bl;\r\n                        mblc = c_;\r\n                    }\r\n                }\r\n                return mblc;\r\n            }));\r\n            loop_.push(bez_);\r\n        }\r\n        loops_.push(loop_);\r\n    }\r\n    return loops_;\r\n}\r\n\r\n//# sourceMappingURL=normalize-loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/normalize-loop.js?')},"./node_modules/flo-boolean/node/loop/normalize/to-grid.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toGrid": () => (/* binding */ toGrid)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/**\r\n * Sends a onto a fixed-spacing grid with 2**significantFigures divisions. Each\r\n * division is 2**maxExp / 2**significantFigures wide.\r\n * @param a\r\n * @param expMax log2(max extent of grid in positive and negative directions)\r\n *\r\n * @param significantFigures\r\n */\r\nfunction toGrid(a, expMax, significantFigures) {\r\n    let expA = Math.floor(Math.log2(Math.abs(a)));\r\n    let expDif = expMax - expA;\r\n    let newSig = significantFigures - expDif + 1;\r\n    if (newSig <= 0) {\r\n        return 0;\r\n    }\r\n    if (significantFigures >= 53) {\r\n        return a;\r\n    }\r\n    return (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.reduceSignificand)(a, newSig);\r\n}\r\n\r\n//# sourceMappingURL=to-grid.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/normalize/to-grid.js?')},"./node_modules/flo-boolean/node/loop/reverse-orientation.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reverseOrientation": () => (/* binding */ reverseOrientation)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n/* harmony import */ var _loop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop.js */ "./node_modules/flo-boolean/node/loop/loop.js");\n\r\n\r\n/**\r\n * Returns a completely reversed loop of the given bezier loop.\r\n * @param loop\r\n */\r\nfunction reverseOrientation(loop) {\r\n    let beziers = [];\r\n    let curves = loop.curves;\r\n    for (let i = curves.length - 1; i >= 0; i--) {\r\n        let curve = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.reverse)(curves[i].ps);\r\n        beziers.push(curve);\r\n    }\r\n    return (0,_loop_js__WEBPACK_IMPORTED_MODULE_1__.loopFromBeziers)(beziers);\r\n}\r\n\r\n//# sourceMappingURL=reverse-orientation.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/reverse-orientation.js?')},"./node_modules/flo-boolean/node/loop/simplify-bounds.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "simplifyBounds": () => (/* binding */ simplifyBounds)\n/* harmony export */ });\n/** Used in tests only - not used in algorithm */\r\nfunction simplifyBounds(bounds) {\r\n    return {\r\n        minX: bounds.minX.p[0],\r\n        minY: bounds.minY.p[1],\r\n        maxX: bounds.maxX.p[0],\r\n        maxY: bounds.maxY.p[1],\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=simplify-bounds.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/loop/simplify-bounds.js?')},"./node_modules/flo-boolean/node/point-on-shape/point-on-shape.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "PointOnShape": () => (/* binding */ PointOnShape)\n/* harmony export */ });\n/* harmony import */ var flo_bezier3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flo-bezier3 */ "./node_modules/flo-bezier3/node/index.js");\n\r\n/**\r\n * Represents a point on the shape boundary.\r\n */\r\nclass PointOnShape {\r\n    /**\r\n     * @param curve\tThe [[ICurve]] on the shape boundary this points belong to.\r\n     * @param t The bezier parameter value on the curve to identify the point\r\n     * coordinates.\r\n     */\r\n    constructor(curve, t) {\r\n        this.curve = curve;\r\n        this.t = t;\r\n        // Cache\r\n        this.p_ = undefined;\r\n    }\r\n    /**\r\n     * The planar point coordinates of this [[PointOnShape]].\r\n     */\r\n    get p() {\r\n        return this.p_ === undefined\r\n            ? this.p_ = (0,flo_bezier3__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(this.curve.ps, this.t)\r\n            : this.p_;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=point-on-shape.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/point-on-shape/point-on-shape.js?')},"./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "arcToCubicCurves": () => (/* binding */ arcToCubicCurves)\n/* harmony export */ });\n// TODO - a work in progress - currently using a different (less accurate?) \r\n// function.\r\n/**\r\n * @hidden\r\n * Get an array of corresponding cubic bezier curve parameters for given arc\r\n * curve paramters.\r\n */\r\nfunction arcToCubicCurves(\r\n/** the start point */\r\npS, \r\n/** radius x */\r\nrx, \r\n/** radius y */\r\nry, \r\n/** x-axis rotation - in degrees */\r\nrotationAngle, largeArcFlag, sweepFlag, pE) {\r\n    return [[\r\n            pS,\r\n            pE\r\n        ]];\r\n}\r\n/**\r\n * @param x\r\n * @param y\r\n * @param angleRad\r\n */\r\nfunction rotate(x, y, angleRad) {\r\n    let X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\r\n    let Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\r\n    return { x: X, y: Y };\r\n}\r\n/**\r\n * @param degrees\r\n */\r\nfunction degToRad(degrees) {\r\n    return (Math.PI * degrees) / 180;\r\n}\r\n\r\n//# sourceMappingURL=arc-to-cubic-curves.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js?')},"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"beziersToSvgPathStr\": () => (/* binding */ beziersToSvgPathStr)\n/* harmony export */ });\n/**\r\n * Returns an SVG path string representation of the given bezier loop.\r\n * @param beziers An array of bezier curves each given as an array of\r\n * control points.\r\n */\r\nfunction beziersToSvgPathStr(beziers) {\r\n    let str = '';\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        if (i === 0) {\r\n            str = 'M ' +\r\n                ps[0][0].toString() + ' ' +\r\n                ps[0][1].toString() + '\\n';\r\n        }\r\n        if (ps.length === 4) {\r\n            str += 'C ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' +\r\n                ps[2][0].toString() + ' ' +\r\n                ps[2][1].toString() + ' ' +\r\n                ps[3][0].toString() + ' ' +\r\n                ps[3][1].toString() + ' ' + '\\n';\r\n        }\r\n        else if (ps.length === 3) {\r\n            str += 'Q ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' +\r\n                ps[2][0].toString() + ' ' +\r\n                ps[2][1].toString() + ' ' + '\\n';\r\n        }\r\n        else if (ps.length === 2) {\r\n            str += 'L ' +\r\n                ps[1][0].toString() + ' ' +\r\n                ps[1][1].toString() + ' ' + '\\n';\r\n        }\r\n    }\r\n    return str + ' z' + '\\n';\r\n}\r\n\r\n//# sourceMappingURL=beziers-to-svg-path-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js?")},"./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getBeziersFromRawPaths": () => (/* binding */ getBeziersFromRawPaths)\n/* harmony export */ });\n/* harmony import */ var _path_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path-state.js */ "./node_modules/flo-boolean/node/svg/path-state.js");\n/* harmony import */ var _path_segment_z_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-segment/z.js */ "./node_modules/flo-boolean/node/svg/path-segment/z.js");\n/* harmony import */ var _path_segment_c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path-segment/c.js */ "./node_modules/flo-boolean/node/svg/path-segment/c.js");\n/* harmony import */ var _path_segment_s_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path-segment/s.js */ "./node_modules/flo-boolean/node/svg/path-segment/s.js");\n/* harmony import */ var _path_segment_l_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path-segment/l.js */ "./node_modules/flo-boolean/node/svg/path-segment/l.js");\n/* harmony import */ var _path_segment_h_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path-segment/h.js */ "./node_modules/flo-boolean/node/svg/path-segment/h.js");\n/* harmony import */ var _path_segment_v_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./path-segment/v.js */ "./node_modules/flo-boolean/node/svg/path-segment/v.js");\n/* harmony import */ var _path_segment_q_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path-segment/q.js */ "./node_modules/flo-boolean/node/svg/path-segment/q.js");\n/* harmony import */ var _path_segment_t_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./path-segment/t.js */ "./node_modules/flo-boolean/node/svg/path-segment/t.js");\n/* harmony import */ var _path_segment_a_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./path-segment/a.js */ "./node_modules/flo-boolean/node/svg/path-segment/a.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst pathFs = {\r\n    //a, // elliptical arc\r\n    c: _path_segment_c_js__WEBPACK_IMPORTED_MODULE_2__.c,\r\n    h: _path_segment_h_js__WEBPACK_IMPORTED_MODULE_5__.h,\r\n    l: _path_segment_l_js__WEBPACK_IMPORTED_MODULE_4__.l,\r\n    q: _path_segment_q_js__WEBPACK_IMPORTED_MODULE_7__.q,\r\n    s: _path_segment_s_js__WEBPACK_IMPORTED_MODULE_3__.s,\r\n    t: _path_segment_t_js__WEBPACK_IMPORTED_MODULE_8__.t,\r\n    v: _path_segment_v_js__WEBPACK_IMPORTED_MODULE_6__.v,\r\n    z: _path_segment_z_js__WEBPACK_IMPORTED_MODULE_1__.z // close path\r\n};\r\n/**\r\n * Returns order 1, 2 and 3 beziers from the given SVG DOM element. If a path\r\n * data tag is not "C, Q or L, etc", i.e. if it is not an absolute bezier\r\n * coordinate then it is converted into one.\r\n * @param paths An SVG element\r\n */\r\nfunction getBeziersFromRawPaths(paths) {\r\n    if (paths.length === 0) {\r\n        return []; // A shape is not described   \r\n    }\r\n    if (paths[0].type.toLowerCase() !== \'m\') {\r\n        throw new Error(\'Invalid SVG - every new path must start with an M or m.\');\r\n    }\r\n    let s = new _path_state_js__WEBPACK_IMPORTED_MODULE_0__.PathState();\r\n    let beziersArrays = [];\r\n    let beziers = [];\r\n    let prevType = undefined;\r\n    for (let i = 0; i < paths.length; i++) {\r\n        let pathSeg = paths[i];\r\n        let type = pathSeg.type.toLowerCase();\r\n        s.vals = pathSeg.values;\r\n        // If pathSeg was lowercase, it is relative - make absolute\r\n        if (pathSeg.type === type) {\r\n            if (type === \'v\') {\r\n                s.vals[0] += s.p[1];\r\n            }\r\n            else if (type === \'a\') {\r\n                s.vals[5] += s.p[0];\r\n                s.vals[6] += s.p[1];\r\n            }\r\n            else {\r\n                for (let i = 0; i < s.vals.length; i++) {\r\n                    s.vals[i] += s.p[i % 2];\r\n                }\r\n            }\r\n        }\r\n        if (type === \'m\') {\r\n            if (beziers.length) {\r\n                // This is a subpath, close as if the previous command was a \r\n                // Z or z.\r\n                if (prevType !== \'z\') {\r\n                    beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_1__.z)(s));\r\n                }\r\n                // Start new path\r\n                beziersArrays.push(beziers);\r\n                beziers = [];\r\n            }\r\n            s.initialPoint = s.p = s.vals;\r\n            prevType = type;\r\n            continue;\r\n        }\r\n        if (type === \'a\') {\r\n            beziers.push(...(0,_path_segment_a_js__WEBPACK_IMPORTED_MODULE_9__.a)(s));\r\n        }\r\n        else {\r\n            let f = pathFs[type];\r\n            if (!f) {\r\n                throw new Error(\'Invalid SVG - command not recognized.\');\r\n            }\r\n            let ps = f(s);\r\n            s.p = ps[ps.length - 1]; // Update current point\r\n            beziers.push(ps);\r\n        }\r\n        prevType = type;\r\n    }\r\n    if (beziers.length > 0) {\r\n        // This is a subpath, close as if the previous command was a Z or z.\r\n        if (prevType !== \'z\') {\r\n            beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_1__.z)(s));\r\n        }\r\n        // Start new path\r\n        beziersArrays.push(beziers);\r\n    }\r\n    return beziersArrays;\r\n}\r\n\r\n//# sourceMappingURL=get-beziers-from-raw-paths.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js?')},"./node_modules/flo-boolean/node/svg/get-paths-from-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getPathsFromStr": () => (/* binding */ getPathsFromStr)\n/* harmony export */ });\n/* harmony import */ var _get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-beziers-from-raw-paths.js */ "./node_modules/flo-boolean/node/svg/get-beziers-from-raw-paths.js");\n/* harmony import */ var _path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-data-polyfill/parse-path-data-string.js */ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js");\n\r\n\r\n/**\r\n * Returns an array of loops with each loop consisting of an array of beziers\r\n * and each bezier in turn consisting of an array of control points from the\r\n * given SVG path string. An array of loops are returned (as opposed to a single\r\n * loop) since an SVG path may have sub-paths.\r\n * @param str The SVG path string, e.g. \'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z\'\r\n */\r\nfunction getPathsFromStr(str) {\r\n    return (0,_get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__.getBeziersFromRawPaths)((0,_path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__.parsePathDataString)(str));\r\n}\r\n\r\n//# sourceMappingURL=get-paths-from-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/get-paths-from-str.js?')},"./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loopsToSvgPathStr\": () => (/* binding */ loopsToSvgPathStr)\n/* harmony export */ });\n/* harmony import */ var _beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./beziers-to-svg-path-str.js */ \"./node_modules/flo-boolean/node/svg/beziers-to-svg-path-str.js\");\n\r\n/**\r\n * Returns an SVG path string representation of the given bezier loops.\r\n * @param loops An array of loops having an array of bezier curves each given as\r\n * an array of control points.\r\n */\r\nfunction loopsToSvgPathStr(loops) {\r\n    let str = '';\r\n    for (let loop of loops) {\r\n        str = str + (0,_beziers_to_svg_path_str_js__WEBPACK_IMPORTED_MODULE_0__.beziersToSvgPathStr)(loop) + '\\n';\r\n    }\r\n    return str;\r\n}\r\n\r\n//# sourceMappingURL=loops-to-svg-path-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/loops-to-svg-path-str.js?")},"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "parseNumber": () => (/* binding */ parseNumber)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\r\n * Source/core/svg/SVGParserUtilities.cpp.\r\n * Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\r\n * @param source\r\n */\r\nfunction parseNumber(source) {\r\n    var exponent = 0;\r\n    var integer = 0;\r\n    var frac = 1;\r\n    var decimal = 0;\r\n    var sign = 1;\r\n    var expsign = 1;\r\n    var startIndex = source._currentIndex;\r\n    source._skipOptionalSpaces();\r\n    // Read the sign.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === "+") {\r\n        source._currentIndex += 1;\r\n    }\r\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === "-") {\r\n        source._currentIndex += 1;\r\n        sign = -1;\r\n    }\r\n    if (source._currentIndex === source._endIndex ||\r\n        ((source._string[source._currentIndex] < "0" || source._string[source._currentIndex] > "9") &&\r\n            source._string[source._currentIndex] !== ".")) {\r\n        throw new Error(\'The first character of a number must be one of [0-9+-.].\');\r\n    }\r\n    // Read the integer part, build right-to-left.\r\n    var startIntPartIndex = source._currentIndex;\r\n    while (source._currentIndex < source._endIndex &&\r\n        source._string[source._currentIndex] >= "0" &&\r\n        source._string[source._currentIndex] <= "9") {\r\n        source._currentIndex += 1; // Advance to first non-digit.\r\n    }\r\n    if (source._currentIndex !== startIntPartIndex) {\r\n        var scanIntPartIndex = source._currentIndex - 1;\r\n        var multiplier = 1;\r\n        while (scanIntPartIndex >= startIntPartIndex) {\r\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\r\n            scanIntPartIndex -= 1;\r\n            multiplier *= 10;\r\n        }\r\n    }\r\n    // Read the decimals.\r\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === ".") {\r\n        source._currentIndex += 1;\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < "0" ||\r\n            source._string[source._currentIndex] > "9") {\r\n            throw new Error(\'There must be a least one digit following the .\');\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= "0" &&\r\n            source._string[source._currentIndex] <= "9") {\r\n            frac *= 10;\r\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    // Read the exponent part.\r\n    if (source._currentIndex !== startIndex &&\r\n        source._currentIndex + 1 < source._endIndex &&\r\n        (source._string[source._currentIndex] === "e" || source._string[source._currentIndex] === "E") &&\r\n        (source._string[source._currentIndex + 1] !== "x" && source._string[source._currentIndex + 1] !== "m")) {\r\n        source._currentIndex += 1;\r\n        // Read the sign of the exponent.\r\n        if (source._string[source._currentIndex] === "+") {\r\n            source._currentIndex += 1;\r\n        }\r\n        else if (source._string[source._currentIndex] === "-") {\r\n            source._currentIndex += 1;\r\n            expsign = -1;\r\n        }\r\n        if (source._currentIndex >= source._endIndex ||\r\n            source._string[source._currentIndex] < "0" ||\r\n            source._string[source._currentIndex] > "9") {\r\n            throw new Error(\'There must be an exponent.\');\r\n        }\r\n        while (source._currentIndex < source._endIndex &&\r\n            source._string[source._currentIndex] >= "0" &&\r\n            source._string[source._currentIndex] <= "9") {\r\n            exponent *= 10;\r\n            exponent += (Number(source._string[source._currentIndex]));\r\n            source._currentIndex += 1;\r\n        }\r\n    }\r\n    var number = integer + decimal;\r\n    number *= sign;\r\n    if (exponent) {\r\n        number *= Math.pow(10, expsign * exponent);\r\n    }\r\n    if (startIndex === source._currentIndex) {\r\n        throw new Error(\'Internal error: startIndex === source._currentIndex\');\r\n    }\r\n    source._skipOptionalSpacesOrDelimiter();\r\n    return number;\r\n}\r\n\r\n//# sourceMappingURL=parse-number.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js?')},"./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "parsePathDataString": () => (/* binding */ parsePathDataString)\n/* harmony export */ });\n/* harmony import */ var _source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./source.js */ "./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js");\n\r\n/**\r\n * @hidden\r\n * @param string\r\n */\r\nfunction parsePathDataString(string) {\r\n    if (!string.length) {\r\n        return [];\r\n    }\r\n    let source = new _source_js__WEBPACK_IMPORTED_MODULE_0__.Source(string);\r\n    let pathData = [];\r\n    if (!source.initialCommandIsMoveTo()) {\r\n        throw new Error(\'Path must start with m or M\');\r\n    }\r\n    while (source.hasMoreData()) {\r\n        pathData.push(source.parseSegment());\r\n    }\r\n    return pathData;\r\n}\r\n\r\n//# sourceMappingURL=parse-path-data-string.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-path-data-string.js?')},"./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Source": () => (/* binding */ Source)\n/* harmony export */ });\n/* harmony import */ var _parse_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-number.js */ "./node_modules/flo-boolean/node/svg/path-data-polyfill/parse-number.js");\n\r\n/** @hidden */\r\nconst COMMAND_MAP = {\r\n    Z: "Z", M: "M", L: "L", C: "C", Q: "Q", A: "A", H: "H", V: "V", S: "S", T: "T",\r\n    z: "Z", m: "m", l: "l", c: "c", q: "q", a: "a", h: "h", v: "v", s: "s", t: "t"\r\n};\r\n/** @hidden */\r\nclass Source {\r\n    constructor(string) {\r\n        this._string = string;\r\n        this._currentIndex = 0;\r\n        this._endIndex = this._string.length;\r\n        this._prevCommand = undefined;\r\n        this._skipOptionalSpaces();\r\n    }\r\n    parseSegment() {\r\n        var char = this._string[this._currentIndex];\r\n        var command = COMMAND_MAP[char];\r\n        if (command === undefined) {\r\n            if (this._prevCommand === undefined) {\r\n                throw new Error(\'Implicit command not allowed for first commands.\');\r\n            }\r\n            // Check for remaining coordinates in the current command.\r\n            if ((char === "+" || char === "-" || char === "." || (char >= "0" && char <= "9")) &&\r\n                this._prevCommand !== "Z") {\r\n                if (this._prevCommand === "M") {\r\n                    command = "L";\r\n                }\r\n                else if (this._prevCommand === "m") {\r\n                    command = "l";\r\n                }\r\n                else {\r\n                    command = this._prevCommand;\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\'Remaining coordinates not found for implicit command\');\r\n            }\r\n        }\r\n        else {\r\n            this._currentIndex += 1;\r\n        }\r\n        this._prevCommand = command;\r\n        var values = undefined;\r\n        var cmd = command.toUpperCase();\r\n        if (cmd === "H" || cmd === "V") {\r\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\r\n        }\r\n        else if (cmd === "M" || cmd === "L" || cmd === "T") {\r\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\r\n        }\r\n        else if (cmd === "S" || cmd === "Q") {\r\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\r\n        }\r\n        else if (cmd === "C") {\r\n            values = [\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\r\n            ];\r\n        }\r\n        else if (cmd === "A") {\r\n            values = [\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                this._parseArcFlag(),\r\n                this._parseArcFlag(),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\r\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\r\n            ];\r\n        }\r\n        else if (cmd === "Z") {\r\n            this._skipOptionalSpaces();\r\n            values = [];\r\n        }\r\n        if (values === undefined) {\r\n            throw new Error(\'Unknown command\');\r\n        }\r\n        else {\r\n            return { type: command, values };\r\n        }\r\n    }\r\n    hasMoreData() {\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    initialCommandIsMoveTo() {\r\n        // If the path is empty it is still valid, so return true.\r\n        if (!this.hasMoreData()) {\r\n            return true;\r\n        }\r\n        var command = COMMAND_MAP[this._string[this._currentIndex]];\r\n        return command === "M" || command === "m";\r\n    }\r\n    _isCurrentSpace() {\r\n        var char = this._string[this._currentIndex];\r\n        return char <= " " && (char === " " || char === "\\n" || char === "\\t" || char === "\\r" || char === "\\f");\r\n    }\r\n    _skipOptionalSpaces() {\r\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\r\n            this._currentIndex += 1;\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _skipOptionalSpacesOrDelimiter() {\r\n        if (this._currentIndex < this._endIndex &&\r\n            !this._isCurrentSpace() &&\r\n            this._string[this._currentIndex] !== ",") {\r\n            return false;\r\n        }\r\n        if (this._skipOptionalSpaces()) {\r\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === ",") {\r\n                this._currentIndex += 1;\r\n                this._skipOptionalSpaces();\r\n            }\r\n        }\r\n        return this._currentIndex < this._endIndex;\r\n    }\r\n    _parseArcFlag() {\r\n        if (this._currentIndex >= this._endIndex) {\r\n            throw new Error(\'Unable to parse arc flag\');\r\n        }\r\n        let flag = undefined;\r\n        let flagChar = this._string[this._currentIndex];\r\n        this._currentIndex += 1;\r\n        if (flagChar === "0") {\r\n            flag = 0;\r\n        }\r\n        else if (flagChar === "1") {\r\n            flag = 1;\r\n        }\r\n        else {\r\n            throw new Error(\'Unable to parse arc flag - arc flag must be 0 or 1\');\r\n        }\r\n        this._skipOptionalSpacesOrDelimiter();\r\n        return flag;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=source.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-data-polyfill/source.js?')},"./node_modules/flo-boolean/node/svg/path-segment/a.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ a)\n/* harmony export */ });\n/* harmony import */ var _arc_to_cubic_curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../arc-to-cubic-curves.js */ "./node_modules/flo-boolean/node/svg/arc-to-cubic-curves.js");\n\r\n/**\r\n * @hidden\r\n * A and a: (from www.w3.org)\r\n *\r\n * params: rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n *\r\n * Draws an elliptical arc from the current point to (x, y). The size and\r\n * orientation of the ellipse are defined by two radii (rx, ry) and an\r\n * x-axis-rotation, which indicates how the ellipse as a whole is rotated\r\n * relative to the current coordinate system. The center (cx, cy) of the ellipse\r\n * is calculated automatically to satisfy the constraints imposed by the other\r\n * parameters. large-arc-flag and sweep-flag contribute to the automatic\r\n * calculations and help determine how the arc is drawn.\r\n */\r\nfunction a(s) {\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    let curves = (0,_arc_to_cubic_curves_js__WEBPACK_IMPORTED_MODULE_0__.arcToCubicCurves)(s.p, s.vals[0], s.vals[1], s.vals[2], s.vals[3], s.vals[4], [s.vals[5], s.vals[6]]);\r\n    let lastPs = curves[curves.length - 1];\r\n    s.p = lastPs[lastPs.length - 1]; // Update current point\r\n    return curves;\r\n}\r\n\r\n//# sourceMappingURL=a.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/a.js?')},"./node_modules/flo-boolean/node/svg/path-segment/c.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ c)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * C and c: (from www.w3.org)\r\n *\r\n * params: x1 y1 x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y)\r\n * using (x1,y1) as the control point at the beginning of the\r\n * curve and (x2,y2) as the control point at the end of the\r\n * curve. C (uppercase) indicates that absolute coordinates\r\n * will follow; c (lowercase) indicates that relative\r\n * coordinates will follow. Multiple sets of coordinates may\r\n * be specified to draw a polybézier. At the end of the\r\n * command, the new current point becomes the final (x,y)\r\n * coordinate pair used in the polybézier.\r\n */\r\nfunction c(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]],\r\n        [s.vals[4], s.vals[5]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=c.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/c.js?')},"./node_modules/flo-boolean/node/svg/path-segment/h.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": () => (/* binding */ h)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * H and h: (from www.w3.org)\r\n *\r\n * params: x\r\n *\r\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\r\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\r\n * indicates that relative coordinates will follow. Multiple x values can be\r\n * provided (although usually this doesn\'t make sense). At the end of the\r\n * command, the new current point becomes (x, cpy) for the final value of x.\r\n */\r\nfunction h(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.vals[0], s.p[1]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/h.js?')},"./node_modules/flo-boolean/node/svg/path-segment/l.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "l": () => (/* binding */ l)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * L and l: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draw a line from the current point to the given (x,y) coordinate which\r\n * becomes the new current point. L (uppercase) indicates that absolute\r\n * coordinates will follow; l (lowercase) indicates that relative coordinates\r\n * will follow. A number of coordinates pairs may be specified to draw a\r\n * polyline. At the end of the command, the new current point is set to the\r\n * final set of coordinates provided.\r\n */\r\nfunction l(s) {\r\n    let ps = [\r\n        s.p,\r\n        s.vals\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=l.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/l.js?')},"./node_modules/flo-boolean/node/svg/path-segment/q.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "q": () => (/* binding */ q)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * Q and q: (from www.w3.org)\r\n *\r\n * params: x1 y1 x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\r\n * as the control point. Q (uppercase) indicates that absolute coordinates will\r\n * follow; q (lowercase) indicates that relative coordinates will follow.\r\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\r\n * end of the command, the new current point becomes the final (x,y) coordinate\r\n * pair used in the polybézier.\r\n */\r\nfunction q(s) {\r\n    let QP1 = [s.vals[0], s.vals[1]];\r\n    let QP2 = [s.vals[2], s.vals[3]];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    let ps = [s.p, QP1, QP2];\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=q.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/q.js?')},"./node_modules/flo-boolean/node/svg/path-segment/s.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "s": () => (/* binding */ s)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * S and s: (from www.w3.org)\r\n *\r\n * params: x2 y2 x y\r\n *\r\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\r\n * point is assumed to be the reflection of the second control point on the\r\n * previous command relative to the current point. (If there is no previous\r\n * command or if the previous command was not an C, c, S or s, assume the first\r\n * control point is coincident with the current point.) (x2,y2) is the second\r\n * control point (i.e., the control point at the end of the curve). S\r\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\r\n * indicates that relative coordinates will follow. Multiple sets of coordinates\r\n * may be specified to draw a polybézier. At the end of the command, the new\r\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction s(s) {\r\n    let p = s.prev2ndCubicControlPoint\r\n        ? [(s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0],\r\n            (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1]]\r\n        : s.p;\r\n    let ps = [\r\n        s.p,\r\n        p,\r\n        [s.vals[0], s.vals[1]],\r\n        [s.vals[2], s.vals[3]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = ps[2];\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=s.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/s.js?')},"./node_modules/flo-boolean/node/svg/path-segment/t.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "t": () => (/* binding */ t)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * T and t: (from www.w3.org)\r\n *\r\n * params: x y\r\n *\r\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\r\n * point is assumed to be the reflection of the control point on the previous\r\n * command relative to the current point. (If there is no previous command or if\r\n * the previous command was not a Q, q, T or t, assume the control point is\r\n * coincident with the current point.) T (uppercase) indicates that absolute\r\n * coordinates will follow; t (lowercase) indicates that relative coordinates\r\n * will follow. At the end of the command, the new current point becomes the\r\n * final (x,y) coordinate pair used in the polybézier.\r\n */\r\nfunction t(s) {\r\n    let p = s.prev2ndQuadraticControlPoint\r\n        ? [(s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0],\r\n            (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1]]\r\n        : s.p;\r\n    let QP1 = p;\r\n    let QP2 = [s.vals[0], s.vals[1]];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = QP1;\r\n    return [s.p, QP1, QP2];\r\n}\r\n\r\n//# sourceMappingURL=t.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/t.js?')},"./node_modules/flo-boolean/node/svg/path-segment/v.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "v": () => (/* binding */ v)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * V and v: (from www.w3.org)\r\n *\r\n * params: y\r\n *\r\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\r\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\r\n * indicates that relative coordinates will follow. Multiple y values can be\r\n * provided (although usually this doesn\'t make sense). At the end of the\r\n * command, the new current point becomes (cpx, y) for the final value of y.\r\n */\r\nfunction v(s) {\r\n    let ps = [\r\n        s.p,\r\n        [s.p[0], s.vals[0]]\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=v.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/v.js?')},"./node_modules/flo-boolean/node/svg/path-segment/z.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "z": () => (/* binding */ z)\n/* harmony export */ });\n/**\r\n * @hidden\r\n * Z and z: (from www.w3.org)\r\n *\r\n * params: (none)\r\n *\r\n * Close the current subpath by drawing a straight line from the current point\r\n * to current subpath\'s initial point. Since the Z and z commands take no\r\n * parameters, they have an identical effect.\r\n */\r\nfunction z(s) {\r\n    let ps = [\r\n        s.p,\r\n        s.initialPoint\r\n    ];\r\n    s.prev2ndCubicControlPoint = undefined;\r\n    s.prev2ndQuadraticControlPoint = undefined;\r\n    return ps;\r\n}\r\n\r\n//# sourceMappingURL=z.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-segment/z.js?')},"./node_modules/flo-boolean/node/svg/path-state.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "PathState": () => (/* binding */ PathState)\n/* harmony export */ });\n/** @hidden */\r\nclass PathState {\r\n    constructor() {\r\n        this.initialPoint = undefined;\r\n        this.vals = undefined;\r\n        // Used in conjunction with "S", "s"\r\n        this.prev2ndCubicControlPoint = undefined;\r\n        // Used in conjunction with "T", "t"\r\n        this.prev2ndQuadraticControlPoint = undefined;\r\n        this.p = [0, 0];\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=path-state.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/svg/path-state.js?')},"./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "areBoxesIntersectingDd": () => (/* binding */ areBoxesIntersectingDd)\n/* harmony export */ });\n/**\r\n * Returns true if the 2 given axis-aligned rectangular boxes intersect.\r\n * @param a An axis-aligned rectangular box\r\n * @param b Another axis-aligned rectangular box\r\n * @param closed (defaults to false) Interpret boxes as being closed (i.e. they\r\n * contain their border) or open. If open then if both boxes have zero area\r\n * then they are both considered close.\r\n */\r\nfunction areBoxesIntersectingDd(closed) {\r\n    return (a, b) => {\r\n        let [[ax0, ay0], [ax1, ay1]] = a;\r\n        let [[bx0, by0], [bx1, by1]] = b;\r\n        // If open then if both boxes have zero area then they are both \r\n        // considered closed.\r\n        /*if ((ax0 === ax1 || ay0 === ay1) && (bx0 === bx1 || by0 === by1)) {\r\n            closed = true;\r\n        }*/\r\n        // Swap so smaller coordinate comes first\r\n        if (ay0[1] > ay1[1] || ay0[1] === ay1[1] && ay0[0] > ay1[0]) {\r\n            [ay0, ay1] = [ay1, ay0];\r\n        }\r\n        ;\r\n        if (by0[1] > by1[1] || by0[1] === by1[1] && by0[0] > by1[0]) {\r\n            [by0, by1] = [by1, by0];\r\n        }\r\n        ;\r\n        if (ax0[1] > ax1[1] || ax0[1] === ax1[1] && ax0[0] > ax1[0]) {\r\n            [ax0, ax1] = [ax1, ax0];\r\n        }\r\n        ;\r\n        if (bx0[1] > bx1[1] || bx0[1] === bx1[1] && bx0[0] > bx1[0]) {\r\n            [bx0, bx1] = [bx1, bx0];\r\n        }\r\n        ;\r\n        return closed\r\n            ? (\r\n            //ax0 <= bx1 && ax1 >= bx0 && \r\n            //by0 <= ay1 && by1 >= ay0\r\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] <= bx1[0])) &&\r\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] >= bx0[0])) &&\r\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] <= ay1[0])) &&\r\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] >= ay0[0])))\r\n            : (\r\n            //ax0 < bx1 && ax1 > bx0 && \r\n            //by0 < ay1 && by1 > ay0\r\n            (ax0[1] < bx1[1] || (ax0[1] === bx1[1] && ax0[0] < bx1[0])) &&\r\n                (ax1[1] > bx0[1] || (ax1[1] === bx0[1] && ax1[0] > bx0[0])) &&\r\n                (by0[1] < ay1[1] || (by0[1] === ay1[1] && by0[0] < ay1[0])) &&\r\n                (by1[1] > ay0[1] || (by1[1] === ay0[1] && by1[0] > ay0[0])));\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=are-boxes-intersecting.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/sweep-line/are-boxes-intersecting.js?')},"./node_modules/flo-boolean/node/sweep-line/sweep-line.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sweepLine": () => (/* binding */ sweepLine)\n/* harmony export */ });\nconst EVENT_LEFT = -1;\r\nconst EVENT_RIGHT = +1;\r\n/**\r\n * Generalized sweepline algorithm.\r\n *\r\n * Typically used to turn O(n^2) algorithms into roughly O(n logn) algorithms.\r\n *\r\n * @param items An array of items that are to be compared. Items should\r\n * typically be geometric objects in 2d space with well-defined left and right\r\n * endpoints.\r\n * @param getLeftmostPoint A function that returns the leftmost point of the\r\n * geometric object of interest.\r\n * @param getRightmostPoint A function that returns the rightmost point of the\r\n * geometric object of interest.\r\n * @param predicate A predicate that takes two geometric objects and returns\r\n * truthy (of some specific type) if they are of interest or falsey otherwise.\r\n */\r\nfunction sweepLine(items, getLeftmost, getRightmost, predicate) {\r\n    // Initialize event queue to contain all endpoints.\r\n    let events = [];\r\n    for (let item of items) {\r\n        events.push({\r\n            type: EVENT_LEFT,\r\n            item,\r\n            x: getLeftmost(item)\r\n        });\r\n        events.push({\r\n            type: EVENT_RIGHT,\r\n            item,\r\n            x: getRightmost(item)\r\n        });\r\n    }\r\n    events.sort(compare);\r\n    let activeItems = new Set();\r\n    /** A list of pairs of items that passed the predicate */\r\n    let pairedItems = [];\r\n    for (let event of events) {\r\n        let item = event.item;\r\n        if (event.type === EVENT_LEFT) {\r\n            for (let activeItem of activeItems.values()) {\r\n                //(window as any).ii++;\r\n                let result = predicate(item, activeItem);\r\n                if (result) {\r\n                    //(window as any).jj++;\r\n                    //console.log(result)\r\n                    pairedItems.push({\r\n                        a: item,\r\n                        b: activeItem,\r\n                        u: result\r\n                    });\r\n                }\r\n            }\r\n            activeItems.add(item);\r\n        }\r\n        else if (event.type === EVENT_RIGHT) {\r\n            activeItems.delete(event.item);\r\n        }\r\n    }\r\n    return pairedItems;\r\n}\r\n/**\r\n * Compare two Events by their x-axis and then by their type.\r\n * @param a An event\r\n * @param b Another event\r\n */\r\nfunction compare(a, b) {\r\n    let res = a.x - b.x;\r\n    if (res !== 0) {\r\n        return res;\r\n    }\r\n    // Alwys put left events before right ones.\r\n    return a.type;\r\n}\r\n\r\n//# sourceMappingURL=sweep-line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-boolean/node/sweep-line/sweep-line.js?')},"./node_modules/flo-draw/node/debug/debug.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enableDebugDrawFs": () => (/* binding */ enableDebugDrawFs)\n/* harmony export */ });\n/* harmony import */ var _draw_fs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draw-fs.js */ "./node_modules/flo-draw/node/draw-fs.js");\n\r\n/**\r\n * Returns a new debug object by spreading boolean operation debug information\r\n * onto the given (possibly undefined) debug object.\r\n * @param debugOn a (possibly undefined) debug object\r\n */\r\nfunction enableDebugDrawFs(debugOn) {\r\n    if (!debugOn) {\r\n        return;\r\n    }\r\n    let debug = window._debug_;\r\n    debug = {\r\n        ...debug,\r\n        fs: {\r\n            ...debug?.fs,\r\n            draw: {\r\n                ..._draw_fs_js__WEBPACK_IMPORTED_MODULE_0__.drawFs\r\n            }\r\n        }\r\n    };\r\n    window._debug_ = debug;\r\n}\r\n\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/debug/debug.js?')},"./node_modules/flo-draw/node/draw-fs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawFs": () => (/* binding */ drawFs)\n/* harmony export */ });\n/* harmony import */ var _draw_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw/circle.js */ "./node_modules/flo-draw/node/draw/circle.js");\n/* harmony import */ var _draw_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw/cross-hair.js */ "./node_modules/flo-draw/node/draw/cross-hair.js");\n/* harmony import */ var _draw_dot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw/dot.js */ "./node_modules/flo-draw/node/draw/dot.js");\n/* harmony import */ var _draw_line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draw/line.js */ "./node_modules/flo-draw/node/draw/line.js");\n/* harmony import */ var _draw_rect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw/rect.js */ "./node_modules/flo-draw/node/draw/rect.js");\n/* harmony import */ var _draw_polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./draw/polygon.js */ "./node_modules/flo-draw/node/draw/polygon.js");\n/* harmony import */ var _draw_loop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./draw/loop.js */ "./node_modules/flo-draw/node/draw/loop.js");\n/* harmony import */ var _draw_polyline_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./draw/polyline.js */ "./node_modules/flo-draw/node/draw/polyline.js");\n/* harmony import */ var _draw_beziers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./draw/beziers.js */ "./node_modules/flo-draw/node/draw/beziers.js");\n/* harmony import */ var _draw_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./draw/cubic-bezier.js */ "./node_modules/flo-draw/node/draw/cubic-bezier.js");\n/* harmony import */ var _draw_bezier_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./draw/bezier.js */ "./node_modules/flo-draw/node/draw/bezier.js");\n/* harmony import */ var _draw_bezier_piece_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./draw/bezier-piece.js */ "./node_modules/flo-draw/node/draw/bezier-piece.js");\n/* harmony import */ var _draw_quad_bezier_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./draw/quad-bezier.js */ "./node_modules/flo-draw/node/draw/quad-bezier.js");\n/* harmony import */ var _draw_text_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./draw/text.js */ "./node_modules/flo-draw/node/draw/text.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet drawFs = {\r\n    circle: _draw_circle_js__WEBPACK_IMPORTED_MODULE_0__.circle,\r\n    crossHair: _draw_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__.crossHair,\r\n    dot: _draw_dot_js__WEBPACK_IMPORTED_MODULE_2__.dot,\r\n    line: _draw_line_js__WEBPACK_IMPORTED_MODULE_3__.line,\r\n    rect: _draw_rect_js__WEBPACK_IMPORTED_MODULE_4__.rect,\r\n    beziers: _draw_beziers_js__WEBPACK_IMPORTED_MODULE_8__.beziers,\r\n    bezier: _draw_bezier_js__WEBPACK_IMPORTED_MODULE_10__.bezier,\r\n    bezierPiece: _draw_bezier_piece_js__WEBPACK_IMPORTED_MODULE_11__.bezierPiece,\r\n    quadBezier: _draw_quad_bezier_js__WEBPACK_IMPORTED_MODULE_12__.quadBezier,\r\n    cubicBezier: _draw_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_9__.cubicBezier,\r\n    polygon: _draw_polygon_js__WEBPACK_IMPORTED_MODULE_5__.polygon,\r\n    loop: _draw_loop_js__WEBPACK_IMPORTED_MODULE_6__.loop,\r\n    polyline: _draw_polyline_js__WEBPACK_IMPORTED_MODULE_7__.polyline,\r\n    text: _draw_text_js__WEBPACK_IMPORTED_MODULE_13__.text\r\n};\r\n\r\n//# sourceMappingURL=draw-fs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw-fs.js?')},"./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierFromBezierPiece": () => (/* binding */ bezierFromBezierPiece)\n/* harmony export */ });\n/* harmony import */ var _evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./evaluate-bezier.js */ "./node_modules/flo-draw/node/draw/evaluate-bezier.js");\n/* harmony import */ var _split_at_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-at.js */ "./node_modules/flo-draw/node/draw/split-at.js");\n\r\n\r\n/**\r\n * Returns a new bezier from the given bezier by limiting its t range.\r\n *\r\n * Duplicated here so we don\'t circularly depend on flo-bezier.\r\n *\r\n * Uses de Casteljau\'s algorithm.\r\n *\r\n * @param ps a bezier\r\n * @param tRange a t range\r\n */\r\nfunction bezierFromBezierPiece(ps, tRange) {\r\n    // If tRange = [0,1] then return original bezier.\r\n    if (tRange[0] === 0 && tRange[1] === 1) {\r\n        return ps;\r\n    }\r\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = (0,_evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_0__.evaluateBezier)(ps, tRange[0]);\r\n        return [p, p, p, p];\r\n    }\r\n    if (tRange[0] === 0) {\r\n        return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[1])[0];\r\n    }\r\n    if (tRange[1] === 1) {\r\n        return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[0])[1];\r\n    }\r\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \r\n    // and tRange[1] !== 1\r\n    return (0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)((0,_split_at_js__WEBPACK_IMPORTED_MODULE_1__.splitAt)(ps, tRange[0])[1], (tRange[1] - tRange[0]) / (1 - tRange[0]))[0];\r\n}\r\n\r\n//# sourceMappingURL=bezier-from-bezier-piece.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js?')},"./node_modules/flo-draw/node/draw/bezier-piece.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezierPiece": () => (/* binding */ bezierPiece)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _cross_hair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cross-hair.js */ "./node_modules/flo-draw/node/draw/cross-hair.js");\n/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bezier.js */ "./node_modules/flo-draw/node/draw/bezier.js");\n/* harmony import */ var _evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./evaluate-bezier.js */ "./node_modules/flo-draw/node/draw/evaluate-bezier.js");\n/* harmony import */ var _bezier_from_bezier_piece_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bezier-from-bezier-piece.js */ "./node_modules/flo-draw/node/draw/bezier-from-bezier-piece.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Draws a bezier piece, i.e. a bezier within a specified t range.\r\n * @param snap\r\n * @param bezierPiece\r\n * @param class\r\n * @param delay\r\n */\r\nfunction bezierPiece(g, ps_, tRange, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let $elems = [];\r\n    // Draw crosshair if t range bounds are equal.\r\n    if (tRange[0] === tRange[1]) {\r\n        let p = (0,_evaluate_bezier_js__WEBPACK_IMPORTED_MODULE_3__.evaluateBezier)(ps_, tRange[0]);\r\n        $elems = (0,_cross_hair_js__WEBPACK_IMPORTED_MODULE_1__.crossHair)(g, p, class_, 1.5);\r\n    }\r\n    else {\r\n        let ps = (0,_bezier_from_bezier_piece_js__WEBPACK_IMPORTED_MODULE_4__.bezierFromBezierPiece)(ps_, tRange);\r\n        $elems = (0,_bezier_js__WEBPACK_IMPORTED_MODULE_2__.bezier)(g, ps, class_);\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $elems.forEach(e => e.remove()), delay);\r\n    }\r\n    return $elems;\r\n}\r\n\r\n//# sourceMappingURL=bezier-piece.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/bezier-piece.js?')},"./node_modules/flo-draw/node/draw/bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bezier": () => (/* binding */ bezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line.js */ "./node_modules/flo-draw/node/draw/line.js");\n/* harmony import */ var _quad_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quad-bezier.js */ "./node_modules/flo-draw/node/draw/quad-bezier.js");\n/* harmony import */ var _cubic_bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubic-bezier.js */ "./node_modules/flo-draw/node/draw/cubic-bezier.js");\n\r\n\r\n\r\n\r\nfunction bezier(g, bezier, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (bezier.length === 2) {\r\n        return (0,_line_js__WEBPACK_IMPORTED_MODULE_1__.line)(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 3) {\r\n        return (0,_quad_bezier_js__WEBPACK_IMPORTED_MODULE_2__.quadBezier)(g, bezier, class_, delay);\r\n    }\r\n    else if (bezier.length === 4) {\r\n        return (0,_cubic_bezier_js__WEBPACK_IMPORTED_MODULE_3__.cubicBezier)(g, bezier, class_, delay);\r\n    }\r\n    return [];\r\n}\r\n\r\n//# sourceMappingURL=bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/bezier.js?')},"./node_modules/flo-draw/node/draw/beziers.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"beziers\": () => (/* binding */ beziers)\n/* harmony export */ });\n/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier.js */ \"./node_modules/flo-draw/node/draw/bezier.js\");\n\r\nconst COLORS = ['red', 'green', 'cyan', 'blue'];\r\n/**\r\n * Draws beziers.\r\n * @param snap\r\n * @param beziers\r\n * @param delay\r\n */\r\nfunction beziers(g, beziers, classes, delay) {\r\n    let alternateColors = classes === undefined;\r\n    let $beziers = [];\r\n    for (let i = 0; i < beziers.length; i++) {\r\n        let ps = beziers[i];\r\n        let color = COLORS[i % COLORS.length];\r\n        let class_ = alternateColors\r\n            ? 'thin5 nofill ' + color\r\n            : classes;\r\n        $beziers.push(...(0,_bezier_js__WEBPACK_IMPORTED_MODULE_0__.bezier)(g, ps, class_));\r\n    }\r\n    if (delay) {\r\n        setTimeout(() => $beziers.forEach(e => e.remove()), delay);\r\n    }\r\n    return $beziers;\r\n}\r\n\r\n//# sourceMappingURL=beziers.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/beziers.js?")},"./node_modules/flo-draw/node/draw/circle.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "circle": () => (/* binding */ circle)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\n/**\r\n * Draws a circle\r\n * @param g An SVG group element wherein to draw the circle.\r\n * @param circle\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction circle(g, circle, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let c = circle.center;\r\n    let r = circle.radius;\r\n    let $circle = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'circle\');\r\n    $circle.setAttributeNS(null, "cx", c[0].toString());\r\n    $circle.setAttributeNS(null, "cy", c[1].toString());\r\n    $circle.setAttributeNS(null, "r", r.toString());\r\n    $circle.setAttributeNS(null, "class", classes);\r\n    g.appendChild($circle);\r\n    if (delay) {\r\n        setTimeout(() => $circle.remove(), delay);\r\n    }\r\n    return [$circle];\r\n}\r\n\r\n//# sourceMappingURL=circle.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/circle.js?')},"./node_modules/flo-draw/node/draw/cross-hair.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "crossHair": () => (/* binding */ crossHair)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circle.js */ "./node_modules/flo-draw/node/draw/circle.js");\n/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.js */ "./node_modules/flo-draw/node/draw/line.js");\n\r\n\r\n\r\n/**\r\n * Draws a crosshair.\r\n */\r\nfunction crossHair(g, p, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, r = 3, delay) {\r\n    let circle_ = { center: p, radius: r };\r\n    let $circle = (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circle)(g, circle_, classes);\r\n    let l1 = [[p[0] - r, p[1]], [p[0] + r, p[1]]];\r\n    let l2 = [[p[0], p[1] - r], [p[0], p[1] + r]];\r\n    let $l1 = (0,_line_js__WEBPACK_IMPORTED_MODULE_2__.line)(g, l1, classes);\r\n    let $l2 = (0,_line_js__WEBPACK_IMPORTED_MODULE_2__.line)(g, l2, classes);\r\n    if (delay) {\r\n        setTimeout(() => {\r\n            $circle.forEach(e => e.remove());\r\n            $l1.forEach(e => e.remove());\r\n            $l2.forEach(e => e.remove());\r\n        }, delay);\r\n    }\r\n    return [...$circle, ...$l1, ...$l2];\r\n}\r\n\r\n//# sourceMappingURL=cross-hair.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/cross-hair.js?')},"./node_modules/flo-draw/node/draw/cubic-bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cubicBezier": () => (/* binding */ cubicBezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n/* harmony import */ var _cross_hair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cross-hair.js */ "./node_modules/flo-draw/node/draw/cross-hair.js");\n\r\n\r\n\r\nfunction cubicBezier(g, bezier, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = bezier;\r\n    if (x0 === x3 && x1 === x3 && x2 === x3 &&\r\n        y0 === y3 && y1 === y3 && y2 === y3) {\r\n        return (0,_cross_hair_js__WEBPACK_IMPORTED_MODULE_2__.crossHair)(g, [x0, y0], class_, 0.2, delay);\r\n    }\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'path\');\r\n    $path.setAttributeNS(null, "d", `M${x0} ${y0} C${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`);\r\n    $path.setAttributeNS(null, "class", class_);\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=cubic-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/cubic-bezier.js?')},"./node_modules/flo-draw/node/draw/default-class.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_CLASS\": () => (/* binding */ DEFAULT_CLASS)\n/* harmony export */ });\nconst DEFAULT_CLASS = 'red thin10 nofill ';\r\n\r\n//# sourceMappingURL=default-class.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/default-class.js?")},"./node_modules/flo-draw/node/draw/dot.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dot\": () => (/* binding */ dot)\n/* harmony export */ });\n/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circle.js */ \"./node_modules/flo-draw/node/draw/circle.js\");\n\r\n/**\r\n * Draws a dot.\r\n */\r\nfunction dot(g, p, r = 3, color = 'red', delay) {\r\n    let [$dot] = (0,_circle_js__WEBPACK_IMPORTED_MODULE_0__.circle)(g, { center: p, radius: r }, 'dot ' + color, delay);\r\n    if (delay) {\r\n        setTimeout(() => $dot.remove(), delay);\r\n    }\r\n    return [$dot];\r\n}\r\n\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/dot.js?")},"./node_modules/flo-draw/node/draw/evaluate-bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateBezier": () => (/* binding */ evaluateBezier)\n/* harmony export */ });\n/**\r\n * Returns an estimate of evaluating the given bezier at the given t value.\r\n * @param ps An order 1, 2 or bezier\r\n * @param t The parameter ∈ [0,1]\r\n */\r\nfunction evaluateBezier(ps, t) {\r\n    let s = 1 - t;\r\n    if (ps.length === 4) {\r\n        // cubic\r\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n        let x = x0 * s ** 3 + 3 * x1 * s ** 2 * t + 3 * x2 * s * t ** 2 + x3 * t ** 3;\r\n        let y = y0 * s ** 3 + 3 * y1 * s ** 2 * t + 3 * y2 * s * t ** 2 + y3 * t ** 3;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 3) {\r\n        // quadratic\r\n        let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n        let x = x0 * s ** 2 + 2 * x1 * s * t + x2 * t ** 2;\r\n        let y = y0 * s ** 2 + 2 * y1 * s * t + y2 * t ** 2;\r\n        return [x, y];\r\n    }\r\n    if (ps.length === 2) {\r\n        // line\r\n        let [[x0, y0], [x1, y1]] = ps;\r\n        let x = x0 * s + x1 * t;\r\n        let y = y0 * s + y1 * t;\r\n        return [x, y];\r\n    }\r\n    return [NaN, NaN];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/evaluate-bezier.js?')},"./node_modules/flo-draw/node/draw/line.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "line": () => (/* binding */ line)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\n/**\r\n *\r\n * @param snap\r\n * @param l\r\n * @param classes\r\n */\r\nfunction line(g, l, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let $line = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'line\');\r\n    $line.setAttributeNS(null, "x1", l[0][0].toString());\r\n    $line.setAttributeNS(null, "y1", l[0][1].toString());\r\n    $line.setAttributeNS(null, "x2", l[1][0].toString());\r\n    $line.setAttributeNS(null, "y2", l[1][1].toString());\r\n    $line.setAttributeNS(null, "class", classes);\r\n    g.appendChild($line);\r\n    if (delay) {\r\n        setTimeout(() => $line.remove(), delay);\r\n    }\r\n    return [$line];\r\n}\r\n\r\n//# sourceMappingURL=line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/line.js?')},"./node_modules/flo-draw/node/draw/loop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loop\": () => (/* binding */ loop)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ \"./node_modules/flo-draw/node/draw/default-class.js\");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ \"./node_modules/flo-draw/node/draw/xmlns.js\");\n\r\n\r\nfunction loop(g, curves, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (!curves.length) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, 'path');\r\n    let d = `M${curves[0][0][0]} ${curves[0][0][1]} `;\r\n    for (let i = 0; i < curves.length; i++) {\r\n        let curve = curves[i];\r\n        d += `${getType(curve.length)} `;\r\n        for (let j = 1; j < curve.length; j++) {\r\n            d += `${curve[j][0]} ${curve[j][1]} `;\r\n        }\r\n    }\r\n    d += ' z';\r\n    $path.setAttributeNS(null, \"d\", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, \"class\", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\nfunction getType(len) {\r\n    if (len === 2) {\r\n        return 'L';\r\n    }\r\n    if (len === 3) {\r\n        return 'Q';\r\n    }\r\n    if (len === 4) {\r\n        return 'C';\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=loop.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/loop.js?")},"./node_modules/flo-draw/node/draw/polygon.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "polygon": () => (/* binding */ polygon)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\n/**\r\n * Draws a polygon\r\n * @param g\r\n * @param poly the polygon specified as an array of points - the last point does\r\n * not have to be specified\r\n * @param class_\r\n * @param delay\r\n */\r\nfunction polygon(g, poly, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'path\');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    d += \' z\';\r\n    $path.setAttributeNS(null, "d", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=polygon.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/polygon.js?')},"./node_modules/flo-draw/node/draw/polyline.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "polyline": () => (/* binding */ polyline)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\nfunction polyline(g, poly, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    if (poly.length < 2) {\r\n        return [];\r\n    }\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'path\');\r\n    let d = `M${poly[0][0]} ${poly[0][1]} L`;\r\n    for (let i = 0; i < poly.length; i++) {\r\n        d += `${poly[i][0]} ${poly[i][1]} `;\r\n    }\r\n    $path.setAttributeNS(null, "d", d);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=polyline.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/polyline.js?')},"./node_modules/flo-draw/node/draw/quad-bezier.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "quadBezier": () => (/* binding */ quadBezier)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\nfunction quadBezier(g, ps, class_ = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let $path = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'path\');\r\n    $path.setAttributeNS(null, "d", `M${x0} ${y0} Q${x1} ${y1} ${x2} ${y2}`);\r\n    if (class_) {\r\n        $path.setAttributeNS(null, "class", class_);\r\n    }\r\n    g.appendChild($path);\r\n    if (delay) {\r\n        setTimeout(() => $path.remove(), delay);\r\n    }\r\n    return [$path];\r\n}\r\n\r\n//# sourceMappingURL=quad-bezier.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/quad-bezier.js?')},"./node_modules/flo-draw/node/draw/rect.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rect": () => (/* binding */ rect)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\nfunction rect(g, rect, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let [[x0, y0], [x1, y1]] = rect;\r\n    let x = x0 < x1 ? x0 : x1;\r\n    let y = y0 < y1 ? y0 : y1;\r\n    let width = Math.abs(x0 - x1);\r\n    let height = Math.abs(y0 - y1);\r\n    let $rect = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'rect\');\r\n    $rect.setAttributeNS(null, "x", x.toString());\r\n    $rect.setAttributeNS(null, "y", y.toString());\r\n    $rect.setAttributeNS(null, "width", width.toString());\r\n    $rect.setAttributeNS(null, "height", height.toString());\r\n    if (classes) {\r\n        $rect.setAttributeNS(null, "class", classes);\r\n    }\r\n    g.appendChild($rect);\r\n    if (delay) {\r\n        setTimeout(() => $rect.remove(), delay);\r\n    }\r\n    return [$rect];\r\n}\r\n\r\n//# sourceMappingURL=rect.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/rect.js?')},"./node_modules/flo-draw/node/draw/split-at.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "splitAt": () => (/* binding */ splitAt)\n/* harmony export */ });\n/**\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1].\r\n * @param ps\r\n * @param t\r\n */\r\nfunction splitAt(ps, t) {\r\n    if (ps.length === 2) {\r\n        return splitLineAt(ps, t);\r\n    }\r\n    else if (ps.length === 3) {\r\n        return splitQuadAt(ps, t);\r\n    }\r\n    else if (ps.length === 4) {\r\n        return splitCubicAt(ps, t);\r\n    }\r\n    return [];\r\n}\r\n/**\r\n * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges\r\n * [0,t] and [t,1]. Uses de Casteljau\'s algorithm.\r\n *\r\n * A loose bound on the accuracy of the resultant points is given by:\r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * @param ps A cubic bezier curve\r\n * @param t The t parameter where the curve should be split\r\n */\r\nfunction splitCubicAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\r\n    let s = 1 - t;\r\n    let t2 = t * t;\r\n    let t3 = t2 * t;\r\n    let s2 = s * s;\r\n    let s3 = s2 * s;\r\n    /** The split point */\r\n    let p = [\r\n        t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\r\n        t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [t * x1 + s * x0,\r\n            t * y1 + s * y0],\r\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0,\r\n            t2 * y2 + 2 * s * t * y1 + s2 * y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1,\r\n            t2 * y3 + 2 * t * s * y2 + s2 * y1],\r\n        [t * x3 + s * x2,\r\n            t * y3 + s * y2],\r\n        [x3, y3]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitQuadAt(ps, t) {\r\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * s * x0 + 2 * s * t * x1 + t * t * x2,\r\n        s * s * y0 + 2 * s * t * y1 + t * t * y2\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        [s * x0 + t * x1,\r\n            s * y0 + t * y1],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [s * x1 + t * x2,\r\n            s * y1 + t * y2],\r\n        [x2, y2]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\nfunction splitLineAt(ps, t) {\r\n    let [[x0, y0], [x1, y1]] = ps;\r\n    let s = 1 - t;\r\n    /** The split point */\r\n    let p = [\r\n        s * x0 + t * x1,\r\n        s * y0 + t * y1\r\n    ];\r\n    let ps1 = [\r\n        [x0, y0],\r\n        p\r\n    ];\r\n    let ps2 = [\r\n        p,\r\n        [x1, y1]\r\n    ];\r\n    return [ps1, ps2];\r\n}\r\n\r\n//# sourceMappingURL=split-at.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/split-at.js?')},"./node_modules/flo-draw/node/draw/text.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "text": () => (/* binding */ text)\n/* harmony export */ });\n/* harmony import */ var _default_class_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default-class.js */ "./node_modules/flo-draw/node/draw/default-class.js");\n/* harmony import */ var _xmlns_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xmlns.js */ "./node_modules/flo-draw/node/draw/xmlns.js");\n\r\n\r\n/**\r\n * Draws text\r\n * @param g a SVG group element wherein to draw\r\n * @param p\r\n * @param str\r\n * @param fontSize\r\n * @param classes\r\n * @param delay\r\n */\r\nfunction text(g, p, str, fontSize, classes = _default_class_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CLASS, delay) {\r\n    let $text = document.createElementNS(_xmlns_js__WEBPACK_IMPORTED_MODULE_1__.XMLNS, \'text\');\r\n    $text.setAttributeNS(null, "x", p[0].toString());\r\n    $text.setAttributeNS(null, "y", p[1].toString());\r\n    $text.setAttributeNS(null, "font-size", fontSize.toString());\r\n    $text.setAttributeNS(null, "class", classes);\r\n    $text.textContent = str;\r\n    g.appendChild($text);\r\n    if (delay) {\r\n        setTimeout(() => $text.remove(), delay);\r\n    }\r\n    return [$text];\r\n}\r\n\r\n//# sourceMappingURL=text.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/text.js?')},"./node_modules/flo-draw/node/draw/xmlns.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XMLNS\": () => (/* binding */ XMLNS)\n/* harmony export */ });\nconst XMLNS = 'http://www.w3.org/2000/svg';\r\n\r\n//# sourceMappingURL=xmlns.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/draw/xmlns.js?")},"./node_modules/flo-draw/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "drawFs": () => (/* reexport safe */ _draw_fs_js__WEBPACK_IMPORTED_MODULE_0__.drawFs),\n/* harmony export */   "enableDebugDrawFs": () => (/* reexport safe */ _debug_debug_js__WEBPACK_IMPORTED_MODULE_1__.enableDebugDrawFs)\n/* harmony export */ });\n/* harmony import */ var _draw_fs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-fs.js */ "./node_modules/flo-draw/node/draw-fs.js");\n/* harmony import */ var _debug_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug/debug.js */ "./node_modules/flo-draw/node/debug/debug.js");\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-draw/node/index.js?')},"./node_modules/flo-gauss-quadrature/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "gaussQuadrature": () => (/* binding */ gaussQuadrature)\n/* harmony export */ });\n// TODO A future improvement can be to use the Gauss–Kronrod rules\r\n// to estimate the error and thus choose a number of constants based\r\n// on the error. Maybe not.\r\n// TODO In future, the constants can be calculated and cached so we can\r\n// choose any value for the order.\r\n// TODO - to limit rounding error do pairwise addition of terms\r\n// TODO order abscissas\r\n// TODO - auto calc abscissas and weights (on first call to function only)\r\n/**\r\n * Numerically integrates the given function using the Gaussian Quadrature\r\n * method.\r\n *\r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * @param f The univariate function to be integrated\r\n * @param interval The integration interval\r\n * @param order Can be 2, 4, 8, or 16. Higher values give more accurate results\r\n * but is slower - defaults to 16.\r\n */\r\nfunction gaussQuadrature(f, interval, order = 16) {\r\n    if (interval[0] === interval[1]) {\r\n        return 0;\r\n    }\r\n    let { weights, abscissas } = GAUSS_CONSTANTS[order];\r\n    let [a, b] = interval;\r\n    let result = 0;\r\n    let m1 = (b - a) / 2;\r\n    let m2 = (b + a) / 2;\r\n    for (let i = 0; i <= order - 1; i++) {\r\n        result += weights[i] * f(m1 * abscissas[i] + m2);\r\n    }\r\n    return m1 * result;\r\n}\r\n// The Gaussian Legendre Quadrature method constants. \r\nconst GAUSS_CONSTANTS = {\r\n    2: {\r\n        weights: [1, 1],\r\n        abscissas: [-0.5773502691896257, 0.5773502691896257]\r\n    },\r\n    4: {\r\n        weights: [\r\n            0.6521451548625461, 0.6521451548625461,\r\n            0.3478548451374538, 0.3478548451374538\r\n        ],\r\n        abscissas: [\r\n            -0.3399810435848563, 0.3399810435848563,\r\n            -0.8611363115940526, 0.8611363115940526\r\n        ]\r\n    },\r\n    8: {\r\n        weights: [\r\n            0.3626837833783620, 0.3626837833783620,\r\n            0.3137066458778873, 0.3137066458778873,\r\n            0.2223810344533745, 0.2223810344533745,\r\n            0.1012285362903763, 0.1012285362903763\r\n        ],\r\n        abscissas: [\r\n            -0.1834346424956498, 0.1834346424956498,\r\n            -0.5255324099163290, 0.5255324099163290,\r\n            -0.7966664774136267, 0.7966664774136267,\r\n            -0.9602898564975363, 0.9602898564975363\r\n        ]\r\n    },\r\n    // Taken from http://keisan.casio.com/exec/system/1330940731\r\n    16: {\r\n        weights: [\r\n            0.0271524594117540948518,\r\n            0.062253523938647892863,\r\n            0.0951585116824927848099,\r\n            0.1246289712555338720525,\r\n            0.1495959888165767320815,\r\n            0.169156519395002538189,\r\n            0.182603415044923588867,\r\n            0.189450610455068496285,\r\n            0.1894506104550684962854,\r\n            0.182603415044923588867,\r\n            0.1691565193950025381893,\r\n            0.149595988816576732081,\r\n            0.124628971255533872053,\r\n            0.095158511682492784809,\r\n            0.062253523938647892863,\r\n            0.027152459411754094852\r\n        ],\r\n        abscissas: [\r\n            -0.989400934991649932596,\r\n            -0.944575023073232576078,\r\n            -0.86563120238783174388,\r\n            -0.7554044083550030338951,\r\n            -0.6178762444026437484467,\r\n            -0.4580167776572273863424,\r\n            -0.28160355077925891323,\r\n            -0.0950125098376374401853,\r\n            0.0950125098376374401853,\r\n            0.28160355077925891323,\r\n            0.4580167776572273863424,\r\n            0.617876244402643748447,\r\n            0.755404408355003033895,\r\n            0.8656312023878317438805,\r\n            0.944575023073232576078,\r\n            0.989400934991649932596\r\n        ],\r\n    },\r\n    64: {\r\n        weights: [\r\n            0.048690957009139724,\r\n            0.048690957009139724,\r\n            0.04857546744150343,\r\n            0.04857546744150343,\r\n            0.048344762234802954,\r\n            0.048344762234802954,\r\n            0.04799938859645831,\r\n            0.04799938859645831,\r\n            0.04754016571483031,\r\n            0.04754016571483031,\r\n            0.04696818281621002,\r\n            0.04696818281621002,\r\n            0.046284796581314416,\r\n            0.046284796581314416,\r\n            0.04549162792741814,\r\n            0.04549162792741814,\r\n            0.044590558163756566,\r\n            0.044590558163756566,\r\n            0.04358372452932345,\r\n            0.04358372452932345,\r\n            0.04247351512365359,\r\n            0.04247351512365359,\r\n            0.04126256324262353,\r\n            0.04126256324262353,\r\n            0.03995374113272034,\r\n            0.03995374113272034,\r\n            0.038550153178615626,\r\n            0.038550153178615626,\r\n            0.03705512854024005,\r\n            0.03705512854024005,\r\n            0.035472213256882386,\r\n            0.035472213256882386,\r\n            0.033805161837141606,\r\n            0.033805161837141606,\r\n            0.03205792835485155,\r\n            0.03205792835485155,\r\n            0.030234657072402478,\r\n            0.030234657072402478,\r\n            0.028339672614259483,\r\n            0.028339672614259483,\r\n            0.02637746971505466,\r\n            0.02637746971505466,\r\n            0.024352702568710874,\r\n            0.024352702568710874,\r\n            0.022270173808383253,\r\n            0.022270173808383253,\r\n            0.02013482315353021,\r\n            0.02013482315353021,\r\n            0.017951715775697343,\r\n            0.017951715775697343,\r\n            0.015726030476024718,\r\n            0.015726030476024718,\r\n            0.013463047896718643,\r\n            0.013463047896718643,\r\n            0.011168139460131128,\r\n            0.011168139460131128,\r\n            0.008846759826363947,\r\n            0.008846759826363947,\r\n            0.006504457968978363,\r\n            0.006504457968978363,\r\n            0.004147033260562468,\r\n            0.004147033260562468,\r\n            0.001783280721696433,\r\n            0.001783280721696433\r\n        ],\r\n        abscissas: [\r\n            -0.024350292663424433,\r\n            0.024350292663424433,\r\n            -0.07299312178779904,\r\n            0.07299312178779904,\r\n            -0.12146281929612056,\r\n            0.12146281929612056,\r\n            -0.16964442042399283,\r\n            0.16964442042399283,\r\n            -0.21742364374000708,\r\n            0.21742364374000708,\r\n            -0.2646871622087674,\r\n            0.2646871622087674,\r\n            -0.31132287199021097,\r\n            0.31132287199021097,\r\n            -0.3572201583376681,\r\n            0.3572201583376681,\r\n            -0.4022701579639916,\r\n            0.4022701579639916,\r\n            -0.4463660172534641,\r\n            0.4463660172534641,\r\n            -0.48940314570705296,\r\n            0.48940314570705296,\r\n            -0.5312794640198946,\r\n            0.5312794640198946,\r\n            -0.571895646202634,\r\n            0.571895646202634,\r\n            -0.6111553551723933,\r\n            0.6111553551723933,\r\n            -0.6489654712546573,\r\n            0.6489654712546573,\r\n            -0.6852363130542333,\r\n            0.6852363130542333,\r\n            -0.7198818501716109,\r\n            0.7198818501716109,\r\n            -0.7528199072605319,\r\n            0.7528199072605319,\r\n            -0.7839723589433414,\r\n            0.7839723589433414,\r\n            -0.8132653151227975,\r\n            0.8132653151227975,\r\n            -0.8406292962525803,\r\n            0.8406292962525803,\r\n            -0.8659993981540928,\r\n            0.8659993981540928,\r\n            -0.8893154459951141,\r\n            0.8893154459951141,\r\n            -0.9105221370785028,\r\n            0.9105221370785028,\r\n            -0.9295691721319396,\r\n            0.9295691721319396,\r\n            -0.9464113748584028,\r\n            0.9464113748584028,\r\n            -0.9610087996520538,\r\n            0.9610087996520538,\r\n            -0.973326827789911,\r\n            0.973326827789911,\r\n            -0.983336253884626,\r\n            0.983336253884626,\r\n            -0.9910133714767443,\r\n            0.9910133714767443,\r\n            -0.9963401167719553,\r\n            0.9963401167719553,\r\n            -0.9993050417357722,\r\n            0.9993050417357722\r\n        ]\r\n    }\r\n};\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-gauss-quadrature/node/index.js?')},"./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "getSmallestIndxYThenX": () => (/* binding */ getSmallestIndxYThenX)\n/* harmony export */ });\n/**\r\n * @internal\r\n */\r\nfunction getSmallestIndxYThenX(ps) {\r\n    let smallest = [\r\n        Number.POSITIVE_INFINITY,\r\n        Number.POSITIVE_INFINITY\r\n    ];\r\n    let smallestI = undefined;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let y = ps[i][1];\r\n        if ((y < smallest[1]) ||\r\n            (y === smallest[1] && ps[i][0] < smallest[0])) {\r\n            smallestI = i;\r\n            smallest = ps[i];\r\n        }\r\n    }\r\n    return smallestI;\r\n}\r\n\r\n//# sourceMappingURL=get-smallest-indx-y-then-x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js?')},"./node_modules/flo-graham-scan/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "grahamScan": () => (/* binding */ grahamScan)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _get_smallest_indx_y_then_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-smallest-indx-y-then-x.js */ "./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js");\n/* harmony import */ var _swap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./swap.js */ "./node_modules/flo-graham-scan/node/swap.js");\n\r\n\r\n\r\n/**\r\n * Finds the convex hull of the given set of 2d points using the\r\n * Graham Scan algorithm and returns the hull as an array of points.\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n *\r\n * Robust: This algorithm is robust via adaptive infinite precision floating\r\n * point arithmetic.\r\n *\r\n * @param ps A set of points\r\n * @param includeAllBoundaryPoints Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to `false`\r\n */\r\nfunction grahamScan(ps, includeAllBoundaryPoints = false) {\r\n    if (!ps.length) {\r\n        return undefined;\r\n    }\r\n    function fail(p1, p2, p3) {\r\n        let res = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(p1, p2, p3);\r\n        return includeAllBoundaryPoints\r\n            ? res < 0\r\n            : res <= 0;\r\n    }\r\n    let ps_ = ps.slice();\r\n    let n = ps_.length;\r\n    let idx = (0,_get_smallest_indx_y_then_x_js__WEBPACK_IMPORTED_MODULE_1__.getSmallestIndxYThenX)(ps_);\r\n    let [p] = ps_.splice(idx, 1);\r\n    ps_.sort((a, b) => {\r\n        let res = -(0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(p, a, b);\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        res = a[1] - b[1];\r\n        if (res !== 0) {\r\n            return res;\r\n        }\r\n        return a[0] - b[0];\r\n    });\r\n    ps_.unshift(p);\r\n    let m = 1;\r\n    for (let i = 2; i < n; i++) {\r\n        while (fail(ps_[m - 1], ps_[m], ps_[i])) {\r\n            if (m > 1) {\r\n                m -= 1;\r\n                continue;\r\n            }\r\n            else if (i === n - 1) {\r\n                m -= 1;\r\n                break;\r\n            }\r\n            else {\r\n                i += 1;\r\n            }\r\n        }\r\n        m += 1;\r\n        (0,_swap_js__WEBPACK_IMPORTED_MODULE_2__.swap)(ps_, m, i);\r\n    }\r\n    return ps_.slice(0, m + 1);\r\n}\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-graham-scan/node/index.js?')},"./node_modules/flo-graham-scan/node/swap.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "swap": () => (/* binding */ swap)\n/* harmony export */ });\n/**\r\n * In-place swap two elements in the given array.\r\n *\r\n * @internal\r\n */\r\nfunction swap(arr, a, b) {\r\n    if (a === b) {\r\n        return;\r\n    }\r\n    let temp = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = temp;\r\n}\r\n\r\n//# sourceMappingURL=swap.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-graham-scan/node/swap.js?')},"./node_modules/flo-ll-rb-tree/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BLACK": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.BLACK),\n/* harmony export */   "LEFT": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.LEFT),\n/* harmony export */   "LlRbTree": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.LlRbTree),\n/* harmony export */   "Node": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   "RED": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.RED),\n/* harmony export */   "RIGHT": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.RIGHT),\n/* harmony export */   "isRed": () => (/* reexport safe */ _tree_js__WEBPACK_IMPORTED_MODULE_0__.isRed),\n/* harmony export */   "nodeToStr": () => (/* reexport safe */ _node_to_str_js__WEBPACK_IMPORTED_MODULE_2__.nodeToStr),\n/* harmony export */   "numberNodeToStr": () => (/* reexport safe */ _number_node_to_str_js__WEBPACK_IMPORTED_MODULE_1__.numberNodeToStr),\n/* harmony export */   "treeToStr": () => (/* reexport safe */ _tree_to_string_js__WEBPACK_IMPORTED_MODULE_3__.treeToStr)\n/* harmony export */ });\n/* harmony import */ var _tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.js */ "./node_modules/flo-ll-rb-tree/node/tree.js");\n/* harmony import */ var _number_node_to_str_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number-node-to-str.js */ "./node_modules/flo-ll-rb-tree/node/number-node-to-str.js");\n/* harmony import */ var _node_to_str_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node-to-str.js */ "./node_modules/flo-ll-rb-tree/node/node-to-str.js");\n/* harmony import */ var _tree_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tree-to-string.js */ "./node_modules/flo-ll-rb-tree/node/tree-to-string.js");\n\r\n\r\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-ll-rb-tree/node/index.js?')},"./node_modules/flo-ll-rb-tree/node/node-to-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"nodeToStr\": () => (/* binding */ nodeToStr)\n/* harmony export */ });\n/* harmony import */ var _tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.js */ \"./node_modules/flo-ll-rb-tree/node/tree.js\");\n\r\nfunction nodeToStr(valToStr) {\r\n    return (node) => {\r\n        let str;\r\n        if (node.extras !== undefined) {\r\n            str = `{${[node.datum, ...(node.extras)].map(valToStr)}}`;\r\n        }\r\n        else {\r\n            str = valToStr(node.datum);\r\n        }\r\n        return str + ((0,_tree_js__WEBPACK_IMPORTED_MODULE_0__.isRed)(node) ? '•' : '·');\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=node-to-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-ll-rb-tree/node/node-to-str.js?")},"./node_modules/flo-ll-rb-tree/node/number-node-to-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "numberNodeToStr": () => (/* binding */ numberNodeToStr)\n/* harmony export */ });\n/* harmony import */ var _node_to_str_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node-to-str.js */ "./node_modules/flo-ll-rb-tree/node/node-to-str.js");\n\r\nconst numberNodeToStr = (0,_node_to_str_js__WEBPACK_IMPORTED_MODULE_0__.nodeToStr)(t => t.toString());\r\n\r\n//# sourceMappingURL=number-node-to-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-ll-rb-tree/node/number-node-to-str.js?')},"./node_modules/flo-ll-rb-tree/node/tree-to-string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"treeToStr\": () => (/* binding */ treeToStr)\n/* harmony export */ });\n/* harmony import */ var _tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.js */ \"./node_modules/flo-ll-rb-tree/node/tree.js\");\n// Modified from https://www.geeksforgeeks.org/binary-tree-string-brackets/\r\n\r\n/**\r\n * Function to construct string from binary tree\r\n */\r\nfunction treeToStr(nodeToStrFunc) {\r\n    return (tree) => {\r\n        const root = tree.root;\r\n        let treeStr = '';\r\n        f(root);\r\n        return treeStr;\r\n        function f(node) {\r\n            if (node === undefined) {\r\n                return;\r\n            }\r\n            treeStr += nodeToStrFunc(node);\r\n            // if leaf node, then return\r\n            if (node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.LEFT] === undefined && node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.RIGHT] == undefined) {\r\n                return;\r\n            }\r\n            // left subtree\r\n            if (node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.LEFT] !== undefined) {\r\n                treeStr += '(';\r\n                f(node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.LEFT]);\r\n                treeStr += ')';\r\n            }\r\n            // right subtree\r\n            if (node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.RIGHT] !== undefined) {\r\n                treeStr += '[';\r\n                f(node[_tree_js__WEBPACK_IMPORTED_MODULE_0__.RIGHT]);\r\n                treeStr += ']';\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=tree-to-string.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-ll-rb-tree/node/tree-to-string.js?")},"./node_modules/flo-ll-rb-tree/node/tree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BLACK": () => (/* binding */ BLACK),\n/* harmony export */   "LEFT": () => (/* binding */ LEFT),\n/* harmony export */   "LlRbTree": () => (/* binding */ LlRbTree),\n/* harmony export */   "Node": () => (/* binding */ Node),\n/* harmony export */   "RED": () => (/* binding */ RED),\n/* harmony export */   "RIGHT": () => (/* binding */ RIGHT),\n/* harmony export */   "isRed": () => (/* binding */ isRed)\n/* harmony export */ });\n// Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n// See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n// See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n// See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html \r\nconst LEFT = -1;\r\nconst RIGHT = 1;\r\nconst BLACK = 1;\r\nconst RED = 0;\r\n/**\r\n * Red Black Tree node.\r\n */\r\nclass Node {\r\n    constructor(datum) {\r\n        this.datum = datum;\r\n        this.color = RED;\r\n    }\r\n}\r\nfunction isRed(node) {\r\n    return !!node && node.color === RED;\r\n}\r\nclass LlRbTree {\r\n    /**\r\n     * @param compare a comparator function\r\n     * @param duplicatesAllowed defaults to `true`; if `false` then if a\r\n     * duplicate is inserted (as per the equivalence relation induced by the\r\n     * compare function) then replace it; if `true` then instead still insert\r\n     * it (so there can be multiple nodes with the same value in the tree)\r\n     * @param data an optional initial array of data\r\n     */\r\n    constructor(compare, duplicatesAllowed = true, data) {\r\n        this.compare = compare;\r\n        this.duplicatesAllowed = duplicatesAllowed;\r\n        this.getMinNode = this.getMinOrMaxNode(LEFT);\r\n        this.getMaxNode = this.getMinOrMaxNode(RIGHT);\r\n        this.root = undefined;\r\n        this.nodeCount = 0;\r\n        this.valueCount = 0;\r\n        if (!data) {\r\n            return;\r\n        }\r\n        for (const datum of data) {\r\n            this.insert(datum);\r\n        }\r\n    }\r\n    isEmpty() { return !this.root; }\r\n    /**\r\n     * Find and returns the (first) node in the tree with the given datum using\r\n     * the tree compare function. Returns `undefined` if the node was not found.\r\n     */\r\n    find(datum) {\r\n        const tree = this;\r\n        let node = this.root;\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c === 0) {\r\n                return node;\r\n            }\r\n            node = node[c > 0 ? RIGHT : LEFT];\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns an ordered (by the tree compare function) array of data as\r\n     * contained in the nodes of the tree by doing an in order traversal.\r\n     */\r\n    toArrayInOrder() {\r\n        const values = [];\r\n        f(this.root);\r\n        function f(node) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            f(node[LEFT]);\r\n            values.push(node.datum);\r\n            if (node.extras !== undefined) {\r\n                values.push(...node.extras);\r\n            }\r\n            f(node[RIGHT]);\r\n        }\r\n        return values;\r\n    }\r\n    insertMulti(data) {\r\n        const tree = this;\r\n        for (let datum of data) {\r\n            tree.insert(datum);\r\n        }\r\n    }\r\n    /**\r\n     * Inserts a node with the given datum into the tree.\r\n     */\r\n    insert(datum) {\r\n        const tree = this;\r\n        tree.root = f(tree.root, datum);\r\n        tree.root.color = BLACK;\r\n        tree.root.parent = undefined;\r\n        function f(h, datum) {\r\n            if (h === undefined) {\r\n                tree.valueCount++;\r\n                tree.nodeCount++;\r\n                return new Node(datum);\r\n            }\r\n            let c = tree.compare(datum, h.datum);\r\n            if (c === 0) {\r\n                if (tree.duplicatesAllowed) {\r\n                    tree.valueCount++;\r\n                    if (h.extras === undefined) {\r\n                        h.extras = [datum];\r\n                    }\r\n                    else {\r\n                        h.extras.push(datum);\r\n                    }\r\n                }\r\n                else {\r\n                    h.datum = datum; // replace old value\r\n                }\r\n            }\r\n            if (c !== 0) {\r\n                const dir = c > 0 ? RIGHT : LEFT;\r\n                h[dir] = f(h[dir], datum);\r\n                h[dir].parent = h;\r\n            }\r\n            if (isRed(h[RIGHT]) && !isRed(h[LEFT])) {\r\n                h = rotate(LEFT, h);\r\n            }\r\n            if (isRed(h[LEFT]) && isRed(h[LEFT][LEFT])) {\r\n                h = rotate(RIGHT, h);\r\n            }\r\n            if (isRed(h[LEFT]) && isRed(h[RIGHT])) {\r\n                flipColors(h);\r\n            }\r\n            return h;\r\n        }\r\n    }\r\n    /**\r\n     * Removes an item from the tree based on the given datum and returns the\r\n     * item that was removed or `undefined` if nothing was removed.\r\n     *\r\n     * @param datum\r\n     * @param all defaults to `false`; if `true` and duplicates exist, remove all\r\n     * @param compareStrict if provided then only delete an item if it passes the\r\n     * strict comparison function, i.e. if `compareStrict(item,node_value) === true`.\r\n     */\r\n    remove(datum, all = false, compareStrict) {\r\n        const tree = this;\r\n        if (tree.root === undefined) {\r\n            return undefined;\r\n        }\r\n        let removed = undefined;\r\n        const root = f(tree.root, datum);\r\n        if (root === null) {\r\n            return undefined;\r\n        }\r\n        tree.root = root;\r\n        if (tree.root !== undefined) {\r\n            tree.root.color = BLACK;\r\n            tree.root.parent = undefined;\r\n        }\r\n        return removed;\r\n        function f(h, datum) {\r\n            const theresExtras = tree.duplicatesAllowed && h.extras !== undefined;\r\n            let c = tree.compare(datum, h.datum);\r\n            if ((c < 0 && !h[LEFT]) || (c > 0 && !h[RIGHT])) {\r\n                return h; // end reached - no match\r\n            }\r\n            if (c < 0) {\r\n                if (!isRed(h[LEFT]) &&\r\n                    !isRed(h[LEFT][LEFT])) {\r\n                    h = moveRedLeft(h);\r\n                }\r\n                const g = f(h[LEFT], datum);\r\n                if (g === null) {\r\n                    return null;\r\n                }\r\n                h[LEFT] = g;\r\n                if (h[LEFT]) {\r\n                    h[LEFT].parent = h;\r\n                }\r\n                return fixUp(h);\r\n            }\r\n            if (isRed(h[LEFT])) {\r\n                h = rotate(RIGHT, h);\r\n                c = tree.compare(datum, h.datum);\r\n            }\r\n            if (c === 0 && !h[RIGHT]) {\r\n                if (theresExtras && !all) {\r\n                    // There are multiple items at this node.\r\n                    if (compareStrict === undefined || compareStrict(datum, h.datum)) {\r\n                        removed = h.datum;\r\n                        h.datum = h.extras.pop();\r\n                        tree.valueCount--;\r\n                        if (h.extras.length === 0) {\r\n                            h.extras = undefined;\r\n                        }\r\n                        return h;\r\n                    }\r\n                    else {\r\n                        const extras = h.extras;\r\n                        for (let i = 0; i < extras.length; i++) {\r\n                            if (compareStrict(datum, extras[i])) {\r\n                                removed = extras.splice(i, 1)[0];\r\n                                tree.valueCount--;\r\n                                if (extras.length === 0) {\r\n                                    h.extras = undefined;\r\n                                }\r\n                                return h;\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n                }\r\n                if (compareStrict === undefined || compareStrict(datum, h.datum)) {\r\n                    removed = h.datum;\r\n                    tree.valueCount -= 1 + (theresExtras ? h.extras.length : 0);\r\n                    tree.nodeCount--;\r\n                    return undefined;\r\n                }\r\n                else {\r\n                    return null; // no match\r\n                }\r\n            }\r\n            if (!isRed(h[RIGHT]) &&\r\n                !isRed(h[RIGHT][LEFT])) {\r\n                h = moveRedRight(h);\r\n                c = tree.compare(datum, h.datum);\r\n            }\r\n            if (c === 0) {\r\n                if (theresExtras && !all) {\r\n                    // There are multiple items at this node.\r\n                    if (compareStrict === undefined || compareStrict(datum, h.datum)) {\r\n                        removed = h.datum;\r\n                        h.datum = h.extras.pop();\r\n                        tree.valueCount--;\r\n                        if (h.extras.length === 0) {\r\n                            h.extras = undefined;\r\n                        }\r\n                        //// const g = f(h[RIGHT]!, datum);\r\n                        // if (g === null) { return null; }\r\n                        //// h[RIGHT] = g!;\r\n                    }\r\n                    else {\r\n                        const extras = h.extras;\r\n                        let found = false;\r\n                        for (let i = 0; i < extras.length; i++) {\r\n                            if (compareStrict(datum, extras[i])) {\r\n                                removed = extras.splice(i, 1)[0];\r\n                                tree.valueCount--;\r\n                                if (extras.length === 0) {\r\n                                    h.extras = undefined;\r\n                                }\r\n                                //// const g = f(h[RIGHT]!, extras[i]);\r\n                                // if (g === null) { return null; }\r\n                                //// h[RIGHT] = g!;\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (compareStrict === undefined || compareStrict(datum, h.datum)) {\r\n                        tree.valueCount -= 1 + (theresExtras ? h.extras.length : 0);\r\n                        removed = h.datum;\r\n                        const minNode = tree.getMinNode(h[RIGHT]);\r\n                        h.datum = minNode?.datum;\r\n                        if (tree.duplicatesAllowed) {\r\n                            h.extras = minNode?.extras;\r\n                        }\r\n                        h[RIGHT] = removeMin(h[RIGHT]);\r\n                        tree.nodeCount--;\r\n                    }\r\n                    else {\r\n                        return null; // no match\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const g = f(h[RIGHT], datum);\r\n                if (g === null) {\r\n                    return null;\r\n                }\r\n                h[RIGHT] = g;\r\n            }\r\n            if (h[RIGHT]) {\r\n                h[RIGHT].parent = h;\r\n            }\r\n            return fixUp(h);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the two ordered nodes bounding the datum.\r\n     *\r\n     * * If the datum falls on a node, that node and the next (to the right) is\r\n     * returned.\r\n     * * If the given datum is smaller than all nodes then the first item in the\r\n     * bounds array is `undefined` and the next is the smallest node\r\n     * * If the given datum is larger than all nodes then the second item in the\r\n     * bounds array is `undefined` and the first item is the largest node\r\n     *\r\n     */\r\n    findBounds(datum) {\r\n        const tree = this;\r\n        let node = tree.root;\r\n        const bounds = [undefined, undefined];\r\n        if (node === undefined) {\r\n            return bounds;\r\n        }\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c >= 0) {\r\n                bounds[0] = node;\r\n            }\r\n            else {\r\n                bounds[1] = node;\r\n            }\r\n            node = node[c >= 0 ? RIGHT : LEFT];\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns the two ordered nodes bounding the datum.\r\n     *\r\n     * * If the datum falls on a node, returns the nodes before and after this\r\n     * one.\r\n     * * If the given datum is smaller than all nodes then the first item in the\r\n     * bounds array is `undefined` and the next is the smallest node\r\n     * * If the given datum is larger than all nodes then the second item in the\r\n     * bounds array is `undefined` and the first item is the largest node\r\n     *\r\n     * @param tree\r\n     * @param datum\r\n     */\r\n    findBoundsExcl(datum) {\r\n        const tree = this;\r\n        const node = tree.root;\r\n        const bounds = [undefined, undefined];\r\n        if (node === undefined) {\r\n            return bounds;\r\n        }\r\n        f(node);\r\n        function f(node) {\r\n            while (node) {\r\n                const c = tree.compare(datum, node.datum);\r\n                if (c === 0) {\r\n                    // Search on both sides\r\n                    f(node[LEFT]);\r\n                    f(node[RIGHT]);\r\n                    return;\r\n                }\r\n                if (c > 0) {\r\n                    bounds[0] = node;\r\n                }\r\n                else if (c < 0) {\r\n                    bounds[1] = node;\r\n                }\r\n                node = node[c > 0 ? RIGHT : LEFT];\r\n            }\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns an array of all matching data found.\r\n     *\r\n     * If duplicates are not allowed it\'s better to just use `find`.\r\n     *\r\n     * @param datum\r\n     */\r\n    findAll(datum) {\r\n        const tree = this;\r\n        let node = this.root;\r\n        while (node) {\r\n            const c = tree.compare(datum, node.datum);\r\n            if (c === 0) {\r\n                return [\r\n                    node.datum,\r\n                    ...(node.extras ? node.extras : [])\r\n                ];\r\n            }\r\n            node = node[c > 0 ? RIGHT : LEFT];\r\n        }\r\n        return [];\r\n    }\r\n    /** @internal */\r\n    getMinOrMaxNode(dir) {\r\n        return (node) => {\r\n            if (node === undefined) {\r\n                node = this.root;\r\n            }\r\n            ;\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            while (node[dir]) {\r\n                node = node[dir];\r\n            }\r\n            return node;\r\n        };\r\n    }\r\n    /**\r\n     * Returns the minimum value in the tree starting at the given node. If the\r\n     * tree is empty, `undefined` will be returned.\r\n     *\r\n     * If the min value is required for the entire tree call this function\r\n     * as `tree.min(tree.root)`\r\n     *\r\n     * @param node\r\n     */\r\n    min(node) {\r\n        if (node === undefined) {\r\n            node = this.root;\r\n        }\r\n        ;\r\n        const minNode = this.getMinNode(node);\r\n        if (minNode !== undefined) {\r\n            return minNode.datum;\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns the maximum value in the tree starting at the given node. If the\r\n     * tree is empty, `undefined` will be returned.\r\n     *\r\n     * If the max value is required for the entire tree call this function\r\n     * as `tree.max(tree.root)`\r\n     *\r\n     * @param node\r\n     */\r\n    max(node) {\r\n        if (node === undefined) {\r\n            node = this.root;\r\n        }\r\n        ;\r\n        const maxNode = this.getMaxNode(node);\r\n        if (maxNode !== undefined) {\r\n            return maxNode.datum;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * Returns the node that is at the top after the rotation.\r\n *\r\n * Destructively rotates the given node, say h, in the\r\n * given direction as far as tree rotations go.\r\n *\r\n * @param dir\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction rotate(dir, h) {\r\n    const x = h[-dir];\r\n    h[-dir] = x[dir];\r\n    if (x[dir]) {\r\n        x[dir].parent = h;\r\n    }\r\n    x[dir] = h;\r\n    h.parent = x;\r\n    x.color = h.color;\r\n    h.color = RED;\r\n    return x;\r\n}\r\n/**\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction removeMin(h) {\r\n    if (!h[LEFT]) {\r\n        return undefined;\r\n    }\r\n    if (!isRed(h[LEFT]) &&\r\n        !isRed(h[LEFT][LEFT])) {\r\n        h = moveRedLeft(h);\r\n    }\r\n    h[LEFT] = removeMin(h[LEFT]);\r\n    if (h[LEFT]) {\r\n        h[LEFT].parent = h;\r\n    }\r\n    return fixUp(h);\r\n}\r\n/**\r\n * Destructively flips the color of the given node and both\r\n * it\'s childrens\' colors.\r\n *\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction flipColors(h) {\r\n    h.color = (h.color + 1) % 2;\r\n    h[LEFT].color = (h[LEFT].color + 1) % 2;\r\n    h[RIGHT].color = (h[RIGHT].color + 1) % 2;\r\n}\r\n/**\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction moveRedLeft(h) {\r\n    flipColors(h);\r\n    if (isRed(h[RIGHT][LEFT])) {\r\n        const a = rotate(RIGHT, h[RIGHT]);\r\n        h[RIGHT] = a;\r\n        a.parent = h;\r\n        h = rotate(LEFT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * Returns the node that is at the top after the move.\r\n *\r\n * @param h\r\n *\r\n * @internal\r\n */\r\nfunction moveRedRight(h) {\r\n    flipColors(h);\r\n    if (isRed(h[LEFT][LEFT])) {\r\n        h = rotate(RIGHT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * Returns the node that is at the top after the fix.\r\n *\r\n * Fix right-leaning red nodes.\r\n *\r\n * @internal\r\n */\r\nfunction fixUp(h) {\r\n    if (isRed(h[RIGHT])) {\r\n        h = rotate(LEFT, h);\r\n    }\r\n    if (isRed(h[LEFT]) && isRed(h[LEFT][LEFT])) {\r\n        h = rotate(RIGHT, h);\r\n    }\r\n    // Split 4-nodes.\r\n    if (isRed(h[LEFT]) && isRed(h[RIGHT])) {\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n\r\n//# sourceMappingURL=tree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-ll-rb-tree/node/tree.js?')},"./node_modules/flo-memoize/node/cache.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cache": () => (/* binding */ cache)\n/* harmony export */ });\n/**\r\n * Returns the same result for the same paramters (where the parameters are\r\n * considered the same if they have the same length and contain the same\r\n * ordered elements when elements are compared with `===` (e.g. objects are\r\n * compared *by reference*).\r\n *\r\n * @param f\r\n */\r\nfunction cache(f) {\r\n    let prevParams = undefined;\r\n    let prevResult = undefined;\r\n    return function (...params) {\r\n        if (prevParams === undefined) {\r\n            prevParams = params;\r\n            prevResult = f(...params);\r\n            return prevResult;\r\n        }\r\n        for (let i = 0; i < params.length; i++) {\r\n            const param = params[i];\r\n            if (param !== prevParams[i]) {\r\n                prevParams = params;\r\n                prevResult = f(...params);\r\n                return prevResult;\r\n            }\r\n        }\r\n        return prevResult;\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=cache.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-memoize/node/cache.js?')},"./node_modules/flo-memoize/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cache\": () => (/* reexport safe */ _cache_js__WEBPACK_IMPORTED_MODULE_1__.cache),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"memoize2\": () => (/* binding */ memoize2)\n/* harmony export */ });\n/* harmony import */ var _pair_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair-map.js */ \"./node_modules/flo-memoize/node/pair-map.js\");\n/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache.js */ \"./node_modules/flo-memoize/node/cache.js\");\n\r\n\r\nconst SUPPORTED = typeof WeakMap === 'function';\r\n/**\r\n * Memoize (by reference on the input parameter) the given arity 1 function.\r\n */\r\nfunction memoize(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a) {\r\n        let result = results.get(a);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a);\r\n        results.set(a, result);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Memoize (by reference on the ordered input parameters) the given arity 2 function.\r\n */\r\nfunction memoize2(f) {\r\n    if (!SUPPORTED) {\r\n        return f;\r\n    }\r\n    let results = new WeakMap();\r\n    return function (a, b) {\r\n        let result = (0,_pair_map_js__WEBPACK_IMPORTED_MODULE_0__.pairMap_get)(results, a, b);\r\n        if (result !== undefined) {\r\n            //console.log('cache hit');\r\n            return result;\r\n        }\r\n        //console.log('cache miss');\r\n        result = f(a, b);\r\n        (0,_pair_map_js__WEBPACK_IMPORTED_MODULE_0__.pairMap_set)(results, a, b, result);\r\n        return result;\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-memoize/node/index.js?")},"./node_modules/flo-memoize/node/pair-map.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "pairMap_get": () => (/* binding */ pairMap_get),\n/* harmony export */   "pairMap_set": () => (/* binding */ pairMap_set)\n/* harmony export */ });\n/**\r\n * Adds an ordered pair of values to the map.\r\n *\r\n * @param map The map representing the pairs.\r\n * @param v1\r\n * @param v2\r\n * @param v3\r\n */\r\nfunction pairMap_set(map, v1, v2, v3) {\r\n    let v1Map = map.get(v1);\r\n    if (!v1Map) {\r\n        v1Map = new Map();\r\n        map.set(v1, v1Map);\r\n    }\r\n    v1Map.set(v2, v3);\r\n}\r\n/**\r\n * Returns true if the unordered pair is in the set of pairs (represented by a\r\n * map).\r\n *\r\n * @param map The map representing the pairs.\r\n * @param v1\r\n * @param v2\r\n */\r\nfunction pairMap_get(map, v1, v2) {\r\n    let v1Map = map.get(v1);\r\n    if (!v1Map) {\r\n        return undefined;\r\n    }\r\n    return v1Map.get(v2);\r\n}\r\n\r\n//# sourceMappingURL=pair-map.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-memoize/node/pair-map.js?')},"./node_modules/flo-poly/node/basic/bigint/b-abs-coeff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bAbsCoeff": () => (/* binding */ bAbsCoeff)\n/* harmony export */ });\n/**\r\n * Returns the polynomial with all coeffients the absolute value of the given\r\n * polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bAbsCoeff(p) {\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        const v = p[i];\r\n        p_.push(v < 0n ? -v : v);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=b-abs-coeff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-abs-coeff.js?')},"./node_modules/flo-poly/node/basic/bigint/b-add.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bAdd": () => (/* binding */ bAdd)\n/* harmony export */ });\n/* harmony import */ var _b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bRemoveLeadingZeros = _b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.bRemoveLeadingZeros;\r\n/**\r\n * Returns the result of adding two polynomials with bigint coefficients.\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial\r\n *\r\n * @example\r\n * ```typescript\r\n * bAdd([1n,2n,3n],[3n,4n]); //=> [1n,5n,7n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bAdd(p1, p2) {\r\n    // Initialize result array  \r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    const Δd = d1 - d2;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = p1[i + Δd1] || 0n;\r\n        const c2 = p2[i + Δd2] || 0n;\r\n        result.push(c1 + c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return bRemoveLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=b-add.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-add.js?')},"./node_modules/flo-poly/node/basic/bigint/b-degree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bDegree": () => (/* binding */ bDegree)\n/* harmony export */ });\n/**\r\n * Returns the degree of the given polynomial - the zero polynomial degree is\r\n * returned as -1 (and not -∞ as is conventional).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of bigints\r\n * from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bDegree([9n,8n,7n,6n,5n,4n,3n,2n,1n]); //=> 8\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bDegree(p) {\r\n    return p.length - 1;\r\n}\r\n\r\n//# sourceMappingURL=b-degree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-degree.js?')},"./node_modules/flo-poly/node/basic/bigint/b-divide-by-const.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bDivideByConst": () => (/* binding */ bDivideByConst)\n/* harmony export */ });\n/**\r\n * Divides (using **integer division**) a polynomial by a constant.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param c a constant\r\n *\r\n * @doc\r\n */\r\nfunction bDivideByConst(p, c) {\r\n    const d = p.length;\r\n    const r = [];\r\n    for (let i = 0; i < d; i++) {\r\n        r.push(p[i] / c);\r\n    }\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=b-divide-by-const.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-divide-by-const.js?')},"./node_modules/flo-poly/node/basic/bigint/b-equal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bEqual": () => (/* binding */ bEqual)\n/* harmony export */ });\n/**\r\n * Returns true if two polynomials are exactly equal by comparing coefficients,\r\n * false otherwise.\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b another polynomial\r\n *\r\n * @example\r\n * ```typescript\r\n * bEqual([1n,2n,3n,4n], [1n,2n,3n,4n]);   //=> true\r\n * bEqual([1n,2n,3n,4n], [1n,2n,3n,4n,5n]); //=> false\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bEqual(a, b) {\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (a[i] !== b[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=b-equal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-equal.js?')},"./node_modules/flo-poly/node/basic/bigint/b-invert.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bInvert": () => (/* binding */ bInvert)\n/* harmony export */ });\n/**\r\n * Inverts the given polynomial by reversing the order of the coefficients,\r\n * i.e. p(x) -> x^deg(p) * p(1/x)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bInvert([3n,2n,-5n]);  // => [-5n,2n,3n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bInvert(p) {\r\n    return p.slice().reverse();\r\n}\r\n\r\n//# sourceMappingURL=b-invert.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-invert.js?')},"./node_modules/flo-poly/node/basic/bigint/b-is-rational-multiple-of.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bIsRationalMultipleOf": () => (/* binding */ bIsRationalMultipleOf)\n/* harmony export */ });\n/* harmony import */ var _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gcd/bigint/b-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js");\n\r\n/**\r\n * Returns true if either polynomial is an exact rational multiple of the other.\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b another polynomial\r\n *\r\n * @doc\r\n */\r\nfunction bIsRationalMultipleOf(a, b) {\r\n    // If either polynomial is zero\r\n    if (a.length === 0 || b.length === 0) {\r\n        return true;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    // multiply by -1 if appropriate to make the leading coefficients positive\r\n    const a_ = a[0] < 0n ? a.map(c => -c) : a;\r\n    const b_ = b[0] < 0n ? b.map(c => -c) : b;\r\n    /** leading coefficient of a */\r\n    const lcA = a_[0];\r\n    /** leading coefficient of b */\r\n    const lcB = b_[0];\r\n    const gcd = (0,_gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__.bGcdInt)(lcA, lcB);\r\n    const A = lcA / gcd; // this division is exact\r\n    const B = lcB / gcd; // this division is exact\r\n    for (let i = 0; i < a_.length; i++) {\r\n        const Ab = A * b_[i];\r\n        if (Ab % B !== 0n) {\r\n            return false;\r\n        }\r\n        if (Ab / B !== a_[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=b-is-rational-multiple-of.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-is-rational-multiple-of.js?')},"./node_modules/flo-poly/node/basic/bigint/b-multiply-by-const.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bMultiplyByConst": () => (/* binding */ bMultiplyByConst)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplies a polynomial (with bigint coefficients) by\r\n * a constant.\r\n *\r\n * @param c a constant\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bMultiplyByConst(c, p) {\r\n    if (c === 0n) {\r\n        return [];\r\n    }\r\n    const d = p.length;\r\n    const r = [];\r\n    for (let i = 0; i < d; i++) {\r\n        r.push(c * p[i]);\r\n    }\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=b-multiply-by-const.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-multiply-by-const.js?')},"./node_modules/flo-poly/node/basic/bigint/b-multiply.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bMultiply": () => (/* binding */ bMultiply)\n/* harmony export */ });\n/**\r\n * Returns the result of multiplying 2 polynomials with bigint coefficients.\r\n *\r\n * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)\r\n * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)\r\n * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param b another polynomial.\r\n *\r\n * @example\r\n * ```typescript\r\n * bMultiply([1n,2n,3n], [2n,5n,3n,5n]); //=> [2n, 9n, 19n, 26n, 19n, 15n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bMultiply(a, b) {\r\n    const da = a.length - 1;\r\n    const db = b.length - 1;\r\n    // if either or both is the zero polynomial\r\n    if (da < 0 || db < 0) {\r\n        return [];\r\n    }\r\n    const d = da + db;\r\n    const r = new Array(d + 1).fill(0n);\r\n    for (let i = 0; i < da + 1; i++) {\r\n        for (let j = 0; j < db + 1; j++) {\r\n            r[d - (i + j)] += (a[da - i] * b[db - j]);\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=b-multiply.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-multiply.js?')},"./node_modules/flo-poly/node/basic/bigint/b-negate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bNegate": () => (/* binding */ bNegate)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given polynomial (p -> -p).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bNegate([1n, -2n]); //=> [-1n, 2n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bNegate(p) {\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(-p[i]);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=b-negate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-negate.js?')},"./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bRemoveLeadingZeros": () => (/* binding */ bRemoveLeadingZeros)\n/* harmony export */ });\n/**\r\n * If the highest power coefficient of the given polynomial is 0 then\r\n * removeLeadingZeros can be called to remove all such highest terms so that\r\n * the returned array is a valid presentation of a polynomial.\r\n * @param p a polynomial whose leading zeros should be removed\r\n *\r\n * @doc\r\n */\r\nfunction bRemoveLeadingZeros(p) {\r\n    // @ts-nocheck\r\n    let lzCount = 0;\r\n    for (let i = 0; i <= p.length - 1; i++) {\r\n        if (p[i] !== 0n) {\r\n            break;\r\n        }\r\n        lzCount++;\r\n    }\r\n    if (lzCount !== 0) {\r\n        p = p.slice(lzCount);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=b-remove-leading-zeros.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js?')},"./node_modules/flo-poly/node/basic/bigint/b-subtract.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bSubtract": () => (/* binding */ bSubtract)\n/* harmony export */ });\n/* harmony import */ var _b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bRemoveLeadingZeros = _b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.bRemoveLeadingZeros;\r\n/**\r\n * Returns the result of subtracting the second polynomial from the first with\r\n * coefficients given as bigints; (p1 - p2).\r\n *\r\n * @param a minuend; the polynomial from which will be subtracted; a polynomial\r\n * with coefficients given densely as an array of bigints\r\n * from highest to lowest power, e.g. `[5,-3,0]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b subtrahend; the polynomial that will be subtracted\r\n *\r\n * @example\r\n * ```typescript\r\n * bSubtract([2n,3n],[4n,4n]); //=> [-2n, -1n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bSubtract(a, b) {\r\n    // Initialize result array  \r\n    const da = a.length - 1;\r\n    const db = b.length - 1;\r\n    const Δd = da - db;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const d = Math.max(da, db);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = a[i + Δd1] || 0n;\r\n        const c2 = b[i + Δd2] || 0n;\r\n        result.push(c1 - c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return bRemoveLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=b-subtract.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/bigint/b-subtract.js?')},"./node_modules/flo-poly/node/basic/double/abs-coeff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "absCoeff": () => (/* binding */ absCoeff)\n/* harmony export */ });\n/**\r\n * Returns the polynomial with all coeffients the absolute value of the given\r\n * polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction absCoeff(p) {\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(Math.abs(p[i]));\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=abs-coeff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/abs-coeff.js?')},"./node_modules/flo-poly/node/basic/double/add.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "add": () => (/* binding */ add)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\r\n/**\r\n * Returns the result of adding two polynomials in double precision.\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial\r\n *\r\n * @example\r\n * ```typescript\r\n * add([1,2,3],[3,4]); //=> [1,5,7]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction add(p1, p2) {\r\n    // Initialize result array  \r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    const Δd = d1 - d2;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = p1[i + Δd1] || 0;\r\n        const c2 = p2[i + Δd2] || 0;\r\n        result.push(c1 + c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return removeLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=add.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/add.js?')},"./node_modules/flo-poly/node/basic/double/degree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "degree": () => (/* binding */ degree)\n/* harmony export */ });\n/**\r\n * Returns the degree of the given polynomial - the zero polynomial degree is\r\n * returned as -1 (and not -∞ as is conventional).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * degree([9,8,7,6,5,4,3,2,1]); //=> 8\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction degree(p) {\r\n    return p.length - 1;\r\n}\r\n\r\n//# sourceMappingURL=degree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/degree.js?')},"./node_modules/flo-poly/node/basic/double/divide-by-const.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "divideByConst": () => (/* binding */ divideByConst)\n/* harmony export */ });\n/**\r\n * Divides a polynomial by a constant in double precision.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param c a constant\r\n *\r\n * @doc\r\n */\r\nfunction divideByConst(p, c) {\r\n    const d = p.length;\r\n    const r = [];\r\n    for (let i = 0; i < d; i++) {\r\n        r.push(p[i] / c);\r\n    }\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=divide-by-const.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/divide-by-const.js?')},"./node_modules/flo-poly/node/basic/double/equal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "equal": () => (/* binding */ equal)\n/* harmony export */ });\n/**\r\n * Returns true if two polynomials are exactly equal by comparing coefficients,\r\n * false otherwise.\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial\r\n * @example\r\n * ```typescript\r\n * equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n * equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction equal(p1, p2) {\r\n    if (p1.length !== p2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < p1.length; i++) {\r\n        if (p1[i] !== p2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/equal.js?')},"./node_modules/flo-poly/node/basic/double/invert.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "invert": () => (/* binding */ invert)\n/* harmony export */ });\n/**\r\n * Inverts the given polynomial by reversing the order of the coefficients,\r\n * i.e. p(x) -> x^deg(p) * p(1/x)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * invert([3,2,-5]);  // => [-5,2,3]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction invert(p) {\r\n    return p.slice().reverse();\r\n}\r\n\r\n//# sourceMappingURL=invert.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/invert.js?')},"./node_modules/flo-poly/node/basic/double/is-rational-multiple-of.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "isRationalMultipleOf": () => (/* binding */ isRationalMultipleOf)\n/* harmony export */ });\n/* harmony import */ var _scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scale-to-int/scale-floats-to-ints.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js");\n/* harmony import */ var _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../gcd/double/integer-gcd.js */ "./node_modules/flo-poly/node/gcd/double/integer-gcd.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n/**\r\n * Returns true if either polynomial is an exact rational multiple of the other.\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * double precision floating point numbers from highest to lowest power,\r\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`\r\n * @param b another polynomial\r\n *\r\n * @doc\r\n */\r\nfunction isRationalMultipleOf(a, b) {\r\n    // If either polynomial is zero\r\n    if (a.length === 0 || b.length === 0) {\r\n        return true;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    // multiply by -1 if appropriate to make the leading coefficients positive\r\n    // then scale floating point coefficients to integers\r\n    const a_ = (0,_scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_0__.scaleFloatsToInts)(a[0] < 0 ? a.map(c => -c) : a);\r\n    const b_ = (0,_scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_0__.scaleFloatsToInts)(b[0] < 0 ? b.map(c => -c) : b);\r\n    /** leading coefficient of a */\r\n    const lcA = a_[0];\r\n    /** leading coefficient of b */\r\n    const lcB = b_[0];\r\n    const gcd = (0,_gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_1__.gcdInt)(lcA, lcB);\r\n    const A = lcA / gcd; // this division is exact\r\n    const B = lcB / gcd; // this division is exact\r\n    for (let i = 0; i < a_.length; i++) {\r\n        const Ab = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.twoProduct)(A, b_[i]);\r\n        const { div, rem } = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eLongDivide)(Ab, [B]);\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eSign)(rem) !== 0) {\r\n            return false;\r\n        }\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eCompare)(div, [a_[i]]) !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=is-rational-multiple-of.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/is-rational-multiple-of.js?')},"./node_modules/flo-poly/node/basic/double/multiply-by-const.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "multiplyByConst": () => (/* binding */ multiplyByConst)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\r\n/**\r\n * Returns the result of multiplies a polynomial by a constant in double\r\n * precision.\r\n *\r\n * @param c a constant\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction multiplyByConst(c, p) {\r\n    if (c === 0) {\r\n        return [];\r\n    }\r\n    const d = p.length;\r\n    const p_ = [];\r\n    for (let i = 0; i < d; i++) {\r\n        p_.push(c * p[i]);\r\n    }\r\n    // We *have* to clip due to possible floating point underflow\r\n    return removeLeadingZeros(p_);\r\n}\r\n\r\n//# sourceMappingURL=multiply-by-const.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/multiply-by-const.js?')},"./node_modules/flo-poly/node/basic/double/multiply.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "multiply": () => (/* binding */ multiply)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\r\n/**\r\n * Returns the result of multiplying 2 polynomials in double precision.\r\n *\r\n * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)\r\n * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)\r\n * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial.\r\n * @example\r\n * ```typescript\r\n * multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction multiply(p1, p2) {\r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    // if either or both is the zero polynomial\r\n    if (d1 < 0 || d2 < 0) {\r\n        return [];\r\n    }\r\n    const d = d1 + d2;\r\n    const r = new Array(d + 1).fill(0);\r\n    for (let i = 0; i < d1 + 1; i++) {\r\n        for (let j = 0; j < d2 + 1; j++) {\r\n            r[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);\r\n        }\r\n    }\r\n    return removeLeadingZeros(r);\r\n}\r\n\r\n//# sourceMappingURL=multiply.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/multiply.js?')},"./node_modules/flo-poly/node/basic/double/negate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "negate": () => (/* binding */ negate)\n/* harmony export */ });\n/**\r\n * Returns the negative of the given polynomial (p -> -p).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @example\r\n * ```typescript\r\n * negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction negate(p) {\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(-p[i]);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=negate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/negate.js?')},"./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "removeLeadingZeros": () => (/* binding */ removeLeadingZeros)\n/* harmony export */ });\n/**\r\n * If the highest power coefficient of the given polynomial is 0 then\r\n * removeLeadingZeros can be called to remove all such highest terms so that\r\n * the returned array is a valid presentation of a polynomial.\r\n *\r\n * @param p a polynomial whose leading zeros should be removed\r\n *\r\n * @example\r\n * ```typescript\r\n * removeLeadingZeros([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * removeLeadingZeros([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction removeLeadingZeros(p) {\r\n    let lzCount = 0;\r\n    for (let i = 0; i <= p.length - 1; i++) {\r\n        if (p[i] !== 0) {\r\n            break;\r\n        }\r\n        lzCount++;\r\n    }\r\n    if (lzCount !== 0) {\r\n        p = p.slice(lzCount);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=remove-leading-zeros.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js?')},"./node_modules/flo-poly/node/basic/double/subtract.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "subtract": () => (/* binding */ subtract)\n/* harmony export */ });\n/* harmony import */ var _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst removeLeadingZeros = _remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.removeLeadingZeros;\r\n/**\r\n * Returns the result of subtracting the second polynomial from the first in\r\n * double precision; (p1 - p2).\r\n *\r\n * @param p1 minuend; the polynomial from which will be subtracted; a polynomial\r\n * with coefficients given densely as an array of double floating point numbers\r\n * from highest to lowest power, e.g. `[5,-3,0]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param p2 subtrahend; the polynomial that will be subtracted\r\n *\r\n * @example\r\n * ```typescript\r\n * subtract([2,3],[4,4]); //=> [-2, -1]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction subtract(p1, p2) {\r\n    // Initialize result array  \r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    const Δd = d1 - d2;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = p1[i + Δd1] || 0;\r\n        const c2 = p2[i + Δd2] || 0;\r\n        result.push(c1 - c2);\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return removeLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=subtract.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/double/subtract.js?')},"./node_modules/flo-poly/node/basic/expansion/e-abs-coeff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eAbsCoeff": () => (/* binding */ eAbsCoeff)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eAbs = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs;\r\n/**\r\n * Returns the polynomial with all coeffients the absolute value of the given\r\n * polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eAbsCoeff(p) {\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(eAbs(p[i]));\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=e-abs-coeff.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-abs-coeff.js?')},"./node_modules/flo-poly/node/basic/expansion/e-add.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eAdd": () => (/* binding */ eAdd)\n/* harmony export */ });\n/* harmony import */ var _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\nconst eRemoveLeadingZeros = _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.eRemoveLeadingZeros;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of adding two\r\n * polynomials with coefficients given as Shewchuk floating point expansions.\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial\r\n *\r\n * @example\r\n * ```typescript\r\n * eAdd([[1],[2],[3]],[[3],[4]]); //=> [[1],[5],[7]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eAdd(p1, p2) {\r\n    // Initialize result array  \r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    const Δd = d1 - d2;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = p1[i + Δd1] || [0];\r\n        const c2 = p2[i + Δd2] || [0];\r\n        result.push(fastExpansionSum(c1, c2));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return eRemoveLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=e-add.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-add.js?')},"./node_modules/flo-poly/node/basic/expansion/e-degree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eDegree": () => (/* binding */ eDegree)\n/* harmony export */ });\n/**\r\n * Returns the degree of the given polynomial - the zero polynomial degree is\r\n * returned as -1 (and not -∞ as is conventional).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eDegree([[9],[8],[7],[6],[5],[4],[3],[2],[1]]); //=> 8\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eDegree(p) {\r\n    return p.length - 1;\r\n}\r\n\r\n//# sourceMappingURL=e-degree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-degree.js?')},"./node_modules/flo-poly/node/basic/expansion/e-equal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eEqual": () => (/* binding */ eEqual)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eCompare = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare;\r\n/**\r\n * Returns true if two polynomials (with coefficients given as Shewchuk floating\r\n * point expansions) are exactly equal by comparing coefficients, false otherwise.\r\n *\r\n * @param p1 a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param p2 another polynomial\r\n *\r\n * @example\r\n * ```typescript\r\n * eEqual([[1],[2],[3],[0,4]], [[1],[2],[3],[4]]);   //=> true\r\n * eEqual([[1],[2],[3],[4]], [[1],[2],[3],[4],[5]]); //=> false\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eEqual(p1, p2) {\r\n    if (p1.length !== p2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < p1.length; i++) {\r\n        if (eCompare(p1[i], p2[i]) !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=e-equal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-equal.js?')},"./node_modules/flo-poly/node/basic/expansion/e-invert.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eInvert": () => (/* binding */ eInvert)\n/* harmony export */ });\n/**\r\n * Inverts the given polynomial (with coefficients given as Shewchuk floating\r\n * point expansions) by reversing the order of the coefficients,\r\n * i.e. p(x) -> x^deg(p) * p(1/x)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eInvert([[3],[2],[-5]]);  // => [[-5],[2],[3]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eInvert(p) {\r\n    return p.slice().reverse();\r\n}\r\n\r\n//# sourceMappingURL=e-invert.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-invert.js?')},"./node_modules/flo-poly/node/basic/expansion/e-is-const-or-zero.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIsConstOrZero": () => (/* binding */ eIsConstOrZero)\n/* harmony export */ });\n/**\r\n * Returns true if the given polynomial (with coefficients given as Shewchuk\r\n * floating point expansions) is a constant or the zero polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eIsConstOrZero(p) {\r\n    return p.length <= 1;\r\n}\r\n\r\n//# sourceMappingURL=e-is-const-or-zero.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-is-const-or-zero.js?')},"./node_modules/flo-poly/node/basic/expansion/e-is-rational-multiple-of.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIsRationalMultipleOf": () => (/* binding */ eIsRationalMultipleOf)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scale-to-int/scale-floatss-to-intss.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js");\n/* harmony import */ var _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../gcd/expansion/e-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js");\n\r\n\r\n\r\n/**\r\n * Returns true if either polynomial is an exact rational multiple of the other.\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\r\n * @param b another polynomial\r\n *\r\n * @doc\r\n */\r\nfunction eIsRationalMultipleOf(a, b) {\r\n    // If either polynomial is zero\r\n    if (a.length === 0 || b.length === 0) {\r\n        return true;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    // multiply by -1 if appropriate to make the leading coefficients positive\r\n    // then scale floating point coefficients to integers\r\n    const a_ = (0,_scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatssToIntss)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(a[0]) < 0 ? a.map(c => (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf)(c)) : a);\r\n    const b_ = (0,_scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatssToIntss)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(b[0]) < 0 ? b.map(c => (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf)(c)) : b);\r\n    /** leading coefficient of a */\r\n    const lcA = a_[0];\r\n    /** leading coefficient of b */\r\n    const lcB = b_[0];\r\n    const gcd = (0,_gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_2__.eGcdInt)(lcA, lcB);\r\n    const A = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eIntDiv)(lcA, gcd); // this division is exact\r\n    const B = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eIntDiv)(lcB, gcd); // this division is exact\r\n    for (let i = 0; i < a_.length; i++) {\r\n        const Ab = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct)(A, b_[i]);\r\n        const { div, rem } = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eLongDivide)(Ab, B);\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(rem) !== 0) {\r\n            return false;\r\n        }\r\n        if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)(div, a_[i]) !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=e-is-rational-multiple-of.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-is-rational-multiple-of.js?')},"./node_modules/flo-poly/node/basic/expansion/e-is-unit.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eIsUnit": () => (/* binding */ eIsUnit)\n/* harmony export */ });\n/**\r\n * Returns true if the given polynomial (with coefficients given as Shewchuk\r\n * floating point expansions) is the unit polynomial, i.e. === 1.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eIsUnit(p) {\r\n    return p.length === 1 && p[0].length === 1 && p[0][0] === 1;\r\n}\r\n\r\n//# sourceMappingURL=e-is-unit.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-is-unit.js?')},"./node_modules/flo-poly/node/basic/expansion/e-multiply-by-const.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eMultiplyByConst": () => (/* binding */ eMultiplyByConst)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of multiplying a\r\n * polynomial (with coefficients given as Shewchuk floating point expansions)\r\n * by a constant (given as a Shewchuk floating point expansion)\r\n *\r\n * @param c a constant (given as a Shewchuk floating point expansion)\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eMultiplyByConst([0.25], [[3],[2],[1]]); //=> [[0.75], [0.5], [0.25]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eMultiplyByConst(c, p) {\r\n    if (eSign(c) === 0) {\r\n        return [];\r\n    }\r\n    const d = p.length - 1;\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        result.push(expansionProduct(c, p[i]));\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-multiply-by-const.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-multiply-by-const.js?')},"./node_modules/flo-poly/node/basic/expansion/e-multiply.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eMultiply": () => (/* binding */ eMultiply)\n/* harmony export */ });\n/* harmony import */ var _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eRemoveLeadingZeros = _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_0__.eRemoveLeadingZeros;\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.expansionProduct;\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.fastExpansionSum;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of multiplying two\r\n * polynomials (with coefficients given as Shewchuk floating point expansions).\r\n *\r\n * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)\r\n * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)\r\n * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param b another polynomial.\r\n *\r\n * @example\r\n * ```typescript\r\n * eMultiply([[1],[2],[3]], [[2],[5],[3],[5]]); //=> [[2], [9], [19], [26], [19], [15]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eMultiply(a, b) {\r\n    const da = a.length - 1;\r\n    const db = b.length - 1;\r\n    // if either or both is the zero polynomial\r\n    if (da < 0 || db < 0) {\r\n        return [];\r\n    }\r\n    const d = da + db;\r\n    const result = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i < da + 1; i++) {\r\n        for (let j = 0; j < db + 1; j++) {\r\n            result[d - (i + j)] = fastExpansionSum(result[d - (i + j)], expansionProduct(a[da - i], b[db - j]));\r\n        }\r\n    }\r\n    return eRemoveLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=e-multiply.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-multiply.js?')},"./node_modules/flo-poly/node/basic/expansion/e-negate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eNegate": () => (/* binding */ eNegate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\n\r\nconst eNegativeOf = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\n/**\r\n * Returns the negative of the given polynomial (with coefficients given as\r\n * Shewchuk floating point expansions), i.e. (p -> -p).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eNegate([[0.1], [-0.2]]); //=> [[-0.1], [0.2]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eNegate(p) {\r\n    const result = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        result.push(eNegativeOf(p[i]));\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-negate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-negate.js?')},"./node_modules/flo-poly/node/basic/expansion/e-product.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eProduct": () => (/* binding */ eProduct)\n/* harmony export */ });\n/* harmony import */ var _e_multiply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-multiply.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply.js");\n\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of the product of 0 or\r\n * more polynomials.\r\n *\r\n * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)\r\n * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)\r\n * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)\r\n *\r\n * @param ps an array of polynomials each with coefficients given densely as an\r\n * array of Shewchuk floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eProduct([[[1],[2],[3]], [[2],[5],[3],[5]]]); //=> [[2], [9], [19], [26], [19], [15]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eProduct(ps) {\r\n    if (ps.length === 0) {\r\n        return [[1]];\r\n    }\r\n    let p = ps[0];\r\n    for (let i = 1; i < ps.length; i++) {\r\n        p = (0,_e_multiply_js__WEBPACK_IMPORTED_MODULE_0__.eMultiply)(p, ps[i]);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=e-product.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-product.js?')},"./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eRemoveLeadingZeros": () => (/* binding */ eRemoveLeadingZeros)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\n/**\r\n * If the highest power coefficient of the given polynomial is 0 then\r\n * removeLeadingZeros can be called to remove all such highest terms so that\r\n * the returned array is a valid presentation of a polynomial.\r\n *\r\n * @internal\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eRemoveLeadingZeros([[1e-18], [1e-10], [1e-1]]); //=> [[1e-18], [1e-10], [1e-1]]\r\n * eRemoveLeadingZeros([[0], [1e-10], [1e-1]]); //=> [[1e-10], [1e-1]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eRemoveLeadingZeros(p) {\r\n    let lzCount = 0;\r\n    for (let i = 0; i <= p.length - 1; i++) {\r\n        if (eSign(p[i]) !== 0) {\r\n            break;\r\n        }\r\n        lzCount++;\r\n    }\r\n    if (lzCount !== 0) {\r\n        p = p.slice(lzCount);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=e-remove-leading-zeros.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js?')},"./node_modules/flo-poly/node/basic/expansion/e-subtract.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eSubtract": () => (/* binding */ eSubtract)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eDiff = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff;\r\nconst eRemoveLeadingZeros = _e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_1__.eRemoveLeadingZeros;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of subtracting the\r\n * second polynomial from the first (both with coefficients given as Shewchuk\r\n * floating point expansions); (p1 - p2).\r\n *\r\n * @param p1 minuend; the polynomial from which will be subtracted; a polynomial\r\n * with coefficients given densely as Shewchuk floating point expansions\r\n * from highest to lowest power, e.g. `[[5],[-3],[0]]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param p2 subtrahend; the polynomial that will be subtracted\r\n *\r\n * @example\r\n * ```typescript\r\n * eSubtract([[2],[3]],[[4],[4]]); //=> [[-2], [-1]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eSubtract(p1, p2) {\r\n    // Initialize result array  \r\n    const d1 = p1.length - 1;\r\n    const d2 = p2.length - 1;\r\n    const Δd = d1 - d2;\r\n    const Δd1 = Δd < 0 ? +Δd : 0;\r\n    const Δd2 = Δd > 0 ? -Δd : 0;\r\n    const d = Math.max(d1, d2);\r\n    // Add coefficients\r\n    const result = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const c1 = p1[i + Δd1] || [0];\r\n        const c2 = p2[i + Δd2] || [0];\r\n        result.push(eDiff(c1, c2));\r\n    }\r\n    // Ensure the result is a valid polynomial representation\r\n    return eRemoveLeadingZeros(result);\r\n}\r\n\r\n//# sourceMappingURL=e-subtract.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/expansion/e-subtract.js?')},"./node_modules/flo-poly/node/basic/to-cas-str.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toCasStr\": () => (/* binding */ toCasStr)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\r\n/** @internal */\r\nfunction isNumber(x) {\r\n    return typeof x === 'number';\r\n}\r\n/** @internal */\r\nfunction isShewchuk(x) {\r\n    return Array.isArray(x);\r\n}\r\n/** @internal */\r\nfunction isBigint(x) {\r\n    return typeof x === 'bigint';\r\n}\r\n/**\r\n * Returns a string representing the given polynomial that is readable by a\r\n * human or a CAS (Computer Algebra System).\r\n *\r\n * * **note:** if the polynomial coefficients are given as Shewchuk expansions\r\n * then the coefficients are first down-converted to double precision\r\n *\r\n * @param p a polynomial (with coefficients given densely as an array of Shewchuk\r\n * floating point expansions **or** double precision floating point numbers **or**\r\n * bigints) from highest to lowest power, e.g. `[5,-3,0]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n * toCasStr([[5],[4],[3],[2],[1]]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n * toCasStr([5n,4n,3n,2n,1n]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction toCasStr(p) {\r\n    const d = p.length - 1;\r\n    let str = '';\r\n    for (let i = 0; i < d + 1; i++) {\r\n        const _v = p[i];\r\n        const v = isShewchuk(_v)\r\n            ? (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(_v)\r\n            : _v; // bigint or number\r\n        const absV = isBigint(v)\r\n            ? (_v < 0n ? -v : v)\r\n            : Math.abs(v);\r\n        let cStr = nonNegativeNumberToString(absV);\r\n        cStr = (v >= 0 ? ' + ' : ' - ') + cStr;\r\n        if (i === d) {\r\n            str += cStr;\r\n        }\r\n        else if (i === d - 1) {\r\n            str += cStr + '*x';\r\n        }\r\n        else {\r\n            str += cStr + '*x^' + (d - i).toString();\r\n        }\r\n    }\r\n    return str;\r\n}\r\n/**\r\n * from https://stackoverflow.com/a/46545519/2010061\r\n *\r\n * @internal\r\n */\r\nfunction nonNegativeNumberToString(num) {\r\n    let numStr = num.toString();\r\n    if (isBigint(num)) {\r\n        return numStr;\r\n    }\r\n    if (Math.abs(num) < 1) {\r\n        const e = parseInt(numStr.split('e-')[1]);\r\n        if (e) {\r\n            num *= 10 ** (e - 1);\r\n            numStr = '0.' + (new Array(e)).join('0') + num.toString().substring(2);\r\n        }\r\n    }\r\n    else {\r\n        let e = parseInt(numStr.split('+')[1]);\r\n        if (e > 20) {\r\n            e -= 20;\r\n            num /= 10 ** e;\r\n            numStr = num.toString() + (new Array(e + 1)).join('0');\r\n        }\r\n    }\r\n    return numStr;\r\n}\r\n\r\n//# sourceMappingURL=to-cas-str.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/basic/to-cas-str.js?")},"./node_modules/flo-poly/node/calculus/bigint/b-differentiate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bDifferentiate": () => (/* binding */ bDifferentiate)\n/* harmony export */ });\n/**\r\n * Returns the result of differentiating the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of bigints\r\n * from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bDifferentiate([5n, 4n, 3n, 2n, 1n]); //=> [20n, 12n, 6n, 2n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bDifferentiate(p) {\r\n    const r = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        r.push(BigInt((d - i)) * p[i]);\r\n    }\r\n    return r;\r\n}\r\n\r\n//# sourceMappingURL=b-differentiate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/bigint/b-differentiate.js?')},"./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDifferentiateWithError": () => (/* binding */ ddDifferentiateWithError)\n/* harmony export */ });\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../error-analysis/gamma.js */ "./node_modules/flo-poly/node/error-analysis/gamma.js");\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_1__.ddMultDouble2;\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eEstimate;\r\nconst γγ3 = (0,_error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_0__["γγ"])(3);\r\n/**\r\n * Returns the result (and resulting coefficient-wise error bound) of\r\n * differentiating the given polynomial (with coefficients given in\r\n * double-double precision) in double-double precision.\r\n *\r\n * @param pWithErr an object with 2 properties: `p`: a polynomial with\r\n * coefficients given densely as an array of double-double precision floating\r\n * point numbers from highest to lowest power, e.g. `[[5],[-3],[0]]` represents\r\n * the polynomial `5x^2 - 3x` **and** `pE`: the coefficient-wise error bound of\r\n * the input polynomial\r\n *\r\n * @doc\r\n */\r\nfunction ddDifferentiateWithError(pWithErr) {\r\n    const { p, pE } = pWithErr;\r\n    const dp = [];\r\n    const dpE = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        const deg = d - i;\r\n        const c = ddMultDouble2(deg, p[i]);\r\n        dp.push(c);\r\n        // if 1,2,4 or 8, etc. then no additional error occurs on multiply\r\n        // if 3,5,7 or 9, etc. then additional error occurs\r\n        // deg is a power of 2 <=> (deg & deg-1) === 0\r\n        const extraErr = (deg & deg - 1) === 0 ? 0 : γγ3;\r\n        const $c = eEstimate(c);\r\n        dpE.push(\r\n        //deg * (pE[i] + Math.abs($c)*extraErr)\r\n        deg * pE[i] + Math.abs($c) * extraErr);\r\n    }\r\n    return { p: dp, pE: dpE };\r\n}\r\n\r\n//# sourceMappingURL=dd-differentiate-with-err.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js?')},"./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDifferentiate": () => (/* binding */ ddDifferentiate)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ddMultDouble2 = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\n/**\r\n * Returns the result of differentiating the given polynomial (with coefficients\r\n * given in double-double precision) in double-double precision.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * ddDifferentiate([[0,5], [0,4], [0,3], [0,2], [0,1]]); //=> [[0,20], [0,12], [0,6], [0,2]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction ddDifferentiate(p) {\r\n    const result = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push(ddMultDouble2((d - i), p[i]));\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=dd-differentiate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js?')},"./node_modules/flo-poly/node/calculus/double-double/dd-integrate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddIntegrate": () => (/* binding */ ddIntegrate)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n/**\r\n * Returns the result of integrating the given polynomial in double-double\r\n * precision.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest\r\n * power, e.g. `[[0,5],[0,-3],[0,0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param c the constant of intergration\r\n *\r\n * @example\r\n * ```typescript\r\n * integrate([[0,3], [0,2], [0,1]]); //=> [[0,1], [0,1], [0,1], [0,c]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction ddIntegrate(p, c) {\r\n    const result = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d + 1; i++) {\r\n        result.push((0,double_double__WEBPACK_IMPORTED_MODULE_0__.ddDivDouble)(p[i], (d + 1 - i)));\r\n    }\r\n    result.push(c);\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=dd-integrate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/double-double/dd-integrate.js?')},"./node_modules/flo-poly/node/calculus/double/differentiate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "differentiate": () => (/* binding */ differentiate)\n/* harmony export */ });\n/**\r\n * Returns the result of differentiating the given polynomial in double\r\n * precision.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction differentiate(p) {\r\n    const result = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push((d - i) * p[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=differentiate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/double/differentiate.js?')},"./node_modules/flo-poly/node/calculus/double/integrate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "integrate": () => (/* binding */ integrate)\n/* harmony export */ });\n/**\r\n * Returns the result of integrating the given polynomial in double precision.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param c the constant of intergration\r\n *\r\n * @example\r\n * ```typescript\r\n * integrate([3, 2, 1]); //=> [1, 1, 1, c]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction integrate(p, c) {\r\n    const result = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d + 1; i++) {\r\n        result.push(p[i] / (d + 1 - i));\r\n    }\r\n    result.push(c);\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=integrate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/double/integrate.js?')},"./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eDifferentiate": () => (/* binding */ eDifferentiate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst scaleExpansion = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of differentiating the\r\n * given polynomial (with Shewchuk expansion coefficients).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eDifferentiate([[5], [4], [3], [2], [1]]); //=> [[20], [12], [6], [2]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eDifferentiate(p) {\r\n    const result = [];\r\n    const d = p.length - 1;\r\n    for (let i = 0; i < d; i++) {\r\n        result.push(scaleExpansion(p[i], d - i));\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-differentiate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js?')},"./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-linear.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bChangeVariablesLinear": () => (/* binding */ bChangeVariablesLinear)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(ax + b).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param a the `a` in `ax + b`\r\n * @param b the `b` in `ax + b`\r\n *\r\n * @example\r\n * ```typescript\r\n * bChangeVariablesLinear([1n,2n,7n], 3n, 4n); //=> [9n, 30n, 31n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bChangeVariablesLinear(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \r\n    // code below. \r\n    // d_i is calculated as d = T*c, where c are the original \r\n    // coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0n));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1n;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0n);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0n;\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] += t[i][j] * p[d - j];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=b-change-variables-linear.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-linear.js?')},"./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-scale.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bChangeVariablesScale": () => (/* binding */ bChangeVariablesScale)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(ax).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`\r\n *\r\n * @example\r\n * ```typescript\r\n * bChangeVariablesScale([1n,2n,7n], 3n); //=> [9n, 6n, 7n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bChangeVariablesScale(p, a) {\r\n    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. \r\n    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient\r\n    // vector.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0n));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1n;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = 0n;\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0n);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0n;\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] += t[i][j] * p[d - j];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=b-change-variables-scale.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-scale.js?')},"./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-translate-x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bChangeVariablesTranslateX": () => (/* binding */ bChangeVariablesTranslateX)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(x + b).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b the `b` in `x + b`\r\n *\r\n * @example\r\n * ```typescript\r\n * bChangeVariablesTranslateX([1n,2n,7n], 3n); //=> [1n, 8n, 22n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bChangeVariablesTranslateX(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0n));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1n;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0n);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0n;\r\n        for (let j = i; j <= d; j++) {\r\n            const acc = t[i][j] * p[d - j];\r\n            res[d - i] += acc;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=b-change-variables-translate-x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-translate-x.js?')},"./node_modules/flo-poly/node/change-variables/bigint/b-reflect-about-y-axis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bReflectAboutYAxis": () => (/* binding */ bReflectAboutYAxis)\n/* harmony export */ });\n/**\r\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\r\n * perform the change of variables: p(x) <- p(-x).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bReflectAboutYAxis([5n, 4n, 3n, 2n, 1n]); //=> [5n, -4n, 3n, -2n, 1n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bReflectAboutYAxis(p) {\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    const result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = -result[i];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=b-reflect-about-y-axis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/bigint/b-reflect-about-y-axis.js?')},"./node_modules/flo-poly/node/change-variables/double/change-variables-linear.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "changeVariablesLinear": () => (/* binding */ changeVariablesLinear)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(ax + b) in double precision.\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a the `a` in `ax + b`\r\n * @param b the `b` in `ax + b`\r\n *\r\n * @example\r\n * ```typescript\r\n * changeVariablesLinear([1,2,7], 3, 4); //=> [9, 30, 31]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction changeVariablesLinear(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the \r\n    // code below. \r\n    // d_i is calculated as d = T*c, where c are the original \r\n    // coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] += t[i][j] * p[d - j];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=change-variables-linear.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/double/change-variables-linear.js?')},"./node_modules/flo-poly/node/change-variables/double/change-variables-scale.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "changeVariablesScale": () => (/* binding */ changeVariablesScale)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(ax) in double precision.\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`\r\n *\r\n * @example\r\n * ```typescript\r\n * changeVariablesScale([1,2,7], 3); //=> [9, 6, 7]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction changeVariablesScale(p, a) {\r\n    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. \r\n    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient\r\n    // vector.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = 0;\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = a * t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] += t[i][j] * p[d - j];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=change-variables-scale.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/double/change-variables-scale.js?')},"./node_modules/flo-poly/node/change-variables/double/change-variables-translate-x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "changeVariablesTranslateX": () => (/* binding */ changeVariablesTranslateX)\n/* harmony export */ });\n/**\r\n * Returns the result of performing a change of variables of the\r\n * form: p(x) <- p(x + b) in double precision.\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param b the `b` in `x + b`\r\n *\r\n * @example\r\n * ```typescript\r\n * changeVariablesTranslateX([1,2,7], 3); //=> [1, 8, 22]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction changeVariablesTranslateX(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill(0));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = 1;\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = b * t[0][j - 1];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = b * t[i][j - 1] + t[i - 1][j - 1];\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill(0);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = 0;\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] += t[i][j] * p[d - j];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=change-variables-translate-x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/double/change-variables-translate-x.js?')},"./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reflectAboutYAxis": () => (/* binding */ reflectAboutYAxis)\n/* harmony export */ });\n/**\r\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\r\n * perform the change of variables: p(x) <- p(-x).\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction reflectAboutYAxis(p) {\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    const result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = -result[i];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=reflect-about-y-axis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js?')},"./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eChangeVariablesLinear": () => (/* binding */ eChangeVariablesLinear)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst scaleExpansion2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of performing a change\r\n * of variables of the form: p(x) <- p(ax + b) on the given polynomial (with\r\n * coefficients given as Shewchuk expansions).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a the `a` in `ax + b`\r\n * @param b the `b` in `ax + b`\r\n *\r\n * @example\r\n * ```typescript\r\n * eChangeVariablesLinear([[1],[2],[7]], 3, 4); //=> [[9], [30], [31]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eChangeVariablesLinear(p, a, b) {\r\n    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = scaleExpansion2(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = fastExpansionSum(scaleExpansion2(b, t[i][j - 1]), scaleExpansion2(a, t[i - 1][j - 1]));\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            const acc = expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=e-change-variables-linear.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js?')},"./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-scale.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eChangeVariablesScale": () => (/* binding */ eChangeVariablesScale)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst scaleExpansion2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of performing a change\r\n * of variables of the form: p(x) <- p(ax).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`\r\n *\r\n * @example\r\n * ```typescript\r\n * eChangeVariablesScale([[1],[2],[7]], 3); //=> [[9], [6], [7]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eChangeVariablesScale(p, a) {\r\n    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. \r\n    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient\r\n    // vector.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = [0];\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = scaleExpansion2(a, t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            res[d - i] = fastExpansionSum(res[d - i], expansionProduct(t[i][j], p[d - j]));\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=e-change-variables-scale.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-scale.js?')},"./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-translate-x.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eChangeVariablesTranslateX": () => (/* binding */ eChangeVariablesTranslateX)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst scaleExpansion2 = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion2;\r\n/**\r\n * Returns the exact result (bar undeflow / overflow) of performing a change of\r\n * variables of the form: p(x) <- p(x + b) on the given polynomial (with\r\n * coefficients given as Shewchuk expansions).\r\n *\r\n * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param b the `b` in `x + b`\r\n *\r\n * @doc\r\n */\r\nfunction eChangeVariablesTranslateX(p, b) {\r\n    // We let the coefficients of p(x + b) be denoted by d_i in the code below. \r\n    // d_i is calculated as d = T*c, where c are the original coefficients.\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    // Initialize a zero matrix\r\n    const t = [];\r\n    for (let i = 0; i < d + 1; i++) {\r\n        t.push(new Array(d + 1).fill([0]));\r\n    }\r\n    // Calculate the triangular matrix T\r\n    t[0][0] = [1];\r\n    for (let j = 1; j <= d; j++) {\r\n        t[0][j] = scaleExpansion2(b, t[0][j - 1]);\r\n        for (let i = 1; i <= j; i++) {\r\n            t[i][j] = fastExpansionSum(scaleExpansion2(b, t[i][j - 1]), t[i - 1][j - 1]);\r\n        }\r\n    }\r\n    // Multiply\r\n    const res = new Array(d + 1).fill([0]);\r\n    for (let i = 0; i <= d; i++) {\r\n        res[d - i] = [0];\r\n        for (let j = i; j <= d; j++) {\r\n            const acc = expansionProduct(t[i][j], p[d - j]);\r\n            res[d - i] = fastExpansionSum(res[d - i], acc);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=e-change-variables-translate-x.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-translate-x.js?')},"./node_modules/flo-poly/node/change-variables/expansion/e-reflect-about-y-axis.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eReflectAboutYAxis": () => (/* binding */ eReflectAboutYAxis)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eNegativeOf = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\n/**\r\n * Returns the result of reflecting the given polynomial about the Y-axis, i.e.\r\n * perform the change of variables: p(x) <- p(-x).\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eReflectAboutYAxis([[5],[4],[3],[2],[1]]); //=> [[5], [-4], [3], [-2], [1]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eReflectAboutYAxis(p) {\r\n    const d = p.length - 1;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    const result = p.slice();\r\n    for (let i = 0; i < d + 1; i++) {\r\n        if (i % 2) {\r\n            result[i] = eNegativeOf(result[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-reflect-about-y-axis.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/change-variables/expansion/e-reflect-about-y-axis.js?')},"./node_modules/flo-poly/node/error-analysis/condition-number.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "conditionNumber": () => (/* binding */ conditionNumber)\n/* harmony export */ });\n/* harmony import */ var _basic_double_abs_coeff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/double/abs-coeff.js */ "./node_modules/flo-poly/node/basic/double/abs-coeff.js");\n/* harmony import */ var _evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../evaluate/double/comp-horner-k.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js");\n\r\n\r\n/**\r\n * Returns an accurate estimate (K === 4 => double-double-double-double\r\n * precision) of the condition number of the given polynomial when evaluated at\r\n * a given point.\r\n *\r\n * * **for testing purposes**\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction conditionNumber(p, x) {\r\n    const pN = (0,_basic_double_abs_coeff_js__WEBPACK_IMPORTED_MODULE_0__.absCoeff)(p);\r\n    const pD = p;\r\n    const N = (0,_evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_1__.CompHornerK)(pN, x, 4);\r\n    const D = Math.abs((0,_evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_1__.CompHornerK)(pD, x, 4));\r\n    return Math.abs(N / D);\r\n}\r\n\r\n//# sourceMappingURL=condition-number.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/error-analysis/condition-number.js?')},"./node_modules/flo-poly/node/error-analysis/gamma.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "γ": () => (/* binding */ γ),\n/* harmony export */   "γγ": () => (/* binding */ γγ)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\r\nconst uu = u * u;\r\n/**\r\n * The canonical floating point error function, γ.\r\n *\r\n * * roughly `=== n * (Number.EPSILON / 2)`\r\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\r\n * @param n the parameter - typically a small positive integer, e.g. for\r\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\r\n * polynomial\r\n *\r\n * @doc\r\n */\r\nfunction γ(n) {\r\n    const nu = n * u;\r\n    return nu / (1 - nu);\r\n}\r\n/**\r\n * The canonical, once compensated (implying double-double precision),\r\n * floating point error function.\r\n *\r\n * * roughly `=== n * (Number.EPSILON / 2)**2`\r\n * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)\r\n * @param n the parameter - typically a small positive integer, e.g. for\r\n * polynomial evaluation this === 2*d + 1, where d is the degree of the\r\n * polynomial\r\n *\r\n * @doc\r\n */\r\nfunction γγ(n) {\r\n    const nuu = n * uu;\r\n    return nuu / (1 - nuu);\r\n}\r\n\r\n//# sourceMappingURL=gamma.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/error-analysis/gamma.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-elevate-degree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bElevateDegree": () => (/* binding */ bElevateDegree)\n/* harmony export */ });\n/**\r\n * Returns the result of elevating the given polynomial by the given degree.\r\n *\r\n * @param p\r\n * @param deg\r\n *\r\n * @internal\r\n */\r\nfunction bElevateDegree(p, deg) {\r\n    const p_ = p.slice();\r\n    for (let i = 0; i < deg; i++) {\r\n        p_.push(0n);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=b-elevate-degree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-elevate-degree.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-internal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPdivInternal": () => (/* binding */ bPdivInternal)\n/* harmony export */ });\n/* harmony import */ var _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/bigint/b-degree.js */ "./node_modules/flo-poly/node/basic/bigint/b-degree.js");\n/* harmony import */ var _b_elevate_degree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-elevate-degree.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-elevate-degree.js");\n/* harmony import */ var _basic_bigint_b_add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../basic/bigint/b-add.js */ "./node_modules/flo-poly/node/basic/bigint/b-add.js");\n/* harmony import */ var _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../basic/bigint/b-multiply.js */ "./node_modules/flo-poly/node/basic/bigint/b-multiply.js");\n/* harmony import */ var _basic_bigint_b_subtract_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../basic/bigint/b-subtract.js */ "./node_modules/flo-poly/node/basic/bigint/b-subtract.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bDegree = _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__.bDegree;\r\nconst bElevateDegree = _b_elevate_degree_js__WEBPACK_IMPORTED_MODULE_1__.bElevateDegree;\r\nconst bAdd = _basic_bigint_b_add_js__WEBPACK_IMPORTED_MODULE_2__.bAdd;\r\nconst bMultiply = _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_3__.bMultiply;\r\nconst bSubtract = _basic_bigint_b_subtract_js__WEBPACK_IMPORTED_MODULE_4__.bSubtract;\r\n/**\r\n * Returns the `quotient` and `remainder` of the pseudo division of `a/b` (a, b\r\n * both being polynomials) naively, i.e. in such a way that all intermediate\r\n * calculations and the final result are **not** guaranteed to be in ℤ, i.e.\r\n * performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * and returns `q` and `r` in the formula `a = bq + r`,\r\n * where `degree(r) < degree(b)`. `q` is called the quotient and `r` the\r\n * remainder.\r\n *\r\n * * **precondition:** the coefficients must be integers; if they are not they\r\n * can easily be scaled from floating point numbers to integers by calling\r\n * [[scaleFloatssToBigintss]] before calling this function (recall that all floating\r\n * point numbers are rational).\r\n *\r\n * * **precondition:** b !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * see [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)\r\n *\r\n * @param a the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of bigints from highest to lowest\r\n * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`\r\n * @param b the polynomial b in the formula a = bq + r\r\n *\r\n * @internal\r\n */\r\nfunction bPdivInternal(a, b) {\r\n    let q = [];\r\n    const d = bDegree(b);\r\n    const c = b[0];\r\n    let r = a;\r\n    while (true) {\r\n        const deg = bDegree(r) - d;\r\n        if (deg < 0) {\r\n            return { q, r };\r\n        }\r\n        // The division below is guaranteed to be exact\r\n        const s = bElevateDegree([r[0] / c], deg);\r\n        q = bAdd(q, s);\r\n        r = bSubtract(r, bMultiply(s, b));\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-pdiv-internal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-internal.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPdivTrivial": () => (/* binding */ bPdivTrivial)\n/* harmony export */ });\n/* harmony import */ var _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/bigint/b-degree.js */ "./node_modules/flo-poly/node/basic/bigint/b-degree.js");\n/* harmony import */ var _basic_bigint_b_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/bigint/b-multiply-by-const.js */ "./node_modules/flo-poly/node/basic/bigint/b-multiply-by-const.js");\n/* harmony import */ var _b_pdiv_internal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./b-pdiv-internal.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-internal.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bDegree = _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__.bDegree;\r\nconst bMultiplyByConst = _basic_bigint_b_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_1__.bMultiplyByConst;\r\nconst bPdivInternal = _b_pdiv_internal_js__WEBPACK_IMPORTED_MODULE_2__.bPdivInternal;\r\nconst abs = (n) => n >= 0 ? n : -n;\r\n/**\r\n * Performs a **trivial pseudo-division** and returns the `quotient` and `remainder`\r\n * of the pseudo division of `a/b` (a, b both being polynomials) in such a way\r\n * that all intermediate calculations and the final result are done in ℤ, i.e.\r\n * performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * and returns a scaled `r` and `q` in the formula `a = bq + r`, where\r\n * `degree(r) < degree(b)`. `q` is called the quotient and `r` the remainder.\r\n *\r\n * * **precondition:** the coefficients must be bigints; if they are not they\r\n * can easily be scaled from floating point numbers to bigints by calling\r\n * [[scaleFloatsToBigints]] or similar before calling this function (recall that\r\n * all floating point numbers are rational).\r\n *\r\n * * **precondition:** b !== [0], i.e. unequal to the zero polynomial.\r\n *\r\n * * see [trivial pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)\r\n * * see also [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)\r\n *\r\n * @param a the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of bigints from highest to lowest\r\n * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`\r\n * @param b the polynomial b in the formula a = bq + r\r\n * @param positiveMultiplier defaults to false - if set to true then the\r\n * multiplier (of the coefficients of the dividend)\r\n * `leadingCoeff(b)^(deg(a)-deg(b)+1)` will be\r\n * modified to `abs(leadingCoeff(b)^(deg(a)-deg(b)+1))`\r\n *\r\n * @doc\r\n */\r\nfunction bPdivTrivial(a, b, positiveMultiplier = false) {\r\n    const d = bDegree(a) - bDegree(b) + 1;\r\n    if (d < 1) {\r\n        return { q: [], r: a };\r\n    }\r\n    let m = b[0] ** BigInt(d);\r\n    m = positiveMultiplier\r\n        ? abs(m)\r\n        : m;\r\n    const a_ = bMultiplyByConst(m, a);\r\n    return bPdivInternal(a_, b);\r\n}\r\n\r\n//# sourceMappingURL=b-pdiv-trivial.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-primitive.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPremSequencePrimitive": () => (/* binding */ bPremSequencePrimitive)\n/* harmony export */ });\n/* harmony import */ var _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js");\n/* harmony import */ var _factor_bigint_b_primitive_part_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../factor/bigint/b-primitive-part.js */ "./node_modules/flo-poly/node/factor/bigint/b-primitive-part.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bPdivTrivial = _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__.bPdivTrivial;\r\nconst bGetPrimitivePart = _factor_bigint_b_primitive_part_js__WEBPACK_IMPORTED_MODULE_1__.bPrimitivePart;\r\n/**\r\n * Returns the primitive pseudo remainder sequence of a/b.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n* * see [Primitive Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of bigints from highest to lowest\r\n * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r;\r\n *\r\n * @doc\r\n */\r\nfunction bPremSequencePrimitive(f, g) {\r\n    const r = [f, g]; // Initialize the PRS\r\n    let i = 1;\r\n    while (true) {\r\n        let r_ = bPdivTrivial(r[i - 1], r[i]).r;\r\n        r_ = bGetPrimitivePart(r_);\r\n        if (r_.length === 0) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (r_.length === 1) {\r\n            // the remainder is a constant so the next remainder \r\n            // will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-prem-sequence-primitive.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-primitive.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPremSequenceSubresultant": () => (/* binding */ bPremSequenceSubresultant)\n/* harmony export */ });\n/* harmony import */ var _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/bigint/b-degree.js */ "./node_modules/flo-poly/node/basic/bigint/b-degree.js");\n/* harmony import */ var _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bDegree = _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_0__.bDegree;\r\nconst bPdivTrivial = _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_1__.bPdivTrivial;\r\n/**\r\n * Returns the subresultant pseudo remainder sequence of a/b.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of bigints from highest to lowest\r\n * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r;\r\n * @param sturm if set to true then calculate a Sturm sequence instead\r\n *\r\n * @doc\r\n */\r\nfunction bPremSequenceSubresultant(f, g, sturm = false) {\r\n    const r = [f, g]; // Initialize the PRS\r\n    const d = [bDegree(f), bDegree(g)];\r\n    const a = [1n]; // a_1 === 1\r\n    const c = [1n]; // c_1 === 1\r\n    let i = 1;\r\n    while (true) {\r\n        a.push(r[i][0]); // leading coefficient of r[i-1]\r\n        const d_ = d[i - 1] - d[i];\r\n        const bD_ = BigInt(d_);\r\n        const sgn = sturm\r\n            ? -1\r\n            : (d_ + 1) % 2 === 0 ? +1 : -1;\r\n        const D = a[i - 1] * c[i - 1] ** bD_;\r\n        const exp = -bD_ + 1n;\r\n        const cTerm1 = a[i] ** bD_;\r\n        const cTerm2 = c[i - 1] ** (exp < 0n ? -exp : exp);\r\n        c.push(exp < 0\r\n            ? cTerm1 / cTerm2\r\n            : cTerm1 * cTerm2);\r\n        let r_ = bPdivTrivial(r[i - 1], r[i], sturm).r\r\n            .map(coeff => coeff / D);\r\n        r_ = sgn > 0 ? r_ : r_.map(c => -c);\r\n        d.push(bDegree(r_));\r\n        if (r_.length === 0) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (r_.length === 1) {\r\n            // the remainder is a constant so the next remainder \r\n            // will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-prem-sequence-subresultant.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-trivial.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPremSequenceTrivial": () => (/* binding */ bPremSequenceTrivial)\n/* harmony export */ });\n/* harmony import */ var _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bPdivTrivial = _b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__.bPdivTrivial;\r\n/**\r\n * ❗ DON\'T USE - coefficients grow way too big, making it slow - use\r\n * [[bPremSequenceSubresultant]] instead. ❗\r\n *\r\n * Returns the trivial pseudo remainder sequence of a/b.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n* * see [Trivial Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of bigints from highest to lowest\r\n * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r;\r\n *\r\n * @doc\r\n */\r\nfunction bPremSequenceTrivial(f, g) {\r\n    const r = [f, g]; // Initialize the PRS\r\n    let i = 1;\r\n    while (true) {\r\n        const r_ = bPdivTrivial(r[i - 1], r[i]).r;\r\n        if (r_.length === 0) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (r_.length === 1) {\r\n            // the remainder is a constant so the next remainder \r\n            // will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=b-prem-sequence-trivial.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-trivial.js?')},"./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bSturmChain": () => (/* binding */ bSturmChain)\n/* harmony export */ });\n/* harmony import */ var _calculus_bigint_b_differentiate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/bigint/b-differentiate.js */ "./node_modules/flo-poly/node/calculus/bigint/b-differentiate.js");\n/* harmony import */ var _b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bDifferentiate = _calculus_bigint_b_differentiate_js__WEBPACK_IMPORTED_MODULE_0__.bDifferentiate;\r\nconst bPremSequenceSubresultant = _b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__.bPremSequenceSubresultant;\r\n/**\r\n * Returns the Sturm Chain for the given polynomial using pseudo remainders.\r\n *\r\n * * see [Sturm\'s Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)\r\n * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bSturmChain([-3n,4n,2n,-2n]); //=> [[-3n, 4n, 2n, -2n], [-9n, 8n, 2n], [-204n, 138n], [-1692n]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bSturmChain(p) {\r\n    const dp = bDifferentiate(p);\r\n    return bPremSequenceSubresultant(p, dp, true);\r\n}\r\n\r\n//# sourceMappingURL=b-sturm-chain.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js?')},"./node_modules/flo-poly/node/euclidean-division-related/double/prem-sequence-subresultant.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "premSequenceSubresultant": () => (/* binding */ premSequenceSubresultant)\n/* harmony export */ });\n/* harmony import */ var _expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../expansion/e-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ePremSequenceSubresultant = _expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_0__.ePremSequenceSubresultant;\r\n/**\r\n * Returns the subresultant pseudo remainder sequence of a/b with the resulting\r\n * polynomials given with coefficients as Shewchuk expansions.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * Intermediate calculations are done in infinite precision up to\r\n * overlow (meaning integers can be represented *exactly* up to\r\n * `2^1024 === 1797...(300 more digits)...37216`) and may\r\n * thus not be applicable to very high degree polynomials (in which case it is\r\n * better to use [[bPremSequenceSubresultant]])\r\n *\r\n * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of double precision floating point numbers\r\n * from highest to lowest power, e.g. `[5,-3,0]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r;\r\n * @param sturm if set to true then calculate a Sturm sequence instead\r\n *\r\n * @doc\r\n */\r\nfunction premSequenceSubresultant(f, g, sturm = false) {\r\n    return ePremSequenceSubresultant(f.map(c => [c]), g.map(c => [c]), sturm);\r\n}\r\n\r\n//# sourceMappingURL=prem-sequence-subresultant.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/double/prem-sequence-subresultant.js?')},"./node_modules/flo-poly/node/euclidean-division-related/double/sturm-chain.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "sturmChain": () => (/* binding */ sturmChain)\n/* harmony export */ });\n/* harmony import */ var _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/expansion/e-differentiate.js */ "./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js");\n/* harmony import */ var _expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expansion/e-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eDifferentiate = _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_0__.eDifferentiate;\r\nconst ePremSequenceSubresultant = _expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__.ePremSequenceSubresultant;\r\n/**\r\n * Returns the Sturm chain for the given polynomial using pseudo remainders\r\n * with the resulting polynomials given with coefficients as Shewchuk\r\n * expansions.\r\n *\r\n * * intermediate calculations use Shewchuk expansions and the final result is\r\n * given as an array of polynomials with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * * see [Sturm\'s Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)\r\n * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double precision floating point numbers from highest to lowest power,\r\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * sturmChain([-3,4,2,-2]); //=> [[[-3],[4],[2],[-2]],[[-9],[8],[2]],[[-204],[138]],[[-1692]]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction sturmChain(p) {\r\n    // convert from double precision to Shewchuk expansion\r\n    const p_ = p.map(c => [c]);\r\n    const dp = eDifferentiate(p_);\r\n    return ePremSequenceSubresultant(p_, dp, true);\r\n}\r\n\r\n//# sourceMappingURL=sturm-chain.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/double/sturm-chain.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-elevate-degree.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eElevateDegree": () => (/* binding */ eElevateDegree)\n/* harmony export */ });\n/**\r\n * Returns the result of elevating the given polynomial by the given degree.\r\n *\r\n * @param p\r\n * @param deg\r\n *\r\n * @internal\r\n */\r\nfunction eElevateDegree(p, deg) {\r\n    const p_ = p.slice();\r\n    for (let i = 0; i < deg; i++) {\r\n        p_.push([0]);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=e-elevate-degree.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-elevate-degree.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-internal.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePdivInternal": () => (/* binding */ ePdivInternal)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n/* harmony import */ var _e_elevate_degree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-elevate-degree.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-elevate-degree.js");\n/* harmony import */ var _basic_expansion_e_add_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../basic/expansion/e-add.js */ "./node_modules/flo-poly/node/basic/expansion/e-add.js");\n/* harmony import */ var _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../basic/expansion/e-multiply.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply.js");\n/* harmony import */ var _basic_expansion_e_subtract_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../basic/expansion/e-subtract.js */ "./node_modules/flo-poly/node/basic/expansion/e-subtract.js");\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eDiv = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiv;\r\nconst eDegree = _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_1__.eDegree;\r\nconst eElevateDegree = _e_elevate_degree_js__WEBPACK_IMPORTED_MODULE_2__.eElevateDegree;\r\nconst eAdd = _basic_expansion_e_add_js__WEBPACK_IMPORTED_MODULE_3__.eAdd;\r\nconst eMultiply = _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_4__.eMultiply;\r\nconst subtractExact = _basic_expansion_e_subtract_js__WEBPACK_IMPORTED_MODULE_5__.eSubtract;\r\n/**\r\n * Returns the `quotient` and `remainder` of the pseudo division of `a/b` (a, b\r\n * both being polynomials) naively, i.e. in such a way that all intermediate\r\n * calculations and the final result are **not** guaranteed to be in ℤ, i.e.\r\n * performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * and returns `q` and `r` in the formula `a = bq + r`,\r\n * where `degree(r) < degree(b)`. `q` is called the quotient and `r` the\r\n * remainder.\r\n *\r\n * * **precondition:** the coefficients must be integers; if they are not they\r\n * can easily be scaled from floating point numbers to integers by calling\r\n * [[scaleFloatsToBigints]] or similar before calling this function (recall that\r\n * all floating point numbers are rational).\r\n *\r\n * * **precondition:** b !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * see [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)\r\n *\r\n * @param a the polynomial a in the formula a = bq + r\r\n * @param b the polynomial b in the formula a = bq + r\r\n *\r\n * @internal\r\n */\r\nfunction ePdivInternal(a, b) {\r\n    let q = [];\r\n    const d = eDegree(b);\r\n    const c = b[0];\r\n    let r = a;\r\n    while (true) {\r\n        const deg = eDegree(r) - d;\r\n        if (deg < 0) {\r\n            return { q, r };\r\n        }\r\n        // The division below is guaranteed to be exact\r\n        let s = [eDiv(r[0], c, 0)];\r\n        s = eElevateDegree(s, deg);\r\n        q = eAdd(q, s);\r\n        r = subtractExact(r, eMultiply(s, b));\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=e-pdiv-internal.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-internal.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePdivTrivial": () => (/* binding */ ePdivTrivial)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n/* harmony import */ var _basic_expansion_e_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../basic/expansion/e-multiply-by-const.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply-by-const.js");\n/* harmony import */ var _e_pdiv_internal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-pdiv-internal.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-internal.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eDegree = _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_1__.eDegree;\r\nconst eAbs = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs;\r\nconst eIntPow = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eIntPow;\r\n/**\r\n * Performs a **trivial pseudo-division** and returns the `quotient` and `remainder`\r\n * of the pseudo division of `a/b` (a, b both being polynomials) in such a way\r\n * that all intermediate calculations and the final result are done in ℤ, i.e.\r\n * performs Euclidean (i.e. long) division on the two given polynomials, a/b,\r\n * and returns a scaled `r` and `q` in the formula `a = bq + r`, where\r\n * `degree(r) < degree(b)`. `q` is called the quotient and `r` the remainder.\r\n *\r\n * * **precondition:** the coefficients must integers (and also Shewchuk\r\n * floating point expansions); if they are not they can easily be scaled from\r\n * floating point numbers to Shewchuk expansions by calling [[scaleFloatsToInts]]\r\n * or similar before calling this function (recall that all floating point\r\n * numbers are rational).\r\n *\r\n * * Intermediate calculations (and the input coefficients) are done in\r\n * infinite precision up to overlow (meaning integers can be represented\r\n * *exactly* up to `2^1024 === 1797...(300 more digits)...37216`) and may\r\n * thus not be applicable to very high degree polynomials (in which case it is\r\n * better to use [[bPdivTrivial]])\r\n *\r\n * * **precondition:** b !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * see [trivial pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)\r\n * * see also [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)\r\n * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)\r\n * * see also [subresultant pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence)\r\n *\r\n * @param a the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of integer Shewchuk expansions from\r\n * highest to lowest power, e.g. `[[5],[-3],[0]]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b the polynomial b in the formula a = bq + r\r\n * @param positiveMultiplier defaults to false - if set to true then the\r\n * multiplier (of the coefficients of the dividend)\r\n * `leadingCoeff(b)^(deg(a)-deg(b)+1)` will be\r\n * modified to `abs(leadingCoeff(b)^(deg(a)-deg(b)+1))`\r\n *\r\n * @doc\r\n */\r\nfunction ePdivTrivial(a, b, positiveMultiplier = false) {\r\n    // change to pseudo-remainder, i.e. not simply r = a; this allows the \r\n    // remainders to stay in \'Z\', i.e. let m = leadingCoeff(b)^(deg(a)-deg(b)+1)\r\n    const d = eDegree(a) - eDegree(b) + 1;\r\n    if (d < 1) {\r\n        return { q: [], r: a };\r\n    }\r\n    let m = eIntPow(b[0], d);\r\n    m = positiveMultiplier\r\n        ? eAbs(m)\r\n        : m;\r\n    const a_ = (0,_basic_expansion_e_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_2__.eMultiplyByConst)(m, a);\r\n    return (0,_e_pdiv_internal_js__WEBPACK_IMPORTED_MODULE_3__.ePdivInternal)(a_, b);\r\n}\r\n\r\n//# sourceMappingURL=e-pdiv-trivial.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-primitive.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePremSequencePrimitive": () => (/* binding */ ePremSequencePrimitive)\n/* harmony export */ });\n/* harmony import */ var _e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js");\n/* harmony import */ var _factor_expansion_e_primitive_part_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../factor/expansion/e-primitive-part.js */ "./node_modules/flo-poly/node/factor/expansion/e-primitive-part.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ePdivTrivial = _e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_0__.ePdivTrivial;\r\nconst eGetPrimitivePart = _factor_expansion_e_primitive_part_js__WEBPACK_IMPORTED_MODULE_1__.ePrimitivePart;\r\n/**\r\n * Returns the primitive pseudo remainder sequence of a/b.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n* * see [Primitive Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of Shewchuk expansions from highest to\r\n * lowest power, e.g. `[[5],[-3],[0]]` represents the  polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r;\r\n *\r\n * @doc\r\n */\r\nfunction ePremSequencePrimitive(f, g) {\r\n    const r = [f, g]; // Initialize the PRS\r\n    let i = 1;\r\n    while (true) {\r\n        let r_ = ePdivTrivial(r[i - 1], r[i]).r;\r\n        r_ = eGetPrimitivePart(r_);\r\n        if (r_.length === 0) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (r_.length === 1) {\r\n            // the remainder is a constant so the next remainder \r\n            // will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=e-prem-sequence-primitive.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-primitive.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePremSequenceSubresultant": () => (/* binding */ ePremSequenceSubresultant)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _basic_expansion_e_is_const_or_zero_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/expansion/e-is-const-or-zero.js */ "./node_modules/flo-poly/node/basic/expansion/e-is-const-or-zero.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n/* harmony import */ var _e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./e-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ePdivTrivial = _e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_3__.ePdivTrivial;\r\nconst eIsConstOrZero = _basic_expansion_e_is_const_or_zero_js__WEBPACK_IMPORTED_MODULE_1__.eIsConstOrZero;\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst eIntPow = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eIntPow;\r\nconst eDiv = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiv;\r\nconst eNegativeOf = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eNegativeOf;\r\nconst eDegree = _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_2__.eDegree;\r\n/**\r\n * Returns the subresultant pseudo remainder sequence of a/b.\r\n *\r\n * * **precondition:** g !== [], i.e. unequal to the zero polynomial.\r\n *\r\n * * **precondition:** the coefficients must be integer Shewchuk floating point\r\n * expansions; if they are not they can easily be scaled from\r\n * floating point numbers to Shewchuk expansions by calling [[scaleFloatsToInts]]\r\n * or similar before calling this function (recall that all floating point\r\n * numbers are rational).\r\n *\r\n * * Intermediate calculations (and the input coefficients) are done in\r\n * infinite precision up to overlow (meaning integers can be represented\r\n * *exactly* up to `2^1024 === 1797...(300 more digits)...37216`) and may\r\n * thus not be applicable to very high degree polynomials (in which case it is\r\n * better to use [[bPremSequenceSubresultant]])\r\n *\r\n * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)\r\n *\r\n * @param f the polynomial a in the formula a = bq + r; the polynomial is given\r\n * with coefficients as a dense array of integer Shewchuk expansions from\r\n * highest to lowest power, e.g. `[[5],[-3],[0]]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param g the polynomial b in the formula a = bq + r\r\n * @param sturm if set to true then calculate a Sturm sequence instead\r\n *\r\n * @doc\r\n */\r\nfunction ePremSequenceSubresultant(f, g, sturm = false) {\r\n    const r = [f, g]; // Initialize the PRS\r\n    const d = [eDegree(f), eDegree(g)];\r\n    const a = [[1]]; // a_1 === 1\r\n    const c = [[1]]; // c_1 === 1\r\n    let i = 2;\r\n    while (true) {\r\n        a.push(r[i - 1][0]); // leading coefficient of r[i-1]\r\n        const d_ = d[i - 2] - d[i - 1];\r\n        const sgn = sturm\r\n            ? -1\r\n            : (d_ + 1) % 2 === 0 ? +1 : -1;\r\n        const D = expansionProduct(a[i - 2], eIntPow(c[i - 2], d_));\r\n        const exp = -d_ + 1;\r\n        const cTerm1 = eIntPow(a[i - 1], d_);\r\n        const cTerm2 = eIntPow(c[i - 2], Math.abs(exp));\r\n        c.push(exp < 0\r\n            ? eDiv(cTerm1, cTerm2, 0)\r\n            : expansionProduct(cTerm1, cTerm2));\r\n        let r_ = ePdivTrivial(r[i - 2], r[i - 1], sturm).r\r\n            .map(coeff => eDiv(coeff, D, 0));\r\n        r_ = sgn > 0 ? r_ : r_.map(eNegativeOf);\r\n        d.push(eDegree(r_));\r\n        if (r_.length === 0) {\r\n            return r;\r\n        }\r\n        r.push(r_);\r\n        if (eIsConstOrZero(r_)) {\r\n            // the remainder is a constant so the next remainder \r\n            // will be 0 anyway\r\n            return r;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=e-prem-sequence-subresultant.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js?')},"./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eSturmChain": () => (/* binding */ eSturmChain)\n/* harmony export */ });\n/* harmony import */ var _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/expansion/e-differentiate.js */ "./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js");\n/* harmony import */ var _e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./e-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js");\n/* harmony import */ var _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scale-to-int/scale-floatss-to-intss.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eDifferentiate = _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_0__.eDifferentiate;\r\nconst ePremSequenceSubresultant = _e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_1__.ePremSequenceSubresultant;\r\nconst scaleFloatssToIntss = _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_2__.scaleFloatssToIntss;\r\n/**\r\n * Returns the Sturm chain for the given polynomial using pseudo remainders.\r\n *\r\n * * see [Sturm\'s Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)\r\n * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eSturmChain([[-3],[4],[2],[-2]]); //=> [[[-3],[4],[2],[-2]],[[-9],[8],[2]],[[-204],[138]],[[-1692]]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eSturmChain(p) {\r\n    p = scaleFloatssToIntss(p);\r\n    const dp = eDifferentiate(p);\r\n    return ePremSequenceSubresultant(p, dp, true);\r\n}\r\n\r\n//# sourceMappingURL=e-sturm-chain.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js?')},"./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-0.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bEvaluateAt0": () => (/* binding */ bEvaluateAt0)\n/* harmony export */ });\n/**\r\n * Returns the constant term of the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bEvaluateAt0([3n,2n,99n]); //=> 99n\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bEvaluateAt0(p) {\r\n    return p.length === 0 ? 0n : p[p.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=b-evaluate-at-0.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-0.js?')},"./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bEvaluateAt1": () => (/* binding */ bEvaluateAt1)\n/* harmony export */ });\n/**\r\n * Returns the exact result of evaluating the given polynomial at 1.\r\n *\r\n * * faster than at an arbitrary point.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bEvaluateAt1(p) {\r\n    let res = 0n;\r\n    for (let i = 0; i < p.length; i++) {\r\n        res += p[i];\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=b-evaluate-at-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-1.js?')},"./node_modules/flo-poly/node/evaluate/bigint/b-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bHorner\": () => (/* binding */ bHorner)\n/* harmony export */ });\n/**\r\n * Returns the result of evaluating (at an integer value) a univariate\r\n * polynomial with bigint coefficients using Horner's method.\r\n *\r\n * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction bHorner(p, x) {\r\n    let q = 0n;\r\n    for (let i = 0; i < p.length; i++) {\r\n        q = q * x + p[i];\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=b-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/bigint/b-horner.js?")},"./node_modules/flo-poly/node/evaluate/double/abs-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AbsHorner": () => (/* binding */ AbsHorner)\n/* harmony export */ });\nconst abs = Math.abs;\r\n/**\r\n * Returns the result of evaluating a univariate polynomial using\r\n * Horner\'s method and where the absolute value of each coefficient is taken.\r\n *\r\n * * intermediate calculations are done in double precision\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which `p` should be evaluated\r\n *\r\n * @doc\r\n */\r\nfunction AbsHorner(p, x) {\r\n    let q = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        q = q * x + abs(p[i]);\r\n    }\r\n    return q;\r\n}\r\n// inlined (with q => e2, p => p0)\r\n//let e2 = abs(p0[0]); for (let i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }\r\n\r\n//# sourceMappingURL=abs-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/abs-horner.js?')},"./node_modules/flo-poly/node/evaluate/double/comp-horner-is-faithful.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "compHornerIsFaithful": () => (/* binding */ compHornerIsFaithful)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _horner_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner-sum.js */ "./node_modules/flo-poly/node/evaluate/double/horner-sum.js");\n/* harmony import */ var _horner_abs_sum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./horner-abs-sum.js */ "./node_modules/flo-poly/node/evaluate/double/horner-abs-sum.js");\n/* harmony import */ var _gammas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gammas.js */ "./node_modules/flo-poly/node/evaluate/double/gammas.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst HornerSum = _horner_sum_js__WEBPACK_IMPORTED_MODULE_2__.HornerSum;\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__.EFTHorner;\r\nconst HornerAbsSum = _horner_abs_sum_js__WEBPACK_IMPORTED_MODULE_3__.HornerAbsSum;\r\nconst γs = _gammas_js__WEBPACK_IMPORTED_MODULE_4__["γs"];\r\nconst u = Number.EPSILON;\r\n/**\r\n * Returns the result of evaluating a univariate polynomial using once compensated\r\n * Horner\'s method, including a dynamic check for faithfull rounding and a\r\n * certified running error bound.\r\n *\r\n * * once compensated means the error in the evaluation is reduced by roughly\r\n * `1 / Number.EPSILON` which is again roughly `2^53` - it is the same as using\r\n * double-double precision in a normal Horner evaluation\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see also [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction compHornerIsFaithful(p, x) {\r\n    const n = p.length - 1;\r\n    const { r̂, pπ, pσ } = EFTHorner(p, x);\r\n    const ĉ = HornerSum(pπ, pσ, x);\r\n    const [e, r̄] = twoSum(r̂, ĉ);\r\n    const b̂ = HornerAbsSum(pπ, pσ, Math.abs(x));\r\n    const α̂ = (γs(2 * n - 1) * b̂) / ((1 - 2 * (n + 1) * u));\r\n    const β̂ = (α̂ + Math.abs(e)) / (1 - 2 * u);\r\n    return {\r\n        isFaithful: α̂ < (u / 2) * Math.abs(r̄),\r\n        errBound: β̂,\r\n        r̄\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=comp-horner-is-faithful.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/comp-horner-is-faithful.js?')},"./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "CompHornerK": () => (/* binding */ CompHornerK)\n/* harmony export */ });\n/* harmony import */ var _sum_k_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sum-k.js */ "./node_modules/flo-poly/node/evaluate/double/sum-k.js");\n/* harmony import */ var _eft_horner_k_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eft-horner-k.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner-k.js");\n/* harmony import */ var _horner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner.js */ "./node_modules/flo-poly/node/evaluate/double/horner.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst SumK = _sum_k_js__WEBPACK_IMPORTED_MODULE_0__.SumK;\r\nconst EFTHornerK = _eft_horner_k_js__WEBPACK_IMPORTED_MODULE_1__.EFTHornerK;\r\nconst Horner = _horner_js__WEBPACK_IMPORTED_MODULE_2__.Horner;\r\n/**\r\n * Returns a result of evaluating a univariate polynomial using K times compensated\r\n * Horner\'s method.\r\n *\r\n * * K times compensated means the error in the evaluation is reduced by roughly\r\n * `(1 / Number.EPSILON)**K` which is again roughly `2^(53*K)` - it is the same as using\r\n * double-double-.... (K times) precision in a normal Horner evaluation\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, `Stef Graillat, Philippe Langlois, Nicolas Louvet`](https://hal.archives-ouvertes.fr/hal-00285603/document)\r\n * * for K-times compensated with K <= 4 this is the fastest known method, but\r\n * the running time grows exponentially with K.\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see also [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n * @param K (K - 1) === the number of compensations to do\r\n *\r\n * @doc\r\n */\r\nfunction CompHornerK(p, x, K) {\r\n    K = Math.min(p.length - 1, K);\r\n    const { hs, ps } = EFTHornerK(p, x, K);\r\n    const leafStart = 2 ** (K - 1); // cardinality and start of the leaves\r\n    for (let i = 0; i < leafStart; i++) {\r\n        hs.push(Horner(ps[leafStart + i], x));\r\n    }\r\n    const r̄ = SumK(hs, K);\r\n    return r̄;\r\n}\r\n\r\n//# sourceMappingURL=comp-horner-k.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js?')},"./node_modules/flo-poly/node/evaluate/double/comp-horner-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "compHornerWithRunningError": () => (/* binding */ compHornerWithRunningError)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _horner_sum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner-sum.js */ "./node_modules/flo-poly/node/evaluate/double/horner-sum.js");\n/* harmony import */ var _horner_abs_sum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./horner-abs-sum.js */ "./node_modules/flo-poly/node/evaluate/double/horner-abs-sum.js");\n/* harmony import */ var _gammas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gammas.js */ "./node_modules/flo-poly/node/evaluate/double/gammas.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_1__.EFTHorner;\r\nconst HornerSum = _horner_sum_js__WEBPACK_IMPORTED_MODULE_2__.HornerSum;\r\nconst HornerAbsSum = _horner_abs_sum_js__WEBPACK_IMPORTED_MODULE_3__.HornerAbsSum;\r\nconst γs = _gammas_js__WEBPACK_IMPORTED_MODULE_4__["γs"];\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of evaluating a univariate polynomial using once compensated\r\n * Horner\'s method, including a certified running error bound as an array in the\r\n * form: [result, absolute error].\r\n *\r\n * * Exactly the same as compHornerIsFaithful, except that it does not include\r\n * a faithfully rounded check.\r\n *\r\n * * once compensated means the error in the evaluation is reduced by roughly\r\n * `1 / Number.EPSILON` which is again roughly `2^53` - it is the same as using\r\n * double-double precision in a normal Horner evaluation\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see also [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction compHornerWithRunningError(p, x) {\r\n    const n = p.length - 1;\r\n    const { r̂, pπ, pσ } = EFTHorner(p, x);\r\n    // inlined\r\n    //const pπ: number[] = []; const pσ: number[] = []; const σ: number; const r̂ = p[0];\tfor (const i=1; i<p.length; i++) { const [π,pi] = twoProduct(r̂,x); [σ,r̂] = twoSum(pi, p[i]); pπ.push(π); pσ.push(σ); }\r\n    const ĉ = HornerSum(pπ, pσ, x);\r\n    const [e, r̄] = twoSum(r̂, ĉ);\r\n    const b̂ = HornerAbsSum(pπ, pσ, Math.abs(x));\r\n    const α̂ = (γs(2 * n - 1) * b̂) / ((1 - 2 * (n + 1) * u));\r\n    const β̂ = (α̂ + Math.abs(e)) / (1 - 2 * u);\r\n    return [r̄, β̂];\r\n}\r\n\r\n//# sourceMappingURL=comp-horner-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/comp-horner-with-running-error.js?')},"./node_modules/flo-poly/node/evaluate/double/comp-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "compHorner": () => (/* binding */ compHorner)\n/* harmony export */ });\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _horner_sum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./horner-sum.js */ "./node_modules/flo-poly/node/evaluate/double/horner-sum.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__.EFTHorner;\r\nconst HornerSum = _horner_sum_js__WEBPACK_IMPORTED_MODULE_1__.HornerSum;\r\n/**\r\n * Returns a result of evaluating a univariate polynomial using once compensated\r\n * Horner\'s method.\r\n *\r\n * * once compensated means the error in the evaluation is reduced by roughly\r\n * `1 / Number.EPSILON` which is again roughly `2^53` - it is equivalent as using\r\n * double-double precision in a normal Horner evaluation\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction compHorner(p, x) {\r\n    const { r̂, pπ, pσ } = EFTHorner(p, x);\r\n    const ĉ = HornerSum(pπ, pσ, x);\r\n    return r̂ + ĉ;\r\n}\r\n\r\n//# sourceMappingURL=comp-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/comp-horner.js?')},"./node_modules/flo-poly/node/evaluate/double/eft-horner-k.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "EFTHornerK": () => (/* binding */ EFTHornerK)\n/* harmony export */ });\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__.EFTHorner;\r\n/**\r\n * @param p\r\n * @param x\r\n * @param K\r\n *\r\n * @internal\r\n */\r\nfunction EFTHornerK(p, x, K) {\r\n    const ps = [p];\r\n    const hs = [];\r\n    const card = (2 ** K) - 1; // size of the tree, i.e. cardinality of the nodes\r\n    for (let i = 0; i < card; i++) {\r\n        const { r̂, pπ, pσ } = EFTHorner(ps[i], x);\r\n        hs.push(r̂);\r\n        ps.push(pπ);\r\n        ps.push(pσ);\r\n    }\r\n    return { hs, ps: ps.slice(2 ** (K - 1)) };\r\n}\r\n\r\n//# sourceMappingURL=eft-horner-k.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/eft-horner-k.js?')},"./node_modules/flo-poly/node/evaluate/double/eft-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "EFTHorner": () => (/* binding */ EFTHorner)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst twoProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoProduct;\r\n/**\r\n * Returns an EFT (error free transformation) for the Horner evaluation of a\r\n * polymial at a specified x. The result is returned as an object with\r\n * properties: r̂ -> the calculated evaluation, pπ and pσ -> two polynomials\r\n * with coefficients around 2^53 times smaller than the input polynomial.\r\n *\r\n * * r̂ + pπ(x) + pσ(x) = the *exact* evaluation (no error)\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see also [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction EFTHorner(p, x) {\r\n    const pπ = []; // A polynomial containing part of the error\r\n    const pσ = []; // Another polynomial containing part of the error\r\n    let σ;\r\n    let r̂ = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        const [π, pi] = twoProduct(r̂, x);\r\n        [σ, r̂] = twoSum(pi, p[i]);\r\n        // inlined\r\n        //r̂ = pi + p[i]; const bv = r̂ - pi; σ = (pi - (x-bv)) + (p[i]-bv);\r\n        pπ.push(π);\r\n        pσ.push(σ);\r\n    }\r\n    return { r̂, pπ, pσ };\r\n}\r\n// inlined\r\n//const pπ: number[] = []; const pσ: number[] = []; const σ: number; const r̂ = p[0];\tfor (const i=1; i<p.length; i++) { const [π,pi] = twoProduct(r̂,x); [σ,r̂] = twoSum(pi, p[i]); pπ.push(π); pσ.push(σ); } return { r̂, pπ, pσ }\r\n\r\n//# sourceMappingURL=eft-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/eft-horner.js?')},"./node_modules/flo-poly/node/evaluate/double/eval-certified-incl-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalCertifiedInclError": () => (/* binding */ evalCertifiedInclError)\n/* harmony export */ });\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js");\n/* harmony import */ var _horner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner.js */ "./node_modules/flo-poly/node/evaluate/double/horner.js");\n/* harmony import */ var _abs_horner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abs-horner.js */ "./node_modules/flo-poly/node/evaluate/double/abs-horner.js");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/gamma.js */ "./node_modules/flo-poly/node/error-analysis/gamma.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst γ = _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_4__["γ"];\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__.EFTHorner;\r\nconst hornerWithRunningError = _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.hornerWithRunningError;\r\nconst Horner = _horner_js__WEBPACK_IMPORTED_MODULE_2__.Horner;\r\nconst AbsHorner = _abs_horner_js__WEBPACK_IMPORTED_MODULE_3__.AbsHorner;\r\nconst γ1 = γ(1);\r\nconst γ2 = γ(2);\r\n/**\r\n * Returns the result of evaluating the given polynomial (with specified\r\n * coefficient-wise error bounds) at `x` such that the sign is correct when\r\n * positive or negative and undecided when 0 - an additional `multiplier`\r\n * parameter can enforce additional bits (beyond the sign bit) to be correct.\r\n *\r\n * * designed to be fast in \'easy\' cases (say condition number < 2^53) and\r\n * harder cases (condition number < 2^106) since nearly all typical\r\n * calculations will have condition number < 2^106\r\n * * a staggered approach is used - first double precision, then simulated\r\n * double-double precision (i.e. once compensated Horner evluation) is tried\r\n * before giving up and returning 0 - see point below\r\n * * if zero is returned then the calculated result is too close to 0 to\r\n * determine the sign; the caller of this function can then resort to a more\r\n * accurate (possibly exact) evaluation\r\n *\r\n * @param p an array of 2 polynomials with coefficients given densely as an\r\n * array of double precision floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`;\r\n * the first polynomial\'s coefficients represent the \'high part\' (a double) of a\r\n * double-double precision value, while the second polynomial\'s coefficients\r\n * represent the \'low part\', i.e. designating `hp` for high part and `lp` for\r\n * low part it must be that they are non-overlapping -> `twoSum(lp,hp)` will\r\n * equal `[lp,hp]`; put another way, if the given polynomial is given as e.g. a\r\n * linear polynomial with coefficients in double precision,\r\n * e.g. `[[1.7053025658242404e-13, 2354.33721613], [-7.105427357601002e-15,284.5673337]]`\r\n * then this parameter, `p`, should be `[[2354.33721613], 284.5673337], [1.7053025658242404e-13, -7.105427357601002e-15]]`\r\n * which is simply the result of transposing the original polynomial if it is\r\n * seen as a matrix\r\n * @param pE defaults to `undefined`; an error polynomial that provides a\r\n * coefficient-wise error bound on the input polynomial; all coefficients must\r\n * be positive; if `undefined` then the input polynomial will be assumed exact\r\n * @param x the value at which to evaluate the polynomial\r\n * @param multiplier defaults to 1; the final calculation error needs to be a\r\n * multiple of this number smaller than the evaluated value, otherwise zero is\r\n * returned - useful if not only the sign is important but also some bits, e.g.\r\n * if multiplier = 8 then 3 bits will have to be correct otherwise 0 is returned\r\n *\r\n * @doc\r\n */\r\nfunction evalCertifiedInclError(p, x, pE = undefined, multiplier = 1) {\r\n    const absX = Math.abs(x);\r\n    // first do a fast evaluation\r\n    const [r, e1] = hornerWithRunningError(p[0], x);\r\n    // the line below was changed due to negative values of x now also allowed\r\n    const e2 = γ2 * AbsHorner(p[0], absX); // the error due to not considering p[1]\r\n    // error due to imprecision in coefficients\r\n    // the line below was changed due to negative values of x now also allowed\r\n    //const E = pE ? Horner(pE, x) : 0; \r\n    const E = pE !== undefined\r\n        ? Horner(pE, absX)\r\n        : 0;\r\n    const ee = e1 + e2 + E; // in difficult cases E can be larger than e1+e2\r\n    if (ee * multiplier < Math.abs(r)) {\r\n        // we are within bounds\r\n        return { r̂: r, e: ee };\r\n    }\r\n    // error is too large - do a more precise evaluation\r\n    let { r̂, pπ, pσ } = EFTHorner(p[0], x);\r\n    const [C1, c1] = hornerWithRunningError(pπ, x);\r\n    const [C2, c2] = hornerWithRunningError(pσ, x);\r\n    const [C3, c3] = hornerWithRunningError(p[1], x);\r\n    let e = (c1 + c2 + c3) + E; // typically: c1,c2 < c3 < E\r\n    r̂ = (C1 + C2 + C3) + r̂; // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)\r\n    e += γ1 * r̂;\r\n    if (e * multiplier < Math.abs(r̂)) {\r\n        return { r̂, e };\r\n    }\r\n    // error is still too large to return the correct sign (if multiplier === 1)\r\n    return { r̂: 0, e };\r\n}\r\n\r\n//# sourceMappingURL=eval-certified-incl-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/eval-certified-incl-error.js?')},"./node_modules/flo-poly/node/evaluate/double/eval-certified.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalCertified": () => (/* binding */ evalCertified)\n/* harmony export */ });\n/* harmony import */ var _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js");\n/* harmony import */ var _horner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horner.js */ "./node_modules/flo-poly/node/evaluate/double/horner.js");\n/* harmony import */ var _abs_horner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abs-horner.js */ "./node_modules/flo-poly/node/evaluate/double/abs-horner.js");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error-analysis/gamma.js */ "./node_modules/flo-poly/node/error-analysis/gamma.js");\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst γ = _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_4__["γ"];\r\nconst EFTHorner = _eft_horner_js__WEBPACK_IMPORTED_MODULE_0__.EFTHorner;\r\nconst hornerWithRunningError = _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_1__.hornerWithRunningError;\r\nconst Horner = _horner_js__WEBPACK_IMPORTED_MODULE_2__.Horner;\r\nconst AbsHorner = _abs_horner_js__WEBPACK_IMPORTED_MODULE_3__.AbsHorner;\r\nconst γ1 = γ(1);\r\nconst γ2 = γ(2);\r\n/**\r\n * Returns the result of evaluating the given polynomial (with specified\r\n * coefficient-wise error bounds) at x such that the sign is correct when\r\n * positive or negative and undecided when 0 - an additional `multiplier`\r\n * parameter can enforce additional bits (beyond the sign) to be correct.\r\n *\r\n * * designed to be fast in \'easy\' cases (say condition number < 2^53) and\r\n * harder cases (condition number < 2^106) since nearly all typical\r\n * calculations will have condition number < 2^106\r\n * * a staggered approach is used - first double precision, then simulated\r\n * double-double precision (i.e. once compensated Horner evluation) is tried\r\n * before giving up and returning 0 - see point below\r\n * * if zero is returned then the calculated result is too close to 0 to\r\n * determine the sign; the caller of this function can then resort to a more\r\n * accurate (possibly exact) evaluation\r\n *\r\n * @param p an array of 2 polynomials with coefficients given densely as an\r\n * array of double precision floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`;\r\n * the first polynomial\'s coefficients represent the \'high part\' (a double) of a\r\n * double-double precision value, while the second polynomial\'s coefficients\r\n * represent the \'low part\', i.e. designating `hp` for high part and `lp` for\r\n * low part it must be that they are non-overlapping -> `twoSum(lp,hp)` will\r\n * equal `[lp,hp]`; put another way, if the given polynomial is given as e.g. a\r\n * linear polynomial with coefficients in double precision,\r\n * e.g. `[[1.7053025658242404e-13, 2354.33721613], [-7.105427357601002e-15,284.5673337]]`\r\n * then this parameter, `p`, should be `[[2354.33721613], 284.5673337], [1.7053025658242404e-13, -7.105427357601002e-15]]`\r\n * which is simply the result of transposing the original polynomial if it is\r\n * seen as a matrix\r\n * @param pE defaults to `undefined`; an error polynomial that provides a\r\n * coefficient-wise error bound on the input polynomial; all coefficients must\r\n * be positive; if `undefined` then the input polynomial will be assumed exact\r\n * @param x the value at which to evaluate the polynomial\r\n * @param multiplier defaults to 1; the final calculation error needs to be a\r\n * multiple of this number smaller than the evaluated value, otherwise zero is\r\n * returned - useful if not only the sign is important but also some bits, e.g.\r\n * if multiplier = 8 then 3 bits will have to be correct otherwise 0 is returned\r\n *\r\n * @doc\r\n */\r\nfunction evalCertified(p, x, pE = undefined, multiplier = 1) {\r\n    const absX = Math.abs(x);\r\n    const p0 = p[0];\r\n    // first do a fast evaluation\r\n    const [r, e1] = hornerWithRunningError(p0, x);\r\n    // inlined above line:\r\n    //const r = p0[0]; const e1 = Math.abs(r) / 2; for (const i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));\r\n    /** the error due to not considering p[1] */\r\n    // the line below was changed due to negative values of x now also allowed\r\n    const e2 = γ2 * AbsHorner(p0, absX);\r\n    // inlined above line:\r\n    //const e2 = abs(p0[0]); for (const i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }\r\n    /** error due to imprecision in coefficients */\r\n    // the line below was changed due to negative values of x now also allowed\r\n    const E = pE !== undefined ? Horner(pE, absX) : 0;\r\n    //const E = p0[0]; for (const i=1; i<p0.length; i++) {E = E*x + p0[i]; }\r\n    const ee = e1 + e2 + E; // in difficult cases E can be larger than e1+e2\r\n    if (ee * multiplier < Math.abs(r)) {\r\n        // we are within bounds\r\n        return r;\r\n    }\r\n    // error is too large - do a more precise evaluation (i.e. once compensated\r\n    // with K === 2)\r\n    let { r̂, pπ, pσ } = EFTHorner(p0, x);\r\n    const [C1, c1] = hornerWithRunningError(pπ, x);\r\n    const [C2, c2] = hornerWithRunningError(pσ, x);\r\n    const [C3, c3] = hornerWithRunningError(p[1], x);\r\n    // typically: c1,c2 < c3 < E\r\n    let e = (c1 + c2 + c3) + E;\r\n    // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)\r\n    r̂ = (C1 + C2 + C3) + r̂;\r\n    e += γ1 * r̂;\r\n    if (e * multiplier < Math.abs(r̂)) {\r\n        return r̂;\r\n    }\r\n    // error is still too large to return the correct sign (if multiplier === 1)\r\n    return 0;\r\n}\r\n\r\n//# sourceMappingURL=eval-certified.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/eval-certified.js?')},"./node_modules/flo-poly/node/evaluate/double/eval-k.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalK": () => (/* binding */ evalK),\n/* harmony export */   "evalK2": () => (/* binding */ evalK2),\n/* harmony export */   "evalK4": () => (/* binding */ evalK4)\n/* harmony export */ });\n/* harmony import */ var _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js");\n/* harmony import */ var _comp_horner_k_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comp-horner-k.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js");\n/* harmony import */ var _comp_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comp-horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-with-running-error.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst hornerWithRunningError = _horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_0__.hornerWithRunningError;\r\nconst CompHornerK = _comp_horner_k_js__WEBPACK_IMPORTED_MODULE_1__.CompHornerK;\r\nconst compHornerWithRunningError = _comp_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_2__.compHornerWithRunningError;\r\n/**\r\n * Returns the result of evaluating the given polynomial at `x` such that at least\r\n * the sign bit is correct *up to 3-times compensated evaluation (K = 4)*, i.e.\r\n * as if evaluating in double-double-double-double precision.\r\n *\r\n * * uses a staggered algorithm, first trying in double precision, then in\r\n * double-double and finally in double-double-double-double\r\n *\r\n * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)\r\n * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)\r\n * * see also [Horner\'s Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction evalK(p, x) {\r\n    const [r̂, e] = hornerWithRunningError(p, x);\r\n    // inlined \r\n    //const r̂ = p[0]; const e = Math.abs(r̂) / 2; for (const i=1; i<p.length; i++) { r̂ = r̂*x + p[i]; e = Math.abs(x)*e + Math.abs(r̂); } e = Number.EPSILON * (2*e - Math.abs(r̂));\r\n    if (Math.abs(r̂) - e < 0) {\r\n        return evalK2(p, x);\r\n        // inlined\r\n        //[r̂, e] = compHornerWithRunningError(p, x); if (Math.abs(r̂) - e < 0) { return evalK4(p, x); } return { r̂, level: 2 }\r\n    }\r\n    return r̂;\r\n}\r\nfunction evalK2(p, x) {\r\n    const [r̂, e] = compHornerWithRunningError(p, x);\r\n    if (Math.abs(r̂) - e < 0) {\r\n        return evalK4(p, x);\r\n    }\r\n    return r̂;\r\n}\r\n// inlined\r\n//[r̂, e] = compHornerWithRunningError(p, x); if (Math.abs(r̂) - e < 0) { return evalK4(p, x); } return { r̂, level: 2 }\r\nfunction evalK4(p, x) {\r\n    const r̂ = CompHornerK(p, x, 4);\r\n    return r̂;\r\n}\r\n\r\n//# sourceMappingURL=eval-k.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/eval-k.js?')},"./node_modules/flo-poly/node/evaluate/double/evaluate-at-0.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateAt0": () => (/* binding */ evaluateAt0)\n/* harmony export */ });\n/**\r\n * Returns the constant term of the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * evaluateAt0([3,2,99]); //=> 99\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction evaluateAt0(p) {\r\n    return p.length === 0 ? 0 : p[p.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=evaluate-at-0.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/evaluate-at-0.js?')},"./node_modules/flo-poly/node/evaluate/double/evaluate-at-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evaluateAt1": () => (/* binding */ evaluateAt1)\n/* harmony export */ });\n/**\r\n * Returns the result of evaluating the given polynomial at 1 using double\r\n * precision for intermediate calculations.\r\n *\r\n * * faster than at an arbitrary point.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction evaluateAt1(p) {\r\n    let res = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        res += p[i];\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=evaluate-at-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/evaluate-at-1.js?')},"./node_modules/flo-poly/node/evaluate/double/gammas.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "γs": () => (/* binding */ γs)\n/* harmony export */ });\nconst u = Number.EPSILON / 2;\r\n// cache standard error bound units\r\nconst _γs = [];\r\n/** @internal */\r\nfunction γs(n) {\r\n    return _γs[n] || ((1 + u) * (n * u / (1 - n * u)));\r\n}\r\n\r\n//# sourceMappingURL=gammas.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/gammas.js?')},"./node_modules/flo-poly/node/evaluate/double/horner-abs-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "HornerAbsSum": () => (/* binding */ HornerAbsSum)\n/* harmony export */ });\n/**\r\n * @param p1\r\n * @param p2\r\n *\r\n * @internal\r\n */\r\nfunction HornerAbsSum(p1, p2, x) {\r\n    let q = 0;\r\n    for (let i = 0; i < p1.length; i++) {\r\n        // TODO - Math.abs(p1[i] + p2[i]) <-- should this be Math.abs(p1[i]) + Math.abs(p2[i]) ??\r\n        q = Math.abs(p1[i] + p2[i]) + q * x;\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=horner-abs-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/horner-abs-sum.js?')},"./node_modules/flo-poly/node/evaluate/double/horner-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "HornerSum": () => (/* binding */ HornerSum)\n/* harmony export */ });\n/**\r\n * * helper function\r\n *\r\n * @param p1\r\n * @param p2\r\n *\r\n * @internal\r\n */\r\nfunction HornerSum(p1, p2, a) {\r\n    let result = 0;\r\n    for (let i = 0; i < p1.length; i++) {\r\n        result = p1[i] + p2[i] + result * a;\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=horner-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/horner-sum.js?')},"./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "hornerWithRunningError": () => (/* binding */ hornerWithRunningError)\n/* harmony export */ });\nconst abs = Math.abs;\r\nconst u = Number.EPSILON / 2;\r\n/**\r\n * Returns the result of evaluating a polyniomial at a point x, including a\r\n * running error bound as an array in the form `[r,e]` where `r` is the result\r\n * of the evaluation and `e` is the error.\r\n *\r\n * * see e.g. page 95 (at bottom) of [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction hornerWithRunningError(p, x) {\r\n    let r̂ = p[0];\r\n    let e = abs(r̂) * 0.5;\r\n    for (let i = 1; i < p.length; i++) {\r\n        r̂ = r̂ * x + p[i];\r\n        e = e * abs(x) + abs(r̂);\r\n    }\r\n    e = u * (2 * e - abs(r̂));\r\n    return [r̂, e];\r\n}\r\n// inlined (where r̂ => r, e => e1, p => p0)\r\n//let r = p0[0]; let e1 = Math.abs(r) / 2; for (let i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));\r\n\r\n//# sourceMappingURL=horner-with-running-error.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js?')},"./node_modules/flo-poly/node/evaluate/double/horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Horner\": () => (/* binding */ Horner)\n/* harmony export */ });\n/**\r\n * Returns the result of evaluating a univariate polynomial using\r\n * Horner's method in double precision floating point arithmetic.\r\n *\r\n * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction Horner(p, x) {\r\n    let q = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        q = q * x + p[i];\r\n    }\r\n    return q;\r\n}\r\n// inlined (with q => E, p => p0)\r\n//let E = p0[0]; for (let i=1; i<p0.length; i++) {E = E*x + p0[i]; }\r\n\r\n//# sourceMappingURL=horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/horner.js?")},"./node_modules/flo-poly/node/evaluate/double/sum-k.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "SumK": () => (/* binding */ SumK)\n/* harmony export */ });\n/* harmony import */ var _vec_sum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vec-sum.js */ "./node_modules/flo-poly/node/evaluate/double/vec-sum.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst vecSum = _vec_sum_js__WEBPACK_IMPORTED_MODULE_0__.vecSum;\r\n/**\r\n * * helper function - K compensated vector sum\r\n *\r\n * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf\r\n *\r\n * @param x\r\n * @param K\r\n *\r\n * @internal\r\n */\r\nfunction SumK(p, K) {\r\n    for (let i = 1; i < K; i++) {\r\n        p = vecSum(p);\r\n    }\r\n    let res = p[0];\r\n    for (let i = 1; i < p.length; i++) {\r\n        res += p[i];\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=sum-k.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/sum-k.js?')},"./node_modules/flo-poly/node/evaluate/double/vec-sum.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "vecSum": () => (/* binding */ vecSum)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\n/**\r\n * * helper function\r\n *\r\n * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf\r\n *\r\n * @param x\r\n * @param K\r\n *\r\n * @internal\r\n */\r\nfunction vecSum(p_) {\r\n    const p = p_.slice();\r\n    for (let i = 1; i < p.length; i++) {\r\n        [p[i - 1], p[i]] = twoSum(p[i], p[i - 1]);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=vec-sum.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/double/vec-sum.js?')},"./node_modules/flo-poly/node/evaluate/expansion/e-e-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eeHorner": () => (/* binding */ eeHorner)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst expansionProduct = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of evaluating a\r\n * univariate polynomial at a point given as a Shewchuk expansion using\r\n * Horner\'s method - the result is returned as a Shewchuk expansion.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction eeHorner(p, x) {\r\n    let result = [0];\r\n    for (let i = 0; i < p.length; i++) {\r\n        result = fastExpansionSum(p[i], expansionProduct(result, x));\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-e-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/expansion/e-e-horner.js?')},"./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-0.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eEvaluateAt0": () => (/* binding */ eEvaluateAt0)\n/* harmony export */ });\n/**\r\n * Returns the constant term of the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * evaluateAt0([[3],[2],[99]]); //=> [99]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eEvaluateAt0(p) {\r\n    return p.length === 0 ? [0] : p[p.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=e-evaluate-at-0.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-0.js?')},"./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eEvaluateAt1": () => (/* binding */ eEvaluateAt1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst fastExpansionSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of evaluating the given\r\n * polynomial at 1.\r\n *\r\n * * faster than at an arbitrary point.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eEvaluateAt1(p) {\r\n    let res = [0];\r\n    for (let i = 0; i < p.length; i++) {\r\n        res = fastExpansionSum(res, p[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\n//# sourceMappingURL=e-evaluate-at-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js?')},"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eHorner": () => (/* binding */ eHorner)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst fes = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.fastExpansionSum;\r\nconst sce = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.scaleExpansion;\r\n/**\r\n * Returns the exact result (bar underflow / overflow) of evaluating a\r\n * univariate polynomial using Horner\'s method - the result is returned as a\r\n * Shewchuk expansion.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param x the value at which to evaluate the polynomial\r\n *\r\n * @doc\r\n */\r\nfunction eHorner(p, x) {\r\n    let q = [0];\r\n    for (let i = 0; i < p.length; i++) {\r\n        q = fes(p[i], sce(q, x));\r\n    }\r\n    return q;\r\n}\r\n\r\n//# sourceMappingURL=e-horner.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/evaluate/expansion/e-horner.js?')},"./node_modules/flo-poly/node/factor/bigint/b-content.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bContent": () => (/* binding */ bContent)\n/* harmony export */ });\n/* harmony import */ var _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gcd/bigint/b-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bGcdInts = _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__.bGcdInts;\r\n// for some reason the tests fails if not done like below likely because Node\r\n// and TypeScript and BigInt doesn\'t work perfectly together yet\r\nconst b1 = 1n;\r\n/**\r\n * Returns cont(p), i.e. the content of the given polynomial defined as the\r\n * greatest common divisor of its coefficients.\r\n *\r\n * * the sign is chosen such that dividing the polynomial by cont(p) will\r\n * always result in a positive leading coefficient\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bContent(p) {\r\n    if (p.length === 0) {\r\n        // the zero polynomial\r\n        return b1;\r\n    }\r\n    return p[0] < 0n ? -bGcdInts(p) : bGcdInts(p);\r\n}\r\n\r\n//# sourceMappingURL=b-content.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/bigint/b-content.js?')},"./node_modules/flo-poly/node/factor/bigint/b-primitive-part.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPrimitivePart": () => (/* binding */ bPrimitivePart)\n/* harmony export */ });\n/* harmony import */ var _b_content_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b-content.js */ "./node_modules/flo-poly/node/factor/bigint/b-content.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bContent = _b_content_js__WEBPACK_IMPORTED_MODULE_0__.bContent;\r\n/**\r\n * Returns the primitive part of the given polynomial.\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * the sign is chosen such that the leading term coefficient is positive\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bPrimitivePart(p) {\r\n    const c = bContent(p);\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(p[i] / c);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=b-primitive-part.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/bigint/b-primitive-part.js?')},"./node_modules/flo-poly/node/factor/double/content.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "content": () => (/* binding */ content)\n/* harmony export */ });\n/* harmony import */ var _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gcd/double/integer-gcd.js */ "./node_modules/flo-poly/node/gcd/double/integer-gcd.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst gcdInts = _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__.gcdInts;\r\n/**\r\n * Returns cont(p), i.e. the content of the given polynomial defined as the\r\n * greatest common divisor of its coefficients.\r\n *\r\n * * the sign is chosen such that dividing the polynomial by cont(p) will\r\n * always result in a positive leading coefficient\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * * **precondition** p must have integer coefficients, else use e.g. [[scaleFloatsToInts]]\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double precision floating point numbers from highest to lowest power, e.g.\r\n * `[5,-3,0]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction content(p) {\r\n    if (p.length === 0) {\r\n        // the zero polynomial\r\n        return 1;\r\n    }\r\n    return Math.sign(p[0]) * gcdInts(p);\r\n}\r\n\r\n//# sourceMappingURL=content.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/double/content.js?')},"./node_modules/flo-poly/node/factor/double/primitive-part.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "primitivePart": () => (/* binding */ primitivePart)\n/* harmony export */ });\n/* harmony import */ var _content_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content.js */ "./node_modules/flo-poly/node/factor/double/content.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst getContent = _content_js__WEBPACK_IMPORTED_MODULE_0__.content;\r\n/**\r\n * Returns the primitive part of the given polynomial.\r\n *\r\n * * the sign is chosen such that the leading term coefficient is positive\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * * **precondition** p must have integer coefficients, else use e.g. [[scaleFloatsToInts]]\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double precision floating point numbers from highest to lowest power, e.g.\r\n * `[5,-3,0]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction primitivePart(p) {\r\n    const c = getContent(p);\r\n    const p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(p[i] / c);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=primitive-part.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/double/primitive-part.js?')},"./node_modules/flo-poly/node/factor/expansion/e-content.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eContent": () => (/* binding */ eContent)\n/* harmony export */ });\n/* harmony import */ var _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gcd/expansion/e-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eGcdInts = _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_0__.eGcdInts;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eSign;\r\nconst eNegativeOf = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\n/**\r\n * Returns cont(p), i.e. the content of the given polynomial defined as the\r\n * greatest common divisor of its coefficients.\r\n *\r\n * * the sign is chosen such that dividing the polynomial by cont(p) will\r\n * always result in a positive leading coefficient\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eContent(p) {\r\n    if (p.length === 0) {\r\n        // the zero polynomial\r\n        return [1];\r\n    }\r\n    return eSign(p[0]) < 0 ? eNegativeOf(eGcdInts(p)) : eGcdInts(p);\r\n}\r\n\r\n//# sourceMappingURL=e-content.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/expansion/e-content.js?')},"./node_modules/flo-poly/node/factor/expansion/e-primitive-part.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePrimitivePart": () => (/* binding */ ePrimitivePart)\n/* harmony export */ });\n/* harmony import */ var _e_content_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./e-content.js */ "./node_modules/flo-poly/node/factor/expansion/e-content.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eContent = _e_content_js__WEBPACK_IMPORTED_MODULE_0__.eContent;\r\nconst eDiv = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eDiv;\r\n/**\r\n * Returns the primitive part of the given polynomial.\r\n *\r\n * * the sign is chosen such that the leading term coefficient is positive\r\n *\r\n * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)\r\n *\r\n * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the\r\n * content of `p` and `2x² - x - 1` is its primitive part.\r\n *\r\n * @param a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction ePrimitivePart(p) {\r\n    let c = eContent(p);\r\n    let p_ = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        p_.push(eDiv(p[i], c, 0));\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=e-primitive-part.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/factor/expansion/e-primitive-part.js?')},"./node_modules/flo-poly/node/gcd/bigint/b-gcd-prs.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bGcdPrs": () => (/* binding */ bGcdPrs)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_bigint_b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../euclidean-division-related/bigint/b-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bPremSequenceSubresultant = _euclidean_division_related_bigint_b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_0__.bPremSequenceSubresultant;\r\n/**\r\n * :::tip Heads up!\r\n * Use the modular gcd algorithm, [[gcdModular]] (still to be implemented 😢), instead - it is faster.\r\n * :::\r\n *\r\n * Returns the GCD (Greatest Common Divisor) of the two given polynomials using\r\n * Pseudo Remainder Sequences (PRSs) (bar overflow). The returned GCD is a\r\n * polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`.\r\n *\r\n * @param a a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n * @param b another polynomial\r\n *\r\n * @doc\r\n */\r\nfunction bGcdPrs(a, b) {\r\n    if (a.length === 0) {\r\n        return b;\r\n    }\r\n    else if (b.length === 0) {\r\n        return a;\r\n    }\r\n    const seq = bPremSequenceSubresultant(a, b, false);\r\n    return seq[seq.length - 1];\r\n}\r\n\r\n//# sourceMappingURL=b-gcd-prs.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/gcd/bigint/b-gcd-prs.js?')},"./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bGcdInt": () => (/* binding */ bGcdInt),\n/* harmony export */   "bGcdInts": () => (/* binding */ bGcdInts)\n/* harmony export */ });\n/**\r\n * Computes and returns the greatest common divisor of two integers a and b,\r\n * using the [Euclidean Algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).\r\n *\r\n * @doc\r\n */\r\nfunction bGcdInt(a, b) {\r\n    a = a < 0n ? -a : a;\r\n    b = b < 0n ? -b : b;\r\n    // The below 2 commented lines represent Euclid\'s original algorithm.\r\n    //if (a === b) { return a; }\r\n    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);\r\n    if (a === 0n) {\r\n        return b;\r\n    }\r\n    if (b === 0n) {\r\n        return a;\r\n    }\r\n    while (b !== 0n) {\r\n        const t = b;\r\n        b = a % b;\r\n        a = t;\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * Naively computes and returns the greatest common divisor of 2 or more\r\n * integers by taking each integer in turn and calculating the GCD of that\r\n * integer and the previously calculated GCD (where the first GCD is simply\r\n * taken as the first number).\r\n *\r\n * @param vals the integers for which the GCD is to be calculated\r\n *\r\n * @doc\r\n */\r\nfunction bGcdInts(vals) {\r\n    const vals_ = vals.slice();\r\n    const len = vals_.length;\r\n    // make array of numbers all positive\r\n    for (let i = 0; i < len; i++) {\r\n        vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];\r\n    }\r\n    let a = vals_[0];\r\n    for (let i = 1; i < len; i++) {\r\n        a = bGcdInt(a, vals_[i]);\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * * ❗ don\'t use - too slow - use [[bGcdInts]] instead ❗\r\n *\r\n * Computes and returns the greatest common divisor of 2 or more integers by\r\n * calculating GCDs rescursively using a tree (Divide and Conquer).\r\n *\r\n * * It turns out this method is *slower* than the naive method\r\n */ /*\r\nfunction bGcdIntsTree(vals: bigint[]): bigint {\r\n   const vals_ = vals.slice();\r\n\r\n   // make array of numbers all positive\r\n   for (const i=0; i<vals_.length; i++) {\r\n       vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];\r\n   }\r\n   \r\n   // Divide and conquer\r\n   while (vals_.length > 1) {\r\n       const newVals = [];\r\n       const len = vals_.length;\r\n       for (const i=0; i<len-1; i += 2) {\r\n           newVals.push(bGcdInt(vals_[i], vals_[i+1]));\r\n       }\r\n       if (len % 2 !== 0) {\r\n           newVals.push(vals_[len-1]);\r\n       }\r\n\r\n       vals_ = newVals;\r\n   }\r\n   \r\n   return vals_[0];\r\n}\r\n*/\r\n\r\n//# sourceMappingURL=b-integer-gcd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js?')},"./node_modules/flo-poly/node/gcd/double/integer-gcd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "gcdInt": () => (/* binding */ gcdInt),\n/* harmony export */   "gcdIntBinary": () => (/* binding */ gcdIntBinary),\n/* harmony export */   "gcdInts": () => (/* binding */ gcdInts),\n/* harmony export */   "gcdIntsTree": () => (/* binding */ gcdIntsTree)\n/* harmony export */ });\n/**\r\n * Computes the greatest common divisor of two integers a and b, using the\r\n * Euclidean Algorithm.\r\n *\r\n * **precondition** a, b must be integers\r\n *\r\n * @doc\r\n */\r\nfunction gcdInt(a, b) {\r\n    a = Math.abs(a);\r\n    b = Math.abs(b);\r\n    // The below 2 commented lines represent Euclid\'s original algorithm.\r\n    //if (a === b) { return a; }\r\n    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);\r\n    if (a === 0) {\r\n        return b;\r\n    }\r\n    if (b === 0) {\r\n        return a;\r\n    }\r\n    while (b !== 0) {\r\n        const t = b;\r\n        b = a % b;\r\n        a = t;\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * Computes the greatest common divisor of two integers a and b, using the\r\n * binary GCD algorithm - probably slower than just using gcdInt that uses\r\n * the Euclidean Algorithm.\r\n */\r\nfunction gcdIntBinary(a, b) {\r\n    a = Math.abs(a);\r\n    b = Math.abs(b);\r\n    if (a === 0) {\r\n        return b;\r\n    }\r\n    if (b === 0) {\r\n        return a;\r\n    }\r\n    // Reduce a and/or b to odd numbers and keep track of the greatest power of \r\n    // 2 dividing both a and b.\r\n    let k = 1;\r\n    while (a % 2 === 0 && b % 2 === 0) {\r\n        a = a / 2; // right shift\r\n        b = b / 2; // right shift\r\n        k = k * 2; // left shift\r\n    }\r\n    // Reduce a to an odd number...\r\n    while (a % 2 === 0) {\r\n        a = a / 2; // right shift\r\n    }\r\n    // Henceforth, a is always odd...\r\n    while (b) {\r\n        // Remove all factors of 2 in b as they are not common\r\n        while (b % 2 === 0) {\r\n            b = b / 2; // right shift\r\n        }\r\n        // a and b are both odd. Swap values such that it is the larger of the \r\n        // two values, and then set b to the difference (which is even)\r\n        if (a > b) {\r\n            [a, b] = [b, a];\r\n        }\r\n        b = b - a; // b=0 iff b=a\r\n    }\r\n    // Restore common factors of 2...\r\n    return k * a;\r\n}\r\n/**\r\n * Naively computes and returns the greatest common divisor of 2 or more\r\n * integers by taking each integer in turn and calculating the GCD of that\r\n * integer and the previously calculated GCD (where the first GCD is simply\r\n * taken as the first number).\r\n *\r\n * @param vals the integers for which the GCD is to be calculated\r\n *\r\n * @doc\r\n */\r\nfunction gcdInts(vals) {\r\n    const vals_ = vals.slice();\r\n    const len = vals_.length;\r\n    // make array of numbers all positive\r\n    for (let i = 0; i < len; i++) {\r\n        vals_[i] = Math.abs(vals_[i]);\r\n    }\r\n    let a = vals_[0];\r\n    for (let i = 1; i < len; i++) {\r\n        a = gcdInt(a, vals_[i]);\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * :::tip Heads up!\r\n * don\'t use - too slow - use [[gcdInts]] instead\r\n * :::\r\n *\r\n * Computes and returns the greatest common divisor of 2 or more integers by\r\n * calculating GCDs rescursively using a tree (Divide and Conquer).\r\n *\r\n * * It turns out this method is *slower* than the naive method\r\n *\r\n * @param vals the integers for which the GCD is to be calculated\r\n *\r\n * @internal\r\n */\r\nfunction gcdIntsTree(vals) {\r\n    let vals_ = vals.slice();\r\n    // make array of numbers all positive\r\n    for (let i = 0; i < vals_.length; i++) {\r\n        vals_[i] = Math.abs(vals_[i]);\r\n    }\r\n    // Divide and conquer\r\n    while (vals_.length > 1) {\r\n        const newVals = [];\r\n        const len = vals_.length;\r\n        for (let i = 0; i < len - 1; i += 2) {\r\n            newVals.push(gcdInt(vals_[i], vals_[i + 1]));\r\n        }\r\n        if (len % 2 !== 0) {\r\n            newVals.push(vals_[len - 1]);\r\n        }\r\n        vals_ = newVals;\r\n    }\r\n    return vals_[0];\r\n}\r\n\r\n//export { gcdInt, gcdInts }\r\n//# sourceMappingURL=integer-gcd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/gcd/double/integer-gcd.js?')},"./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eGcdInt": () => (/* binding */ eGcdInt),\n/* harmony export */   "eGcdInts": () => (/* binding */ eGcdInts)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eAbs = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst eRem = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eRem;\r\n/**\r\n * Computes the greatest common divisor of two integers a and b, using the\r\n * Euclidean Algorithm.\r\n *\r\n * **precondition** a, b must be integers given as Shewchuk expansions\r\n *\r\n * @doc\r\n */\r\nfunction eGcdInt(a, b) {\r\n    a = eAbs(a);\r\n    b = eAbs(b);\r\n    // The below 2 commented lines represent Euclid\'s original algorithm.\r\n    //if (a === b) { return a; }\r\n    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);\r\n    if (eSign(a) === 0) {\r\n        return b;\r\n    }\r\n    if (eSign(b) === 0) {\r\n        return a;\r\n    }\r\n    while (eSign(b) !== 0) {\r\n        const t = b;\r\n        b = eRem(a, b);\r\n        a = t;\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * Naively computes and returns the greatest common divisor of 2 or more\r\n * integers by taking each integer in turn and calculating the GCD of that\r\n * integer and the previously calculated GCD (where the first GCD is simply\r\n * taken as the first number).\r\n *\r\n * @param vals the integers (given as Shewchuk expansions) for which the GCD is\r\n * to be calculated\r\n */\r\nfunction eGcdInts(vals) {\r\n    const vals_ = vals.slice();\r\n    const len = vals_.length;\r\n    // make array of numbers all positive\r\n    for (let i = 0; i < len; i++) {\r\n        vals_[i] = eAbs(vals_[i]);\r\n    }\r\n    let a = vals_[0];\r\n    for (let i = 1; i < len; i++) {\r\n        a = eGcdInt(a, vals_[i]);\r\n    }\r\n    return a;\r\n}\r\n\r\n//# sourceMappingURL=e-integer-gcd.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js?')},"./node_modules/flo-poly/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AbsHorner": () => (/* reexport safe */ _evaluate_double_abs_horner_js__WEBPACK_IMPORTED_MODULE_74__.AbsHorner),\n/* harmony export */   "CompHornerK": () => (/* reexport safe */ _evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_77__.CompHornerK),\n/* harmony export */   "EFTHorner": () => (/* reexport safe */ _evaluate_double_eft_horner_js__WEBPACK_IMPORTED_MODULE_79__.EFTHorner),\n/* harmony export */   "Horner": () => (/* reexport safe */ _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_85__.Horner),\n/* harmony export */   "absCoeff": () => (/* reexport safe */ _basic_double_abs_coeff_js__WEBPACK_IMPORTED_MODULE_13__.absCoeff),\n/* harmony export */   "add": () => (/* reexport safe */ _basic_double_add_js__WEBPACK_IMPORTED_MODULE_14__.add),\n/* harmony export */   "allRoots": () => (/* reexport safe */ _roots_naive_all_roots_js__WEBPACK_IMPORTED_MODULE_132__.allRoots),\n/* harmony export */   "allRootsCertified": () => (/* reexport safe */ _roots_certified_all_roots_certified_js__WEBPACK_IMPORTED_MODULE_112__.allRootsCertified),\n/* harmony export */   "allRootsCertifiedSimplified": () => (/* reexport safe */ _roots_certified_all_roots_certified_simplified_js__WEBPACK_IMPORTED_MODULE_113__.allRootsCertifiedSimplified),\n/* harmony export */   "bAbsCoeff": () => (/* reexport safe */ _basic_bigint_b_abs_coeff_js__WEBPACK_IMPORTED_MODULE_1__.bAbsCoeff),\n/* harmony export */   "bAdd": () => (/* reexport safe */ _basic_bigint_b_add_js__WEBPACK_IMPORTED_MODULE_2__.bAdd),\n/* harmony export */   "bChangeVariablesLinear": () => (/* reexport safe */ _change_variables_bigint_b_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_46__.bChangeVariablesLinear),\n/* harmony export */   "bChangeVariablesScale": () => (/* reexport safe */ _change_variables_bigint_b_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_47__.bChangeVariablesScale),\n/* harmony export */   "bChangeVariablesTranslateX": () => (/* reexport safe */ _change_variables_bigint_b_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_48__.bChangeVariablesTranslateX),\n/* harmony export */   "bContent": () => (/* reexport safe */ _factor_bigint_b_content_js__WEBPACK_IMPORTED_MODULE_91__.bContent),\n/* harmony export */   "bDegree": () => (/* reexport safe */ _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_3__.bDegree),\n/* harmony export */   "bDifferentiate": () => (/* reexport safe */ _calculus_bigint_b_differentiate_js__WEBPACK_IMPORTED_MODULE_39__.bDifferentiate),\n/* harmony export */   "bDivideByConst": () => (/* reexport safe */ _basic_bigint_b_divide_by_const_js__WEBPACK_IMPORTED_MODULE_4__.bDivideByConst),\n/* harmony export */   "bEqual": () => (/* reexport safe */ _basic_bigint_b_equal_js__WEBPACK_IMPORTED_MODULE_5__.bEqual),\n/* harmony export */   "bEvaluateAt0": () => (/* reexport safe */ _evaluate_bigint_b_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_72__.bEvaluateAt0),\n/* harmony export */   "bEvaluateAt1": () => (/* reexport safe */ _evaluate_bigint_b_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_73__.bEvaluateAt1),\n/* harmony export */   "bFlatCoefficients": () => (/* reexport safe */ _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatCoefficients),\n/* harmony export */   "bFlatCoefficientsArr": () => (/* reexport safe */ _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatCoefficientsArr),\n/* harmony export */   "bFlatRoots": () => (/* reexport safe */ _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatRoots),\n/* harmony export */   "bFlatRootsArr": () => (/* reexport safe */ _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatRootsArr),\n/* harmony export */   "bFromRoots": () => (/* reexport safe */ _roots_from_roots_bigint_b_from_roots_js__WEBPACK_IMPORTED_MODULE_129__.bFromRoots),\n/* harmony export */   "bGcdInt": () => (/* reexport safe */ _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_98__.bGcdInt),\n/* harmony export */   "bGcdInts": () => (/* reexport safe */ _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_98__.bGcdInts),\n/* harmony export */   "bGcdPrs": () => (/* reexport safe */ _gcd_bigint_b_gcd_prs_js__WEBPACK_IMPORTED_MODULE_97__.bGcdPrs),\n/* harmony export */   "bHorner": () => (/* reexport safe */ _evaluate_bigint_b_horner_js__WEBPACK_IMPORTED_MODULE_71__.bHorner),\n/* harmony export */   "bInvert": () => (/* reexport safe */ _basic_bigint_b_invert_js__WEBPACK_IMPORTED_MODULE_6__.bInvert),\n/* harmony export */   "bIsRationalMultipleOf": () => (/* reexport safe */ _basic_bigint_b_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_7__.bIsRationalMultipleOf),\n/* harmony export */   "bMultiply": () => (/* reexport safe */ _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_8__.bMultiply),\n/* harmony export */   "bMultiplyByConst": () => (/* reexport safe */ _basic_bigint_b_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_9__.bMultiplyByConst),\n/* harmony export */   "bNegate": () => (/* reexport safe */ _basic_bigint_b_negate_js__WEBPACK_IMPORTED_MODULE_10__.bNegate),\n/* harmony export */   "bNumRoots": () => (/* reexport safe */ _roots_descartes_bigint_b_num_roots_js__WEBPACK_IMPORTED_MODULE_117__.bNumRoots),\n/* harmony export */   "bNumRootsIn01": () => (/* reexport safe */ _roots_descartes_bigint_b_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_118__.bNumRootsIn01),\n/* harmony export */   "bNumRootsInRange": () => (/* reexport safe */ _roots_descartes_bigint_b_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_119__.bNumRootsInRange),\n/* harmony export */   "bP1Norm": () => (/* reexport safe */ _norm_bigint_b_p_1_norm_js__WEBPACK_IMPORTED_MODULE_101__.bP1Norm),\n/* harmony export */   "bP2NormSquared": () => (/* reexport safe */ _norm_bigint_b_p_2_norm_squared_js__WEBPACK_IMPORTED_MODULE_102__.bP2NormSquared),\n/* harmony export */   "bPInfNorm": () => (/* reexport safe */ _norm_bigint_b_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_103__.bPInfNorm),\n/* harmony export */   "bPdivTrivial": () => (/* reexport safe */ _euclidean_division_related_bigint_b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_60__.bPdivTrivial),\n/* harmony export */   "bPremSequencePrimitive": () => (/* reexport safe */ _euclidean_division_related_bigint_b_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_61__.bPremSequencePrimitive),\n/* harmony export */   "bPremSequenceSubresultant": () => (/* reexport safe */ _euclidean_division_related_bigint_b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_62__.bPremSequenceSubresultant),\n/* harmony export */   "bPremSequenceTrivial": () => (/* reexport safe */ _euclidean_division_related_bigint_b_prem_sequence_trivial_js__WEBPACK_IMPORTED_MODULE_63__.bPremSequenceTrivial),\n/* harmony export */   "bPrimitivePart": () => (/* reexport safe */ _factor_bigint_b_primitive_part_js__WEBPACK_IMPORTED_MODULE_92__.bPrimitivePart),\n/* harmony export */   "bReflectAboutYAxis": () => (/* reexport safe */ _change_variables_bigint_b_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_49__.bReflectAboutYAxis),\n/* harmony export */   "bRemoveLeadingZeros": () => (/* reexport safe */ _basic_bigint_b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_11__.bRemoveLeadingZeros),\n/* harmony export */   "bSignChanges": () => (/* reexport safe */ _roots_descartes_bigint_b_sign_changes_js__WEBPACK_IMPORTED_MODULE_120__.bSignChanges),\n/* harmony export */   "bSturmChain": () => (/* reexport safe */ _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_64__.bSturmChain),\n/* harmony export */   "bSubtract": () => (/* reexport safe */ _basic_bigint_b_subtract_js__WEBPACK_IMPORTED_MODULE_12__.bSubtract),\n/* harmony export */   "bisection": () => (/* reexport safe */ _roots_naive_bisection_js__WEBPACK_IMPORTED_MODULE_133__.bisection),\n/* harmony export */   "brent": () => (/* reexport safe */ _roots_naive_brent_js__WEBPACK_IMPORTED_MODULE_134__.brent),\n/* harmony export */   "brentPoly": () => (/* reexport safe */ _roots_naive_brent_poly_js__WEBPACK_IMPORTED_MODULE_135__.brentPoly),\n/* harmony export */   "changeVariablesLinear": () => (/* reexport safe */ _change_variables_double_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_50__.changeVariablesLinear),\n/* harmony export */   "changeVariablesScale": () => (/* reexport safe */ _change_variables_double_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_51__.changeVariablesScale),\n/* harmony export */   "changeVariablesTranslateX": () => (/* reexport safe */ _change_variables_double_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_52__.changeVariablesTranslateX),\n/* harmony export */   "compHorner": () => (/* reexport safe */ _evaluate_double_comp_horner_js__WEBPACK_IMPORTED_MODULE_75__.compHorner),\n/* harmony export */   "compHornerIsFaithful": () => (/* reexport safe */ _evaluate_double_comp_horner_is_faithful_js__WEBPACK_IMPORTED_MODULE_76__.compHornerIsFaithful),\n/* harmony export */   "compHornerWithRunningError": () => (/* reexport safe */ _evaluate_double_comp_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_78__.compHornerWithRunningError),\n/* harmony export */   "conditionNumber": () => (/* reexport safe */ _error_analysis_condition_number_js__WEBPACK_IMPORTED_MODULE_58__.conditionNumber),\n/* harmony export */   "content": () => (/* reexport safe */ _factor_double_content_js__WEBPACK_IMPORTED_MODULE_93__.content),\n/* harmony export */   "createRootExact": () => (/* reexport safe */ _roots_certified_root_interval_js__WEBPACK_IMPORTED_MODULE_115__.createRootExact),\n/* harmony export */   "ddDeflate": () => (/* reexport safe */ _roots_naive_dd_deflate_js__WEBPACK_IMPORTED_MODULE_136__.ddDeflate),\n/* harmony export */   "ddDifferentiate": () => (/* reexport safe */ _calculus_double_double_dd_differentiate_js__WEBPACK_IMPORTED_MODULE_42__.ddDifferentiate),\n/* harmony export */   "ddDifferentiateWithError": () => (/* reexport safe */ _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_43__.ddDifferentiateWithError),\n/* harmony export */   "ddIntegrate": () => (/* reexport safe */ _calculus_double_double_dd_integrate_js__WEBPACK_IMPORTED_MODULE_44__.ddIntegrate),\n/* harmony export */   "deflate": () => (/* reexport safe */ _roots_naive_deflate_js__WEBPACK_IMPORTED_MODULE_137__.deflate),\n/* harmony export */   "degree": () => (/* reexport safe */ _basic_double_degree_js__WEBPACK_IMPORTED_MODULE_15__.degree),\n/* harmony export */   "differentiate": () => (/* reexport safe */ _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_40__.differentiate),\n/* harmony export */   "divideByConst": () => (/* reexport safe */ _basic_double_divide_by_const_js__WEBPACK_IMPORTED_MODULE_16__.divideByConst),\n/* harmony export */   "eAbsCoeff": () => (/* reexport safe */ _basic_expansion_e_abs_coeff_js__WEBPACK_IMPORTED_MODULE_25__.eAbsCoeff),\n/* harmony export */   "eAdd": () => (/* reexport safe */ _basic_expansion_e_add_js__WEBPACK_IMPORTED_MODULE_26__.eAdd),\n/* harmony export */   "eChangeVariablesLinear": () => (/* reexport safe */ _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_54__.eChangeVariablesLinear),\n/* harmony export */   "eChangeVariablesScale": () => (/* reexport safe */ _change_variables_expansion_e_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_55__.eChangeVariablesScale),\n/* harmony export */   "eChangeVariablesTranslateX": () => (/* reexport safe */ _change_variables_expansion_e_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_56__.eChangeVariablesTranslateX),\n/* harmony export */   "eContent": () => (/* reexport safe */ _factor_expansion_e_content_js__WEBPACK_IMPORTED_MODULE_95__.eContent),\n/* harmony export */   "eDegree": () => (/* reexport safe */ _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_27__.eDegree),\n/* harmony export */   "eDifferentiate": () => (/* reexport safe */ _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_45__.eDifferentiate),\n/* harmony export */   "eEqual": () => (/* reexport safe */ _basic_expansion_e_equal_js__WEBPACK_IMPORTED_MODULE_28__.eEqual),\n/* harmony export */   "eEvaluateAt0": () => (/* reexport safe */ _evaluate_expansion_e_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_88__.eEvaluateAt0),\n/* harmony export */   "eEvaluateAt1": () => (/* reexport safe */ _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_89__.eEvaluateAt1),\n/* harmony export */   "eFromRoots": () => (/* reexport safe */ _roots_from_roots_expansion_e_from_roots_js__WEBPACK_IMPORTED_MODULE_131__.eFromRoots),\n/* harmony export */   "eGcdInt": () => (/* reexport safe */ _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_100__.eGcdInt),\n/* harmony export */   "eGcdInts": () => (/* reexport safe */ _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_100__.eGcdInts),\n/* harmony export */   "eHorner": () => (/* reexport safe */ _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_90__.eHorner),\n/* harmony export */   "eInvert": () => (/* reexport safe */ _basic_expansion_e_invert_js__WEBPACK_IMPORTED_MODULE_29__.eInvert),\n/* harmony export */   "eIsConstOrZero": () => (/* reexport safe */ _basic_expansion_e_is_const_or_zero_js__WEBPACK_IMPORTED_MODULE_30__.eIsConstOrZero),\n/* harmony export */   "eIsRationalMultipleOf": () => (/* reexport safe */ _basic_expansion_e_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_31__.eIsRationalMultipleOf),\n/* harmony export */   "eIsUnit": () => (/* reexport safe */ _basic_expansion_e_is_unit_js__WEBPACK_IMPORTED_MODULE_32__.eIsUnit),\n/* harmony export */   "eMultiply": () => (/* reexport safe */ _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_33__.eMultiply),\n/* harmony export */   "eMultiplyByConst": () => (/* reexport safe */ _basic_expansion_e_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_34__.eMultiplyByConst),\n/* harmony export */   "eNegate": () => (/* reexport safe */ _basic_expansion_e_negate_js__WEBPACK_IMPORTED_MODULE_35__.eNegate),\n/* harmony export */   "eNumRoots": () => (/* reexport safe */ _roots_descartes_expansion_e_num_roots_js__WEBPACK_IMPORTED_MODULE_125__.eNumRoots),\n/* harmony export */   "eNumRootsIn01": () => (/* reexport safe */ _roots_descartes_expansion_e_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_126__.eNumRootsIn01),\n/* harmony export */   "eNumRootsInRange": () => (/* reexport safe */ _roots_descartes_expansion_e_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_127__.eNumRootsInRange),\n/* harmony export */   "eP1Norm": () => (/* reexport safe */ _norm_expansion_e_p_1_norm_js__WEBPACK_IMPORTED_MODULE_107__.eP1Norm),\n/* harmony export */   "eP2Norm": () => (/* reexport safe */ _norm_expansion_e_p_2_norm_js__WEBPACK_IMPORTED_MODULE_108__.eP2Norm),\n/* harmony export */   "ePInfNorm": () => (/* reexport safe */ _norm_expansion_e_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_109__.ePInfNorm),\n/* harmony export */   "ePdivTrivial": () => (/* reexport safe */ _euclidean_division_related_expansion_e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_67__.ePdivTrivial),\n/* harmony export */   "ePremSequencePrimitive": () => (/* reexport safe */ _euclidean_division_related_expansion_e_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_68__.ePremSequencePrimitive),\n/* harmony export */   "ePremSequenceSubresultant": () => (/* reexport safe */ _euclidean_division_related_expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_69__.ePremSequenceSubresultant),\n/* harmony export */   "ePrimitivePart": () => (/* reexport safe */ _factor_expansion_e_primitive_part_js__WEBPACK_IMPORTED_MODULE_96__.ePrimitivePart),\n/* harmony export */   "eProduct": () => (/* reexport safe */ _basic_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_36__.eProduct),\n/* harmony export */   "eReflectAboutYAxis": () => (/* reexport safe */ _change_variables_expansion_e_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_57__.eReflectAboutYAxis),\n/* harmony export */   "eRemoveLeadingZeros": () => (/* reexport safe */ _basic_expansion_e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_37__.eRemoveLeadingZeros),\n/* harmony export */   "eSignChanges": () => (/* reexport safe */ _roots_descartes_expansion_e_sign_changes_js__WEBPACK_IMPORTED_MODULE_128__.eSignChanges),\n/* harmony export */   "eSturmChain": () => (/* reexport safe */ _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_70__.eSturmChain),\n/* harmony export */   "eSubtract": () => (/* reexport safe */ _basic_expansion_e_subtract_js__WEBPACK_IMPORTED_MODULE_38__.eSubtract),\n/* harmony export */   "eeHorner": () => (/* reexport safe */ _evaluate_expansion_e_e_horner_js__WEBPACK_IMPORTED_MODULE_87__.eeHorner),\n/* harmony export */   "equal": () => (/* reexport safe */ _basic_double_equal_js__WEBPACK_IMPORTED_MODULE_17__.equal),\n/* harmony export */   "evalCertified": () => (/* reexport safe */ _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_80__.evalCertified),\n/* harmony export */   "evalCertifiedInclError": () => (/* reexport safe */ _evaluate_double_eval_certified_incl_error_js__WEBPACK_IMPORTED_MODULE_81__.evalCertifiedInclError),\n/* harmony export */   "evalK": () => (/* reexport safe */ _evaluate_double_eval_k_js__WEBPACK_IMPORTED_MODULE_82__.evalK),\n/* harmony export */   "evaluateAt0": () => (/* reexport safe */ _evaluate_double_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_83__.evaluateAt0),\n/* harmony export */   "evaluateAt1": () => (/* reexport safe */ _evaluate_double_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_84__.evaluateAt1),\n/* harmony export */   "flatCoefficients": () => (/* reexport safe */ _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatCoefficients),\n/* harmony export */   "flatCoefficientsArr": () => (/* reexport safe */ _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatCoefficientsArr),\n/* harmony export */   "flatRoots": () => (/* reexport safe */ _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatRoots),\n/* harmony export */   "flatRootsArr": () => (/* reexport safe */ _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatRootsArr),\n/* harmony export */   "fromRoots": () => (/* reexport safe */ _roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_130__.fromRoots),\n/* harmony export */   "gcdInt": () => (/* reexport safe */ _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_99__.gcdInt),\n/* harmony export */   "gcdInts": () => (/* reexport safe */ _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_99__.gcdInts),\n/* harmony export */   "hornerWithRunningError": () => (/* reexport safe */ _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_86__.hornerWithRunningError),\n/* harmony export */   "integrate": () => (/* reexport safe */ _calculus_double_integrate_js__WEBPACK_IMPORTED_MODULE_41__.integrate),\n/* harmony export */   "invert": () => (/* reexport safe */ _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_18__.invert),\n/* harmony export */   "isRationalMultipleOf": () => (/* reexport safe */ _basic_double_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_19__.isRationalMultipleOf),\n/* harmony export */   "mid": () => (/* reexport safe */ _roots_certified_root_interval_js__WEBPACK_IMPORTED_MODULE_115__.mid),\n/* harmony export */   "multiply": () => (/* reexport safe */ _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_20__.multiply),\n/* harmony export */   "multiplyByConst": () => (/* reexport safe */ _basic_double_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_21__.multiplyByConst),\n/* harmony export */   "negate": () => (/* reexport safe */ _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_22__.negate),\n/* harmony export */   "negativeRootLowerBound_LMQ": () => (/* reexport safe */ _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.negativeRootLowerBound_LMQ),\n/* harmony export */   "negativeRootUpperBound_LMQ": () => (/* reexport safe */ _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.negativeRootUpperBound_LMQ),\n/* harmony export */   "numRoots": () => (/* reexport safe */ _roots_descartes_double_num_roots_js__WEBPACK_IMPORTED_MODULE_121__.numRoots),\n/* harmony export */   "numRootsIn01": () => (/* reexport safe */ _roots_descartes_double_num_roots_in_0_1_js__WEBPACK_IMPORTED_MODULE_122__.numRootsIn01),\n/* harmony export */   "numRootsInRange": () => (/* reexport safe */ _roots_descartes_double_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_123__.numRootsInRange),\n/* harmony export */   "operators": () => (/* binding */ operators),\n/* harmony export */   "p1Norm": () => (/* reexport safe */ _norm_double_p_1_norm_js__WEBPACK_IMPORTED_MODULE_104__.p1Norm),\n/* harmony export */   "p2Norm": () => (/* reexport safe */ _norm_double_p_2_norm_js__WEBPACK_IMPORTED_MODULE_105__.p2Norm),\n/* harmony export */   "pInfNorm": () => (/* reexport safe */ _norm_double_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_106__.pInfNorm),\n/* harmony export */   "positiveRootLowerBound_LMQ": () => (/* reexport safe */ _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.positiveRootLowerBound_LMQ),\n/* harmony export */   "positiveRootUpperBound_LMQ": () => (/* reexport safe */ _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.positiveRootUpperBound_LMQ),\n/* harmony export */   "predictiveRandom": () => (/* reexport safe */ _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.predictiveRandom),\n/* harmony export */   "premSequenceSubresultant": () => (/* reexport safe */ _euclidean_division_related_double_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_65__.premSequenceSubresultant),\n/* harmony export */   "primitivePart": () => (/* reexport safe */ _factor_double_primitive_part_js__WEBPACK_IMPORTED_MODULE_94__.primitivePart),\n/* harmony export */   "quadraticRoots": () => (/* reexport safe */ _roots_naive_quadratic_roots_js__WEBPACK_IMPORTED_MODULE_138__.quadraticRoots),\n/* harmony export */   "refineK1": () => (/* reexport safe */ _roots_certified_refine_k1_js__WEBPACK_IMPORTED_MODULE_114__.refineK1),\n/* harmony export */   "reflectAboutYAxis": () => (/* reexport safe */ _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_53__.reflectAboutYAxis),\n/* harmony export */   "removeLeadingZeros": () => (/* reexport safe */ _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_23__.removeLeadingZeros),\n/* harmony export */   "rootIntervalToExp": () => (/* reexport safe */ _roots_certified_root_interval_to_exp_js__WEBPACK_IMPORTED_MODULE_116__.rootIntervalToExp),\n/* harmony export */   "rootMagnitudeUpperBound_fujiwara": () => (/* reexport safe */ _roots_root_bounds_root_magnitude_upper_bound_fujiwara_js__WEBPACK_IMPORTED_MODULE_140__.rootMagnitudeUpperBound_fujiwara),\n/* harmony export */   "rootMagnitudeUpperBound_rouche": () => (/* reexport safe */ _roots_root_bounds_root_magnitude_upper_bound_rouche_js__WEBPACK_IMPORTED_MODULE_141__.rootMagnitudeUpperBound_rouche),\n/* harmony export */   "scaleFloatToBigint": () => (/* reexport safe */ _scale_to_int_scale_float_to_bigint_js__WEBPACK_IMPORTED_MODULE_145__.scaleFloatToBigint),\n/* harmony export */   "scaleFloatToInt": () => (/* reexport safe */ _scale_to_int_scale_float_to_int_js__WEBPACK_IMPORTED_MODULE_142__.scaleFloatToInt),\n/* harmony export */   "scaleFloatsToBigints": () => (/* reexport safe */ _scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_146__.scaleFloatsToBigints),\n/* harmony export */   "scaleFloatsToInts": () => (/* reexport safe */ _scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_143__.scaleFloatsToInts),\n/* harmony export */   "scaleFloatssToBigintss": () => (/* reexport safe */ _scale_to_int_scale_floatss_to_bigintss_js__WEBPACK_IMPORTED_MODULE_147__.scaleFloatssToBigintss),\n/* harmony export */   "scaleFloatssToIntss": () => (/* reexport safe */ _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_144__.scaleFloatssToIntss),\n/* harmony export */   "signChanges": () => (/* reexport safe */ _roots_descartes_double_sign_changes_js__WEBPACK_IMPORTED_MODULE_124__.signChanges),\n/* harmony export */   "sturmChain": () => (/* reexport safe */ _euclidean_division_related_double_sturm_chain_js__WEBPACK_IMPORTED_MODULE_66__.sturmChain),\n/* harmony export */   "subtract": () => (/* reexport safe */ _basic_double_subtract_js__WEBPACK_IMPORTED_MODULE_24__.subtract),\n/* harmony export */   "toCasStr": () => (/* reexport safe */ _basic_to_cas_str_js__WEBPACK_IMPORTED_MODULE_0__.toCasStr),\n/* harmony export */   "γ": () => (/* reexport safe */ _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_59__["γ"]),\n/* harmony export */   "γγ": () => (/* reexport safe */ _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_59__["γγ"])\n/* harmony export */ });\n/* harmony import */ var _basic_to_cas_str_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic/to-cas-str.js */ "./node_modules/flo-poly/node/basic/to-cas-str.js");\n/* harmony import */ var _basic_bigint_b_abs_coeff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/bigint/b-abs-coeff.js */ "./node_modules/flo-poly/node/basic/bigint/b-abs-coeff.js");\n/* harmony import */ var _basic_bigint_b_add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic/bigint/b-add.js */ "./node_modules/flo-poly/node/basic/bigint/b-add.js");\n/* harmony import */ var _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic/bigint/b-degree.js */ "./node_modules/flo-poly/node/basic/bigint/b-degree.js");\n/* harmony import */ var _basic_bigint_b_divide_by_const_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basic/bigint/b-divide-by-const.js */ "./node_modules/flo-poly/node/basic/bigint/b-divide-by-const.js");\n/* harmony import */ var _basic_bigint_b_equal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./basic/bigint/b-equal.js */ "./node_modules/flo-poly/node/basic/bigint/b-equal.js");\n/* harmony import */ var _basic_bigint_b_invert_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./basic/bigint/b-invert.js */ "./node_modules/flo-poly/node/basic/bigint/b-invert.js");\n/* harmony import */ var _basic_bigint_b_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./basic/bigint/b-is-rational-multiple-of.js */ "./node_modules/flo-poly/node/basic/bigint/b-is-rational-multiple-of.js");\n/* harmony import */ var _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./basic/bigint/b-multiply.js */ "./node_modules/flo-poly/node/basic/bigint/b-multiply.js");\n/* harmony import */ var _basic_bigint_b_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./basic/bigint/b-multiply-by-const.js */ "./node_modules/flo-poly/node/basic/bigint/b-multiply-by-const.js");\n/* harmony import */ var _basic_bigint_b_negate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./basic/bigint/b-negate.js */ "./node_modules/flo-poly/node/basic/bigint/b-negate.js");\n/* harmony import */ var _basic_bigint_b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./basic/bigint/b-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js");\n/* harmony import */ var _basic_bigint_b_subtract_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./basic/bigint/b-subtract.js */ "./node_modules/flo-poly/node/basic/bigint/b-subtract.js");\n/* harmony import */ var _basic_double_abs_coeff_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./basic/double/abs-coeff.js */ "./node_modules/flo-poly/node/basic/double/abs-coeff.js");\n/* harmony import */ var _basic_double_add_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./basic/double/add.js */ "./node_modules/flo-poly/node/basic/double/add.js");\n/* harmony import */ var _basic_double_degree_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./basic/double/degree.js */ "./node_modules/flo-poly/node/basic/double/degree.js");\n/* harmony import */ var _basic_double_divide_by_const_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./basic/double/divide-by-const.js */ "./node_modules/flo-poly/node/basic/double/divide-by-const.js");\n/* harmony import */ var _basic_double_equal_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./basic/double/equal.js */ "./node_modules/flo-poly/node/basic/double/equal.js");\n/* harmony import */ var _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./basic/double/invert.js */ "./node_modules/flo-poly/node/basic/double/invert.js");\n/* harmony import */ var _basic_double_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./basic/double/is-rational-multiple-of.js */ "./node_modules/flo-poly/node/basic/double/is-rational-multiple-of.js");\n/* harmony import */ var _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./basic/double/multiply.js */ "./node_modules/flo-poly/node/basic/double/multiply.js");\n/* harmony import */ var _basic_double_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./basic/double/multiply-by-const.js */ "./node_modules/flo-poly/node/basic/double/multiply-by-const.js");\n/* harmony import */ var _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./basic/double/negate.js */ "./node_modules/flo-poly/node/basic/double/negate.js");\n/* harmony import */ var _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./basic/double/remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n/* harmony import */ var _basic_double_subtract_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./basic/double/subtract.js */ "./node_modules/flo-poly/node/basic/double/subtract.js");\n/* harmony import */ var _basic_expansion_e_abs_coeff_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./basic/expansion/e-abs-coeff.js */ "./node_modules/flo-poly/node/basic/expansion/e-abs-coeff.js");\n/* harmony import */ var _basic_expansion_e_add_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./basic/expansion/e-add.js */ "./node_modules/flo-poly/node/basic/expansion/e-add.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n/* harmony import */ var _basic_expansion_e_equal_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./basic/expansion/e-equal.js */ "./node_modules/flo-poly/node/basic/expansion/e-equal.js");\n/* harmony import */ var _basic_expansion_e_invert_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./basic/expansion/e-invert.js */ "./node_modules/flo-poly/node/basic/expansion/e-invert.js");\n/* harmony import */ var _basic_expansion_e_is_const_or_zero_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./basic/expansion/e-is-const-or-zero.js */ "./node_modules/flo-poly/node/basic/expansion/e-is-const-or-zero.js");\n/* harmony import */ var _basic_expansion_e_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./basic/expansion/e-is-rational-multiple-of.js */ "./node_modules/flo-poly/node/basic/expansion/e-is-rational-multiple-of.js");\n/* harmony import */ var _basic_expansion_e_is_unit_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./basic/expansion/e-is-unit.js */ "./node_modules/flo-poly/node/basic/expansion/e-is-unit.js");\n/* harmony import */ var _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./basic/expansion/e-multiply.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply.js");\n/* harmony import */ var _basic_expansion_e_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./basic/expansion/e-multiply-by-const.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply-by-const.js");\n/* harmony import */ var _basic_expansion_e_negate_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./basic/expansion/e-negate.js */ "./node_modules/flo-poly/node/basic/expansion/e-negate.js");\n/* harmony import */ var _basic_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./basic/expansion/e-product.js */ "./node_modules/flo-poly/node/basic/expansion/e-product.js");\n/* harmony import */ var _basic_expansion_e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./basic/expansion/e-remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js");\n/* harmony import */ var _basic_expansion_e_subtract_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./basic/expansion/e-subtract.js */ "./node_modules/flo-poly/node/basic/expansion/e-subtract.js");\n/* harmony import */ var _calculus_bigint_b_differentiate_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./calculus/bigint/b-differentiate.js */ "./node_modules/flo-poly/node/calculus/bigint/b-differentiate.js");\n/* harmony import */ var _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./calculus/double/differentiate.js */ "./node_modules/flo-poly/node/calculus/double/differentiate.js");\n/* harmony import */ var _calculus_double_integrate_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./calculus/double/integrate.js */ "./node_modules/flo-poly/node/calculus/double/integrate.js");\n/* harmony import */ var _calculus_double_double_dd_differentiate_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./calculus/double-double/dd-differentiate.js */ "./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js");\n/* harmony import */ var _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./calculus/double-double/dd-differentiate-with-err.js */ "./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js");\n/* harmony import */ var _calculus_double_double_dd_integrate_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./calculus/double-double/dd-integrate.js */ "./node_modules/flo-poly/node/calculus/double-double/dd-integrate.js");\n/* harmony import */ var _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./calculus/expansion/e-differentiate.js */ "./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js");\n/* harmony import */ var _change_variables_bigint_b_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./change-variables/bigint/b-change-variables-linear.js */ "./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-linear.js");\n/* harmony import */ var _change_variables_bigint_b_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./change-variables/bigint/b-change-variables-scale.js */ "./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-scale.js");\n/* harmony import */ var _change_variables_bigint_b_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./change-variables/bigint/b-change-variables-translate-x.js */ "./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-translate-x.js");\n/* harmony import */ var _change_variables_bigint_b_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./change-variables/bigint/b-reflect-about-y-axis.js */ "./node_modules/flo-poly/node/change-variables/bigint/b-reflect-about-y-axis.js");\n/* harmony import */ var _change_variables_double_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./change-variables/double/change-variables-linear.js */ "./node_modules/flo-poly/node/change-variables/double/change-variables-linear.js");\n/* harmony import */ var _change_variables_double_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./change-variables/double/change-variables-scale.js */ "./node_modules/flo-poly/node/change-variables/double/change-variables-scale.js");\n/* harmony import */ var _change_variables_double_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./change-variables/double/change-variables-translate-x.js */ "./node_modules/flo-poly/node/change-variables/double/change-variables-translate-x.js");\n/* harmony import */ var _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./change-variables/double/reflect-about-y-axis.js */ "./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js");\n/* harmony import */ var _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./change-variables/expansion/e-change-variables-linear.js */ "./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js");\n/* harmony import */ var _change_variables_expansion_e_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./change-variables/expansion/e-change-variables-scale.js */ "./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-scale.js");\n/* harmony import */ var _change_variables_expansion_e_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./change-variables/expansion/e-change-variables-translate-x.js */ "./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-translate-x.js");\n/* harmony import */ var _change_variables_expansion_e_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./change-variables/expansion/e-reflect-about-y-axis.js */ "./node_modules/flo-poly/node/change-variables/expansion/e-reflect-about-y-axis.js");\n/* harmony import */ var _error_analysis_condition_number_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./error-analysis/condition-number.js */ "./node_modules/flo-poly/node/error-analysis/condition-number.js");\n/* harmony import */ var _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./error-analysis/gamma.js */ "./node_modules/flo-poly/node/error-analysis/gamma.js");\n/* harmony import */ var _euclidean_division_related_bigint_b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./euclidean-division-related/bigint/b-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js");\n/* harmony import */ var _euclidean_division_related_bigint_b_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./euclidean-division-related/bigint/b-prem-sequence-primitive.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-primitive.js");\n/* harmony import */ var _euclidean_division_related_bigint_b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./euclidean-division-related/bigint/b-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js");\n/* harmony import */ var _euclidean_division_related_bigint_b_prem_sequence_trivial_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./euclidean-division-related/bigint/b-prem-sequence-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-trivial.js");\n/* harmony import */ var _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./euclidean-division-related/bigint/b-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js");\n/* harmony import */ var _euclidean_division_related_double_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./euclidean-division-related/double/prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/double/prem-sequence-subresultant.js");\n/* harmony import */ var _euclidean_division_related_double_sturm_chain_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./euclidean-division-related/double/sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/double/sturm-chain.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./euclidean-division-related/expansion/e-pdiv-trivial.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./euclidean-division-related/expansion/e-prem-sequence-primitive.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-primitive.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./euclidean-division-related/expansion/e-prem-sequence-subresultant.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _evaluate_bigint_b_horner_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./evaluate/bigint/b-horner.js */ "./node_modules/flo-poly/node/evaluate/bigint/b-horner.js");\n/* harmony import */ var _evaluate_bigint_b_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./evaluate/bigint/b-evaluate-at-0.js */ "./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-0.js");\n/* harmony import */ var _evaluate_bigint_b_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./evaluate/bigint/b-evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-1.js");\n/* harmony import */ var _evaluate_double_abs_horner_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./evaluate/double/abs-horner.js */ "./node_modules/flo-poly/node/evaluate/double/abs-horner.js");\n/* harmony import */ var _evaluate_double_comp_horner_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./evaluate/double/comp-horner.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner.js");\n/* harmony import */ var _evaluate_double_comp_horner_is_faithful_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./evaluate/double/comp-horner-is-faithful.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-is-faithful.js");\n/* harmony import */ var _evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./evaluate/double/comp-horner-k.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js");\n/* harmony import */ var _evaluate_double_comp_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./evaluate/double/comp-horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/comp-horner-with-running-error.js");\n/* harmony import */ var _evaluate_double_eft_horner_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./evaluate/double/eft-horner.js */ "./node_modules/flo-poly/node/evaluate/double/eft-horner.js");\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./evaluate/double/eval-certified.js */ "./node_modules/flo-poly/node/evaluate/double/eval-certified.js");\n/* harmony import */ var _evaluate_double_eval_certified_incl_error_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./evaluate/double/eval-certified-incl-error.js */ "./node_modules/flo-poly/node/evaluate/double/eval-certified-incl-error.js");\n/* harmony import */ var _evaluate_double_eval_k_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./evaluate/double/eval-k.js */ "./node_modules/flo-poly/node/evaluate/double/eval-k.js");\n/* harmony import */ var _evaluate_double_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./evaluate/double/evaluate-at-0.js */ "./node_modules/flo-poly/node/evaluate/double/evaluate-at-0.js");\n/* harmony import */ var _evaluate_double_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./evaluate/double/evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/double/evaluate-at-1.js");\n/* harmony import */ var _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./evaluate/double/horner.js */ "./node_modules/flo-poly/node/evaluate/double/horner.js");\n/* harmony import */ var _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./evaluate/double/horner-with-running-error.js */ "./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js");\n/* harmony import */ var _evaluate_expansion_e_e_horner_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./evaluate/expansion/e-e-horner.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-e-horner.js");\n/* harmony import */ var _evaluate_expansion_e_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./evaluate/expansion/e-evaluate-at-0.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-0.js");\n/* harmony import */ var _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./evaluate/expansion/e-evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./evaluate/expansion/e-horner.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-horner.js");\n/* harmony import */ var _factor_bigint_b_content_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./factor/bigint/b-content.js */ "./node_modules/flo-poly/node/factor/bigint/b-content.js");\n/* harmony import */ var _factor_bigint_b_primitive_part_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./factor/bigint/b-primitive-part.js */ "./node_modules/flo-poly/node/factor/bigint/b-primitive-part.js");\n/* harmony import */ var _factor_double_content_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./factor/double/content.js */ "./node_modules/flo-poly/node/factor/double/content.js");\n/* harmony import */ var _factor_double_primitive_part_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./factor/double/primitive-part.js */ "./node_modules/flo-poly/node/factor/double/primitive-part.js");\n/* harmony import */ var _factor_expansion_e_content_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./factor/expansion/e-content.js */ "./node_modules/flo-poly/node/factor/expansion/e-content.js");\n/* harmony import */ var _factor_expansion_e_primitive_part_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./factor/expansion/e-primitive-part.js */ "./node_modules/flo-poly/node/factor/expansion/e-primitive-part.js");\n/* harmony import */ var _gcd_bigint_b_gcd_prs_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./gcd/bigint/b-gcd-prs.js */ "./node_modules/flo-poly/node/gcd/bigint/b-gcd-prs.js");\n/* harmony import */ var _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./gcd/bigint/b-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js");\n/* harmony import */ var _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./gcd/double/integer-gcd.js */ "./node_modules/flo-poly/node/gcd/double/integer-gcd.js");\n/* harmony import */ var _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./gcd/expansion/e-integer-gcd.js */ "./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js");\n/* harmony import */ var _norm_bigint_b_p_1_norm_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./norm/bigint/b-p-1-norm.js */ "./node_modules/flo-poly/node/norm/bigint/b-p-1-norm.js");\n/* harmony import */ var _norm_bigint_b_p_2_norm_squared_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./norm/bigint/b-p-2-norm-squared.js */ "./node_modules/flo-poly/node/norm/bigint/b-p-2-norm-squared.js");\n/* harmony import */ var _norm_bigint_b_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./norm/bigint/b-p-inf-norm.js */ "./node_modules/flo-poly/node/norm/bigint/b-p-inf-norm.js");\n/* harmony import */ var _norm_double_p_1_norm_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./norm/double/p-1-norm.js */ "./node_modules/flo-poly/node/norm/double/p-1-norm.js");\n/* harmony import */ var _norm_double_p_2_norm_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./norm/double/p-2-norm.js */ "./node_modules/flo-poly/node/norm/double/p-2-norm.js");\n/* harmony import */ var _norm_double_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./norm/double/p-inf-norm.js */ "./node_modules/flo-poly/node/norm/double/p-inf-norm.js");\n/* harmony import */ var _norm_expansion_e_p_1_norm_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./norm/expansion/e-p-1-norm.js */ "./node_modules/flo-poly/node/norm/expansion/e-p-1-norm.js");\n/* harmony import */ var _norm_expansion_e_p_2_norm_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./norm/expansion/e-p-2-norm.js */ "./node_modules/flo-poly/node/norm/expansion/e-p-2-norm.js");\n/* harmony import */ var _norm_expansion_e_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./norm/expansion/e-p-inf-norm.js */ "./node_modules/flo-poly/node/norm/expansion/e-p-inf-norm.js");\n/* harmony import */ var _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./predictive-random/double/random.js */ "./node_modules/flo-poly/node/predictive-random/double/random.js");\n/* harmony import */ var _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./predictive-random/bigint/b-random.js */ "./node_modules/flo-poly/node/predictive-random/bigint/b-random.js");\n/* harmony import */ var _roots_certified_all_roots_certified_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./roots/certified/all-roots-certified.js */ "./node_modules/flo-poly/node/roots/certified/all-roots-certified.js");\n/* harmony import */ var _roots_certified_all_roots_certified_simplified_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./roots/certified/all-roots-certified-simplified.js */ "./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js");\n/* harmony import */ var _roots_certified_refine_k1_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./roots/certified/refine-k1.js */ "./node_modules/flo-poly/node/roots/certified/refine-k1.js");\n/* harmony import */ var _roots_certified_root_interval_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./roots/certified/root-interval.js */ "./node_modules/flo-poly/node/roots/certified/root-interval.js");\n/* harmony import */ var _roots_certified_root_interval_to_exp_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./roots/certified/root-interval-to-exp.js */ "./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js");\n/* harmony import */ var _roots_descartes_bigint_b_num_roots_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./roots/descartes/bigint/b-num-roots.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots.js");\n/* harmony import */ var _roots_descartes_bigint_b_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./roots/descartes/bigint/b-num-roots-0-1.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-0-1.js");\n/* harmony import */ var _roots_descartes_bigint_b_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./roots/descartes/bigint/b-num-roots-in-range.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-in-range.js");\n/* harmony import */ var _roots_descartes_bigint_b_sign_changes_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./roots/descartes/bigint/b-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js");\n/* harmony import */ var _roots_descartes_double_num_roots_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./roots/descartes/double/num-roots.js */ "./node_modules/flo-poly/node/roots/descartes/double/num-roots.js");\n/* harmony import */ var _roots_descartes_double_num_roots_in_0_1_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./roots/descartes/double/num-roots-in-0-1.js */ "./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-0-1.js");\n/* harmony import */ var _roots_descartes_double_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./roots/descartes/double/num-roots-in-range.js */ "./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-range.js");\n/* harmony import */ var _roots_descartes_double_sign_changes_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./roots/descartes/double/sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js");\n/* harmony import */ var _roots_descartes_expansion_e_num_roots_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./roots/descartes/expansion/e-num-roots.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots.js");\n/* harmony import */ var _roots_descartes_expansion_e_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./roots/descartes/expansion/e-num-roots-0-1.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-0-1.js");\n/* harmony import */ var _roots_descartes_expansion_e_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./roots/descartes/expansion/e-num-roots-in-range.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-in-range.js");\n/* harmony import */ var _roots_descartes_expansion_e_sign_changes_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./roots/descartes/expansion/e-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js");\n/* harmony import */ var _roots_from_roots_bigint_b_from_roots_js__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./roots/from-roots/bigint/b-from-roots.js */ "./node_modules/flo-poly/node/roots/from-roots/bigint/b-from-roots.js");\n/* harmony import */ var _roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./roots/from-roots/double/from-roots.js */ "./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js");\n/* harmony import */ var _roots_from_roots_expansion_e_from_roots_js__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./roots/from-roots/expansion/e-from-roots.js */ "./node_modules/flo-poly/node/roots/from-roots/expansion/e-from-roots.js");\n/* harmony import */ var _roots_naive_all_roots_js__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./roots/naive/all-roots.js */ "./node_modules/flo-poly/node/roots/naive/all-roots.js");\n/* harmony import */ var _roots_naive_bisection_js__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./roots/naive/bisection.js */ "./node_modules/flo-poly/node/roots/naive/bisection.js");\n/* harmony import */ var _roots_naive_brent_js__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./roots/naive/brent.js */ "./node_modules/flo-poly/node/roots/naive/brent.js");\n/* harmony import */ var _roots_naive_brent_poly_js__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./roots/naive/brent-poly.js */ "./node_modules/flo-poly/node/roots/naive/brent-poly.js");\n/* harmony import */ var _roots_naive_dd_deflate_js__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./roots/naive/dd-deflate.js */ "./node_modules/flo-poly/node/roots/naive/dd-deflate.js");\n/* harmony import */ var _roots_naive_deflate_js__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./roots/naive/deflate.js */ "./node_modules/flo-poly/node/roots/naive/deflate.js");\n/* harmony import */ var _roots_naive_quadratic_roots_js__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./roots/naive/quadratic-roots.js */ "./node_modules/flo-poly/node/roots/naive/quadratic-roots.js");\n/* harmony import */ var _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./roots/root-bounds/root-bounds-lmq.js */ "./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js");\n/* harmony import */ var _roots_root_bounds_root_magnitude_upper_bound_fujiwara_js__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./roots/root-bounds/root-magnitude-upper-bound-fujiwara.js */ "./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js");\n/* harmony import */ var _roots_root_bounds_root_magnitude_upper_bound_rouche_js__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./roots/root-bounds/root-magnitude-upper-bound-rouche.js */ "./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js");\n/* harmony import */ var _scale_to_int_scale_float_to_int_js__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./scale-to-int/scale-float-to-int.js */ "./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js");\n/* harmony import */ var _scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./scale-to-int/scale-floats-to-ints.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js");\n/* harmony import */ var _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./scale-to-int/scale-floatss-to-intss.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js");\n/* harmony import */ var _scale_to_int_scale_float_to_bigint_js__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./scale-to-int/scale-float-to-bigint.js */ "./node_modules/flo-poly/node/scale-to-int/scale-float-to-bigint.js");\n/* harmony import */ var _scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./scale-to-int/scale-floats-to-bigints.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floats-to-bigints.js");\n/* harmony import */ var _scale_to_int_scale_floatss_to_bigintss_js__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./scale-to-int/scale-floatss-to-bigintss.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js");\n// basic\r\n\r\n// basic bigint\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// basic double\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// basic expansion\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// calculus bigint\r\n\r\n// calculus double\r\n\r\n\r\n// calculus double-double\r\n\r\n\r\n\r\n// calculus expansion\r\n\r\n// change variables bigint\r\n\r\n\r\n\r\n\r\n// change variables double\r\n\r\n\r\n\r\n\r\n// change variables expansion\r\n\r\n\r\n\r\n\r\n// error analysis\r\n\r\n\r\n\r\n// euclidean division related bigint\r\n\r\n\r\n\r\n\r\n\r\n// euclidean division related double\r\n\r\n\r\n// euclidean division related expansion\r\n\r\n\r\n\r\n\r\n// evaluate bigint\r\n\r\n\r\n\r\n// evaluate double\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// evaluate expansion\r\n\r\n\r\n\r\n\r\n// factor bigint\r\n\r\n\r\n// factor double\r\n\r\n\r\n// factor expansion\r\n\r\n\r\n// gcd bigint\r\n\r\n\r\n\r\n// gcd double\r\n//import { gcdPrs } from \'./gcd/double/gcd-prs.js\';\r\n\r\n\r\n// gcd expansion\r\n//import { eGcdPrs } from \'./gcd/expansion/e-gcd-prs.js\';\r\n\r\n\r\n// norm bigint\r\n\r\n\r\n\r\n// norm double\r\n\r\n\r\n\r\n// norm expansion\r\n\r\n\r\n\r\n// predictive random double\r\n\r\n\r\n\r\n\r\n\r\n// predictive random bigint\r\n\r\n\r\n\r\n\r\n// roots certified\r\n\r\n\r\n\r\n\r\n\r\n\r\n// roots descartes bigint\r\n\r\n\r\n\r\n\r\n// roots descartes double\r\n\r\n\r\n\r\n\r\n// roots descartes expansion\r\n\r\n\r\n\r\n\r\n// roots from roots\r\n\r\n\r\n\r\n// roots naive\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// roots root bounds\r\n\r\n\r\n\r\n\r\n\r\n\r\n// scale to int\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst operators = {\r\n    // basic\r\n    toCasStr: _basic_to_cas_str_js__WEBPACK_IMPORTED_MODULE_0__.toCasStr,\r\n    // basic bigint\r\n    bAbsCoeff: _basic_bigint_b_abs_coeff_js__WEBPACK_IMPORTED_MODULE_1__.bAbsCoeff,\r\n    bAdd: _basic_bigint_b_add_js__WEBPACK_IMPORTED_MODULE_2__.bAdd,\r\n    bDegree: _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_3__.bDegree,\r\n    bDivideByConst: _basic_bigint_b_divide_by_const_js__WEBPACK_IMPORTED_MODULE_4__.bDivideByConst,\r\n    bEqual: _basic_bigint_b_equal_js__WEBPACK_IMPORTED_MODULE_5__.bEqual,\r\n    bInvert: _basic_bigint_b_invert_js__WEBPACK_IMPORTED_MODULE_6__.bInvert,\r\n    bIsRationalMultipleOf: _basic_bigint_b_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_7__.bIsRationalMultipleOf,\r\n    bMultiply: _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_8__.bMultiply,\r\n    bMultiplyByConst: _basic_bigint_b_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_9__.bMultiplyByConst,\r\n    bNegate: _basic_bigint_b_negate_js__WEBPACK_IMPORTED_MODULE_10__.bNegate,\r\n    bRemoveLeadingZeros: _basic_bigint_b_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_11__.bRemoveLeadingZeros,\r\n    bSubtract: _basic_bigint_b_subtract_js__WEBPACK_IMPORTED_MODULE_12__.bSubtract,\r\n    // basic double\r\n    absCoeff: _basic_double_abs_coeff_js__WEBPACK_IMPORTED_MODULE_13__.absCoeff,\r\n    add: _basic_double_add_js__WEBPACK_IMPORTED_MODULE_14__.add,\r\n    degree: _basic_double_degree_js__WEBPACK_IMPORTED_MODULE_15__.degree,\r\n    divideByConst: _basic_double_divide_by_const_js__WEBPACK_IMPORTED_MODULE_16__.divideByConst,\r\n    equal: _basic_double_equal_js__WEBPACK_IMPORTED_MODULE_17__.equal,\r\n    invert: _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_18__.invert,\r\n    isRationalMultipleOf: _basic_double_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_19__.isRationalMultipleOf,\r\n    multiply: _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_20__.multiply,\r\n    multiplyByConst: _basic_double_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_21__.multiplyByConst,\r\n    negate: _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_22__.negate,\r\n    removeLeadingZeros: _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_23__.removeLeadingZeros,\r\n    subtract: _basic_double_subtract_js__WEBPACK_IMPORTED_MODULE_24__.subtract,\r\n    // basic expansion\r\n    eAbsCoeff: _basic_expansion_e_abs_coeff_js__WEBPACK_IMPORTED_MODULE_25__.eAbsCoeff,\r\n    eAdd: _basic_expansion_e_add_js__WEBPACK_IMPORTED_MODULE_26__.eAdd,\r\n    eDegree: _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_27__.eDegree,\r\n    eEqual: _basic_expansion_e_equal_js__WEBPACK_IMPORTED_MODULE_28__.eEqual,\r\n    eInvert: _basic_expansion_e_invert_js__WEBPACK_IMPORTED_MODULE_29__.eInvert,\r\n    eIsConstOrZero: _basic_expansion_e_is_const_or_zero_js__WEBPACK_IMPORTED_MODULE_30__.eIsConstOrZero,\r\n    eIsRationalMultipleOf: _basic_expansion_e_is_rational_multiple_of_js__WEBPACK_IMPORTED_MODULE_31__.eIsRationalMultipleOf,\r\n    eIsUnit: _basic_expansion_e_is_unit_js__WEBPACK_IMPORTED_MODULE_32__.eIsUnit,\r\n    eMultiply: _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_33__.eMultiply,\r\n    eMultiplyByConst: _basic_expansion_e_multiply_by_const_js__WEBPACK_IMPORTED_MODULE_34__.eMultiplyByConst,\r\n    eNegate: _basic_expansion_e_negate_js__WEBPACK_IMPORTED_MODULE_35__.eNegate,\r\n    eProduct: _basic_expansion_e_product_js__WEBPACK_IMPORTED_MODULE_36__.eProduct,\r\n    eRemoveLeadingZeros: _basic_expansion_e_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_37__.eRemoveLeadingZeros,\r\n    eSubtract: _basic_expansion_e_subtract_js__WEBPACK_IMPORTED_MODULE_38__.eSubtract,\r\n    // calculus bigint\r\n    bDifferentiate: _calculus_bigint_b_differentiate_js__WEBPACK_IMPORTED_MODULE_39__.bDifferentiate,\r\n    // calculus double\r\n    differentiate: _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_40__.differentiate,\r\n    integrate: _calculus_double_integrate_js__WEBPACK_IMPORTED_MODULE_41__.integrate,\r\n    // calculus double-double\r\n    ddDifferentiate: _calculus_double_double_dd_differentiate_js__WEBPACK_IMPORTED_MODULE_42__.ddDifferentiate,\r\n    ddDifferentiateWithError: _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_43__.ddDifferentiateWithError,\r\n    ddIntegrate: _calculus_double_double_dd_integrate_js__WEBPACK_IMPORTED_MODULE_44__.ddIntegrate,\r\n    // calculus expansion\r\n    eDifferentiate: _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_45__.eDifferentiate,\r\n    // change variables bigint\r\n    bChangeVariablesLinear: _change_variables_bigint_b_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_46__.bChangeVariablesLinear,\r\n    bChangeVariablesScale: _change_variables_bigint_b_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_47__.bChangeVariablesScale,\r\n    bChangeVariablesTranslateX: _change_variables_bigint_b_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_48__.bChangeVariablesTranslateX,\r\n    bReflectAboutYAxis: _change_variables_bigint_b_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_49__.bReflectAboutYAxis,\r\n    // change variables double\r\n    changeVariablesLinear: _change_variables_double_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_50__.changeVariablesLinear,\r\n    changeVariablesScale: _change_variables_double_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_51__.changeVariablesScale,\r\n    changeVariablesTranslateX: _change_variables_double_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_52__.changeVariablesTranslateX,\r\n    reflectAboutYAxis: _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_53__.reflectAboutYAxis,\r\n    // change variables expansion\r\n    eChangeVariablesLinear: _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_54__.eChangeVariablesLinear,\r\n    eChangeVariablesScale: _change_variables_expansion_e_change_variables_scale_js__WEBPACK_IMPORTED_MODULE_55__.eChangeVariablesScale,\r\n    eChangeVariablesTranslateX: _change_variables_expansion_e_change_variables_translate_x_js__WEBPACK_IMPORTED_MODULE_56__.eChangeVariablesTranslateX,\r\n    eReflectAboutYAxis: _change_variables_expansion_e_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_57__.eReflectAboutYAxis,\r\n    // error analysis\r\n    conditionNumber: _error_analysis_condition_number_js__WEBPACK_IMPORTED_MODULE_58__.conditionNumber,\r\n    γ: _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_59__["γ"],\r\n    γγ: _error_analysis_gamma_js__WEBPACK_IMPORTED_MODULE_59__["γγ"],\r\n    // euclidean division related bigint\r\n    bPdivTrivial: _euclidean_division_related_bigint_b_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_60__.bPdivTrivial,\r\n    bPremSequencePrimitive: _euclidean_division_related_bigint_b_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_61__.bPremSequencePrimitive,\r\n    bPremSequenceSubresultant: _euclidean_division_related_bigint_b_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_62__.bPremSequenceSubresultant,\r\n    bPremSequenceTrivial: _euclidean_division_related_bigint_b_prem_sequence_trivial_js__WEBPACK_IMPORTED_MODULE_63__.bPremSequenceTrivial,\r\n    bSturmChain: _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_64__.bSturmChain,\r\n    // euclidean division related double\r\n    premSequenceSubresultant: _euclidean_division_related_double_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_65__.premSequenceSubresultant,\r\n    sturmChain: _euclidean_division_related_double_sturm_chain_js__WEBPACK_IMPORTED_MODULE_66__.sturmChain,\r\n    // euclidean division related expansion\r\n    ePdivTrivial: _euclidean_division_related_expansion_e_pdiv_trivial_js__WEBPACK_IMPORTED_MODULE_67__.ePdivTrivial,\r\n    ePremSequencePrimitive: _euclidean_division_related_expansion_e_prem_sequence_primitive_js__WEBPACK_IMPORTED_MODULE_68__.ePremSequencePrimitive,\r\n    ePremSequenceSubresultant: _euclidean_division_related_expansion_e_prem_sequence_subresultant_js__WEBPACK_IMPORTED_MODULE_69__.ePremSequenceSubresultant,\r\n    eSturmChain: _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_70__.eSturmChain,\r\n    // evaluate bigint\r\n    bHorner: _evaluate_bigint_b_horner_js__WEBPACK_IMPORTED_MODULE_71__.bHorner,\r\n    bEvaluateAt0: _evaluate_bigint_b_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_72__.bEvaluateAt0,\r\n    bEvaluateAt1: _evaluate_bigint_b_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_73__.bEvaluateAt1,\r\n    // evaluate double\r\n    AbsHorner: _evaluate_double_abs_horner_js__WEBPACK_IMPORTED_MODULE_74__.AbsHorner,\r\n    compHorner: _evaluate_double_comp_horner_js__WEBPACK_IMPORTED_MODULE_75__.compHorner,\r\n    compHornerIsFaithful: _evaluate_double_comp_horner_is_faithful_js__WEBPACK_IMPORTED_MODULE_76__.compHornerIsFaithful,\r\n    CompHornerK: _evaluate_double_comp_horner_k_js__WEBPACK_IMPORTED_MODULE_77__.CompHornerK,\r\n    compHornerWithRunningError: _evaluate_double_comp_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_78__.compHornerWithRunningError,\r\n    EFTHorner: _evaluate_double_eft_horner_js__WEBPACK_IMPORTED_MODULE_79__.EFTHorner,\r\n    evalCertified: _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_80__.evalCertified,\r\n    evalCertifiedInclError: _evaluate_double_eval_certified_incl_error_js__WEBPACK_IMPORTED_MODULE_81__.evalCertifiedInclError,\r\n    evalK: _evaluate_double_eval_k_js__WEBPACK_IMPORTED_MODULE_82__.evalK,\r\n    evaluateAt0: _evaluate_double_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_83__.evaluateAt0,\r\n    evaluateAt1: _evaluate_double_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_84__.evaluateAt1,\r\n    Horner: _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_85__.Horner,\r\n    hornerWithRunningError: _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_86__.hornerWithRunningError,\r\n    // evaluate expansion\r\n    eeHorner: _evaluate_expansion_e_e_horner_js__WEBPACK_IMPORTED_MODULE_87__.eeHorner,\r\n    eEvaluateAt0: _evaluate_expansion_e_evaluate_at_0_js__WEBPACK_IMPORTED_MODULE_88__.eEvaluateAt0,\r\n    eEvaluateAt1: _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_89__.eEvaluateAt1,\r\n    eHorner: _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_90__.eHorner,\r\n    // factor bigint\r\n    bContent: _factor_bigint_b_content_js__WEBPACK_IMPORTED_MODULE_91__.bContent,\r\n    bPrimitivePart: _factor_bigint_b_primitive_part_js__WEBPACK_IMPORTED_MODULE_92__.bPrimitivePart,\r\n    // factor double\r\n    content: _factor_double_content_js__WEBPACK_IMPORTED_MODULE_93__.content,\r\n    primitivePart: _factor_double_primitive_part_js__WEBPACK_IMPORTED_MODULE_94__.primitivePart,\r\n    // factor expansion\r\n    eContent: _factor_expansion_e_content_js__WEBPACK_IMPORTED_MODULE_95__.eContent,\r\n    ePrimitivePart: _factor_expansion_e_primitive_part_js__WEBPACK_IMPORTED_MODULE_96__.ePrimitivePart,\r\n    // norm bigint\r\n    bP1Norm: _norm_bigint_b_p_1_norm_js__WEBPACK_IMPORTED_MODULE_101__.bP1Norm,\r\n    bP2NormSquared: _norm_bigint_b_p_2_norm_squared_js__WEBPACK_IMPORTED_MODULE_102__.bP2NormSquared,\r\n    bPInfNorm: _norm_bigint_b_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_103__.bPInfNorm,\r\n    // norm double\r\n    p1Norm: _norm_double_p_1_norm_js__WEBPACK_IMPORTED_MODULE_104__.p1Norm,\r\n    p2Norm: _norm_double_p_2_norm_js__WEBPACK_IMPORTED_MODULE_105__.p2Norm,\r\n    pInfNorm: _norm_double_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_106__.pInfNorm,\r\n    // norm expansion\r\n    eP1Norm: _norm_expansion_e_p_1_norm_js__WEBPACK_IMPORTED_MODULE_107__.eP1Norm,\r\n    eP2Norm: _norm_expansion_e_p_2_norm_js__WEBPACK_IMPORTED_MODULE_108__.eP2Norm,\r\n    ePInfNorm: _norm_expansion_e_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_109__.ePInfNorm,\r\n    // predictive random double\r\n    flatRoots: _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatRoots,\r\n    flatRootsArr: _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatRootsArr,\r\n    flatCoefficients: _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatCoefficients,\r\n    flatCoefficientsArr: _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.flatCoefficientsArr,\r\n    predictiveRandom: _predictive_random_double_random_js__WEBPACK_IMPORTED_MODULE_110__.predictiveRandom,\r\n    // predictive random bigint\r\n    bFlatRoots: _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatRoots,\r\n    bFlatRootsArr: _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatRootsArr,\r\n    bFlatCoefficients: _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatCoefficients,\r\n    bFlatCoefficientsArr: _predictive_random_bigint_b_random_js__WEBPACK_IMPORTED_MODULE_111__.bFlatCoefficientsArr,\r\n    // roots certified\r\n    allRootsCertified: _roots_certified_all_roots_certified_js__WEBPACK_IMPORTED_MODULE_112__.allRootsCertified,\r\n    allRootsCertifiedSimplified: _roots_certified_all_roots_certified_simplified_js__WEBPACK_IMPORTED_MODULE_113__.allRootsCertifiedSimplified,\r\n    refineK1: _roots_certified_refine_k1_js__WEBPACK_IMPORTED_MODULE_114__.refineK1,\r\n    mid: _roots_certified_root_interval_js__WEBPACK_IMPORTED_MODULE_115__.mid,\r\n    createRootExact: _roots_certified_root_interval_js__WEBPACK_IMPORTED_MODULE_115__.createRootExact,\r\n    rootIntervalToExp: _roots_certified_root_interval_to_exp_js__WEBPACK_IMPORTED_MODULE_116__.rootIntervalToExp,\r\n    // roots descartes bigint\r\n    bNumRoots: _roots_descartes_bigint_b_num_roots_js__WEBPACK_IMPORTED_MODULE_117__.bNumRoots,\r\n    bNumRootsIn01: _roots_descartes_bigint_b_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_118__.bNumRootsIn01,\r\n    bNumRootsInRange: _roots_descartes_bigint_b_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_119__.bNumRootsInRange,\r\n    bSignChanges: _roots_descartes_bigint_b_sign_changes_js__WEBPACK_IMPORTED_MODULE_120__.bSignChanges,\r\n    // roots descartes double\r\n    numRoots: _roots_descartes_double_num_roots_js__WEBPACK_IMPORTED_MODULE_121__.numRoots,\r\n    numRootsIn01: _roots_descartes_double_num_roots_in_0_1_js__WEBPACK_IMPORTED_MODULE_122__.numRootsIn01,\r\n    numRootsInRange: _roots_descartes_double_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_123__.numRootsInRange,\r\n    signChanges: _roots_descartes_double_sign_changes_js__WEBPACK_IMPORTED_MODULE_124__.signChanges,\r\n    // roots descartes expansion\r\n    eNumRoots: _roots_descartes_expansion_e_num_roots_js__WEBPACK_IMPORTED_MODULE_125__.eNumRoots,\r\n    eNumRootsIn01: _roots_descartes_expansion_e_num_roots_0_1_js__WEBPACK_IMPORTED_MODULE_126__.eNumRootsIn01,\r\n    eNumRootsInRange: _roots_descartes_expansion_e_num_roots_in_range_js__WEBPACK_IMPORTED_MODULE_127__.eNumRootsInRange,\r\n    eSignChanges: _roots_descartes_expansion_e_sign_changes_js__WEBPACK_IMPORTED_MODULE_128__.eSignChanges,\r\n    // roots from roots\r\n    bFromRoots: _roots_from_roots_bigint_b_from_roots_js__WEBPACK_IMPORTED_MODULE_129__.bFromRoots,\r\n    fromRoots: _roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_130__.fromRoots,\r\n    eFromRoots: _roots_from_roots_expansion_e_from_roots_js__WEBPACK_IMPORTED_MODULE_131__.eFromRoots,\r\n    // roots naive\r\n    allRoots: _roots_naive_all_roots_js__WEBPACK_IMPORTED_MODULE_132__.allRoots,\r\n    bisection: _roots_naive_bisection_js__WEBPACK_IMPORTED_MODULE_133__.bisection,\r\n    brent: _roots_naive_brent_js__WEBPACK_IMPORTED_MODULE_134__.brent,\r\n    brentPoly: _roots_naive_brent_poly_js__WEBPACK_IMPORTED_MODULE_135__.brentPoly,\r\n    ddDeflate: _roots_naive_dd_deflate_js__WEBPACK_IMPORTED_MODULE_136__.ddDeflate,\r\n    deflate: _roots_naive_deflate_js__WEBPACK_IMPORTED_MODULE_137__.deflate,\r\n    quadraticRoots: _roots_naive_quadratic_roots_js__WEBPACK_IMPORTED_MODULE_138__.quadraticRoots,\r\n    // roots root bounds\r\n    positiveRootUpperBound_LMQ: _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.positiveRootUpperBound_LMQ,\r\n    positiveRootLowerBound_LMQ: _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.positiveRootLowerBound_LMQ,\r\n    negativeRootLowerBound_LMQ: _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.negativeRootLowerBound_LMQ,\r\n    negativeRootUpperBound_LMQ: _roots_root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_139__.negativeRootUpperBound_LMQ,\r\n    rootMagnitudeUpperBound_fujiwara: _roots_root_bounds_root_magnitude_upper_bound_fujiwara_js__WEBPACK_IMPORTED_MODULE_140__.rootMagnitudeUpperBound_fujiwara,\r\n    rootMagnitudeUpperBound_rouche: _roots_root_bounds_root_magnitude_upper_bound_rouche_js__WEBPACK_IMPORTED_MODULE_141__.rootMagnitudeUpperBound_rouche,\r\n    // scale to int\r\n    scaleFloatToInt: _scale_to_int_scale_float_to_int_js__WEBPACK_IMPORTED_MODULE_142__.scaleFloatToInt,\r\n    scaleFloatsToInts: _scale_to_int_scale_floats_to_ints_js__WEBPACK_IMPORTED_MODULE_143__.scaleFloatsToInts,\r\n    scaleFloatssToIntss: _scale_to_int_scale_floatss_to_intss_js__WEBPACK_IMPORTED_MODULE_144__.scaleFloatssToIntss,\r\n    scaleFloatToBigint: _scale_to_int_scale_float_to_bigint_js__WEBPACK_IMPORTED_MODULE_145__.scaleFloatToBigint,\r\n    scaleFloatsToBigints: _scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_146__.scaleFloatsToBigints,\r\n    scaleFloatssToBigintss: _scale_to_int_scale_floatss_to_bigintss_js__WEBPACK_IMPORTED_MODULE_147__.scaleFloatssToBigintss,\r\n    // gcd bigint\r\n    bGcdPrs: _gcd_bigint_b_gcd_prs_js__WEBPACK_IMPORTED_MODULE_97__.bGcdPrs,\r\n    bGcdInt: _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_98__.bGcdInt,\r\n    bGcdInts: _gcd_bigint_b_integer_gcd_js__WEBPACK_IMPORTED_MODULE_98__.bGcdInts,\r\n    // gcd double\r\n    //gcdPrs,\r\n    gcdInt: _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_99__.gcdInt,\r\n    gcdInts: _gcd_double_integer_gcd_js__WEBPACK_IMPORTED_MODULE_99__.gcdInts,\r\n    // gcd expansion\r\n    //eGcdPrs,\r\n    eGcdInt: _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_100__.eGcdInt,\r\n    eGcdInts: _gcd_expansion_e_integer_gcd_js__WEBPACK_IMPORTED_MODULE_100__.eGcdInts\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/index.js?')},"./node_modules/flo-poly/node/norm/bigint/b-p-1-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bP1Norm": () => (/* binding */ bP1Norm)\n/* harmony export */ });\n/**\r\n * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute\r\n * values of the given array of bigints.\r\n *\r\n * * if the array of bigints represent polynomial coefficients then the p-1\r\n * norm is known as the `length` of the polynomial\r\n *\r\n * @param p an array of bigints\r\n *\r\n * @doc\r\n */\r\nfunction bP1Norm(p) {\r\n    let s = 0n;\r\n    for (let i = 0; i < p.length; i++) {\r\n        const n = p[i];\r\n        s += n < 0n ? -n : n;\r\n    }\r\n    return s;\r\n}\r\n\r\n//# sourceMappingURL=b-p-1-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/bigint/b-p-1-norm.js?')},"./node_modules/flo-poly/node/norm/bigint/b-p-2-norm-squared.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bP2NormSquared": () => (/* binding */ bP2NormSquared)\n/* harmony export */ });\n/**\r\n * Returns the `p-2 norm` squared, i.e. the square of the `Euclidean norm` of\r\n * the given array of bigints.\r\n *\r\n * @param p an array of bigints; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction bP2NormSquared(p) {\r\n    let s = 0n;\r\n    for (let i = 0; i < p.length; i++) {\r\n        s += p[i] ** 2n;\r\n    }\r\n    return s;\r\n}\r\n\r\n//# sourceMappingURL=b-p-2-norm-squared.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/bigint/b-p-2-norm-squared.js?')},"./node_modules/flo-poly/node/norm/bigint/b-p-inf-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bPInfNorm": () => (/* binding */ bPInfNorm)\n/* harmony export */ });\n/**\r\n * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value\r\n * within the given array of bigints / coefficients.\r\n *\r\n * @param p an array of bigints; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction bPInfNorm(p) {\r\n    let max = 0n;\r\n    for (let i = 0; i < p.length; i++) {\r\n        let v = p[i];\r\n        v = v < 0n ? -v : v;\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n\r\n//# sourceMappingURL=b-p-inf-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/bigint/b-p-inf-norm.js?')},"./node_modules/flo-poly/node/norm/double/p-1-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "p1Norm": () => (/* binding */ p1Norm)\n/* harmony export */ });\n/**\r\n * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute\r\n * values of the given array of numbers (with intermediate calculations done\r\n * in double precision).\r\n *\r\n * * if the array of numbers represent polynomial coefficients then the p-1\r\n * norm is known as the `length` of the polynomial\r\n *\r\n * @param p an array of numbers\r\n *\r\n * @doc\r\n */\r\nfunction p1Norm(p) {\r\n    let s = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        s += Math.abs(p[i]);\r\n    }\r\n    return s;\r\n}\r\n\r\n//# sourceMappingURL=p-1-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/double/p-1-norm.js?')},"./node_modules/flo-poly/node/norm/double/p-2-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "p2Norm": () => (/* binding */ p2Norm)\n/* harmony export */ });\n/**\r\n * Returns the `p-2 norm`, i.e. `Euclidean norm` of the given array of numbers\r\n * (with intermediate calculations done in double precision).\r\n *\r\n * @param p an array of numbers; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction p2Norm(p) {\r\n    let s = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        s += p[i] ** 2;\r\n    }\r\n    return Math.sqrt(s);\r\n}\r\n\r\n//# sourceMappingURL=p-2-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/double/p-2-norm.js?')},"./node_modules/flo-poly/node/norm/double/p-inf-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "pInfNorm": () => (/* binding */ pInfNorm)\n/* harmony export */ });\n/**\r\n * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value\r\n * within the given array of numbers / coefficients (with intermediate\r\n * calculations done in double precision).\r\n *\r\n * @param p an array of numbers; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction pInfNorm(p) {\r\n    let max = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        const v = Math.abs(p[i]);\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n\r\n//# sourceMappingURL=p-inf-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/double/p-inf-norm.js?')},"./node_modules/flo-poly/node/norm/expansion/e-p-1-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eP1Norm": () => (/* binding */ eP1Norm)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\n/**\r\n * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute\r\n * values of the given array of Shewchuk expansions (with intermediate\r\n * calculations (and the final result) done in double precision).\r\n *\r\n * * if the array of expansions represent polynomial coefficients then the p-1\r\n * norm is known as the `length` of the polynomial\r\n *\r\n * @param p an array of Shewchuk expansions\r\n *\r\n * @doc\r\n */\r\nfunction eP1Norm(p) {\r\n    let s = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        s += Math.abs(eEstimate(p[i]));\r\n    }\r\n    return s;\r\n}\r\n\r\n//# sourceMappingURL=e-p-1-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/expansion/e-p-1-norm.js?')},"./node_modules/flo-poly/node/norm/expansion/e-p-2-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eP2Norm": () => (/* binding */ eP2Norm)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\n/**\r\n * Returns the `p-2 norm`, i.e. `Euclidean norm` of the given array of Shewchuk\r\n * expansions (with intermediate calculations (and the final result) done in\r\n * double precision).\r\n *\r\n * @param p an array of Shewchuk expansions; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction eP2Norm(p) {\r\n    let s = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        s += eEstimate(p[i]) ** 2;\r\n    }\r\n    return Math.sqrt(s);\r\n}\r\n\r\n//# sourceMappingURL=e-p-2-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/expansion/e-p-2-norm.js?')},"./node_modules/flo-poly/node/norm/expansion/e-p-inf-norm.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ePInfNorm": () => (/* binding */ ePInfNorm)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\n/**\r\n * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value\r\n * within the given array of numbers / coefficients (with intermediate\r\n * calculations (and the final result) done in double precision).\r\n *\r\n * @param p an array of numbers; can represent an array of polynomial\r\n * coefficients\r\n *\r\n * @doc\r\n */\r\nfunction ePInfNorm(p) {\r\n    let max = 0;\r\n    for (let i = 0; i < p.length; i++) {\r\n        const v = Math.abs(eEstimate(p[i]));\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n\r\n//# sourceMappingURL=e-p-inf-norm.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/norm/expansion/e-p-inf-norm.js?')},"./node_modules/flo-poly/node/predictive-random/bigint/b-random.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bFlatCoefficients": () => (/* binding */ bFlatCoefficients),\n/* harmony export */   "bFlatCoefficientsArr": () => (/* binding */ bFlatCoefficientsArr),\n/* harmony export */   "bFlatRoots": () => (/* binding */ bFlatRoots),\n/* harmony export */   "bFlatRootsArr": () => (/* binding */ bFlatRootsArr)\n/* harmony export */ });\n/* harmony import */ var _double_random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../double/random.js */ "./node_modules/flo-poly/node/predictive-random/double/random.js");\n/* harmony import */ var _scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scale-to-int/scale-floats-to-bigints.js */ "./node_modules/flo-poly/node/scale-to-int/scale-floats-to-bigints.js");\n\r\n\r\n/**\r\n * Some seed value for the simple random number generator.\r\n *\r\n * @internal\r\n */\r\nconst SEED = 123456789;\r\n/**\r\n * Generates and returns a polynomial with random **roots** (with coefficients\r\n * given densely as an array of bigints from highest to\r\n * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * all roots will approximate real values so is not at all representative of\r\n * a natural random root distribution\r\n *\r\n * * the exact same polynomial will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param d the degree of the polynomials\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @doc\r\n */\r\nfunction bFlatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    const res = (0,_double_random_js__WEBPACK_IMPORTED_MODULE_0__.flatRoots)(d, a, b, seed, odds);\r\n    return { p: (0,_scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatsToBigints)(res.p), seed: res.seed };\r\n}\r\n/**\r\n * Generates and returns an array of polynomials with random **roots** (with\r\n * coefficients given densely as an array of bigints from highest to\r\n * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * all roots will approximate real values so is not at all representative of\r\n * a natural random root distribution\r\n *\r\n * * the exact same polynomials will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param n the number of polynomials to generate.\r\n * @param d the degree of the polynomials\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @doc\r\n */\r\nfunction bFlatRootsArr(n, d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    return (0,_double_random_js__WEBPACK_IMPORTED_MODULE_0__.flatRootsArr)(n, d, a, b, seed, odds).map(_scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatsToBigints);\r\n}\r\n/**\r\n * Generates and returns a polynomial with random **coefficients**\r\n * (with coefficients given densely as an array of bigints from highest to\r\n * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * the exact same polynomials will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param d the length of the polynomial coefficients array\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @doc\r\n */\r\nfunction bFlatCoefficients(d, a = 0, b = 1, seed = SEED) {\r\n    const res = (0,_double_random_js__WEBPACK_IMPORTED_MODULE_0__.flatCoefficients)(d, a, b, seed);\r\n    return { p: (0,_scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatsToBigints)(res.p), seed: res.seed };\r\n}\r\n/**\r\n * Generates and returns an array of polynomials with random **coefficients**\r\n * (with coefficients given densely as an array of bigints from highest to\r\n * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * the exact same polynomials will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param n the number of polynomials to generate.\r\n * @param d the length of the polynomial coefficients array\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @doc\r\n */\r\nfunction bFlatCoefficientsArr(n, d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    return (0,_double_random_js__WEBPACK_IMPORTED_MODULE_0__.flatCoefficientsArr)(n, d, a, b, seed, odds).map(_scale_to_int_scale_floats_to_bigints_js__WEBPACK_IMPORTED_MODULE_1__.scaleFloatsToBigints);\r\n}\r\n\r\n//# sourceMappingURL=b-random.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/predictive-random/bigint/b-random.js?')},"./node_modules/flo-poly/node/predictive-random/double/random.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "flatCoefficients": () => (/* binding */ flatCoefficients),\n/* harmony export */   "flatCoefficientsArr": () => (/* binding */ flatCoefficientsArr),\n/* harmony export */   "flatRoots": () => (/* binding */ flatRoots),\n/* harmony export */   "flatRootsArr": () => (/* binding */ flatRootsArr),\n/* harmony export */   "predictiveRandom": () => (/* binding */ predictiveRandom)\n/* harmony export */ });\n/* harmony import */ var _roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../roots/from-roots/double/from-roots.js */ "./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js");\n\r\n/**\r\n * Arbitrary seed value for the simple random number generator.\r\n *\r\n * @internal\r\n */\r\nconst SEED = 123456789;\r\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n *\r\n * @internal\r\n */\r\nconst RANGE = 4294967296;\r\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n *\r\n * @param f\r\n *\r\n * @internal\r\n */\r\nfunction createArrFunction(f) {\r\n    return function (n, d, a, b, seed = SEED, odds = 0) {\r\n        const res = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const v = f(d, a, b, seed, odds);\r\n            const p = v.p;\r\n            seed = v.seed;\r\n            res.push(p);\r\n        }\r\n        return res;\r\n    };\r\n}\r\n/**\r\n * Generates and returns an array of polynomials with random **roots** (with coefficients\r\n * given densely as an array of double floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * all roots will approximate real values so is not at all representative of\r\n * a natural random root distribution\r\n *\r\n * * the exact same polynomials will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param n the number of polynomials to generate.\r\n * @param d the degree of the polynomials\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @example\r\n * ```typescript\r\n * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nconst flatRootsArr = createArrFunction(flatRoots);\r\n/**\r\n * Generates and returns an array of polynomials with random **coefficients** (with coefficients\r\n * given densely as an array of double floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * the exact same polynomials will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param n the number of polynomials to generate.\r\n * @param d the length of the polynomial coefficients array\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @example\r\n * ```typescript\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nconst flatCoefficientsArr = createArrFunction(flatCoefficients);\r\n/**\r\n * Returns a quasi-random number to be used as the next input to this function.\r\n *\r\n * * see [stackoverflow](https://stackoverflow.com/questions/3062746/special-simple-random-number-generator)\r\n *\r\n * @param seed\r\n *\r\n * @internal\r\n */\r\nfunction predictiveRandom(seed) {\r\n    const a = 134775813;\r\n    return (a * seed + 1) % RANGE;\r\n}\r\n/**\r\n * Generates a random array of numbers picked from a bounded flat\r\n * distribution (i.e. a rectangular distribution) with specified odds of\r\n * duplication of consecutive values.\r\n *\r\n * @param n the number of values to generate\r\n * @param a defaults to 0; the lower bound of the distribution\r\n * @param b defaults to 1; the upper bound of the distribution\r\n * @param seed defaults to 123456789; a seed\r\n * @param odds defaults to 0; the odds that a number will be doubled (applied\r\n * recursively so that some numbers will be tripled, etc.\r\n *\r\n * @internal\r\n */\r\nfunction randomArray(n, a, b, seed, odds = 0) {\r\n    let vs = [];\r\n    for (let i = 0; i < n; i++) {\r\n        seed = predictiveRandom(seed);\r\n        const v = ((seed / RANGE) * (b - a)) + a;\r\n        seed = push(seed, vs, v, odds);\r\n    }\r\n    vs = vs.slice(0, n);\r\n    return { vs, seed };\r\n}\r\n/**\r\n * Helper function that will add more numbers to the passed array - modifies the\r\n * values parameter.\r\n *\r\n * @param seed\r\n * @param values an existing array of values - will be modified!\r\n * @param x the number that will be added (possibly multiple times)\r\n * @param odds the odds that the number will be added again (recursively).\r\n *\r\n * @internal\r\n */\r\nfunction push(seed, values, x, odds) {\r\n    seed = predictiveRandom(seed);\r\n    values.push(x);\r\n    if ((seed / RANGE) < odds) {\r\n        seed = push(seed, values, x, odds);\r\n    }\r\n    return seed;\r\n}\r\n/**\r\n * Generates and returns an array of polynomials with random **roots** (with coefficients\r\n * given densely as an array of double floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * also returns a new seed value that can be used as the input to the next\r\n * call to a predictive random function\r\n *\r\n * * all roots will approximate real values so is not at all representative of\r\n * a natural random root distribution\r\n *\r\n * * the exact same polynomial will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param d the degree of the polynomials\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @example\r\n * ```typescript\r\n * flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {\r\n    const randArr = randomArray(d, a, b, seed, odds);\r\n    seed = randArr.seed;\r\n    const p = (0,_roots_from_roots_double_from_roots_js__WEBPACK_IMPORTED_MODULE_0__.fromRoots)(randArr.vs);\r\n    return { p, seed };\r\n}\r\n/**\r\n * Generates and returns an array of polynomials with random **coefficients** (with coefficients\r\n * given densely as an array of double floating point numbers from highest to\r\n * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).\r\n *\r\n * * also returns a new seed value that can be used as the input to the next\r\n * call to a predictive random function\r\n *\r\n * * the exact same polynomial will be created on each call to this function\r\n * if the same seed is used; this is by design to improve testing.\r\n *\r\n * @param d the length of the polynomial coefficients array\r\n * @param a defaults to 0; the lower bound of the coefficients\r\n * @param b defaults to 1; the upper bound of the coefficients\r\n * @param seed defaults to 123456789; a seed value in [0,4294967296]\r\n * @param odds defaults to 0; the odds that a root will be doubled (applied\r\n * recursively so that some roots could be tripled, etc.\r\n *\r\n * @example\r\n * ```typescript\r\n * flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction flatCoefficients(d, a = -1, b = +1, seed = SEED) {\r\n    const randArr = randomArray(d, a, b, seed);\r\n    seed = randArr.seed;\r\n    const p = randArr.vs;\r\n    return { p, seed };\r\n}\r\n\r\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/predictive-random/double/random.js?')},"./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "allRootsCertifiedSimplified": () => (/* binding */ allRootsCertifiedSimplified)\n/* harmony export */ });\n/* harmony import */ var _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./all-roots-certified.js */ "./node_modules/flo-poly/node/roots/certified/all-roots-certified.js");\n\r\nfunction allRootsCertifiedSimplified(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY, returnUndefinedForZeroPoly) {\r\n    return (0,_all_roots_certified_js__WEBPACK_IMPORTED_MODULE_0__.allRootsCertified)(p.map(c => [0, c]), lb, ub, undefined, undefined, returnUndefinedForZeroPoly);\r\n}\r\n\r\n//# sourceMappingURL=all-roots-certified-simplified.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js?')},"./node_modules/flo-poly/node/roots/certified/all-roots-certified.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"allRootsCertified\": () => (/* binding */ allRootsCertified)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n/* harmony import */ var _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../calculus/double-double/dd-differentiate-with-err.js */ \"./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js\");\n/* harmony import */ var _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../calculus/expansion/e-differentiate.js */ \"./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js\");\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ \"./node_modules/flo-poly/node/evaluate/double/eval-certified.js\");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var _transpose_poly_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transpose-poly.js */ \"./node_modules/flo-poly/node/roots/certified/transpose-poly.js\");\n/* harmony import */ var _eval_adaptive_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eval-adaptive.js */ \"./node_modules/flo-poly/node/roots/certified/eval-adaptive.js\");\n/* harmony import */ var _refine_certified_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./refine-certified.js */ \"./node_modules/flo-poly/node/roots/certified/refine-certified.js\");\n/* harmony import */ var _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../root-bounds/root-bounds-lmq.js */ \"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js\");\n/* harmony import */ var _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../evaluate/double/horner-with-running-error.js */ \"./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst ddDifferentiateWithError = _calculus_double_double_dd_differentiate_with_err_js__WEBPACK_IMPORTED_MODULE_1__.ddDifferentiateWithError;\r\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_3__.evalCertified;\r\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_4__.eHorner;\r\nconst transposePoly = _transpose_poly_js__WEBPACK_IMPORTED_MODULE_5__.transposePoly;\r\nconst evalAdaptive = _eval_adaptive_js__WEBPACK_IMPORTED_MODULE_6__.evalAdaptive;\r\nconst refineCertified = _refine_certified_js__WEBPACK_IMPORTED_MODULE_7__.refineCertified;\r\nconst negativeRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_8__.negativeRootLowerBound_LMQ;\r\nconst positiveRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_8__.positiveRootUpperBound_LMQ;\r\nconst eDifferentiate = _calculus_expansion_e_differentiate_js__WEBPACK_IMPORTED_MODULE_2__.eDifferentiate;\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate;\r\nconst hornerWithRunningError = _evaluate_double_horner_with_running_error_js__WEBPACK_IMPORTED_MODULE_9__.hornerWithRunningError;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst max = Math.max;\r\nconst min = Math.min;\r\nconst abs = Math.abs;\r\nconst eps = Number.EPSILON;\r\nconst onePlusEps = 1 + eps;\r\nfunction allRootsCertified(p, lb = 0, ub = 1, pE, getPExact, returnUndefinedForZeroPoly) {\r\n    // if `getPExact` is not specified then assume the given double-double \r\n    // precision coefficient polynomial is exact\r\n    if (!getPExact) {\r\n        getPExact = () => p;\r\n    }\r\n    //const δ = 2*Number.EPSILON * max(1, max(abs(lb), abs(ub)));\r\n    // if `pE` is not specified then assume there is no error\r\n    pE = pE || new Array(p.length).fill(0); // no error\r\n    // set `diffCount` to 0 so `getPolyExact` can be accurate\r\n    let diffCount = 0;\r\n    // lazy loaded array of the given polynomial and its derivatives\r\n    let psExact = undefined;\r\n    //----------------------------------------------------------------------\r\n    // Remove leading zero coefficients \r\n    // (the case of leading zero coefficients can now be handled)\r\n    // `p` and `getPExact()` *must* be of same length\r\n    //----------------------------------------------------------------------\r\n    let polyExact = undefined; // lazy loaded\r\n    // while the leading coefficient is smaller then the error bound \r\n    // i.e. possibly zero\t\r\n    while (p.length > 0 && abs(p[0][1]) <= pE[0]) {\r\n        polyExact = polyExact || getPExact();\r\n        // if leading coefficient really is zero\r\n        if (eSign(polyExact[0]) === 0) {\r\n            // shift the leading coefficient and error out without altering the \r\n            // given polynomial and error bound (shift is destructive, slice is not)\r\n            p = p.slice();\r\n            p.shift();\r\n            pE = pE.slice();\r\n            pE.shift();\r\n            // also shift out the exact polynomial's leading coefficient\r\n            polyExact.shift();\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (p.length === 0) {\r\n        // return `undefined` for the zero polynomial?\r\n        return returnUndefinedForZeroPoly ? undefined : [];\r\n    }\r\n    else if (p.length === 1) {\r\n        // return `[]` for a degree 1 polynomial (a non-zero constant)\r\n        return [];\r\n    }\r\n    if (lb === Number.NEGATIVE_INFINITY || ub === Number.POSITIVE_INFINITY) {\r\n        const pDoubleCoeffs = p.map(c => c[1]);\r\n        if (lb === Number.NEGATIVE_INFINITY) {\r\n            lb = negativeRootUpperBound_LMQ(pDoubleCoeffs);\r\n        }\r\n        if (ub === Number.POSITIVE_INFINITY) {\r\n            ub = positiveRootUpperBound_LMQ(pDoubleCoeffs);\r\n        }\r\n    }\r\n    const p_ = transposePoly(p);\r\n    let bCount;\r\n    let exact;\r\n    const deg = p.length - 1;\r\n    bCount = 0;\r\n    exact = false;\r\n    let LB; // evaluation at lb\r\n    do {\r\n        LB = exact\r\n            ? eEstimate(eHorner(getPolyExact(), lb))\r\n            : evalCertified(p_, lb, pE);\r\n        if (LB === 0) {\r\n            bCount++;\r\n            // the max bCount is empirically selected for max performance\r\n            if (bCount >= 3 && !exact) {\r\n                exact = true;\r\n                continue;\r\n            }\r\n            lb -= 2 * Number.EPSILON * max(1, abs(lb));\r\n        }\r\n    } while (LB === 0);\r\n    bCount = 0;\r\n    exact = false;\r\n    let UB; // evaluation at ub\r\n    do {\r\n        UB = exact\r\n            ? eEstimate(eHorner(getPolyExact(), ub))\r\n            : evalCertified(p_, ub, pE);\r\n        if (UB === 0) {\r\n            bCount++;\r\n            if (bCount >= 3 && !exact) { // the max bCount is empirically selected for max performance\r\n                exact = true;\r\n                continue;\r\n            }\r\n            ub += 2 * Number.EPSILON * max(1, abs(ub));\r\n        }\r\n    } while (UB === 0);\r\n    // Get all derivatives with their coefficient-wise error bounds, i.e. \r\n    // ps === [p, dp, ddp, ..., constant]\r\n    //        [0,  1,   2, ..., deg     ]\r\n    const ps = [{ p, pE }];\r\n    const ps_ = [transposePoly(p)]; // the transposed versions\r\n    for (let i = 1; i <= deg; i++) {\r\n        const dP = ddDifferentiateWithError(ps[i - 1]);\r\n        ps.push(dP);\r\n        ps_.push(transposePoly(dP.p)); // the transposed versions\r\n    }\r\n    let is = [];\r\n    let curPE;\r\n    let curP_;\r\n    diffCount = deg - 1; // update diffcount\r\n    for (; diffCount >= 0; diffCount--) {\r\n        curPE = ps[diffCount].pE;\r\n        // on first iteration curP_ is linear, \r\n        // on second it is quadratic, etc. ...\r\n        curP_ = ps_[diffCount];\r\n        is = getRootsWithin();\r\n    }\r\n    // depends externally on `diffCount` and `psExact`\r\n    function getPolyExact() {\r\n        // cache\r\n        if (psExact !== undefined) {\r\n            return psExact[diffCount];\r\n        }\r\n        // keep TypeScript happy; `getPExact` cannot be `undefined` here\r\n        let poly = polyExact || getPExact();\r\n        psExact = [poly];\r\n        while (poly.length > 1) {\r\n            poly = eDifferentiate(poly);\r\n            psExact.push(poly);\r\n        }\r\n        return psExact[diffCount];\r\n    }\r\n    return is;\r\n    // All cases:\r\n    // ----------\r\n    // Note: [_a,a_] denotes a micro-interval, whereas [b_,_a], [a_,_b] denotes a\r\n    // normal interval.\r\n    // Note: In all iterations we check [_a,a_] and [a_,_b]. In the final\r\n    // iteration we check [_b,b_], then we've checked all intervals.\r\n    // \r\n    // ⇑ represents +pos (above x-axis) and ⇓ represents -neg\r\n    // (the symmetric cases also applies where + and - are interchanged)\r\n    // ? means does not matter\r\n    // -----------------------------------------------------------------\r\n    // CASE 1A:\r\n    // _A⇑ | A_⇑ | _B⇑\r\n    //  - [_a,a_] → \r\n    //    - _a === a_\r\n    //        ? no root \r\n    //        : A_/_A close enough to zero\r\n    //            ? close even root \r\n    //            : no roots\r\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\r\n    // CASE 1B:\r\n    // _A⇑ | A_⇑ | _B⇓  \r\n    //  - [_a,a_] → \r\n    //    - _a === a_\r\n    //        ? no root \r\n    //        : A_/_A close enough to zero ? close even root : no roots\r\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n    // CASE 2A:\r\n    // _A⇑ | A_⇓ | _B⇑\r\n    //  - [_a,a_] → odd root(s)\r\n    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n    // CASE 2B:\r\n    // _A⇑ | A_⇓ | _B⇓\r\n    //  - [_a,a_] → odd root(s)\r\n    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)\r\n    // CASE 3A: \r\n    // A_0 | A_? | _B? | B_?  \r\n    // CASE 3B: \r\n    // A_? | A_0 | _B? | B_?  \r\n    /**\r\n     * Finds and returns all roots of the given polynomial within the given\r\n     * intervals, starting from the lower bound (lb) and ending at the upper\r\n     * bound (ub) as fetched from the closure.\r\n     *\r\n     * * **precondition** intervals should be disjoint, i.e endpoints are not allowed\r\n     * to be equal - it must be that a_ !== _b\r\n     * * **precondition** the curve must be monotone increasing or decreasing between\r\n     * b_ and _a AND a_ and _b\r\n     * * **precondition** the value at the lower bound (LB) and upper bound (UB)\r\n     * must !== 0\r\n     *\r\n     * @internal\r\n     *\r\n     * @param curP_ a polynomial given as an array with each consecutive element of\r\n     * the array having more accurate coefficients than the previous (by adding\r\n     * consecutive double precision coefficients to prior coefficients)\r\n     * @param is the micro-intervals\r\n     */\r\n    function getRootsWithin() {\r\n        const roots = [];\r\n        // If there are no micro-intervals then check the interval between lb and ub.\r\n        const LB = evalAdaptive(curP_, curPE, lb, getPolyExact);\r\n        if (!is.length) {\r\n            // close even root not possible\r\n            const UB = evalAdaptive(curP_, curPE, ub, getPolyExact);\r\n            if (LB * UB >= 0) {\r\n                return [];\r\n            }\r\n            const [tS, tE] = refineCertified(curP_, curPE, lb, ub, LB, UB, getPolyExact /*, δ*/);\r\n            return [{ tS, tE, multiplicity: 1 }];\r\n        }\r\n        //---- First check from lb to the left side of the first micro-interval.\r\n        let _a = is[0].tS;\r\n        let _A = evalAdaptive(curP_, curPE, _a, getPolyExact);\r\n        if (LB * _A > 0) {\r\n            // no roots possible (curve is monotone increasing or decreasing)\r\n        }\r\n        else if (LB * _A < 0) {\r\n            // recall LB must !== 0 as a precondition\r\n            const [tS, tE] = refineCertified(curP_, curPE, lb, _a, LB, _A, getPolyExact /*, δ*/);\r\n            roots.push({ tS, tE, multiplicity: 1 });\r\n        } //else {\r\n        // _A === 0\r\n        // no roots possible in [lb,_a]\r\n        //}\r\n        let a_ = lb;\r\n        let A_ = LB;\r\n        let _b = _a;\r\n        let _B = _A;\r\n        let a;\r\n        for (let i = 0; i < is.length; i++) {\r\n            const i_ = is[i + 1]; // right micro-interval\r\n            a = is[i];\r\n            _a = _b;\r\n            a_ = is[i].tE;\r\n            _b = i_ ? i_.tS : ub;\r\n            const B_ = A_;\r\n            _A = _B;\r\n            A_ = evalAdaptive(curP_, curPE, a_, getPolyExact);\r\n            _B = evalAdaptive(curP_, curPE, _b, getPolyExact);\r\n            if (_A * A_ > 0) {\r\n                //---- CASE 1: _A⇑ | A_⇑   OR   _A⇓ | A_⇓\r\n                if (A_ * _B > 0) {\r\n                    //---- CASE 1A: _A⇑ | A_⇑ | _B⇑   OR   _A⇓ | A_⇓ | _B⇓\r\n                    //console.log('CASE 1A');\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA();\r\n                    }\r\n                    // [a_,_b] → no root\r\n                }\r\n                else if (A_ * _B < 0) {\r\n                    //---- CASE 1B: _A⇑ | A_⇑ | _B⇓   OR   _A⇓ | A_⇓ | _B⇑\r\n                    //console.log('CASE 1B');\r\n                    // we cannot exclude this case as their may be even \r\n                    // multiplicity >= 4 roots; we would've been able if we\r\n                    // knew that a.multiplicity === 1 exactly and thus the code\r\n                    // could still be improved slightly\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA();\r\n                    }\r\n                    // [a_,_b] → single root (curve is monotone increasing or decreasing)\r\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\r\n                    roots.push({ tS, tE, multiplicity: 1 });\r\n                }\r\n                else { // _B === 0\r\n                    //---- CASE 1C: _A⇑ | A_⇑ | _B0   OR   _A⇓ | A_⇓ | _B0\r\n                    //console.log('CASE 1C');\r\n                    // we cannot exclude this case as their may be even \r\n                    // multiplicity >= 4 roots; we would've been able if we\r\n                    // knew that a.multiplicity === 1 exactly and thus the code\r\n                    // could still be improved slightly\r\n                    if (a_ !== _a && a.multiplicity % 2 === 1) {\r\n                        checkEvenAA();\r\n                    }\r\n                    // [a_,_b] → no root\r\n                }\r\n            }\r\n            else if (_A * A_ < 0) {\r\n                //---- CASE 2 _A⇑ | A_⇓   OR   _A⇓ | A_⇑\r\n                //console.log('CASE 2');\r\n                // - [_a,a_] → odd root(s)\r\n                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\r\n                if (A_ * _B < 0) {\r\n                    //---- CASE 2A: _A⇑ | A_⇓ | _B⇑   OR   _A⇓ | A_⇑ | _B⇓\r\n                    //console.log('CASE 2A');\r\n                    // [a_,_b] → single root\r\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\r\n                    roots.push({ tS, tE, multiplicity: 1 });\r\n                }\r\n                else if (A_ * _B > 0) {\r\n                    //---- CASE 2B: _A⇑ | A_⇓ | _B⇓   OR   _A⇓ | A_⇑ | _B⇑\r\n                    //console.log('CASE 2B');\r\n                    // [a_,_b] → no roots\r\n                }\r\n                else { // _B === 0\r\n                    //console.log('CASE 2C');\r\n                    // [a_,_b] → no roots\r\n                }\r\n            }\r\n            else if (A_ === 0) {\r\n                //---- CASE 3A A_0\r\n                //console.log('CASE 3A');\r\n                // [_a,a_] → rational root at a_\r\n                // There cannot be a root between a_ and _b since _B !== 0\r\n                if ( /*_a === a_ ||*/_A === 0) {\r\n                    // multiple rational root at a_ OR both _A and A_ is 0\r\n                    // so update multiplicity parity\r\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: a.multiplicity + 1 });\r\n                }\r\n                else {\r\n                    // now _A and _B are both !== 0\r\n                    if (_A * _B > 0) {\r\n                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\r\n                    }\r\n                    else {\r\n                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\r\n                    }\r\n                }\r\n            }\r\n            else { // _A === 0\r\n                //---- CASE 3B _A0\r\n                //console.log('CASE 3B');\r\n                // A_ !== 0 here and _a !== a_\r\n                // [_a,a_] → rational root at _a\r\n                if (A_ * _B < 0) {\r\n                    // [a_,_b] → single root\r\n                    const [tS, tE] = refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);\r\n                    roots.push({ tS, tE, multiplicity: 1 });\r\n                }\r\n                else if (A_ * _B > 0) {\r\n                    // [a_,_b] → no roots\r\n                }\r\n                // - [_a,a_] → \r\n                // B_ and A_ are both !== 0\r\n                if (B_ * A_ > 0) {\r\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\r\n                }\r\n                else {\r\n                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });\r\n                }\r\n            }\r\n        }\r\n        // Combine the root intervals if they are adjacent (they are not \r\n        // allowed to overlap)\r\n        for (let i = 0; i < roots.length - 1; i++) {\r\n            const r = roots[i];\r\n            const r_ = roots[i + 1];\r\n            if (r.tE >= r_.tS) {\r\n                return joinRoots(roots);\r\n            }\r\n        }\r\n        return roots;\r\n        /**\r\n         * Calculates and returns max 2nd derivative - calculated using something\r\n         * akin to a Taylor expansion - could be improved by not taking absolute\r\n         * values, but rather minimum mins. and maximum max values of f(s)?.\r\n         * maxDdP = |f(s)| + δ|f'(s)| + δ^2|f''(s)| + ..., where δ = (a_ - _a),\r\n         * s = _a and f is the second derivative of the current polynomial. We can\r\n         * also potentially short circuit the maxDdP calculation after some terms,\r\n         * the point being there are very likely many optimizations that can still\r\n         * be done.\r\n         *\r\n         * @internal\r\n         */\r\n        function checkEvenAA() {\r\n            //This was the old method when the function only supported lb = 0, ub = 1\r\n            //-----------------------------------------------------------------------\r\n            //const ddP0 = diffCount+2 > deg ? undefined : ps_[diffCount+2][0];\r\n            //const maxDdP2 = 0;\r\n            //for (const j=0; j<ddP0.length; j++) {\r\n            //\t// evaluate at 1\r\n            //\tmaxDdP2 += abs(ddP0[j]);  // this is valid only if |lb| and |ub| <= 1\r\n            //}\r\n            const d = (a_ - _a) * onePlusEps;\r\n            let mult = 1;\r\n            let maxDdP = 0;\r\n            for (let ddDiffCount = diffCount + 2; ddDiffCount <= deg; ddDiffCount++) {\r\n                const p = ps_[ddDiffCount][0];\r\n                const h = hornerWithRunningError(p, _a);\r\n                const fs = abs(h[0]) + h[1];\r\n                maxDdP += fs * mult;\r\n                mult *= d * onePlusEps;\r\n            }\r\n            // maxDdP is now calculated\r\n            const AMinMax = A_ > 0 ? min(_A, A_) : max(_A, A_);\r\n            const δ = 2 * Number.EPSILON * max(1, abs(a_));\r\n            const dMax = maxDdP * (2 * δ); // since the first derivative === 0 somewhere in [_a,a_]\r\n            const yShift = A_ > 0 ? -dMax * 2 * δ : dMax * 2 * δ;\r\n            const y = AMinMax + yShift;\r\n            if (y * A_ < 0) {\r\n                // possible even multiplicity root\r\n                //console.log('A_, yShift', A_, yShift);\r\n                //console.log(toCasStr(ps_[0][0]));\r\n                //console.log('possible even multiplicty root: ', _a, a_);\r\n                // The below multiplicity can really be any non-negative \r\n                // multiple of 2\r\n                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction joinRoots(rs) {\r\n    const newRs = [];\r\n    const r = rs[0];\r\n    // make a clone of the first interval\r\n    let curR = { tS: r.tS, tE: r.tE, multiplicity: r.multiplicity };\r\n    for (let i = 0; i < rs.length - 1; i++) {\r\n        const r = rs[i];\r\n        const r_ = rs[i + 1];\r\n        if (r.tE < r_.tS) {\r\n            // they don't stick together\r\n            newRs.push(curR);\r\n            // make a clone of the next interval\r\n            curR = { tS: r_.tS, tE: r_.tE, multiplicity: r_.multiplicity };\r\n        }\r\n        else {\r\n            // they stick together - expand\r\n            curR.tE = r_.tE;\r\n            curR.multiplicity = r.multiplicity + r_.multiplicity;\r\n        }\r\n    }\r\n    newRs.push(curR);\r\n    return newRs;\r\n}\r\n\r\n//# sourceMappingURL=all-roots-certified.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/all-roots-certified.js?")},"./node_modules/flo-poly/node/roots/certified/eval-adaptive.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "evalAdaptive": () => (/* binding */ evalAdaptive)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ "./node_modules/flo-poly/node/evaluate/double/eval-certified.js");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-horner.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__.evalCertified;\r\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eHorner;\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eEstimate;\r\n/**\r\n * Returns the result of evaluating the given polynomial (with double-double\r\n * precision coefficients) at the given value, where the coefficient-wise error\r\n * is also given.\r\n *\r\n * * **the sign of the returned result is guaranteed to be correct**\r\n * * the evaluation is done adaptively, i.e. if the evaluation cannot be done\r\n * accurately enough then an exact precision polynomial is requested\r\n *\r\n * @param p a polynomial given as an array with each consecutive element of\r\n * the array having more accurate coefficients than the previous (by adding\r\n * consecutive double precision coefficients to prior coefficients)\r\n * @param pE a coefficientwise error bound\r\n * @param x the point of evaluation\r\n * @param psExact an object holding the exact polynomial and all its exact\r\n * derivatives - this object may be modified!\r\n * @param getPsExact a function to retrieve the exact polynomial and all its\r\n * exact derivatives\r\n * @param diffCount the number of differentiations done up to this point\r\n *\r\n * @internal\r\n */\r\nfunction evalAdaptive(p, pE, x, getPolyExact) {\r\n    const r = evalCertified(p, x, pE, 4);\r\n    if (r !== 0) {\r\n        return r;\r\n    }\r\n    // condition number is too high - request higher precision\r\n    return eEstimate(eHorner(getPolyExact(), x));\r\n}\r\n\r\n//# sourceMappingURL=eval-adaptive.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/eval-adaptive.js?')},"./node_modules/flo-poly/node/roots/certified/refine-certified.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"refineCertified\": () => (/* binding */ refineCertified)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/eval-certified.js */ \"./node_modules/flo-poly/node/evaluate/double/eval-certified.js\");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/expansion/e-horner.js */ \"./node_modules/flo-poly/node/evaluate/expansion/e-horner.js\");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! big-float-ts */ \"./node_modules/big-float-ts/node/index.js\");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst evalCertified = _evaluate_double_eval_certified_js__WEBPACK_IMPORTED_MODULE_0__.evalCertified;\r\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eHorner;\r\nconst eEstimate = big_float_ts__WEBPACK_IMPORTED_MODULE_2__.eEstimate;\r\nconst eps = Number.EPSILON;\r\nconst abs = Math.abs;\r\nconst max = Math.max;\r\n/**\r\n * Returns a refined root given a root bracketed in the interval (a,b) of the\r\n * given polynomial using Brent's Method - modified slightly to allow for\r\n * error certified bounds.\r\n *\r\n * * near exact implementation of the original Brent Dekker Method (also known\r\n * as Brent's Method), except that it is specialzed to polynomial evaluation\r\n *\r\n * * Brent's Method is an excellent root-refinement choice since:\r\n *  * guaranteed converge (unlike the Newton and other so-called single-point\r\n * methods),\r\n *  * converges in a reasonable number of iterations even for highly contrived\r\n * functions (unlike Dekker's Method) and\r\n *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and\r\n * Regula-Falsi methods).\r\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\r\n * works but is not precisely Brent's method and runs about 2x or more slower\r\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\r\n *\r\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\r\n * * [c++ implementation of Brent's Method](https://people.sc.fsu.edu/~jburkardt/cpp_src/brent/brent.cpp)\r\n *\r\n * @param p A polynomial with coefficients given densely as an array of double-double\r\n * floating point numbers from highest to lowest power, e.g. `[[0,5],[0,-3],[0,0]]`\r\n * represents the polynomial `5x^2 - 3x`. If `exact` is `true` then this is allowed\r\n * to be `undefined`.\r\n * @param pE An error polynomial that provides a coefficientwise error bound on\r\n * the input polynomial; all coefficients must be positive. If `exact` is `true`\r\n * then this is allowed to be `undefined`.\r\n * @param lb the lower limit of the search interval.\r\n * @param ub the upper limit of the search interval.\r\n * @param fa the result of evaluating the input polynomial at `a`\r\n * @param fb the result of evaluating the input polynomial at `b`\r\n * @param psExact\r\n * @param getPsExact\r\n * @param diffCount\r\n * @param exact set to true if you need to do exact evaluations from the start\r\n *\r\n * @internal\r\n */\r\nfunction refineCertified(p, pE, lb, ub, fa, fb, getPolyExact, exact) {\r\n    //---- Make local copies of a and b.\r\n    let a = lb;\r\n    let b = ub;\r\n    let c = a;\r\n    let fc = fa;\r\n    let e = b - a;\r\n    let d = e;\r\n    while (true) {\r\n        // update delta\r\n        if (abs(fc) < abs(fb)) {\r\n            a = b;\r\n            b = c;\r\n            c = a;\r\n            fa = fb;\r\n            fb = fc;\r\n            fc = fa;\r\n        }\r\n        // Original c++ code had the line below but with us t === 0 and b is \r\n        // taken as 1 and 2.0 * macheps is taken as 2*u === Number.EPSILON (eps)\r\n        // or can also be taken as 4*u === 2*Number.EPSILON (2*eps)\r\n        // adaptive tolerance\r\n        //let δ = 2 * eps * max(1,abs(b));\r\n        //let δ = 2 * u * max(1,abs(b));\r\n        let δ;\r\n        const mm = max(abs(a), abs(b));\r\n        if (mm <= 1) {\r\n            δ = eps;\r\n        }\r\n        else {\r\n            // keep δ = eps * a power of 2\r\n            //δ = eps * 2**Math.ceil(Math.log2(Math.ceil(mm)));  // may be faster to get log2 of an integer\r\n            δ = eps * 2 ** Math.ceil(Math.log2(mm));\r\n        }\r\n        //tol = 2.0 * macheps * abs ( b ) + t;\r\n        const m = 0.5 * (c - b);\r\n        //if (abs(m) <= δ || fb === 0) {\r\n        // modified from the original since we dont need the fb === 0 check here\r\n        if (abs(m) <= δ) {\r\n            // TODO - could potentially make b - c a power of 2 here δ\r\n            return b < c ? [b, c] : [c, b];\r\n        }\r\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\r\n            e = m;\r\n            d = e;\r\n        }\r\n        else {\r\n            let s = fb / fa;\r\n            let p;\r\n            let q;\r\n            if (a === c) {\r\n                p = 2 * m * s;\r\n                q = 1 - s;\r\n            }\r\n            else {\r\n                q = fa / fc;\r\n                const r = fb / fc;\r\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\r\n                q = (q - 1) * (r - 1) * (s - 1);\r\n            }\r\n            if (0 < p) {\r\n                q = -q;\r\n            }\r\n            else {\r\n                p = -p;\r\n            }\r\n            s = e;\r\n            e = d;\r\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\r\n                d = p / q;\r\n            }\r\n            else {\r\n                e = m;\r\n                d = e;\r\n            }\r\n        }\r\n        a = b;\r\n        fa = fb;\r\n        if (δ < abs(d)) {\r\n            b = b + d;\r\n        }\r\n        else if (0 < m) {\r\n            b = b + δ;\r\n        }\r\n        else {\r\n            //b = b - eps;\r\n            b = b - δ;\r\n        }\r\n        fb = exact\r\n            ? eEstimate(eHorner(getPolyExact(), b))\r\n            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` \r\n            // here by a precondition\r\n            : evalCertified(p, b, pE);\r\n        if (fb === 0) {\r\n            // Since `evalCertified` returns zero if undecided the zero result\r\n            // cannot be fully trusted at this point.\r\n            // if we are already doing exact evaluations this is an exact root\r\n            if (exact) {\r\n                return [b, b];\r\n            }\r\n            // We need to calculate δ/2 to the left and right of b to get \r\n            // results that should usually be !== 0. \r\n            // It is a pre-filter. If the result === 0 we need to sharpen the\r\n            // ability of the evaluation by somehow reducing the error bound\r\n            const sL = Math.max(lb, b - δ); // dont overstep bounds\r\n            const sR = Math.min(ub, b + δ); // dont overstep bounds\r\n            // Note: sR - sL <= 2*δ provided lb, ub are in [-1..1] - usually \r\n            // (when sL === s - δ and sR === s + δ) sR - sL === 2*δ. Also δ > 0\r\n            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` \r\n            // here by a precondition\r\n            const fsL = evalCertified(p, sL, pE);\r\n            const fsR = evalCertified(p, sR, pE);\r\n            // if the evaluation method is strong enough return the result\r\n            if (fsL * fsR !== 0) {\r\n                return [sL, sR];\r\n            }\r\n            // At this point either fsL or fsR === 0 so we need to sharpen the\r\n            // evaluation method\r\n            exact = true;\r\n            // get and cache the exact polynomial (we cache this since getting\r\n            // an exact polynomial takes about 15 times more time than getting\r\n            // a double-double polynomial and we very rarely expect to get to \r\n            // this point)\r\n            fb = eEstimate(eHorner(getPolyExact(), b));\r\n            // if the exact evaluation returns 0 we have an exact root\r\n            if (fb === 0) {\r\n                return [b, b];\r\n            }\r\n            // else we've got a new value for fb and from here on we use exact\r\n            // evaluations\r\n        }\r\n        if ((0 < fb && 0 < fc) || (fb <= 0 && fc <= 0)) {\r\n            c = a;\r\n            fc = fa;\r\n            e = b - a;\r\n            d = e;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=refine-certified.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/refine-certified.js?")},"./node_modules/flo-poly/node/roots/certified/refine-k1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "refineK1": () => (/* binding */ refineK1)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../change-variables/expansion/e-change-variables-linear.js */ "./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js");\n/* harmony import */ var _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./all-roots-certified.js */ "./node_modules/flo-poly/node/roots/certified/all-roots-certified.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eChangeVariablesLinear = _change_variables_expansion_e_change_variables_linear_js__WEBPACK_IMPORTED_MODULE_1__.eChangeVariablesLinear;\r\nconst allRootsCertified = _all_roots_certified_js__WEBPACK_IMPORTED_MODULE_2__.allRootsCertified;\r\nconst eToDd = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eToDd;\r\nconst twoSum = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum;\r\nconst eps = Number.EPSILON;\r\n/**\r\n * Returns once compensated root(s) (bar underflow / overflow) given a root\r\n * interval previously calculated using [[allRootsCertified]].\r\n *\r\n * * \'once-compensated\' here means that the typical root interval, `W`,\r\n * (`= Number.EPSILON` at `1`) is reduced to `W**2`; if multiple roots were\r\n * present in the original interval they may be resolved to individual\r\n * intervals\r\n *\r\n * @param ri a root interval previously calculated\r\n * @param p the exact polynomial with coefficients given densely as an array of\r\n * Shewchuk floating point expansions from highest to lowest power,\r\n * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction refineK1(ri, p) {\r\n    const tS = ri.tS;\r\n    // scale is exact by the precondition put on `RootInterval`\r\n    const δ = ri.tE - tS;\r\n    if (δ === 0) {\r\n        return [{\r\n                tS: [0, tS],\r\n                tE: [0, tS],\r\n                multiplicity: ri.multiplicity\r\n            }];\r\n    }\r\n    // Translate the polynomial such that the root is within δ from 0, then\r\n    // scale it such that the roots stay <= 1, i.e. is in [0,1]\r\n    const pExactK1 = eChangeVariablesLinear(p, δ, tS);\r\n    // reduce the polynomial to double-double precision for faster root finding\r\n    const pDdK1 = pExactK1.map(eToDd);\r\n    // update the double-double precision error bound - it is simply the error \r\n    // in rounding the exact coefficients to double-double precision\r\n    const errBoundK1 = pDdK1.map(c => eps * eps * c[1]);\r\n    const getPExactK1 = () => pExactK1;\r\n    // keep TypeScript happy; `allRootsCertified` can safely be assumed not to\r\n    // return `undefined`\r\n    const risLo = allRootsCertified(pDdK1, 0, 1, errBoundK1, getPExactK1);\r\n    const ris = [];\r\n    for (let riLo of risLo) {\r\n        ris.push({\r\n            tS: twoSum(tS, riLo.tS * δ),\r\n            tE: twoSum(tS, riLo.tE * δ),\r\n            multiplicity: riLo.multiplicity\r\n        });\r\n    }\r\n    return ris;\r\n}\r\n\r\n//# sourceMappingURL=refine-k1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/refine-k1.js?')},"./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rootIntervalToExp": () => (/* binding */ rootIntervalToExp)\n/* harmony export */ });\n/**\r\n * Returns the result of converting a double precision root interval to a\r\n * double-double precision one\r\n *\r\n * @param ri a root interval\r\n *\r\n * @doc\r\n */\r\nfunction rootIntervalToExp(ri) {\r\n    return {\r\n        tS: [0, ri.tS],\r\n        tE: [0, ri.tE],\r\n        multiplicity: ri.multiplicity\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=root-interval-to-exp.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js?')},"./node_modules/flo-poly/node/roots/certified/root-interval.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createRootExact": () => (/* binding */ createRootExact),\n/* harmony export */   "mid": () => (/* binding */ mid)\n/* harmony export */ });\n/**\r\n * Simple function that creates and returns an exact root (with a bracketing\r\n * interval width of 0 and multiplicity 1)\r\n *\r\n * @param t\r\n *\r\n * @doc\r\n */\r\nfunction createRootExact(t) {\r\n    return { tS: t, tE: t, multiplicity: 1 };\r\n}\r\n/**\r\n * Simple function that returns the middle of the root bracketing interval - can\r\n * be used to estimate the root\r\n *\r\n * @param ri a root interval\r\n *\r\n * @doc\r\n */\r\nfunction mid(ri) {\r\n    return (ri.tS + ri.tE) / 2;\r\n}\r\n\r\n//# sourceMappingURL=root-interval.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/root-interval.js?')},"./node_modules/flo-poly/node/roots/certified/transpose-poly.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"transposePoly\": () => (/* binding */ transposePoly)\n/* harmony export */ });\n/**\r\n * Transposes the given polynomial (given with multi-precision coefficients)\r\n * into multiple polynomials with each consecutive polynomial 'adjusting'\r\n * the prior one to higher precision.\r\n *\r\n * @param p\r\n *\r\n * @internal\r\n */\r\nfunction transposePoly(p) {\r\n    // transpose the polynomial coefficients into multiple polynomials\r\n    const len = p[0].length;\r\n    const p_ = [];\r\n    for (let i = 0; i < len; i++) {\r\n        const _p = [];\r\n        for (let j = 0; j < p.length; j++) {\r\n            _p.push(p[j][len - (i + 1)]); // from highest to lowest\r\n        }\r\n        p_.push(_p);\r\n    }\r\n    return p_;\r\n}\r\n\r\n//# sourceMappingURL=transpose-poly.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/certified/transpose-poly.js?")},"./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-0-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bNumRootsIn01": () => (/* binding */ bNumRootsIn01)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/bigint/b-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js");\n/* harmony import */ var _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js");\n/* harmony import */ var _evaluate_bigint_b_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../evaluate/bigint/b-evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-1.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bSturmChain = _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.bSturmChain;\r\nconst bSignChanges = _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_1__.bSignChanges;\r\nconst bEvaluateAt1 = _evaluate_bigint_b_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__.bEvaluateAt1;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (0,1) of the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the\r\n * polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction bNumRootsIn01(p) {\r\n    const ps = bSturmChain(p);\r\n    const as = ps.map(p => p[p.length - 1]); // evaluate at 0\r\n    const bs = ps.map(p => bEvaluateAt1(p)); // evaluate at 1\r\n    return bSignChanges(as) - bSignChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=b-num-roots-0-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-0-1.js?')},"./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-in-range.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bNumRootsInRange": () => (/* binding */ bNumRootsInRange)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/bigint/b-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js");\n/* harmony import */ var _evaluate_bigint_b_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../evaluate/bigint/b-horner.js */ "./node_modules/flo-poly/node/evaluate/bigint/b-horner.js");\n/* harmony import */ var _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./b-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bSturmChain = _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.bSturmChain;\r\nconst bHorner = _evaluate_bigint_b_horner_js__WEBPACK_IMPORTED_MODULE_1__.bHorner;\r\nconst bSignChanges = _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.bSignChanges;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (a,b) of the given polynomial.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [1n, 1n, -64n, 236n, -240n];\r\n * bNumRootsInRange(p,-20,-11);  //=> 0\r\n * bNumRootsInRange(p,-11,-9);   //=> 1\r\n * bNumRootsInRange(p,-11,3.5);  //=> 3\r\n * bNumRootsInRange(p,-11,5);    //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bNumRootsInRange(p, a, b) {\r\n    const ps = bSturmChain(p);\r\n    const as = ps.map(p => bHorner(p, a));\r\n    const bs = ps.map(p => bHorner(p, b));\r\n    return bSignChanges(as) - bSignChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=b-num-roots-in-range.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-in-range.js?')},"./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bNumRoots": () => (/* binding */ bNumRoots)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/bigint/b-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js");\n/* harmony import */ var _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../basic/bigint/b-degree.js */ "./node_modules/flo-poly/node/basic/bigint/b-degree.js");\n/* harmony import */ var _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./b-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bSturmChain = _euclidean_division_related_bigint_b_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.bSturmChain;\r\nconst bDegree = _basic_bigint_b_degree_js__WEBPACK_IMPORTED_MODULE_1__.bDegree;\r\nconst bSignChanges = _b_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.bSignChanges;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)\r\n * of the given polynomial.\r\n *\r\n * * From Wikipedia: "In the case of a non-square-free polynomial,\r\n * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number\r\n * of distinct real roots of P".\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [n1, 1n, -64n, 236n, -240n];\r\n * bNumRoots(p); //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bNumRoots(p) {\r\n    const ps = bSturmChain(p);\r\n    const as = ps.map(p => bDegree(p) % 2 === 0 ? p[0] : -p[0]);\r\n    const bs = ps.map(p => p[0]);\r\n    return bSignChanges(as) - bSignChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=b-num-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots.js?')},"./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bSignChanges": () => (/* binding */ bSignChanges)\n/* harmony export */ });\n/**\r\n * Returns the number of sign changes in the polynomial coefficents when\r\n * ordered in descending order; zeros are ignored.\r\n *\r\n * * Descartes\' rule of signs states (quoted from Wikipedia):\r\n * "if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately."\r\n *\r\n * * see [Descartes\' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * bSignChanges([1n,2n,-3n,0n,0n,3n,-1n]); //=> 3\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bSignChanges(p) {\r\n    const d = p.length - 1;\r\n    let result = 0;\r\n    let prevSign = p[0] === 0n ? 0 : p[0] < 0n ? -1 : +1;\r\n    for (let i = 1; i < d + 1; i++) {\r\n        const sign = p[i] === 0n ? 0 : p[i] < 0n ? -1 : +1;\r\n        if (sign !== prevSign && sign !== 0) {\r\n            result++;\r\n            prevSign = sign;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=b-sign-changes.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js?')},"./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-0-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "numRootsIn01": () => (/* binding */ numRootsIn01)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _sign_changes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js");\n/* harmony import */ var _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../evaluate/expansion/e-evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eEvaluateAt1 = _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__.eEvaluateAt1;\r\nconst eSturmChain = _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.eSturmChain;\r\nconst signChanges = _sign_changes_js__WEBPACK_IMPORTED_MODULE_1__.signChanges;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (0,1) of the given polynomial - subject to floating point\r\n * underflow / overflow of intermediate calculations.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * precision floating point numbers from highest to lowest power,\r\n * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction numRootsIn01(p) {\r\n    const p_ = p.map(c => [c]);\r\n    const ps = eSturmChain(p_);\r\n    const as = ps.map(p_ => eSign(p_[p_.length - 1])); // evaluate at 0\r\n    const bs = ps.map(p_ => eSign(eEvaluateAt1(p_))); // evaluate at 1\r\n    return signChanges(as) - signChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=num-roots-in-0-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-0-1.js?')},"./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-range.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "numRootsInRange": () => (/* binding */ numRootsInRange)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_double_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/double/sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/double/sturm-chain.js");\n/* harmony import */ var _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../evaluate/expansion/e-horner.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-horner.js");\n/* harmony import */ var _expansion_e_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expansion/e-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst sturmChain = _euclidean_division_related_double_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.sturmChain;\r\nconst eHorner = _evaluate_expansion_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eHorner;\r\nconst eSignChanges = _expansion_e_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.eSignChanges;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (a,b) of the given polynomial - subject to floating point\r\n * underflow / overflow of intermediate calculations.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a a lower bound\r\n * @param b an upper bound\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [1, 1, -64, 236, -240];\r\n * numRootsInRange(p,-20,-11);  //=> 0\r\n * numRootsInRange(p,-11,-9);   //=> 1\r\n * numRootsInRange(p,-11,3.5);  //=> 3\r\n * numRootsInRange(p,-11,5);    //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction numRootsInRange(p, a, b) {\r\n    const ps = sturmChain(p);\r\n    const as = ps.map(p => eHorner(p, a));\r\n    const bs = ps.map(p => eHorner(p, b));\r\n    return eSignChanges(as) - eSignChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=num-roots-in-range.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-range.js?')},"./node_modules/flo-poly/node/roots/descartes/double/num-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "numRoots": () => (/* binding */ numRoots)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst signChanges = _sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.signChanges;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst eDegree = _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_3__.eDegree;\r\nconst eSturmChain = _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_1__.eSturmChain;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)\r\n * of the given polynomial - subject to floating point underflow / overflow of\r\n * intermediate calculations.\r\n *\r\n * * From Wikipedia: "In the case of a non-square-free polynomial,\r\n * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number\r\n * of distinct real roots of P".\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [1, 1, -64, 236, -240];\r\n * numRoots(p); //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction numRoots(p) {\r\n    const p_ = p.map(c => [c]);\r\n    const ps = eSturmChain(p_);\r\n    const as = ps.map(p_ => eDegree(p_) % 2 === 0 ? eSign(p_[0]) : -eSign(p_[0]));\r\n    const bs = ps.map(p_ => eSign(p_[0]));\r\n    return signChanges(as) - signChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=num-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/double/num-roots.js?')},"./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "signChanges": () => (/* binding */ signChanges)\n/* harmony export */ });\n/**\r\n * Returns the number of sign changes in the polynomial coefficents when\r\n * ordered in descending order; zeros are ignored.\r\n *\r\n * * Descartes\' rule of signs states (quoted from Wikipedia):\r\n * "if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately."\r\n *\r\n * * see [Descartes\' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction signChanges(p) {\r\n    const d = p.length - 1;\r\n    let result = 0;\r\n    let prevSign = Math.sign(p[0]);\r\n    for (let i = 1; i < d + 1; i++) {\r\n        const sign = Math.sign(p[i]);\r\n        if (sign !== prevSign && sign !== 0) {\r\n            result++;\r\n            prevSign = sign;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=sign-changes.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js?')},"./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-0-1.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eNumRootsIn01": () => (/* binding */ eNumRootsIn01)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _double_sign_changes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../double/sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js");\n/* harmony import */ var _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../evaluate/expansion/e-evaluate-at-1.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eEvaluateAt1 = _evaluate_expansion_e_evaluate_at_1_js__WEBPACK_IMPORTED_MODULE_2__.eEvaluateAt1;\r\nconst eSturmChain = _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.eSturmChain;\r\nconst signChanges = _double_sign_changes_js__WEBPACK_IMPORTED_MODULE_1__.signChanges;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_3__.eSign;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (0,1) of the given polynomial - subject to floating point\r\n * underflow / overflow of intermediate calculations.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction eNumRootsIn01(p) {\r\n    const ps = eSturmChain(p);\r\n    const as = ps.map(p => eSign(p[p.length - 1])); // evaluate at 0\r\n    const bs = ps.map(p => eSign(eEvaluateAt1(p))); // evaluate at 1\r\n    return signChanges(as) - signChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=e-num-roots-0-1.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-0-1.js?')},"./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-in-range.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eNumRootsInRange": () => (/* binding */ eNumRootsInRange)\n/* harmony export */ });\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _evaluate_expansion_e_e_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../evaluate/expansion/e-e-horner.js */ "./node_modules/flo-poly/node/evaluate/expansion/e-e-horner.js");\n/* harmony import */ var _e_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./e-sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eeHorner = _evaluate_expansion_e_e_horner_js__WEBPACK_IMPORTED_MODULE_1__.eeHorner;\r\nconst eSturmChain = _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_0__.eSturmChain;\r\nconst eSignChanges = _e_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.eSignChanges;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the open\r\n * interval (a,b) of the given polynomial - subject to floating point\r\n * underflow / overflow of intermediate calculations.\r\n *\r\n * * From Wikipedia: "In the case of a non-square-free polynomial, if\r\n * neither a nor b is a multiple root of p, then V(a) − V(b) is the number of\r\n * distinct real roots of P".\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param a a lower bound given as a Shewchuk expansion\r\n * @param b an upper bound\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [[1], [1], [-64], [236], [-240]];\r\n * eNumRootsInRange(p,-20,-11); //=> 0\r\n * eNumRootsInRange(p,-11,-9);  //=> 1\r\n * eNumRootsInRange(p,-11,3.5); //=> 3\r\n * eNumRootsInRange(p,-11,5);   //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eNumRootsInRange(p, a, b) {\r\n    const ps = eSturmChain(p);\r\n    const as = ps.map(p => eeHorner(p, a));\r\n    const bs = ps.map(p => eeHorner(p, b));\r\n    return eSignChanges(as) - eSignChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=e-num-roots-in-range.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-in-range.js?')},"./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eNumRoots": () => (/* binding */ eNumRoots)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../euclidean-division-related/expansion/e-sturm-chain.js */ "./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js");\n/* harmony import */ var _double_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../double/sign-changes.js */ "./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js");\n/* harmony import */ var _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../basic/expansion/e-degree.js */ "./node_modules/flo-poly/node/basic/expansion/e-degree.js");\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst signChanges = _double_sign_changes_js__WEBPACK_IMPORTED_MODULE_2__.signChanges;\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\nconst eDegree = _basic_expansion_e_degree_js__WEBPACK_IMPORTED_MODULE_3__.eDegree;\r\nconst eSturmChain = _euclidean_division_related_expansion_e_sturm_chain_js__WEBPACK_IMPORTED_MODULE_1__.eSturmChain;\r\n/**\r\n * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)\r\n * of the given polynomial - subject to floating point underflow / overflow of\r\n * intermediate calculations.\r\n *\r\n * * From Wikipedia: "In the case of a non-square-free polynomial,\r\n * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number\r\n * of distinct real roots of P".\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = [[1], [1], [-64], [236], [-240]];\r\n * eNumRoots(p); //=> 4\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eNumRoots(p) {\r\n    const ps = eSturmChain(p);\r\n    const as = ps.map(p => eDegree(p) % 2 === 0 ? eSign(p[0]) : -eSign(p[0]));\r\n    const bs = ps.map(p => eSign(p[0]));\r\n    return signChanges(as) - signChanges(bs);\r\n}\r\n\r\n//# sourceMappingURL=e-num-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots.js?')},"./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eSignChanges": () => (/* binding */ eSignChanges)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eSign = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign;\r\n/**\r\n * Returns the number of sign changes in the polynomial coefficents when\r\n * ordered in descending order; zeros are ignored.\r\n *\r\n * * this function is often called `Descartes` in the literature\r\n *\r\n * * returns an upper bound of the number of *positive* real roots of the given\r\n * polynomial\r\n *\r\n * * the upper bound returned is always a non-negative multiple of two\r\n * (i.e. 0, 2, etc) higher than the actual number of real roots\r\n *\r\n * * the polynomial need not be square free\r\n *\r\n * * Descartes\' rule of signs states (quoted from Wikipedia):\r\n * "if the terms of a polynomial are ordered by descending variable\r\n * exponent, then the number of positive roots of the polynomial is\r\n * either equal to the number of sign differences between consecutive\r\n * nonzero coefficients, or is less than it by an even number. Multiple\r\n * roots of the same value are counted separately."\r\n *\r\n * * see [Descartes\' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of Shewchuk\r\n * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * eSignChanges([[1],[2],[-3],[0],[0],[3],[-1]]); //=> 3\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction eSignChanges(p) {\r\n    const d = p.length - 1;\r\n    if (d < 1) {\r\n        return 0;\r\n    }\r\n    let result = 0;\r\n    let prevSign = Math.sign(eSign(p[0]));\r\n    for (let i = 1; i < d + 1; i++) {\r\n        const sign_ = Math.sign(eSign(p[i]));\r\n        if (sign_ !== prevSign && sign_ !== 0) {\r\n            result++;\r\n            prevSign = sign_;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=e-sign-changes.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js?')},"./node_modules/flo-poly/node/roots/from-roots/bigint/b-from-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bFromRoots": () => (/* binding */ bFromRoots)\n/* harmony export */ });\n/* harmony import */ var _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../basic/bigint/b-multiply.js */ "./node_modules/flo-poly/node/basic/bigint/b-multiply.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst bMultiply = _basic_bigint_b_multiply_js__WEBPACK_IMPORTED_MODULE_0__.bMultiply;\r\n/**\r\n * Constructs a polynomial from the given roots by multiplying out the\r\n * factors (x - root1)(x - root2)\r\n *\r\n * * currently, only integer roots are allowed\r\n *\r\n * @param roots an array of roots\r\n *\r\n * @example\r\n * ```typescript\r\n * fromRoots([1n,2n,3n,3n]); //=> [1n, -9n, 29n, -39n, 18n]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bFromRoots(roots) {\r\n    let p = [1n];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = bMultiply(p, [1n, -roots[i]]);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=b-from-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/from-roots/bigint/b-from-roots.js?')},"./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromRoots": () => (/* binding */ fromRoots)\n/* harmony export */ });\n/* harmony import */ var _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../basic/double/multiply.js */ "./node_modules/flo-poly/node/basic/double/multiply.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst multiply = _basic_double_multiply_js__WEBPACK_IMPORTED_MODULE_0__.multiply;\r\n/**\r\n * Constructs a polynomial from the given roots by multiplying out the\r\n * factors (x - root1)(x - root2) in double precision\r\n *\r\n * * the resulting polynomial may have complex roots close to zero due to\r\n * round-off caused by working in double precision.\r\n *\r\n * * mostly for testing purposes.\r\n *\r\n * * the real roots of the constructed polynomial is unlikely to be exactly\r\n * the same as the roots that the polynomial has been constructed from due to\r\n * floating-point round-off.\r\n *\r\n * @param roots an array of roots\r\n *\r\n * @example\r\n * ```typescript\r\n * fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n *\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed.\r\n * allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction fromRoots(roots) {\r\n    let p = [1];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = multiply(p, [1, -roots[i]]);\r\n    }\r\n    return p;\r\n}\r\n\r\n//# sourceMappingURL=from-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js?')},"./node_modules/flo-poly/node/roots/from-roots/expansion/e-from-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "eFromRoots": () => (/* binding */ eFromRoots)\n/* harmony export */ });\n/* harmony import */ var _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../basic/expansion/e-multiply.js */ "./node_modules/flo-poly/node/basic/expansion/e-multiply.js");\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst eMultiply = _basic_expansion_e_multiply_js__WEBPACK_IMPORTED_MODULE_0__.eMultiply;\r\nconst eNegativeOf = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eNegativeOf;\r\nconst eToDd = big_float_ts__WEBPACK_IMPORTED_MODULE_1__.eToDd;\r\n/**\r\n * Constructs a double-double precision polynomial from the given roots by\r\n * multiplying out the factors (x - root1)(x - root2) in infinite precision\r\n * (bar overflow) and rounding back to double-double precision; also returns\r\n * a coefficient-wise error polynomial and a function that returns the exact\r\n * polynomial.\r\n *\r\n * * mostly for testing purposes.\r\n *\r\n * @param roots an array of roots\r\n *\r\n * @doc\r\n */\r\nfunction eFromRoots(roots) {\r\n    let p = [[1]];\r\n    for (let i = 0; i < roots.length; i++) {\r\n        p = eMultiply(p, [[1], eNegativeOf(roots[i])]);\r\n    }\r\n    const pE = p.map(c => Math.abs(c[c.length - 1] * Number.EPSILON));\r\n    const getPExact = () => p;\r\n    return {\r\n        pDd: p.map(eToDd),\r\n        pE,\r\n        getPExact\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=e-from-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/from-roots/expansion/e-from-roots.js?')},"./node_modules/flo-poly/node/roots/naive/all-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "allRoots": () => (/* binding */ allRoots)\n/* harmony export */ });\n/* harmony import */ var _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../calculus/double/differentiate.js */ "./node_modules/flo-poly/node/calculus/double/differentiate.js");\n/* harmony import */ var _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../evaluate/double/horner.js */ "./node_modules/flo-poly/node/evaluate/double/horner.js");\n/* harmony import */ var _brent_poly_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./brent-poly.js */ "./node_modules/flo-poly/node/roots/naive/brent-poly.js");\n/* harmony import */ var _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../root-bounds/root-bounds-lmq.js */ "./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js");\n/* harmony import */ var _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../basic/double/remove-leading-zeros.js */ "./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js");\n\r\n\r\n\r\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst differentiate = _calculus_double_differentiate_js__WEBPACK_IMPORTED_MODULE_0__.differentiate;\r\nconst Horner = _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_1__.Horner;\r\nconst brentPoly = _brent_poly_js__WEBPACK_IMPORTED_MODULE_2__.brentPoly;\r\nconst negativeRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__.negativeRootLowerBound_LMQ;\r\nconst positiveRootUpperBound_LMQ = _root_bounds_root_bounds_lmq_js__WEBPACK_IMPORTED_MODULE_3__.positiveRootUpperBound_LMQ;\r\nconst removeLeadingZeros = _basic_double_remove_leading_zeros_js__WEBPACK_IMPORTED_MODULE_4__.removeLeadingZeros;\r\n/**\r\n * Find and return all roots of the given polynomial in the given interval.\r\n *\r\n * * an empty array is returned for a constant or the zero polynomial\r\n *\r\n * * **non-exact:** roots are found \'naively\' using double-precision arithmetic\r\n * and accuracy will thus depend on the condition number around the root - use\r\n * [[allRootsCertifiedSimplified]] or [[allRootsCertified]] instead if certified\r\n * root bounds are required (it is about 3x slower, but still very fast!)\r\n *\r\n * * close (where the definition of closeness depends on the condition\r\n * number) or multiple *even* roots can be returned as 0, 1 or more close\r\n * roots, whereas close or multiple *odd* roots are guaranteed to return *at\r\n * least 1 root*\r\n *\r\n * * optimized for polynomials of degree 1 to about 30\r\n *\r\n * * roots are refined using the celebrated Brent\'s Method (and evaluated using\r\n * Horner\'s Method) until a root interval is found with\r\n * width `<= eps * max(1, 2^⌈log₂r⌉)`, where `eps = Number.EPSILON` and\r\n * `r` is a root\r\n *\r\n * * **ordered:** the returned roots are ordered from lowest to highest\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param lb defaults to `Number.NEGATIVE_INFINITY`; lower bound of roots to be\r\n * returned\r\n * @param ub defaults to `Number.POSITIVE_INFINITY`; upper bound of roots to be\r\n * returned\r\n *\r\n * @doc\r\n */\r\nfunction allRoots(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY) {\r\n    p = removeLeadingZeros(p);\r\n    //---- count and remove roots at zero\r\n    let numZerosAtZero = 0;\r\n    while (p[p.length - 1] === 0) {\r\n        p = p.slice(0, -1);\r\n        numZerosAtZero++;\r\n    }\r\n    //------------------------\r\n    // return an empty array for a constant or the zero polynomial\r\n    if (p.length <= 1) {\r\n        const roots = [];\r\n        for (let j = 0; j < numZerosAtZero; j++) {\r\n            roots.push(0);\r\n        }\r\n        return roots;\r\n    }\r\n    if (lb === Number.NEGATIVE_INFINITY) {\r\n        lb = negativeRootUpperBound_LMQ(p);\r\n    }\r\n    if (ub === Number.POSITIVE_INFINITY) {\r\n        ub = positiveRootUpperBound_LMQ(p);\r\n    }\r\n    // Get all derivatives, i.e. \r\n    // ps === [p, dp, ddp, ..., constant]\r\n    //        [0,  1,   2, ..., deg     ]\r\n    const ps = [p];\r\n    for (let i = 1; i <= p.length - 1; i++) {\r\n        ps.push(differentiate(ps[i - 1]));\r\n    }\r\n    //const δ = Math.max(2*eps, 2*eps * Math.max(Math.abs(lb), Math.abs(ub)));\r\n    /** root intervals */\r\n    let is = [];\r\n    // loop: ps[diffCount] === [linear, quadratic, ..., deg]\r\n    for (let diffCount = p.length - 2; diffCount >= 0; diffCount--) {\r\n        // Get roots within intervals:\r\n        // ---------------------------\r\n        // Finds and returns all roots of the given polynomial within the given \r\n        // intervals, starting from the lower bound (lb) and ending at the upper\r\n        // bound (ub)\r\n        const p = ps[diffCount];\r\n        const roots = [];\r\n        let _a_ = lb;\r\n        let _A_ = Horner(p, _a_);\r\n        // if lower bound value is zero and this is the last iteration with \r\n        // p === the original polynomial then push the root at the lower bound\r\n        if (_A_ === 0 && diffCount === 0) {\r\n            roots.push(lb);\r\n        }\r\n        for (let i = 0; i < is.length; i++) {\r\n            const _b_ = is[i];\r\n            const _B_ = Horner(p, _b_);\r\n            // if there is a root at the right interval then add it\r\n            if (_B_ === 0) {\r\n                roots.push(_b_);\r\n            }\r\n            else if (_A_ * _B_ < 0) {\r\n                roots.push(brentPoly(p, _a_, _b_, _A_, _B_));\r\n            }\r\n            _a_ = _b_;\r\n            _A_ = _B_;\r\n        }\r\n        const _B_ = Horner(p, ub);\r\n        if (_A_ * _B_ < 0) {\r\n            roots.push(brentPoly(p, _a_, ub, _A_, _B_));\r\n        }\r\n        // if upper bound value is zero and this is the last iteration with \r\n        // p === the original polynomial then push the root at the upper bound\r\n        if (_B_ === 0 && diffCount === 0) {\r\n            roots.push(ub);\r\n        }\r\n        is = roots;\r\n    }\r\n    if (numZerosAtZero > 0 && lb <= 0 && ub >= 0) {\r\n        // at this point the existing intervals, `is`, are sorted\r\n        // find the insertion spot and insert the zero roots to keep the roots\r\n        // sorted\r\n        let isWithZeroRoots = [];\r\n        let zerosInserted = false;\r\n        for (let i = 0; i < is.length; i++) {\r\n            if (!zerosInserted && is[i] >= 0) {\r\n                // push the zero roots\r\n                for (let j = 0; j < numZerosAtZero; j++) {\r\n                    isWithZeroRoots.push(0);\r\n                }\r\n                zerosInserted = true;\r\n            }\r\n            isWithZeroRoots.push(is[i]);\r\n        }\r\n        return isWithZeroRoots;\r\n    }\r\n    return is;\r\n}\r\n\r\n//# sourceMappingURL=all-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/all-roots.js?')},"./node_modules/flo-poly/node/roots/naive/bisection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bisection\": () => (/* binding */ bisection)\n/* harmony export */ });\nconst abs = Math.abs;\r\nconst max = Math.max;\r\n/**\r\n * Returns a refined root given a root bracketed in the interval (a,b) of the\r\n * given function using the\r\n * [Bisection Method](https://en.wikipedia.org/wiki/Bisection_method) algorithm.\r\n *\r\n * * any function can be supplied (it does not even have to be continuous) as\r\n * long as the root is bracketed.\r\n *\r\n * * this function has no advantages above Brent's method except for its\r\n * simpler implementation and can be slower. Use [[brentPoly]] or [[brent]]\r\n * instead.\r\n *\r\n * * the algorithm stops once the interval width becomes equal or less than\r\n * `2 * Number.EPSILON * max(1,abs(a),abs(b))` where `a` and `b` are the current\r\n * lower and upper interval limits\r\n *\r\n * @param f the function for which the root is sought\r\n * @param a the lower limit of the search interval\r\n * @param b the upper limit of the search interval\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * const f = t => Horner(p,t);\r\n * bisection(f,2.2,3.8); //=> 3\r\n * bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction bisection(f, a, b) {\r\n    if (b < a) {\r\n        [a, b] = [b, a]; // Swap a and b \r\n    }\r\n    const fa = f(a);\r\n    const fb = f(b);\r\n    if (a === b) {\r\n        if (fa !== 0) {\r\n            // Root is not bracketed - this is a precondition.\r\n            throw new Error('Root not bracketed');\r\n        }\r\n        // the root is already found.\r\n        return a;\r\n    }\r\n    if (fa === 0) {\r\n        return a;\r\n    }\r\n    if (fb === 0) {\r\n        return b;\r\n    }\r\n    if (fa * fb > 0) {\r\n        // Root is not bracketed - this is a precondition.\r\n        throw new Error('Root not bracketed');\r\n    }\r\n    while (true) {\r\n        const c = a + (b - a) / 2; // Take midpoint\r\n        const fc = f(c);\r\n        if (fc === 0) {\r\n            return c;\r\n        }\r\n        if (fa * fc < 0) {\r\n            b = c;\r\n        }\r\n        else {\r\n            a = c;\r\n        }\r\n        const δ = 2 * Number.EPSILON * max(1, abs(a), abs(b));\r\n        if (Math.abs(a - b) <= δ) {\r\n            return b;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=bisection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/bisection.js?")},"./node_modules/flo-poly/node/roots/naive/brent-poly.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"brentPoly\": () => (/* binding */ brentPoly)\n/* harmony export */ });\n/* harmony import */ var _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../evaluate/double/horner.js */ \"./node_modules/flo-poly/node/evaluate/double/horner.js\");\n\r\nconst Horner = _evaluate_double_horner_js__WEBPACK_IMPORTED_MODULE_0__.Horner;\r\nconst eps = Number.EPSILON;\r\nconst u = eps / 2;\r\nconst abs = Math.abs;\r\nconst max = Math.max;\r\n/**\r\n * Returns a refined root given a root bracketed in the interval (a,b) of the\r\n * given polynomial using Brent's Method.\r\n *\r\n * * near exact implementation of the original Brent Dekker Method (also known\r\n * as Brent's Method), except that it is specialzed to polynomial evaluation\r\n *\r\n * * the algorithm stops once the interval width becomes equal or less than\r\n * `2 * Number.EPSILON/2 * max(1,abs(a),abs(b))` where `a` and `b` are the current\r\n * lower and upper interval limits\r\n *\r\n * * Brent's Method is an excellent root-refinement choice since:\r\n *  * guaranteed converge (unlike the Newton and other so-called single-point\r\n * methods),\r\n *  * converges in a reasonable number of iterations even for highly contrived\r\n * functions (unlike Dekker's Method) and\r\n *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and\r\n * Regula-Falsi methods).\r\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\r\n * works but is not precisely Brent's method and runs about 2x or more slower\r\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\r\n *\r\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param lb the lower limit of the search interval.\r\n * @param ub the upper limit of the search interval.\r\n * @param fa (may be left out - will be calculated automatically) the result of\r\n * evaluating the input polynomial at `a`\r\n * @param fb (may be left out - will be calculated automatically) the result of\r\n * evaluating the input polynomial at `b`\r\n *\r\n * @example\r\n * ```typescript\r\n * const p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * const a = 2.2;\r\n * const b = 3.8;\r\n * brent(p,a,b); //=> 3.000000000000003\r\n * b = 3.1;\r\n * brent(p,a,b); //=> 3.000000000000001\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction brentPoly(p, lb, ub, fa = Horner(p, lb), fb = Horner(p, ub)) {\r\n    // Precondition: fa, fb !== 0\r\n    //---- Make local copies of a and b.\r\n    let a = lb;\r\n    let b = ub;\r\n    let c = a;\r\n    let fc = fa;\r\n    let e = b - a;\r\n    let d = e;\r\n    while (true) {\r\n        if (abs(fc) < abs(fb)) {\r\n            a = b;\r\n            b = c;\r\n            c = a;\r\n            fa = fb;\r\n            fb = fc;\r\n            fc = fa;\r\n        }\r\n        const δ = 2 * u * max(1, abs(a), abs(b));\r\n        const m = 0.5 * (c - b);\r\n        //if (abs(m) <= δ || fb === 0) {\r\n        if (abs(m) <= δ) {\r\n            // uncomment below if range to be returned\r\n            //return b < c ? [b,c] : [c,b];\r\n            // uncomment below if leftmost guess to be returned\r\n            //return b < c ? b : c;\r\n            // uncomment below if rightmost guess to be returned\r\n            //return b < c ? b : c;\r\n            // uncomment below if any guess to be returned\r\n            return b;\r\n        }\r\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\r\n            e = m;\r\n            d = e;\r\n        }\r\n        else {\r\n            let s = fb / fa;\r\n            let p;\r\n            let q;\r\n            if (a === c) {\r\n                p = 2 * m * s;\r\n                q = 1 - s;\r\n            }\r\n            else {\r\n                q = fa / fc;\r\n                const r = fb / fc;\r\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\r\n                q = (q - 1) * (r - 1) * (s - 1);\r\n            }\r\n            if (0 < p) {\r\n                q = -q;\r\n            }\r\n            else {\r\n                p = -p;\r\n            }\r\n            s = e;\r\n            e = d;\r\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\r\n                d = p / q;\r\n            }\r\n            else {\r\n                e = m;\r\n                d = e;\r\n            }\r\n        }\r\n        a = b;\r\n        fa = fb;\r\n        if (δ < abs(d)) {\r\n            b = b + d;\r\n        }\r\n        else if (0 < m) {\r\n            b = b + δ;\r\n        }\r\n        else {\r\n            //b = b - eps;\r\n            b = b - δ;\r\n        }\r\n        fb = Horner(p, b);\r\n        // inlined above line:\r\n        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }\r\n        if (fb === 0) {\r\n            return b;\r\n        }\r\n        if (fb * fc > 0) {\r\n            c = a;\r\n            fc = fa;\r\n            e = b - a;\r\n            d = e;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=brent-poly.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/brent-poly.js?")},"./node_modules/flo-poly/node/roots/naive/brent.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"brent\": () => (/* binding */ brent)\n/* harmony export */ });\nconst eps = Number.EPSILON;\r\nconst abs = Math.abs;\r\nconst max = Math.max;\r\n/**\r\n * Returns a refined root given a root bracketed in the interval (a,b) of the\r\n * given function using Brent's Method. Any function can be supplied (it\r\n * does not even have to be continuous) as long as the root is bracketed.\r\n *\r\n * * near exact implementation of the original Brent Dekker Method (also known\r\n * as Brent's Method)\r\n *\r\n * * Brent's Method is an excellent root-refinement choice since:\r\n *   * guaranteed converge (unlike the Newton and other so-called single-point\r\n * methods),\r\n *   * converges in a reasonable number of iterations even for highly contrived\r\n * functions (unlike Dekker's Method) and\r\n *   * nearly always converges fast, i.e. super-linearly (unlike the Secant and\r\n * Regula-Falsi methods).\r\n * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)\r\n * works but is not precisely Brent's method and runs about 2x or more slower\r\n * due to it not implementing the critically important 'micro-step' (Aug 2020).\r\n *\r\n * * the algorithm stops once the interval width becomes equal or less than\r\n * `2 * Number.EPSILON * max(1,abs(a),abs(b))` where `a` and `b` are the current\r\n * lower and upper interval limits\r\n *\r\n * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)\r\n *\r\n * @param f the function for which the root is sought.\r\n * @param lb the lower limit of the search interval.\r\n * @param ub the upper limit of the search interval.\r\n *\r\n * @example\r\n * ```typescript\r\n * let p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = t => Horner(p,t);\r\n * brent(f,2.2,3.8); //=> 3.000000000000003\r\n * brent(f,2.2,3.1); //=> 3.000000000000001\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction brent(f, lb, ub) {\r\n    // Precondition: fa, fb !== 0\r\n    //---- Make local copies of a and b.\r\n    let a = lb;\r\n    let b = ub;\r\n    let fa = f(a);\r\n    let fb = f(b);\r\n    let c = a;\r\n    let fc = fa;\r\n    let e = b - a;\r\n    let d = e;\r\n    while (true) {\r\n        if (abs(fc) < abs(fb)) {\r\n            a = b;\r\n            b = c;\r\n            c = a;\r\n            fa = fb;\r\n            fb = fc;\r\n            fc = fa;\r\n        }\r\n        const δ = 2 * eps * max(1, abs(a), abs(b));\r\n        const m = 0.5 * (c - b);\r\n        //if (abs(m) <= δ || fb === 0) {\r\n        if (abs(m) <= δ) {\r\n            // uncomment below if range to be returned\r\n            //return b < c ? [b,c] : [c,b];\r\n            // uncomment below if leftmost guess to be returned\r\n            //return b < c ? b : c;\r\n            // uncomment below if rightmost guess to be returned\r\n            //return b < c ? b : c;\r\n            // uncomment below if any guess to be returned\r\n            return b;\r\n        }\r\n        if (abs(e) < δ || abs(fa) <= abs(fb)) {\r\n            e = m;\r\n            d = e;\r\n        }\r\n        else {\r\n            let s = fb / fa;\r\n            let p;\r\n            let q;\r\n            if (a === c) {\r\n                p = 2 * m * s;\r\n                q = 1 - s;\r\n            }\r\n            else {\r\n                q = fa / fc;\r\n                const r = fb / fc;\r\n                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\r\n                q = (q - 1) * (r - 1) * (s - 1);\r\n            }\r\n            if (0 < p) {\r\n                q = -q;\r\n            }\r\n            else {\r\n                p = -p;\r\n            }\r\n            s = e;\r\n            e = d;\r\n            if (2 * p < 3 * m * q - abs(δ * q) && p < abs(0.5 * s * q)) {\r\n                d = p / q;\r\n            }\r\n            else {\r\n                e = m;\r\n                d = e;\r\n            }\r\n        }\r\n        a = b;\r\n        fa = fb;\r\n        if (δ < abs(d)) {\r\n            b = b + d;\r\n        }\r\n        else if (0 < m) {\r\n            b = b + δ;\r\n        }\r\n        else {\r\n            //b = b - eps;\r\n            b = b - δ;\r\n        }\r\n        fb = f(b);\r\n        // inlined above line:\r\n        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }\r\n        if (fb === 0) {\r\n            return b;\r\n        }\r\n        if (fb * fc > 0) {\r\n            c = a;\r\n            fc = fa;\r\n            e = b - a;\r\n            d = e;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=brent.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/brent.js?")},"./node_modules/flo-poly/node/roots/naive/dd-deflate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ddDeflate": () => (/* binding */ ddDeflate)\n/* harmony export */ });\n/* harmony import */ var double_double__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! double-double */ "./node_modules/double-double/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst qmd = double_double__WEBPACK_IMPORTED_MODULE_0__.ddMultDouble2;\r\nconst qaq = double_double__WEBPACK_IMPORTED_MODULE_0__.ddAddDd;\r\n/**\r\n * Deflates the given polynomial *approximately* by removing a factor (x - r),\r\n * where r is a root of the polynomial.\r\n *\r\n * * **non-exact:** the deflation is done in double-double precision - it is not\r\n * possible to deflate a root exactly in most cases and round-off will thus\r\n * occur - use only if approximate deflation is acceptable\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of\r\n * double-double precision floating point numbers from highest to lowest power,\r\n * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`\r\n * @param root a root of the polynomial.\r\n *\r\n * @example\r\n * ```typescript\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\r\n * ddDeflate([[0,1], [0,-5], [0,8], [0,-4]], [0,2]); //=> [[0,1], [0,-3], [0,2]]\r\n * ddDeflate([[0,1], [0,-3], [0,2], [0,2]);          //=> [[0,1], [0,-1]]\r\n * ddDeflate([[0,1], [0,-1]], [0,1]);                //=> [[0,1]]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction ddDeflate(p, root) {\r\n    const d = p.length - 1;\r\n    const bs = [p[0]];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push(qaq(p[i], qmd(root, bs[i - 1])));\r\n    }\r\n    return bs;\r\n}\r\n\r\n//# sourceMappingURL=dd-deflate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/dd-deflate.js?')},"./node_modules/flo-poly/node/roots/naive/deflate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "deflate": () => (/* binding */ deflate)\n/* harmony export */ });\n/**\r\n * Deflates the given polynomial *approximately* by removing a factor (x - r),\r\n * where r is a root of the polynomial.\r\n *\r\n * * **non-exact:** the deflation is done in double precision - it is not\r\n * possible to deflate a root exactly in most cases and round-off will thus\r\n * occur - use only if approximate deflation is acceptable\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n * @param root a root of the polynomial.\r\n *\r\n * @example\r\n * ```typescript\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2\r\n * deflate([1, -5, 8, -4], 2);  //=> [1, -3, 2]\r\n * deflate([1, -3, 2], 2);      //=> [1,-1]\r\n * deflate([1, -1], 1);         //=> [1]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction deflate(p, root) {\r\n    const d = p.length - 1;\r\n    const bs = [p[0]];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push(p[i] + root * bs[i - 1]);\r\n    }\r\n    return bs;\r\n}\r\n\r\n//# sourceMappingURL=deflate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/deflate.js?')},"./node_modules/flo-poly/node/roots/naive/quadratic-roots.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "quadraticRoots": () => (/* binding */ quadraticRoots)\n/* harmony export */ });\n/**\r\n * Floating-point-stably calculates and returns the ordered quadratic roots of\r\n * the given quadratic polynomial.\r\n *\r\n * * **precondition:** the input polynomial must be quadratic (given as an array\r\n * of exactly 3 values with the first value *unequal* to zero)\r\n * * **non-exact:** it is important to note that even though the roots are\r\n * calculated in a stable way they are still subject to round-off\r\n * * might be slightly faster than calling [[allRoots]].\r\n *\r\n * @param p a quadratic polynomial with coefficients given as an array\r\n * of double floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the quadratic `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * quadraticRoots([1, -3, 2]); //=> [1,2]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction quadraticRoots(p) {\r\n    const [a, b, c] = p;\r\n    const _D = b * b - 4 * a * c;\r\n    if (_D < 0) {\r\n        // No real roots;\r\n        return [];\r\n    }\r\n    if (_D === 0) {\r\n        return [-b / (2 * a)];\r\n    }\r\n    const D = Math.sqrt(_D);\r\n    if (b >= 0) {\r\n        const root1 = (-b - D) / (2 * a);\r\n        const root2 = (2 * c) / (-b - D);\r\n        return root1 < root2\r\n            ? [root1, root2]\r\n            : [root2, root1];\r\n    }\r\n    const root1 = (2 * c) / (-b + D);\r\n    const root2 = (-b + D) / (2 * a);\r\n    return root1 < root2\r\n        ? [root1, root2]\r\n        : [root2, root1];\r\n}\r\n\r\n//# sourceMappingURL=quadratic-roots.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/naive/quadratic-roots.js?')},"./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "positiveToNegativeBound": () => (/* binding */ positiveToNegativeBound)\n/* harmony export */ });\n/* harmony import */ var _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../change-variables/double/reflect-about-y-axis.js */ "./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst reflectAboutYAxis = _change_variables_double_reflect_about_y_axis_js__WEBPACK_IMPORTED_MODULE_0__.reflectAboutYAxis;\r\n/**\r\n * Returns a function that returns a negative root bound given a function that\r\n * returns a positive root bound.\r\n *\r\n * @param positiveBoundFunction\r\n *\r\n * @internal\r\n */\r\nfunction positiveToNegativeBound(positiveBoundFunction) {\r\n    return (p) => {\r\n        return -positiveBoundFunction(reflectAboutYAxis(p));\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=positive-to-negative-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js?')},"./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "negativeRootLowerBound_LMQ": () => (/* binding */ negativeRootLowerBound_LMQ),\n/* harmony export */   "negativeRootUpperBound_LMQ": () => (/* binding */ negativeRootUpperBound_LMQ),\n/* harmony export */   "positiveRootLowerBound_LMQ": () => (/* binding */ positiveRootLowerBound_LMQ),\n/* harmony export */   "positiveRootUpperBound_LMQ": () => (/* binding */ positiveRootUpperBound_LMQ)\n/* harmony export */ });\n/* harmony import */ var _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/double/negate.js */ "./node_modules/flo-poly/node/basic/double/negate.js");\n/* harmony import */ var _upper_to_lower_bound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./upper-to-lower-bound.js */ "./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js");\n/* harmony import */ var _positive_to_negative_bound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./positive-to-negative-bound.js */ "./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js");\n\r\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst negate = _basic_double_negate_js__WEBPACK_IMPORTED_MODULE_0__.negate;\r\nconst upperToLowerBound = _upper_to_lower_bound_js__WEBPACK_IMPORTED_MODULE_1__.upperToLowerBound;\r\nconst positiveToNegativeBound = _positive_to_negative_bound_js__WEBPACK_IMPORTED_MODULE_2__.positiveToNegativeBound;\r\n/**\r\n * Returns an upper bound for the positive real roots of the given polynomial.\r\n *\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436\r\n * positiveRootUpperBound_LMQ([2,3]);           //=> 0\r\n * positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction positiveRootUpperBound_LMQ(p) {\r\n    const deg = p.length - 1;\r\n    if (deg < 1) {\r\n        return 0;\r\n    }\r\n    if (p[0] < 0) {\r\n        p = negate(p);\r\n    }\r\n    const timesUsed = [];\r\n    for (let i = 0; i < deg; i++) {\r\n        timesUsed.push(1);\r\n    }\r\n    let ub = 0;\r\n    for (let m = 0; m <= deg; m++) {\r\n        if (p[m] >= 0) {\r\n            continue;\r\n        }\r\n        let tempub = Number.POSITIVE_INFINITY;\r\n        let any = false;\r\n        for (let k = 0; k < m; k++) {\r\n            if (p[k] <= 0) {\r\n                continue;\r\n            }\r\n            const temp = (-p[m] / (p[k] / 2 ** timesUsed[k])) ** (1 / (m - k));\r\n            timesUsed[k]++;\r\n            if (tempub > temp) {\r\n                tempub = temp;\r\n            }\r\n            any = true;\r\n        }\r\n        if (any && ub < tempub)\r\n            ub = tempub;\r\n    }\r\n    return ub;\r\n}\r\n/**\r\n * Returns a positive lower bound of the real roots of the given polynomial\r\n *\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nconst positiveRootLowerBound_LMQ = upperToLowerBound(positiveRootUpperBound_LMQ);\r\n/**\r\n * Returns a negative lower (further from zero) bound of the real roots of the\r\n * given polynomial.\r\n *\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nconst negativeRootLowerBound_LMQ = positiveToNegativeBound(positiveRootUpperBound_LMQ);\r\n/**\r\n * Returns a negative upper (closer to zero) bound of the real roots of the\r\n * given polynomial.\r\n *\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,\r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nconst negativeRootUpperBound_LMQ = upperToLowerBound(negativeRootLowerBound_LMQ);\r\n\r\n//# sourceMappingURL=root-bounds-lmq.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js?')},"./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rootMagnitudeUpperBound_fujiwara": () => (/* binding */ rootMagnitudeUpperBound_fujiwara)\n/* harmony export */ });\n/**\r\n * Returns an upper bound on the magnitude (absolute value) of the complex\r\n * roots of the given polynomial using the near-optimal Fujiwara bound.\r\n *\r\n * * the bound includes complex roots.\r\n * * the bound is quite tight\r\n *\r\n * * see [Wikipedia](https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#Other_bounds)\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @example\r\n * ```typescript\r\n * rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n * ```\r\n *\r\n * @doc\r\n */\r\nfunction rootMagnitudeUpperBound_fujiwara(p) {\r\n    if (p.length <= 1) {\r\n        return 0;\r\n    }\r\n    const d = p.length - 1;\r\n    const an = p[0];\r\n    const bs = [];\r\n    for (let i = 1; i < d; i++) {\r\n        bs.push((Math.abs(p[i] / an)) ** (1 / i));\r\n    }\r\n    bs.push((Math.abs(p[d] / 2 * an)) ** (1 / d));\r\n    return 2 * Math.max(...bs);\r\n}\r\n\r\n//# sourceMappingURL=root-magnitude-upper-bound-fujiwara.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js?')},"./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rootMagnitudeUpperBound_rouche": () => (/* binding */ rootMagnitudeUpperBound_rouche)\n/* harmony export */ });\n/* harmony import */ var _norm_double_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../norm/double/p-inf-norm.js */ "./node_modules/flo-poly/node/norm/double/p-inf-norm.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst pInfNorm = _norm_double_p_inf_norm_js__WEBPACK_IMPORTED_MODULE_0__.pInfNorm;\r\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche\'s Theorem\r\n * with k = n.\r\n *\r\n * * fast but the bound is not very tight\r\n *\r\n * @param p a polynomial with coefficients given densely as an array of double\r\n * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`\r\n * represents the polynomial `5x^2 - 3x`\r\n *\r\n * @doc\r\n */\r\nfunction rootMagnitudeUpperBound_rouche(p) {\r\n    if (p.length <= 1) {\r\n        return 0;\r\n    }\r\n    return 1 + (pInfNorm(p.slice(1)) / p[0]);\r\n}\r\n\r\n//# sourceMappingURL=root-magnitude-upper-bound-rouche.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js?')},"./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "upperToLowerBound": () => (/* binding */ upperToLowerBound)\n/* harmony export */ });\n/* harmony import */ var _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../basic/double/invert.js */ "./node_modules/flo-poly/node/basic/double/invert.js");\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst invert = _basic_double_invert_js__WEBPACK_IMPORTED_MODULE_0__.invert;\r\n/**\r\n * Returns a function that returns a positive lower root bound given a function\r\n * that returns a positive upper root bound.\r\n *\r\n * @param positiveUpperBoundFunction\r\n *\r\n * @internal\r\n */\r\nfunction upperToLowerBound(positiveUpperBoundFunction) {\r\n    return (p) => {\r\n        return 1 / positiveUpperBoundFunction(invert(p));\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=upper-to-lower-bound.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-float-to-bigint.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatToBigint": () => (/* binding */ scaleFloatToBigint)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\nconst b0 = 0n; // temp until support is better otherwise test fails\r\n/**\r\n * Returns the result of scaling the given float by a power of two such that\r\n * it becomes a bigint - the smallest such integer is returned.\r\n *\r\n * @param a a double precision floating point number\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatToBigint(a) {\r\n    if (a === 0) {\r\n        return b0;\r\n    }\r\n    return BigInt(a * 2 ** (-exponent(a) + bitLength(a) - 1));\r\n}\r\n\r\n//# sourceMappingURL=scale-float-to-bigint.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-float-to-bigint.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatToInt": () => (/* binding */ scaleFloatToInt)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\n/**\r\n * Returns the result of scaling the given float by a power of two such that\r\n * it becomes an integer (overflow not possible) - the smallest such integer is\r\n * returned.\r\n *\r\n * * the result is exact (no round-off can occur)\r\n *\r\n * @param a a double precision floating point number\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatToInt(a) {\r\n    if (a === 0) {\r\n        return 0;\r\n    }\r\n    return a * 2 ** (-exponent(a) + bitLength(a) - 1);\r\n}\r\n\r\n//# sourceMappingURL=scale-float-to-int.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-floats-to-bigints.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatsToBigints": () => (/* binding */ scaleFloatsToBigints)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\nconst b0 = 0n; // so tests are not tripped up - awaiting better support\r\n/**\r\n * Returns the result of scaling the given array of floats by the *same* power\r\n * of two such that all floats become bigints.\r\n *\r\n * * can be used to scale polynomials\r\n *\r\n * @param as an array of double precision floating point numbers\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatsToBigints(as) {\r\n    let e = -1024;\r\n    for (let i = 0; i < as.length; i++) {\r\n        const a = as[i];\r\n        if (a === 0) {\r\n            continue;\r\n        }\r\n        const scalePower = -exponent(a) + bitLength(a) - 1;\r\n        if (scalePower > e) {\r\n            e = scalePower;\r\n        }\r\n    }\r\n    // check for the trivial case\r\n    if (e === 0) {\r\n        return as.map(a => BigInt(a));\r\n    }\r\n    if (e > 0) {\r\n        return as.map(a => {\r\n            if (a === 0) {\r\n                return b0;\r\n            }\r\n            const scalePower = -exponent(a) + bitLength(a) - 1;\r\n            // we first scale `a` to an integer without overflow and then\r\n            // convert it to a bigint before multiplying\r\n            return BigInt(a * 2 ** scalePower) * 2n ** BigInt(e - scalePower);\r\n        });\r\n    }\r\n    // overflow / underflow cannot occur\r\n    return as.map(a => BigInt(a * 2 ** e));\r\n}\r\n\r\n//# sourceMappingURL=scale-floats-to-bigints.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-floats-to-bigints.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatsToInts": () => (/* binding */ scaleFloatsToInts)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\n/**\r\n * Returns the result of scaling the given floats by the *same* power of two\r\n * such that all floats become integers (bar overflow).\r\n *\r\n * * the result is exact (no round-off can occur, but overflow can)\r\n * * can be used to scale polynomials or Shewchuk expansions\r\n *\r\n * @param as an array of double precision floating point numbers\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatsToInts(as) {\r\n    let e = -1024;\r\n    for (let i = 0; i < as.length; i++) {\r\n        const a = as[i];\r\n        if (a === 0) {\r\n            continue;\r\n        }\r\n        const scaleFactor = -exponent(a) + bitLength(a) - 1;\r\n        if (scaleFactor > e) {\r\n            e = scaleFactor;\r\n        }\r\n    }\r\n    return as.map(a => a * 2 ** e);\r\n}\r\n\r\n//# sourceMappingURL=scale-floats-to-ints.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatssToBigintss": () => (/* binding */ scaleFloatssToBigintss)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\nconst b0 = 0n; // so tests are not tripped up - awaiting better support\r\n/**\r\n * Returns the result of scaling the given array of array of floats by the\r\n * *same* power of two such that all floats become bigints.\r\n *\r\n * * can be used to scale polynomials (with coefficients given as Shewchuk\r\n * expansions)\r\n *\r\n * @param ass an array of an array of double precision floating point numbers\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatssToBigintss(ass) {\r\n    let e = -1024;\r\n    for (let i = 0; i < ass.length; i++) {\r\n        const c = ass[i];\r\n        for (let j = 0; j < c.length; j++) {\r\n            const a = c[j];\r\n            if (a === 0) {\r\n                continue;\r\n            }\r\n            const scaleFactor = -exponent(a) + bitLength(a) - 1;\r\n            if (scaleFactor > e) {\r\n                e = scaleFactor;\r\n            }\r\n        }\r\n    }\r\n    // check for the trivial case\r\n    if (e === 0) {\r\n        return ass.map(as => as.map(a => BigInt(a)));\r\n    }\r\n    if (e > 0) {\r\n        return ass.map(as => as.map(a => {\r\n            if (a === 0) {\r\n                return b0;\r\n            }\r\n            const scalePower = -exponent(a) + bitLength(a) - 1;\r\n            // we first scale `a` to an integer without overflow and then\r\n            // convert it to a bigint before multiplying\r\n            return BigInt(a * 2 ** scalePower) * 2n ** BigInt(e - scalePower);\r\n        }));\r\n    }\r\n    // overflow / underflow cannot occur\r\n    return ass.map(as => as.map(a => BigInt(a * 2 ** e)));\r\n}\r\n\r\n//# sourceMappingURL=scale-floatss-to-bigintss.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js?')},"./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scaleFloatssToIntss": () => (/* binding */ scaleFloatssToIntss)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\n// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗\r\nconst exponent = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.exponent;\r\nconst bitLength = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.bitLength;\r\n/**\r\n * Returns the result of scaling the given array of array of floats by the\r\n * *same* power of two such that all floats become integers (bar overflow).\r\n *\r\n * * the result is exact (no round-off can occur, but overflow can)\r\n * * can be used to scale polynomials (with coefficients given as Shewchuk\r\n * expansions)\r\n *\r\n * @param ass an array of an array of double precision floating point numbers\r\n *\r\n * @doc\r\n */\r\nfunction scaleFloatssToIntss(ass) {\r\n    let e = -1024;\r\n    for (let i = 0; i < ass.length; i++) {\r\n        const c = ass[i];\r\n        for (let j = 0; j < c.length; j++) {\r\n            const a = c[j];\r\n            if (a === 0) {\r\n                continue;\r\n            }\r\n            const scaleFactor = -exponent(a) + bitLength(a) - 1;\r\n            if (scaleFactor > e) {\r\n                e = scaleFactor;\r\n            }\r\n        }\r\n    }\r\n    return ass.map(as => as.map(a => a * 2 ** e));\r\n}\r\n\r\n//# sourceMappingURL=scale-floatss-to-intss.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reverseRotate": () => (/* binding */ reverseRotate)\n/* harmony export */ });\n/**\r\n * Returns a rotated (clockwise) version of the given 2-vector given the\r\n * sine and cosine of the angle.\r\n * @param p a 2d vector\r\n * @param sinθ\r\n * @param cosθ\r\n */\r\nfunction reverseRotate(sinθ, cosθ, p) {\r\n    return [\r\n        +p[0] * cosθ + p[1] * sinθ,\r\n        -p[0] * sinθ + p[1] * cosθ\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=reverse-rotate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "reverse": () => (/* binding */ reverse)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector reversed (i.e. scaled by -1).\r\n * @param p a vector\r\n */\r\nfunction reverse(p) {\r\n    return [-p[0], -p[1]];\r\n}\r\n\r\n//# sourceMappingURL=reverse.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rotate90Degrees": () => (/* binding */ rotate90Degrees)\n/* harmony export */ });\n/**\r\n * Returns a 90 degrees rotated version of the given 2-vector.\r\n * @param p a 2d vector\r\n */\r\nfunction rotate90Degrees(p) {\r\n    return [-p[1], p[0]];\r\n}\r\n\r\n//# sourceMappingURL=rotate-90-degrees.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rotateNeg90Degrees": () => (/* binding */ rotateNeg90Degrees)\n/* harmony export */ });\n/**\r\n* Returns a negative 90 degrees rotated version of the given 2-vector.\r\n* @param p a 2d vector\r\n*/\r\nfunction rotateNeg90Degrees(p) {\r\n    return [p[1], -p[0]];\r\n}\r\n\r\n//# sourceMappingURL=rotate-neg-90-degrees.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rotate": () => (/* binding */ rotate)\n/* harmony export */ });\nfunction rotate(sinθ, cosθ, p) {\r\n    function rotateByθ(p) {\r\n        return [\r\n            p[0] * cosθ - p[1] * sinθ,\r\n            p[0] * sinθ + p[1] * cosθ\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? rotateByθ : rotateByθ(p);\r\n}\r\n\r\n//# sourceMappingURL=rotate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "scale": () => (/* binding */ scale)\n/* harmony export */ });\n/**\r\n * Returns a scaled version of the given 2-vector.\r\n * @param p a vector\r\n * @param c a scale factor\r\n */\r\nfunction scale(p, c) {\r\n    return [c * p[0], c * p[1]];\r\n}\r\n\r\n//# sourceMappingURL=scale.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js?')},"./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "transformLinear": () => (/* binding */ transformLinear)\n/* harmony export */ });\nfunction transformLinear([[a, b], [c, d]], p) {\r\n    function transform([x, y]) {\r\n        return [\r\n            a * x + b * y,\r\n            c * x + d * y\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? transform : transform(p);\r\n}\r\n\r\n//# sourceMappingURL=transform-linear.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js?')},"./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "transformAffine": () => (/* binding */ transformAffine)\n/* harmony export */ });\nfunction transformAffine([[a, b], [c, d]], [r, s], p) {\r\n    function transform([x, y]) {\r\n        return [\r\n            a * x + b * y + r,\r\n            c * x + d * y + s\r\n        ];\r\n    }\r\n    // Curry the function\r\n    return p === undefined ? transform : transform(p);\r\n}\r\n\r\n//# sourceMappingURL=transform-affine.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js?')},"./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "translate": () => (/* binding */ translate)\n/* harmony export */ });\n// From: https://en.wikipedia.org/wiki/Affine_transformation\r\n// "If X is the point set of an affine space, then every affine transformation \r\n// on X can be represented as the composition of a linear transformation on X \r\n// and a translation of X"\r\nfunction translate(a, b) {\r\n    function f(b) {\r\n        return [a[0] + b[0], a[1] + b[1]];\r\n    }\r\n    // Curry the function\r\n    return b === undefined ? f : f(b);\r\n}\r\n\r\n//# sourceMappingURL=translate.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js?')},"./node_modules/flo-vector2d/node/cross.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "cross": () => (/* binding */ cross)\n/* harmony export */ });\n/**\r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction cross(a, b) {\r\n    return a[0] * b[1] - a[1] * b[0];\r\n}\r\n\r\n//# sourceMappingURL=cross.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/cross.js?')},"./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "distanceBetweenPointAndLine": () => (/* binding */ distanceBetweenPointAndLine)\n/* harmony export */ });\n/**\r\n * Returns the distance between the given point and line.\r\n * * see https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\r\n * @param p a point\r\n * @param l a line\r\n */\r\nfunction distanceBetweenPointAndLine(p, l) {\r\n    let [x0, y0] = p;\r\n    let [[x1, y1], [x2, y2]] = l;\r\n    let y = y2 - y1;\r\n    let x = x2 - x1;\r\n    let a = (y * x0 - x * y0 + x2 * y1 - y2 * x1);\r\n    let b = Math.sqrt(x * x + y * y);\r\n    return Math.abs(a / b);\r\n}\r\n\r\n//# sourceMappingURL=distance-between-point-and-line.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js?')},"./node_modules/flo-vector2d/node/distance-and-length/distance-between.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "distanceBetween": () => (/* binding */ distanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the distance between two 2d points.\r\n * @param p a point\r\n * @param q another point\r\n */\r\nfunction distanceBetween(p, q) {\r\n    let x = q[0] - p[0];\r\n    let y = q[1] - p[1];\r\n    return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n//# sourceMappingURL=distance-between.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/distance-between.js?')},"./node_modules/flo-vector2d/node/distance-and-length/len.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "len": () => (/* binding */ len)\n/* harmony export */ });\n/**\r\n * Returns the length of the given 2-vector.\r\n * @param p a 2d vector\r\n */\r\nfunction len(p) {\r\n    return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\r\n}\r\n\r\n//# sourceMappingURL=len.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/len.js?')},"./node_modules/flo-vector2d/node/distance-and-length/length-squared.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lengthSquared": () => (/* binding */ lengthSquared)\n/* harmony export */ });\n/**\r\n * Returns the squared length of the given 2-vector.\r\n * @param p a vector\r\n */\r\nfunction lengthSquared(v) {\r\n    return v[0] * v[0] + v[1] * v[1];\r\n}\r\n\r\n//# sourceMappingURL=length-squared.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/length-squared.js?')},"./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "manhattanDistanceBetween": () => (/* binding */ manhattanDistanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the Manhattan distance between two 2d points.\r\n * @param p a point.\r\n * @param q another point.\r\n */\r\nfunction manhattanDistanceBetween(p, q) {\r\n    return Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1]);\r\n}\r\n\r\n//# sourceMappingURL=manhattan-distance-between.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js?')},"./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "manhattanLength": () => (/* binding */ manhattanLength)\n/* harmony export */ });\n/**\r\n * Returns the Manhattan length of the given 2-vector.\r\n * @param p a vector\r\n */\r\nfunction manhattanLength(p) {\r\n    return Math.abs(p[0]) + Math.abs(p[1]);\r\n}\r\n\r\n//# sourceMappingURL=manhattan-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js?')},"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "squaredDistanceBetweenPointAndLineSegment": () => (/* binding */ squaredDistanceBetweenPointAndLineSegment)\n/* harmony export */ });\n/* harmony import */ var _squared_distance_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squared-distance-between.js */ "./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js");\n\r\n/**\r\n * Returns the squared distance between the given point and line segment.\r\n * @param p a point\r\n * @param l a line\r\n */\r\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\r\n    const sqDst = _squared_distance_between_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceBetween;\r\n    let v = l[0];\r\n    let w = l[1];\r\n    let l2 = sqDst(v, w);\r\n    if (l2 == 0) {\r\n        return sqDst(p, v);\r\n    }\r\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\r\n    t = Math.max(0, Math.min(1, t));\r\n    let d2 = sqDst(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\r\n    return d2;\r\n}\r\n\r\n//# sourceMappingURL=squared-distance-between-point-and-line-segment.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js?')},"./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "squaredDistanceBetween": () => (/* binding */ squaredDistanceBetween)\n/* harmony export */ });\n/**\r\n * Returns the squared distance between two 2d points.\r\n * @param p a point\r\n * @param q another point\r\n */\r\nfunction squaredDistanceBetween(p, q) {\r\n    let x = q[0] - p[0];\r\n    let y = q[1] - p[1];\r\n    return x * x + y * y;\r\n}\r\n\r\n//# sourceMappingURL=squared-distance-between.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js?')},"./node_modules/flo-vector2d/node/distance-and-length/to-length.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toLength": () => (/* binding */ toLength)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector scaled to the given length.\r\n * @param p a vector\r\n * @param length the length to scale to\r\n */\r\nfunction toLength(p, length) {\r\n    let c = length / Math.sqrt(p[0] * p[0] + p[1] * p[1]);\r\n    return [c * p[0], c * p[1]];\r\n}\r\n\r\n//# sourceMappingURL=to-length.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/to-length.js?')},"./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "toUnitVector": () => (/* binding */ toUnitVector)\n/* harmony export */ });\n/**\r\n * Returns the given 2-vector scaled to a length of one.\r\n * @param p a vector\r\n */\r\nfunction toUnitVector(p) {\r\n    let scaleFactor = 1 / (Math.sqrt(p[0] * p[0] + p[1] * p[1]));\r\n    return [p[0] * scaleFactor, p[1] * scaleFactor];\r\n}\r\n\r\n//# sourceMappingURL=to-unit-vector.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js?')},"./node_modules/flo-vector2d/node/dot.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "dot": () => (/* binding */ dot)\n/* harmony export */ });\n/**\r\n * Returns the dot (inner) product between two 2-vectors.\r\n * @param a the first vector\r\n * @param b the second vector\r\n */\r\nfunction dot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n//# sourceMappingURL=dot.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/dot.js?')},"./node_modules/flo-vector2d/node/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ccw": () => (/* binding */ ccw),\n/* harmony export */   "centroid": () => (/* reexport safe */ _triangle_centers_centroid_js__WEBPACK_IMPORTED_MODULE_27__.centroid),\n/* harmony export */   "circumCenter": () => (/* reexport safe */ _triangle_centers_circum_center_js__WEBPACK_IMPORTED_MODULE_25__.circumCenter),\n/* harmony export */   "cross": () => (/* reexport safe */ _cross_js__WEBPACK_IMPORTED_MODULE_2__.cross),\n/* harmony export */   "det3": () => (/* reexport safe */ _matrix_det_js__WEBPACK_IMPORTED_MODULE_28__.det3),\n/* harmony export */   "distanceBetween": () => (/* reexport safe */ _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_17__.distanceBetween),\n/* harmony export */   "distanceBetweenPointAndLine": () => (/* reexport safe */ _distance_and_length_distance_between_point_and_line_js__WEBPACK_IMPORTED_MODULE_22__.distanceBetweenPointAndLine),\n/* harmony export */   "doesSegSegIntersect": () => (/* reexport safe */ _lines_and_segments_does_seg_seg_intersect_js__WEBPACK_IMPORTED_MODULE_4__.doesSegSegIntersect),\n/* harmony export */   "dot": () => (/* reexport safe */ _dot_js__WEBPACK_IMPORTED_MODULE_1__.dot),\n/* harmony export */   "equal": () => (/* binding */ equal),\n/* harmony export */   "fromTo": () => (/* binding */ fromTo),\n/* harmony export */   "getClosestTo": () => (/* binding */ getClosestTo),\n/* harmony export */   "getObjClosestTo": () => (/* binding */ getObjClosestTo),\n/* harmony export */   "inCenter": () => (/* reexport safe */ _triangle_centers_in_center_js__WEBPACK_IMPORTED_MODULE_26__.inCenter),\n/* harmony export */   "interpolate": () => (/* binding */ interpolate),\n/* harmony export */   "len": () => (/* reexport safe */ _distance_and_length_len_js__WEBPACK_IMPORTED_MODULE_18__.len),\n/* harmony export */   "lengthSquared": () => (/* reexport safe */ _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_19__.lengthSquared),\n/* harmony export */   "lineLineIntersection": () => (/* reexport safe */ _lines_and_segments_line_line_intersection_js__WEBPACK_IMPORTED_MODULE_5__.lineLineIntersection),\n/* harmony export */   "manhattanDistanceBetween": () => (/* reexport safe */ _distance_and_length_manhattan_distance_between_js__WEBPACK_IMPORTED_MODULE_20__.manhattanDistanceBetween),\n/* harmony export */   "manhattanLength": () => (/* reexport safe */ _distance_and_length_manhattan_length_js__WEBPACK_IMPORTED_MODULE_21__.manhattanLength),\n/* harmony export */   "mean": () => (/* binding */ mean),\n/* harmony export */   "reverse": () => (/* reexport safe */ _affine_transformations_linear_reverse_js__WEBPACK_IMPORTED_MODULE_9__.reverse),\n/* harmony export */   "reverseRotate": () => (/* reexport safe */ _affine_transformations_linear_reverse_rotate_js__WEBPACK_IMPORTED_MODULE_10__.reverseRotate),\n/* harmony export */   "rotate": () => (/* reexport safe */ _affine_transformations_linear_rotate_js__WEBPACK_IMPORTED_MODULE_7__.rotate),\n/* harmony export */   "rotate90Degrees": () => (/* reexport safe */ _affine_transformations_linear_rotate_90_degrees_js__WEBPACK_IMPORTED_MODULE_11__.rotate90Degrees),\n/* harmony export */   "rotateNeg90Degrees": () => (/* reexport safe */ _affine_transformations_linear_rotate_neg_90_degrees_js__WEBPACK_IMPORTED_MODULE_12__.rotateNeg90Degrees),\n/* harmony export */   "scale": () => (/* reexport safe */ _affine_transformations_linear_scale_js__WEBPACK_IMPORTED_MODULE_8__.scale),\n/* harmony export */   "segSegIntersection": () => (/* reexport safe */ _lines_and_segments_seg_seg_intersection_js__WEBPACK_IMPORTED_MODULE_3__.segSegIntersection),\n/* harmony export */   "squaredDistanceBetween": () => (/* reexport safe */ _distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_24__.squaredDistanceBetween),\n/* harmony export */   "squaredDistanceBetweenPointAndLineSegment": () => (/* reexport safe */ _distance_and_length_squared_distance_between_point_and_line_segment_js__WEBPACK_IMPORTED_MODULE_23__.squaredDistanceBetweenPointAndLineSegment),\n/* harmony export */   "toLength": () => (/* reexport safe */ _distance_and_length_to_length_js__WEBPACK_IMPORTED_MODULE_16__.toLength),\n/* harmony export */   "toUnitVector": () => (/* reexport safe */ _distance_and_length_to_unit_vector_js__WEBPACK_IMPORTED_MODULE_15__.toUnitVector),\n/* harmony export */   "transformAffine": () => (/* reexport safe */ _affine_transformations_transform_affine_js__WEBPACK_IMPORTED_MODULE_14__.transformAffine),\n/* harmony export */   "transformLinear": () => (/* reexport safe */ _affine_transformations_linear_transform_linear_js__WEBPACK_IMPORTED_MODULE_13__.transformLinear),\n/* harmony export */   "translate": () => (/* reexport safe */ _affine_transformations_translate_translate_js__WEBPACK_IMPORTED_MODULE_6__.translate)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n/* harmony import */ var _dot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dot.js */ "./node_modules/flo-vector2d/node/dot.js");\n/* harmony import */ var _cross_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cross.js */ "./node_modules/flo-vector2d/node/cross.js");\n/* harmony import */ var _lines_and_segments_seg_seg_intersection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lines-and-segments/seg-seg-intersection.js */ "./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js");\n/* harmony import */ var _lines_and_segments_does_seg_seg_intersect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lines-and-segments/does-seg-seg-intersect.js */ "./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js");\n/* harmony import */ var _lines_and_segments_line_line_intersection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lines-and-segments/line-line-intersection.js */ "./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js");\n/* harmony import */ var _affine_transformations_translate_translate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./affine-transformations/translate/translate.js */ "./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js");\n/* harmony import */ var _affine_transformations_linear_rotate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./affine-transformations/linear/rotate.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js");\n/* harmony import */ var _affine_transformations_linear_scale_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./affine-transformations/linear/scale.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/scale.js");\n/* harmony import */ var _affine_transformations_linear_reverse_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./affine-transformations/linear/reverse.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/reverse.js");\n/* harmony import */ var _affine_transformations_linear_reverse_rotate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./affine-transformations/linear/reverse-rotate.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/reverse-rotate.js");\n/* harmony import */ var _affine_transformations_linear_rotate_90_degrees_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./affine-transformations/linear/rotate-90-degrees.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-90-degrees.js");\n/* harmony import */ var _affine_transformations_linear_rotate_neg_90_degrees_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./affine-transformations/linear/rotate-neg-90-degrees.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/rotate-neg-90-degrees.js");\n/* harmony import */ var _affine_transformations_linear_transform_linear_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./affine-transformations/linear/transform-linear.js */ "./node_modules/flo-vector2d/node/affine-transformations/linear/transform-linear.js");\n/* harmony import */ var _affine_transformations_transform_affine_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./affine-transformations/transform-affine.js */ "./node_modules/flo-vector2d/node/affine-transformations/transform-affine.js");\n/* harmony import */ var _distance_and_length_to_unit_vector_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./distance-and-length/to-unit-vector.js */ "./node_modules/flo-vector2d/node/distance-and-length/to-unit-vector.js");\n/* harmony import */ var _distance_and_length_to_length_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./distance-and-length/to-length.js */ "./node_modules/flo-vector2d/node/distance-and-length/to-length.js");\n/* harmony import */ var _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./distance-and-length/distance-between.js */ "./node_modules/flo-vector2d/node/distance-and-length/distance-between.js");\n/* harmony import */ var _distance_and_length_len_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./distance-and-length/len.js */ "./node_modules/flo-vector2d/node/distance-and-length/len.js");\n/* harmony import */ var _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./distance-and-length/length-squared.js */ "./node_modules/flo-vector2d/node/distance-and-length/length-squared.js");\n/* harmony import */ var _distance_and_length_manhattan_distance_between_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./distance-and-length/manhattan-distance-between.js */ "./node_modules/flo-vector2d/node/distance-and-length/manhattan-distance-between.js");\n/* harmony import */ var _distance_and_length_manhattan_length_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./distance-and-length/manhattan-length.js */ "./node_modules/flo-vector2d/node/distance-and-length/manhattan-length.js");\n/* harmony import */ var _distance_and_length_distance_between_point_and_line_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./distance-and-length/distance-between-point-and-line.js */ "./node_modules/flo-vector2d/node/distance-and-length/distance-between-point-and-line.js");\n/* harmony import */ var _distance_and_length_squared_distance_between_point_and_line_segment_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./distance-and-length/squared-distance-between-point-and-line-segment.js */ "./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between-point-and-line-segment.js");\n/* harmony import */ var _distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./distance-and-length/squared-distance-between.js */ "./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js");\n/* harmony import */ var _triangle_centers_circum_center_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./triangle-centers/circum-center.js */ "./node_modules/flo-vector2d/node/triangle-centers/circum-center.js");\n/* harmony import */ var _triangle_centers_in_center_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./triangle-centers/in-center.js */ "./node_modules/flo-vector2d/node/triangle-centers/in-center.js");\n/* harmony import */ var _triangle_centers_centroid_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./triangle-centers/centroid.js */ "./node_modules/flo-vector2d/node/triangle-centers/centroid.js");\n/* harmony import */ var _matrix_det_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./matrix/det.js */ "./node_modules/flo-vector2d/node/matrix/det.js");\n//==================================\r\n// 2d vector pure functions library\r\n//==================================\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if\r\n * ccw < 0, and colinear if ccw === 0 because ccw is a determinant that gives\r\n * twice the signed area of the triangle formed by the points a, b and c.\r\n * * **certified**\r\n * @param A The first point\r\n * @param B The second point\r\n * @param C The third point\r\n */\r\nconst ccw = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d;\r\n/**\r\n * Returns the second 2-vector minus the first.\r\n * @param p the first vector\r\n * @param q the second vector\r\n  */\r\nfunction fromTo(p, q) {\r\n    return [q[0] - p[0], q[1] - p[1]];\r\n}\r\n/**\r\n * Performs linear interpolation between two 2d points and returns the\r\n * resulting point.\r\n * @param p the first point.\r\n * @param q the second point.\r\n * @param t the interpolation fraction (often in [0,1]).\r\n */\r\nfunction interpolate(p, q, t) {\r\n    return [\r\n        p[0] + (q[0] - p[0]) * t,\r\n        p[1] + (q[1] - p[1]) * t\r\n    ];\r\n}\r\n/**\r\n * Returns the mean of two 2d points.\r\n * @param ps the two points\r\n */\r\nfunction mean(ps) {\r\n    let p = ps[0];\r\n    let q = ps[1];\r\n    return [(p[0] + q[0]) / 2, (p[1] + q[1]) / 2];\r\n}\r\n/**\r\n* Returns true if two 2-vectors are identical (by value), false otherwise.\r\n* @param a a 2d vector\r\n* @param b another 2d vector\r\n*/\r\nfunction equal(a, b) {\r\n    return (a[0] === b[0] && a[1] === b[1]);\r\n}\r\n/**\r\n * Returns the closest point to the array of 2d points or if the array is empty\r\n * returns undefined.\r\n * @param p\r\n * @param ps\r\n */\r\nfunction getClosestTo(p, ps) {\r\n    let closestPoint = undefined;\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let q = ps[i];\r\n        let d = (0,_distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_24__.squaredDistanceBetween)(p, q);\r\n        if (d < closestDistance) {\r\n            closestPoint = q;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestPoint;\r\n}\r\n/**\r\n * Returns the closest point to the array of 2d points by providing a distance\r\n * function. If the given array is empty, returns undefined.\r\n * @param p\r\n * @param ps\r\n * @param f a function that takes the object and returns a point in order to\r\n * apply the Euclidian distance.\r\n */\r\nfunction getObjClosestTo(p, ps, f) {\r\n    let closestObj = undefined; // Closest Point\r\n    let closestDistance = Number.POSITIVE_INFINITY;\r\n    for (let i = 0; i < ps.length; i++) {\r\n        let o = ps[i];\r\n        let d = (0,_distance_and_length_squared_distance_between_js__WEBPACK_IMPORTED_MODULE_24__.squaredDistanceBetween)(p, f(o));\r\n        if (d < closestDistance) {\r\n            closestObj = o;\r\n            closestDistance = d;\r\n        }\r\n    }\r\n    return closestObj;\r\n}\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/index.js?')},"./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doesSegSegIntersect": () => (/* binding */ doesSegSegIntersect)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n * * **robust** uses exact adaptive floating point arithmetic.\r\n * @param a a line segment\r\n * @param b another line segment\r\n */\r\nfunction doesSegSegIntersect(a, b) {\r\n    if (((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(a[0], a[1], b[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(a[0], a[1], b[1])) > 0) {\r\n        return false;\r\n    }\r\n    if (((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(b[0], b[1], a[0]) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.orient2d)(b[0], b[1], a[1])) > 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n//# sourceMappingURL=does-seg-seg-intersect.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js?')},"./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "lineLineIntersection": () => (/* binding */ lineLineIntersection)\n/* harmony export */ });\n/**\r\n * Find point where two lines intersect. Returns he point where the two lines\r\n * intersect or undefined if they don\'t intersect or are the same line.\r\n * see Wikipedia https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\r\n * @param l1 A line\r\n * @param l2 Another line\r\n */\r\nfunction lineLineIntersection(l1, l2) {\r\n    let [[x1, y1], [x2, y2]] = l1;\r\n    let [[x3, y3], [x4, y4]] = l2;\r\n    let x1_ = x2 - x1;\r\n    let y1_ = y2 - y1;\r\n    let x2_ = x4 - x3;\r\n    let y2_ = y4 - y3;\r\n    let denom = x2_ * y1_ - y2_ * x1_;\r\n    if (denom === 0) {\r\n        // parallel\r\n        return undefined;\r\n    }\r\n    let b = ((y3 - y1) * x1_ - (x3 - x1) * y1_) / denom;\r\n    return [\r\n        x3 + b * x2_,\r\n        y3 + b * y2_\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=line-line-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/lines-and-segments/line-line-intersection.js?')},"./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "segSegIntersection": () => (/* binding */ segSegIntersection)\n/* harmony export */ });\n/* harmony import */ var big_float_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! big-float-ts */ "./node_modules/big-float-ts/node/index.js");\n\r\n\r\nconst epr = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.expansionProduct;\r\nconst td = big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoDiff;\r\n/**\r\n* Returns the point where two line segments intersect or undefined if they\r\n* don\'t intersect or if they intersect at infinitely many points.\r\n* * see Geometric primitves http://algs4.cs.princeton.edu/91primitives\r\n* * **certified**\r\n* @param ab The first line\r\n* @param cd The second line\r\n*/\r\nfunction segSegIntersection(ab, cd) {\r\n    let [a, b] = ab;\r\n    let [c, d] = cd;\r\n    let [a0, a1] = a;\r\n    let [b0, b1] = b;\r\n    let [c0, c1] = c;\r\n    let [d0, d1] = d;\r\n    //let denom  = (b[0] - a[0])*(d[1] - c[1]) - (b[1] - a[1])*(d[0] - c[0]);\r\n    let denom = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(epr(td(b0, a0), td(d1, c1)), epr(td(b1, a1), td(d0, c0)));\r\n    //let rNumer = (a[1] - c[1])*(d[0] - c[0]) - (a[0] - c[0])*(d[1] - c[1]);\r\n    let rNumer = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(epr(td(a1, c1), td(d0, c0)), epr(td(a0, c0), td(d1, c1)));\r\n    //let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]); \r\n    let sNumer = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eDiff)(epr(td(a1, c1), td(b0, a0)), epr(td(a0, c0), td(b1, a1)));\r\n    if (denom[denom.length - 1] === 0) {\r\n        // parallel\r\n        if (rNumer[rNumer.length - 1] === 0) {\r\n            // collinear\r\n            // TODO Check if x-projections and y-projections intersect\r\n            // and return the line of intersection if they do.\r\n            return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n    //let r = rNumer / denom;\r\n    //let s = sNumer / denom;\r\n    // if (0 <= r && r <= 1 && 0 <= s && s <= 1)\r\n    if ((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(rNumer) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(denom) >= 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(denom), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(rNumer)) >= 0 &&\r\n        (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(sNumer) * (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eSign)(denom) >= 0 && (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eCompare)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(denom), (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eAbs)(sNumer)) >= 0) {\r\n        let r = (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(rNumer) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(denom);\r\n        //return [a0 + r*(b0 - a0), a1 + r*(b1 - a1)];\r\n        return [\r\n            (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(epr(td(b0, a0), rNumer)) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(denom), a0)),\r\n            (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.twoSum)((0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(epr(td(b1, a1), rNumer)) / (0,big_float_ts__WEBPACK_IMPORTED_MODULE_0__.eEstimate)(denom), a1))\r\n        ];\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=seg-seg-intersection.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js?')},"./node_modules/flo-vector2d/node/matrix/det.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "det3": () => (/* binding */ det3)\n/* harmony export */ });\n/**\r\n * Calculate the determinant of three 3d vectors, i.e. 3x3 matrix\r\n * @param x a 2d vector\r\n * @param y another 2d vector\r\n * @param z another 2d vector\r\n */\r\nfunction det3(x, y, z) {\r\n    return (x[0] * (y[1] * z[2] - y[2] * z[1])) -\r\n        (x[1] * (y[0] * z[2] - y[2] * z[0])) +\r\n        (x[2] * (y[0] * z[1] - y[1] * z[0]));\r\n}\r\n\r\n//# sourceMappingURL=det.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/matrix/det.js?')},"./node_modules/flo-vector2d/node/triangle-centers/centroid.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "centroid": () => (/* binding */ centroid)\n/* harmony export */ });\n/**\r\n* Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n* must be simple, i.e. not self-intersecting.\r\n* @param polygon_\r\n*/\r\nfunction centroid(polygon) {\r\n    let polygon_ = [];\r\n    if (polygon.length === 1) {\r\n        return polygon[0];\r\n    }\r\n    // remove duplicate points\r\n    let prevP = polygon[polygon.length - 1];\r\n    for (let i = 0; i < polygon.length; i++) {\r\n        let [_x, _y] = prevP;\r\n        let [x, y] = polygon[i];\r\n        prevP = [x, y];\r\n        if (x !== _x || y !== _y) {\r\n            polygon_.push([x, y]);\r\n        }\r\n    }\r\n    if (polygon_.length === 2) {\r\n        let p1 = polygon_[0];\r\n        let p2 = polygon_[1];\r\n        let x = p1[0] + p2[0];\r\n        let y = p1[1] + p2[1];\r\n        return [x / 2, y / 2];\r\n    }\r\n    if (polygon_.length === 3) {\r\n        let p1 = polygon_[0];\r\n        let p2 = polygon_[1];\r\n        let p3 = polygon_[2];\r\n        let x = p1[0] + p2[0] + p3[0];\r\n        let y = p1[1] + p2[1] + p3[1];\r\n        return [x / 3, y / 3];\r\n    }\r\n    // polygon.length assumed > 3 and assumed to be non-self-intersecting\r\n    // See wikipedia\r\n    // First calculate the area, A, of the polygon\r\n    let A = 0;\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        let p0 = polygon_[i];\r\n        let p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        A = A + (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    A = A / 2;\r\n    let C = [0, 0];\r\n    for (let i = 0; i < polygon_.length; i++) {\r\n        let p0 = polygon_[i];\r\n        let p1 = (i === polygon_.length - 1)\r\n            ? polygon_[0]\r\n            : polygon_[i + 1];\r\n        C[0] = C[0] + (p0[0] + p1[0]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n        C[1] = C[1] + (p0[1] + p1[1]) * (p0[0] * p1[1] - p1[0] * p0[1]);\r\n    }\r\n    return [C[0] / (6 * A), C[1] / (6 * A)];\r\n}\r\n\r\n//# sourceMappingURL=centroid.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/triangle-centers/centroid.js?')},"./node_modules/flo-vector2d/node/triangle-centers/circum-center.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "circumCenter": () => (/* binding */ circumCenter)\n/* harmony export */ });\n/* harmony import */ var _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../distance-and-length/length-squared.js */ "./node_modules/flo-vector2d/node/distance-and-length/length-squared.js");\n/* harmony import */ var _matrix_det_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matrix/det.js */ "./node_modules/flo-vector2d/node/matrix/det.js");\n\r\n\r\n/**\r\n* Returns the circumcenter of the given 2d triangle.\r\n* @param triangle\r\n*/\r\nfunction circumCenter(triangle) {\r\n    // See wikipedia\r\n    let p1 = triangle[0];\r\n    let p2 = triangle[1];\r\n    let p3 = triangle[2];\r\n    const sqLen = _distance_and_length_length_squared_js__WEBPACK_IMPORTED_MODULE_0__.lengthSquared;\r\n    let Sx = 0.5 * (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([sqLen(p1), p1[1], 1], [sqLen(p2), p2[1], 1], [sqLen(p3), p3[1], 1]);\r\n    let Sy = 0.5 * (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([p1[0], sqLen(p1), 1], [p2[0], sqLen(p2), 1], [p3[0], sqLen(p3), 1]);\r\n    let a = (0,_matrix_det_js__WEBPACK_IMPORTED_MODULE_1__.det3)([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\r\n    return [Sx / a, Sy / a];\r\n}\r\n\r\n//# sourceMappingURL=circum-center.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/triangle-centers/circum-center.js?')},"./node_modules/flo-vector2d/node/triangle-centers/in-center.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "inCenter": () => (/* binding */ inCenter)\n/* harmony export */ });\n/* harmony import */ var _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../distance-and-length/distance-between.js */ "./node_modules/flo-vector2d/node/distance-and-length/distance-between.js");\n\r\n/**\r\n * Returns the incenter of the given triangle.\r\n * * see Wikipedia - https://en.wikipedia.org/wiki/Incenter\r\n * @param triangle\r\n */\r\nfunction inCenter(triangle) {\r\n    const dst = _distance_and_length_distance_between_js__WEBPACK_IMPORTED_MODULE_0__.distanceBetween;\r\n    let p = triangle[0];\r\n    let q = triangle[1];\r\n    let r = triangle[2];\r\n    let a = dst(q, r);\r\n    let b = dst(p, r);\r\n    let c = dst(p, q);\r\n    let lengthSum = a + b + c;\r\n    return [\r\n        (a * p[0] + b * q[0] + c * r[0]) / lengthSum,\r\n        (a * p[1] + b * q[1] + c * r[1]) / lengthSum\r\n    ];\r\n}\r\n\r\n//# sourceMappingURL=in-center.js.map\n\n//# sourceURL=webpack://FloMat/./node_modules/flo-vector2d/node/triangle-centers/in-center.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];if(void 0!==r)return r.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,r)=>{for(var n in r)__webpack_require__.o(r,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.ts");FloMat=__webpack_exports__})();